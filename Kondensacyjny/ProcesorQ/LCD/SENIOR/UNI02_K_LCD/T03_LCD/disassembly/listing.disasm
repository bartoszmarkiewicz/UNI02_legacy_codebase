Disassembly Listing for T03_LCD_BOARD
Generated From:
C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/dist/default/debug/T03_LCD_BOARD.EXT2PGD.debug.elf
2018-09-21 08:22:58

---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/wsw.c  ----------------------
1:             /*---------------------------------------------------------------------------------*/
2:             /*wsw.c*/
3:             /*obsluga 2 cyfrowego wyswietlacza typu LCD ze znakami graficznymi*/
4:             /*format wyswietlania typu ITALY*/
5:             /*
6:             UWAGA:
7:             1.Do modyfikacji danych wyswietlanych na kolejnych pozycjach tablicy priorytetow
8:             wyswietlania, nalezy stosowac funkcje:
9:             -SetData(...
10:            -SetStatus(...
11:            Funkcja SetStatus() daje ponadto mozliwosc modyfikacji stanu diod sygnalizacyjnych
12:            automatycznie przez aktywn¹ pozycje tablicy priorytetow wyswietlania.
13:            2.Aby zmienic stan diod sygnalizacyjnych niezaleznie od tablicy priorytetow wyswietlania
14:            nalezy bezwzglednie stosowac funkcje:
15:            -Swsdid(...
16:            -Rwsdid(...
17:            3.Z dowolna pozycja tablicy priorytetow wyswietlania zwiazana moze byc kolejka wyswietlania.
18:            Kolejka wyswietlania steruje sie za pomoc¹ funkcji:
19:            -GetPos(...
20:            -SetPoz(...
21:            -ResetPoz(...
22:            -ResetKol(...
23:            -RestartKol(...
24:            -AllKolToFirstPoz(...
25:            */
26:            /*---------------------------------------------------------------------------------*/
27:            //#include <pic18.h>
28:            #include <xc.h>
29:            #include "global.h"				//parametry globalne
30:            #include "wsw.h"				//parametry lokalne
31:            #include "print.h"
32:            #include "lcdHD2c.h"			//parametry globalne
33:            /*---------------------------------------------------------------------------------*/
34:            //extern unsigned char x;
35:            
36:            #if NPWD!=0
37:            volatile WPack PWD[NPWD];				//tablica priorytetow wyswietlania PWD[n] (n=0 - najwyzszy priorytet)
38:            #endif
39:            #if NdPWD!=0
40:            volatile WPack DWD[NdPWD];				//tablica danych modyfikowanych dynamicznie wystepujacych wylacznie w kolejkach
41:            #endif
42:            #if NMZNK!=0
43:            volatile WMark KMark[NMZNK];
44:            #endif
45:            volatile WDyn DynData;					//dynamiczny bufor wyswietlania (aktywny gdy dyn=1)
46:            
47:            volatile static WPack bfWswData;			//pamiec danej najnizszego poziomu priorytetow wyswietlania (aktywna gdy only=1)
48:            volatile static WPack WswData;			//dana z informacja o sposobie formatowania
49:            volatile static LedPack LedData;			//dana po formatowaniu bezposrednio wysylana na wyswietlacz
50:            
51:            /*---------------------------------------------------------------------------------*/
52:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
53:            void InitLCD(void)
54:            {
55:            	//LCDCON
56:            	
57:            	LP3=0;				//1:1 presaler dla 1kHz zegara LCD
A214  96AA     BCF LCDPS, 3, ACCESS
58:            	LP2=0;				//frame clock prescaler
A216  94AA     BCF LCDPS, 2, ACCESS
59:            	LP1=0;
A218  92AA     BCF LCDPS, 1, ACCESS
60:            	LP0=0;
A21A  90AA     BCF LCDPS, 0, ACCESS
61:            
62:            	//Segment enable registers (rejestr TRIS musi byæ na tych wejsciach jako input).
63:            	SE00=0;
A21C  90A9     BCF LCDSE0, 0, ACCESS
64:            	SE01=0;	
A21E  92A9     BCF LCDSE0, 1, ACCESS
65:            	SE02=1;
A220  84A9     BSF LCDSE0, 2, ACCESS
66:            	SE03=1;
A222  86A9     BSF LCDSE0, 3, ACCESS
67:            	SE04=1;
A224  88A9     BSF LCDSE0, 4, ACCESS
68:            	SE05=1;
A226  8AA9     BSF LCDSE0, 5, ACCESS
69:            	SE06=1;	
A228  8CA9     BSF LCDSE0, 6, ACCESS
70:            	SE07=1;
A22A  8EA9     BSF LCDSE0, 7, ACCESS
71:            	SE08=0;
A22C  90B6     BCF LCDSE1, 0, ACCESS
72:            	SE09=0;
A22E  92B6     BCF LCDSE1, 1, ACCESS
73:            	SE10=0;
A230  94B6     BCF LCDSE1, 2, ACCESS
74:            	SE11=0;
A232  96B6     BCF LCDSE1, 3, ACCESS
75:            	SE12=0;
A234  98B6     BCF LCDSE1, 4, ACCESS
76:            	SE13=0;
A236  9AB6     BCF LCDSE1, 5, ACCESS
77:            	SE14=0;
A238  9CB6     BCF LCDSE1, 6, ACCESS
78:            	SE15=0;
A23A  9EB6     BCF LCDSE1, 7, ACCESS
79:            	SE16=0;
A23C  90B7     BCF LCDSE2, 0, ACCESS
80:            	SE17=0;
A23E  92B7     BCF LCDSE2, 1, ACCESS
81:            	SE18=0;
A240  94B7     BCF LCDSE2, 2, ACCESS
82:            	SE19=0;
A242  96B7     BCF LCDSE2, 3, ACCESS
83:            	SE20=1;
A244  88B7     BSF LCDSE2, 4, ACCESS
84:            	SE21=1;
A246  8AB7     BSF LCDSE2, 5, ACCESS
85:            	SE22=1;
A248  8CB7     BSF LCDSE2, 6, ACCESS
86:            	SE23=1;
A24A  8EB7     BSF LCDSE2, 7, ACCESS
87:            	SE24=1;
A24C  80B8     BSF LCDSE3, 0, ACCESS
88:            	SE25=1;
A24E  82B8     BSF LCDSE3, 1, ACCESS
89:            	SE26=0;
A250  94B8     BCF LCDSE3, 2, ACCESS
90:            	SE27=0;
A252  96B8     BCF LCDSE3, 3, ACCESS
91:            	SE28=0;
A254  98B8     BCF LCDSE3, 4, ACCESS
92:            	SE29=0;
A256  9AB8     BCF LCDSE3, 5, ACCESS
93:            	SE30=0;
A258  9CB8     BCF LCDSE3, 6, ACCESS
94:            	SE31=0;
A25A  9EB8     BCF LCDSE3, 7, ACCESS
95:            	SE32=0;
A25C  90B9     BCF LCDSE4, 0, ACCESS
96:            
97:            	//LCDCON
98:            	LMUX1=1;			//COM3:COM0 (nie ma potrzeby zmiany wartosci rejestru TRIS)
A25E  82A8     BSF LCDCON, 1, ACCESS
99:            	LMUX0=1;
A260  80A8     BSF LCDCON, 0, ACCESS
100:           	CS1=0;				//system clock source 8MHz
A262  96A8     BCF LCDCON, 3, ACCESS
101:           	CS0=0;
A264  94A8     BCF LCDCON, 2, ACCESS
102:           	SLPEN=0;			//LCD aktywny takze w stanie sleep
A266  9CA8     BCF LCDCON, 6, ACCESS
103:           
104:           	//LCDDATA			
105:           	//SetWSW(0);		//wyzerowanie stanu wyswietlacza
106:           
107:           	//LCDREG
108:           	CKSEL1=0;			//LCD regulator disabled (konfiguracja M2 lub M3)
A268  92D2     BCF LCDREG, 1, ACCESS
109:           	CKSEL0=0;
A26A  90D2     BCF LCDREG, 0, ACCESS
110:           	CPEN=1;				//1charge pump enable bit
A26C  8CD2     BSF LCDREG, 6, ACCESS
111:           
112:           	//LCDPS
113:           	WFT=0;				//waweform TYPEA (nieaktywne przerwanie)
A26E  9EAA     BCF LCDPS, 7, ACCESS
114:           	BIASMD=0;			//bias mode select bit
A270  9CAA     BCF LCDPS, 6, ACCESS
115:           
116:           	//PIR3
117:           	LCDIF=0;			//clear interrupt flag
A272  9CA4     BCF PIR3, 6, ACCESS
118:           
119:           	//IPR3
120:           	LCDIP=0;			//low priority interrupt
A274  9CA5     BCF IPR3, 6, ACCESS
121:           
122:           	//PIE3
123:           	LCDIE=0;			//enable interrupt
A276  9CA3     BCF PIE3, 6, ACCESS
124:           
125:           	//LCDCON
126:           	LCDEN=1;			//aktywacja modulu LCD
A278  8EA8     BSF LCDCON, 7, ACCESS
127:           
128:           	//LCDREG
129:           	BIAS2=1;		//100 voltage control output (3,6Vpeak) - regulacja kontrastu
A27A  8AD2     BSF LCDREG, 5, ACCESS
130:           	BIAS1=1;		//0
A27C  88D2     BSF LCDREG, 4, ACCESS
131:           	BIAS0=1;		//0
A27E  86D2     BSF LCDREG, 3, ACCESS
132:           	//konfiguracja sprzetowa ukladu kontrastu M2
133:           }
A280  0012     RETURN 0
134:           /*---------------------------------------------------------------------------------*/
135:           //Ustawienie wyswietlacza w stan zapalony (wszystkie znaki wlaczone) lub w stan wygaszony (wszystkie znaki wygaszone)
136:           //gdzie dla sall=0 wygaszenie a dla sall=1 zapalenie
137:           void SetWSW(unsigned char sall)
757E  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
138:           {
139:           	//com1
140:           	LCDDATA0=(sall)?0xff:0;	
7580  0100     MOVLB 0x0
7582  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7584  E103     BNZ 0x758C
7586  6B74     CLRF _PFNf_prODP, BANKED
7588  6B75     CLRF _PFNf_prn_cs, BANKED
758A  D002     BRA 0x7590
758C  6B75     CLRF _PFNf_prn_cs, BANKED
758E  6974     SETF _PFNf_prODP, BANKED
7590  C074     MOVFF _PFNf_prODP, LCDDATA0
7592  FFBB     NOP
141:           	LCDDATA1=(sall)?0xff:0;
7594  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7596  E103     BNZ 0x759E
7598  6B76     CLRF _PFNf_prn_in, BANKED
759A  6B77     CLRF _PFNf_prn_pg, BANKED
759C  D002     BRA 0x75A2
759E  6B77     CLRF _PFNf_prn_pg, BANKED
75A0  6976     SETF _PFNf_prn_in, BANKED
75A2  C076     MOVFF _PFNf_prn_in, LCDDATA1
75A4  FFBC     NOP
142:           	LCDDATA2=(sall)?0xff:0;
75A6  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
75A8  E103     BNZ 0x75B0
75AA  6B78     CLRF _PFNf_prn_pp, BANKED
75AC  6B79     CLRF _PFNf_prn_res, BANKED
75AE  D002     BRA 0x75B4
75B0  6B79     CLRF _PFNf_prn_res, BANKED
75B2  6978     SETF _PFNf_prn_pp, BANKED
75B4  C078     MOVFF _PFNf_prn_pp, LCDDATA2
75B6  FFBD     NOP
143:           	LCDDATA3=(sall)?0xff:0;
75B8  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
75BA  E103     BNZ 0x75C2
75BC  6B7A     CLRF _PFNf_res, BANKED
75BE  6B7B     CLRF _PFNf_rozruch, BANKED
75C0  D002     BRA 0x75C6
75C2  6B7B     CLRF _PFNf_rozruch, BANKED
75C4  697A     SETF _PFNf_res, BANKED
75C6  C07A     MOVFF _PFNf_res, LCDDATA3
75C8  FFBE     NOP
144:           	//com2
145:           	LCDDATA6=(sall)?0xff:0;	
75CA  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
75CC  E103     BNZ 0x75D4
75CE  6B7C     CLRF _PFNf_setKey, BANKED
75D0  6B7D     CLRF _PFNf_set_aleg, BANKED
75D2  D002     BRA 0x75D8
75D4  6B7D     CLRF _PFNf_set_aleg, BANKED
75D6  697C     SETF _PFNf_setKey, BANKED
75D8  C07C     MOVFF _PFNf_setKey, LCDDATA6
75DA  FF6C     NOP
146:           	LCDDATA7=(sall)?0xff:0;
75DC  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
75DE  E103     BNZ 0x75E6
75E0  6B7E     CLRF _PFNf_set_eco, BANKED
75E2  6B7F     CLRF _PFNf_set_fnserw, BANKED
75E4  D002     BRA 0x75EA
75E6  6B7F     CLRF _PFNf_set_fnserw, BANKED
75E8  697E     SETF _PFNf_set_eco, BANKED
75EA  C07E     MOVFF _PFNf_set_eco, LCDDATA7
75EC  FF6D     NOP
147:           	LCDDATA8=(sall)?0xff:0;
75EE  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
75F0  E103     BNZ 0x75F8
75F2  6B80     CLRF _PFNf_set_nco, BANKED
75F4  6B81     CLRF _PFNf_set_ncw, BANKED
75F6  D002     BRA 0x75FC
75F8  6B81     CLRF _PFNf_set_ncw, BANKED
75FA  6980     SETF _PFNf_set_nco, BANKED
75FC  C080     MOVFF _PFNf_set_nco, LCDDATA8
75FE  FF6E     NOP
148:           	LCDDATA9=(sall)?0xff:0;
7600  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7602  E103     BNZ 0x760A
7604  6B82     CLRF _PFNf_str_nco, BANKED
7606  6B83     CLRF _PFNf_str_ncw, BANKED
7608  D002     BRA 0x760E
760A  6B83     CLRF _PFNf_str_ncw, BANKED
760C  6982     SETF _PFNf_str_nco, BANKED
760E  C082     MOVFF _PFNf_str_nco, LCDDATA9
7610  FF6F     NOP
149:           	//com3
150:           	LCDDATA12=(sall)?0xff:0;	
7612  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7614  E103     BNZ 0x761C
7616  6B84     CLRF _PFNf_tdzCO, BANKED
7618  6B85     CLRF _PFNf_tdzCW, BANKED
761A  D002     BRA 0x7620
761C  6B85     CLRF _PFNf_tdzCW, BANKED
761E  6984     SETF _PFNf_tdzCO, BANKED
7620  C084     MOVFF _PFNf_tdzCO, LCDDATA12
7622  FF72     NOP
151:           	LCDDATA13=(sall)?0xff:0;
7624  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7626  E103     BNZ 0x762E
7628  6B86     CLRF _PFNf_timZAS, BANKED
762A  6B87     CLRF _PFNf_tmpZW, BANKED
762C  D002     BRA 0x7632
762E  6B87     CLRF _PFNf_tmpZW, BANKED
7630  6986     SETF _PFNf_timZAS, BANKED
7632  C086     MOVFF _PFNf_timZAS, LCDDATA13
7634  FF73     NOP
152:           	LCDDATA14=(sall)?0xff:0;
7636  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7638  E103     BNZ 0x7640
763A  6B88     CLRF _PFNf_toInit, BANKED
763C  6B89     CLRF _PFNf_trbECO, BANKED
763E  D002     BRA 0x7644
7640  6B89     CLRF _PFNf_trbECO, BANKED
7642  6988     SETF _PFNf_toInit, BANKED
7644  C088     MOVFF _PFNf_toInit, LCDDATA14
7646  FF74     NOP
153:           	LCDDATA15=(sall)?0xff:0;
7648  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
764A  E103     BNZ 0x7652
764C  6B8A     CLRF _PFNf_vnt, BANKED
764E  6B8B     CLRF _PFNf_zcfm, BANKED
7650  D002     BRA 0x7656
7652  6B8B     CLRF _PFNf_zcfm, BANKED
7654  698A     SETF _PFNf_vnt, BANKED
7656  C08A     MOVFF _PFNf_vnt, LCDDATA15
7658  FF75     NOP
154:           	//com4
155:           	LCDDATA18=(sall)?0xff:0;	
765A  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
765C  E103     BNZ 0x7664
765E  6B8C     CLRF _PFNf_zima, BANKED
7660  6B8D     CLRF _PWMf_ENPWM2, BANKED
7662  D002     BRA 0x7668
7664  6B8D     CLRF _PWMf_ENPWM2, BANKED
7666  698C     SETF _PFNf_zima, BANKED
7668  C08C     MOVFF _PFNf_zima, LCDDATA18
766A  FF78     NOP
156:           	LCDDATA19=(sall)?0xff:0;
766C  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
766E  E103     BNZ 0x7676
7670  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
7672  6B8F     CLRF _RSDT1f_NoRespToLIN, BANKED
7674  D002     BRA 0x767A
7676  6B8F     CLRF _RSDT1f_NoRespToLIN, BANKED
7678  698E     SETF _RSDT1f_NewLIDN, BANKED
767A  C08E     MOVFF _RSDT1f_NewLIDN, LCDDATA19
767C  FF79     NOP
157:           	LCDDATA20=(sall)?0xff:0;
767E  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7680  E103     BNZ 0x7688
7682  6B90     CLRF _RSDT1f_OdpLIDN, BANKED
7684  6B91     CLRF _RSDT1f_RD_KNF, BANKED
7686  D002     BRA 0x768C
7688  6B91     CLRF _RSDT1f_RD_KNF, BANKED
768A  6990     SETF _RSDT1f_OdpLIDN, BANKED
768C  C090     MOVFF _RSDT1f_OdpLIDN, LCDDATA20
768E  FF7A     NOP
158:           	LCDDATA21=(sall)?0xff:0;
7690  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
7692  E103     BNZ 0x769A
7694  6B92     CLRF _RSDT1f_RD_LIN, BANKED
7696  6B93     CLRF _RSDT1f_RD_STD, BANKED
7698  D003     BRA 0x76A0
769A  0E00     MOVLW 0x0
769C  6B93     CLRF _RSDT1f_RD_STD, BANKED
769E  6992     SETF _RSDT1f_RD_LIN, BANKED
76A0  C092     MOVFF _RSDT1f_RD_LIN, LCDDATA21
76A2  FF7B     NOP
159:           }
76A4  0012     RETURN 0
160:           /*---------------------------------------------------------------------------------*/
161:           void InitWsw(void)
162:           {
163:           	unsigned char i;
164:           
165:           	InitLCD();
AF5C  EC0A     CALL 0xA214, 0
AF5E  F051     NOP
166:           	for(i=0;i<NPWD-1;i++) PWD[i].St.focus=0;
AF60  0100     MOVLB 0x0
AF62  6B74     CLRF _PFNf_prODP, BANKED
AF64  5174     MOVF _PFNf_prODP, W, BANKED
AF66  EC50     CALL 0xA0A0, 0
AF68  F050     NOP
AF6A  D815     RCALL PL632
AF6C  6574     CPFSGT _PFNf_prODP, BANKED
AF6E  D7FA     BRA 0xAF64
167:           #if LCD4D!=0
168:           	for(i=0;i<NPWD-1;i++) PWD[i].St2.focus=0;
AF70  6B74     CLRF _PFNf_prODP, BANKED
AF72  5174     MOVF _PFNf_prODP, W, BANKED
AF74  EC58     CALL 0xA0B0, 0
AF76  F050     NOP
AF78  D80E     RCALL PL632
AF7A  6574     CPFSGT _PFNf_prODP, BANKED
AF7C  D7FA     BRA 0xAF72
169:           #endif
170:           #if NMZNK!=0
171:           	for(i=0;i<NMZNK;i++) KMark[i].focus=0;
AF7E  6B74     CLRF _PFNf_prODP, BANKED
AF80  0EE2     MOVLW 0xE2
AF82  2574     ADDWF _PFNf_prODP, W, BANKED
AF84  EC11     CALL 0xA422, 0
AF86  F052     NOP
AF88  90DF     BCF INDF2, 0, ACCESS
AF8A  0100     MOVLB 0x0
AF8C  2B74     INCF _PFNf_prODP, F, BANKED
AF8E  0E0F     MOVLW 0xF
AF90  6574     CPFSGT _PFNf_prODP, BANKED
AF92  D7F6     BRA 0xAF80
AF94  0C0F     RETLW 0xF
172:           #endif
173:           	//**********************
174:           	//W tym miejscu nalezy wstepnie skonfigurowac wyswietlacz:
175:           	//- ustawic format danych dla pozycji tablicy PWD nie zajmowanych przez kolejki
176:           	//- ustawic format danych dla poszczegolnych pozycji tablicy DWD
177:           //--------	
178:           	//format zmiennych podstawowych umieszczonych w tablicy priorytetow wyswietlania	
179:           	/*SetStatus(&PWD[3],tDEC,tALL,0,0);					//temp WG (dyzurna)
180:           	SetStatus(&PWD[4],tDEC,tALL,0,0);					//temp WU (dyzurna)	
181:           	SetStatus(&PWD[5],tHEX,tALL,0,0);					//stan OFF
182:           	SetStatus(&PWD[6],tDEC|tKROPKA1,tALL,0,0);			//cisnienie WG
183:           	SetStatus(&PWD[7],tDEC,tALL,0,0);					//temp. WU
184:           	SetStatus(&PWD[8],tDEC,tALL,0,0);					//temp. WG (najnizszy priorytet)*/
185:           	//w pozostalych umieszczone sa kolejki wyswietlania.... 
186:           //--------
187:           	//zmienne dynamiczne wyst. wylacznie w kolejkach
188:           	//format zmiennych
189:           
190:           }
191:           //-------------------------------------------------------------------
192:           //UWAGA: DALSZA CZESC DOTYCZY WYLACZNIE KOLEJEK WYSWIETLANIA						
193:           //***************************************************************************************
194:           #if NKOL!=0
195:           //PODSTAWOWE DANE KOLEJEK
196:           //***************************************************************************************
197:           //Kolejka KL0:
198:           //Tablica wskaznikow do danych na kolejnych pozycjach kolejek ktore maja zostac wyswietlone
199:           //Jezeli wskaznik = 0 dana pozycji pobierana jest z tablicy /KWrtPoz/ a jej format okreslony
200:           //jest w tablicy /KFrmPoz/.
201:           
202:           //kod awaryjny
203:           const KAdrPoz KL0_AP[NKL0]=	{
204:           								DWD,			
205:           								DWD+1
206:           							};
207:           //nastawa WU/WG
208:           const KAdrPoz KL1_AP[NKL1]=	{
209:           								DWD+2,
210:           								DWD+3
211:           							};
212:           //kolejka procedur awaryjnych
213:           const KAdrPoz KL2_AP[NKL2]=	{
214:           								DWD+4,
215:           								DWD+5
216:           							};
217:           //**********************
218:           //Dane wyswietlane na kolejnych pozycjach kolejek. Dla kazdej pozycji skladaja sie na nie koleno:
219:           //[wartosc starszej cyfry(ignorowane gdy dec=1 lub hex=1),wartosc wyswietlana (dla dec=1 lub hex=1)
220:           //lub wartosc mlodszej cyfry (dla dec=0 oraz hex=0),czas jaki ma byc wyswietlana pozycja]
221:           //UWAGA: Jezeli ta sama pozycja w tablicy KAdrPoz ma wartosc rozna od 0 brany jest pod uwage tylko ostatni
222:           //parametr czasu przez jaki ma byc wyswietlana pozycja (reszta odczytywana jest pod adresem podanym w tablicy KAdrPoz).
223:           #if RSPADR!=0
224:           //-------------------------------
225:           #if LCD4D==0
226:           //*kolejka kodow awaryjnych						
227:           const KWrtPoz KL0_WP[NKL0]={
228:           							0,0,8,	//6			
229:           							0,0,8
230:           							};
231:           //nastawa WU/WG							
232:           const KWrtPoz KL1_WP[NKL1]={
233:           							0,0,6,
234:           							0,0,6
235:           							};
236:           //kolejka procedur awaryjnych							
237:           const KWrtPoz KL2_WP[NKL2]={
238:           							0,0,20,
239:           							0,0,30
240:           							};
241:           #else
242:           //*kolejka kodow awaryjnych						
243:           const KWrtPoz KL0_WP[NKL0]={
244:           							0,0, 0,0, 8,	//6			
245:           							0,0, 0,0, 8
246:           							};
247:           //nastawa WU/WG							
248:           const KWrtPoz KL1_WP[NKL1]={
249:           							0,0, 0,0, 6,
250:           							0,0, 0,0, 6
251:           							};
252:           //kolejka procedur awaryjnych							
253:           const KWrtPoz KL2_WP[NKL2]={
254:           							0,0, 0,0, 20,
255:           							0,0, 0,0, 30
256:           							};
257:           #endif
258:           //----------------------------------
259:           #else
260:           //*kolejka kodow awaryjnych						
261:           const KWrtPoz KL0_WP[NKL0]={
262:           							8,		
263:           							8
264:           							};
265:           //nastawa WU/WG							
266:           const KWrtPoz KL1_WP[NKL1]={
267:           							6,
268:           							6
269:           							};
270:           //kolejka procedur awaryjnych							
271:           const KWrtPoz KL2_WP[NKL2]={
272:           							15,
273:           							15
274:           							};
275:           //----------------------------------
276:           #endif
277:           //**********************
278:           //Format danych na kolejnych pozycjach kolejki. Na format pozycji skladaja sie kolejno:
279:           //[*,dec,hex,autoOFF,kropka0,kropka1,wygas0,wygas1]
280:           //UWAGA: Jezeli ta sama pozycja w tablicy KAdrPoz ma wartosc rozna od 0 powyzsze parametry 
281:           //nie sa brane pod uwage (odczytywane sa pod adresem podanym w tablicy KAdrPoz)
282:           #if RSPADR!=0
283:           #if LCD4D==0
284:           //*kod bledu
285:           const KFrmPoz KL0_FP[NKL0]={
286:           							0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD
287:           							0,0,0,0,0,0,0,0,0,0,0,0,0
288:           							};
289:           //*nastawa WU/WG
290:           const KFrmPoz KL1_FP[NKL1]={
291:           							0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD+1
292:           							0,0,0,0,0,0,0,0,0,0,0,0,0
293:           							};
294:           //kolejka procedur awaryjnych
295:           const KFrmPoz KL2_FP[NKL2]={
296:           							0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD+1
297:           							0,0,0,0,0,0,0,0,0,0,0,0,0
298:           							};
299:           #else
300:           //*kod bledu
301:           const KFrmPoz KL0_FP[NKL0]={
302:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD
303:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0
304:           							};
305:           //*nastawa WU/WG
306:           const KFrmPoz KL1_FP[NKL1]={
307:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD
308:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0
309:           							};
310:           //kolejka procedur awaryjnych
311:           const KFrmPoz KL2_FP[NKL2]={
312:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,		//nie brany pod uwage - dana umieszczona w DWD
313:           							0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0
314:           							};
315:           #endif
316:           #endif
317:           //**********************
318:           //Dane okreslajace dla kazdej pozycji kolejki czy ma byc wyswietlana
319:           
320:           //*kod bledu
321:           //Jezeli zadna pozycja nie jest ustawiona na 1 to kolejka nie jest aktywna
322:           static KFocus KL0_FC[NKL0]=	{
323:           						0,
324:           						0
325:           						};
326:           //nastawa WU/WG
327:           static KFocus KL1_FC[NKL1]=	{
328:           						0,
329:           						0
330:           						};
331:           //kolejka procedur awaryjnych
332:           static KFocus KL2_FC[NKL2]=	{
333:           						0,
334:           						0
335:           						};
336:           //**********************
337:           //Adres pod ktory maja trafiac dane kolejki (najczesciej pozycja tablicy priorytetow wyswietlania PWD),
338:           //,czas ekspozycji kolejki (0 - ekspozycja ciagla),maska rezerwacji diod sygnalizacyjnych dla potrzeb kolejki
339:           
340:           const KOutput KL0_OUT=	{PWD,0};	//kolejka kodow bledu trafia pod adres najwyzszego priorytetu, czas ekspozycji - ciagly,
341:           const KOutput KL1_OUT=	{PWD+2,3};	//nastawa wyswietlana przez okreslony czas - priorytet 3, czas ekspozycji 4 sek.,
342:           const KOutput KL2_OUT=	{PWD+3,0};	//kolejka procedur awaryjnych
343:           //**********************														
344:           //Adresy danych skladajacych sie na kolejke 
345:           #if RSPADR!=0
346:           const Kolejka KL0={KL0_AP,KL0_WP,KL0_FP,KL0_FC,&KL0_OUT};
347:           const Kolejka KL1={KL1_AP,KL1_WP,KL1_FP,KL1_FC,&KL1_OUT};
348:           const Kolejka KL2={KL2_AP,KL2_WP,KL2_FP,KL2_FC,&KL2_OUT};
349:           #else
350:           const Kolejka KL0={KL0_AP,KL0_WP,KL0_FC,&KL0_OUT};
351:           const Kolejka KL1={KL1_AP,KL1_WP,KL1_FC,&KL1_OUT};
352:           const Kolejka KL2={KL2_AP,KL2_WP,KL2_FC,&KL2_OUT};
353:           #endif
354:           //***************************************************************************************
355:           //TABLICA OBSLUGI WSZYSTKICH KOLEJEK
356:           //NKOL - liczba kolejek
357:           //**********************
358:           //Podstawowe dane kolejki: adres kolejki, liczba pozycji kolejki
359:           volatile const KGlobal Klj[NKOL]=	{
360:           							&KL0,NKL0,
361:           							&KL1,NKL1,
362:           							&KL2,NKL2
363:           							};
364:           #endif
365:           //-------------------------------------------------------------------
366:           //-------------------------------------------------------------------							
367:           //PROCEDURY PUBLICZNE
368:           //-------------------------------------------------------------------
369:           /*Bezwarunkowe wygaszenie wyswietlacza*/
370:           //void WswOff(void)
371:           
372:           /*Wyjscie z bezwarunkowego wygaszenia wyswietlacza*/
373:           //void WswOn(void)
374:           
375:           /*Wyprowadzenie danej na wyswietlacz*/
376:           //void SetData(WPack *wData,unsigned char wdt1, unsigned char wdt0);
377:           
378:           /*Okreslenie formatu danej wysylanej na wyswietlacz*/ 							
379:           //void SetStatus(WPack *wData,unsigned char wst,unsigned char mask);
380:           
381:           /*Aktywacja pozycji kolejki*/							
382:           //void SetPoz(unsigned char nrkol,unsigned char nrpoz);
383:           
384:           /*Deaktywacja pozycji kolejki*/
385:           //void ResetPoz(unsigned char nrkol,unsigned char nrpoz);
386:           
387:           /*Deaktuwacja wszystkich pozycji kolejki*/
388:           //void ResetKol(unsigned char nrkol);
389:           
390:           /*Restart kolejki*/
391:           //void RestartKol(unsigned char nrkol);
392:           
393:           							
394:           /*---------------------------------------------------------------------------------*/
395:           /*-----------------------------PROTECTED DATA--------------------------------------*/
396:           #if NKOL!=0
397:           volatile static KIndeks	KInd[NKOL];
398:           volatile static KTime	KTim[NKOL];
399:           #endif
400:           
401:           //-------------------------------------------------------------------
402:           //Tablica zamiany danej hex/dec na odpowiadajacy jej kod 7LED
403:           #if LTABLE==0
404:           const unsigned char Znak[16]={						//format danych dla wsp. anody
405:           								0b00111111,			//0
406:           								0b00000110,			//1
407:           								0b01011011,			//2
408:           								0b01001111,			//3
409:           								0b01100110,			//4
410:           								0b01101101,			//5
411:           								0b01111101,			//6
412:           								0b00000111,			//7
413:           								0b01111111,			//8
414:           								0b01101111,			//9
415:           								0b01110111,			//A
416:           								0b01111100,			//b
417:           								0b00111001,			//C
418:           								0b01011110,			//d
419:           								0b01111001,			//E
420:           								0b01110001,			//F
421:           								};
422:           #endif
423:           //-------------------------------------------------------------------
424:           //Tablica zamiany danej hex/dec na odpowiadajacy jej kod 7LED
425:           #if LTABLE==1
426:           const unsigned char Znak[16]={						//format danych dla wsp. anody
427:           								0b00111111,			//0
428:           								0b00000110,			//1
429:           								0b01011011,			//2
430:           								0b01001111,			//3
431:           								0b01100110,			//4
432:           								0b01101101,			//5
433:           								0b01111101,			//6
434:           								0b00000111,			//7
435:           								0b01111111,			//8
436:           								0b01101111,			//9
437:           								0b01110111,			//A
438:           								0b01111100,			//b
439:           								0b00111001,			//C
440:           								0b01011110,			//d
441:           								0b01111001,			//E
442:           								0b01110001,			//F
443:           								};
444:           #endif
445:           //-------------------------------------------------------------------
446:           //-------------------------------------------------------------------
447:           //Przygotowanie i wyslanie danej na wyswietlacz
448:           //Funkcja wywolywana w przerwaniu co 10ms.
449:           void RefreshWSW(void)
450:           {
451:           #if NKOL!=0	
452:           	KolProc();					//obsluga kolejki wyswietlania
C01A  EC1F     CALL 0x323E, 0
C01C  F019     NOP
453:           #endif
454:           #if NMZNK!=0					//osluga znakow graficznych
455:           	KolMark();
C01E  ECE1     CALL 0xA3C2, 0
C020  F051     NOP
456:           #endif
457:           	SetPrWswData();				//pobranie danej PWD[n]i zapis do WswData
C022  EC26     CALL 0xA04C, 0
C024  F050     NOP
458:           	FormatWswData();			//konwersja wartosci WswData na LedData
C026  EC21     CALL 0x7442, 0
C028  F03A     NOP
459:           	PrintWswData();				//wyslanie danej LedData na wyswietlacz
C02A  EF0D     GOTO 0x5A1A
C02C  F02D     NOP
460:           }
461:           /*--------------------------------------------------------------*/
462:           //Proc. obslugi kolejek wyswietlania. Focus w tablicy priorytetow PWD jest przyznawany/odbierany
463:           //automatycznie jezeli przynajmniej jedna pozycja kolejki jest aktywna.
464:           #if NKOL!=0
465:           void KolProc(void)
466:           {
467:           	unsigned char i,j,k,l,nC,kk;
468:           	volatile WPack *cadr,*padr,*padr2;
469:           
470:           
471:           	for(j=0;j<NKOL;j++)									
323E  6A3A     CLRF _PFNf_LIN_STR, ACCESS
3610  2A3A     INCF _PFNf_LIN_STR, F, ACCESS
472:           	{
473:           		cadr=(*(*Klj[j].KL).KOut).CAdr;
3240  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3242  D9EB     RCALL PL8
3244  0E06     MOVLW 0x6
3246  DA11     RCALL PL18
3248  DA05     RCALL PL16
324A  DA60     RCALL PL286
324C  0009     TBLRD*+
324E  CFF5     MOVFF TABLAT, _PFNf_LIN_PBCW
3250  F038     NOP
3252  000A     TBLRD*-
3254  CFF5     MOVFF TABLAT, _PFNf_LIN_RT
3256  F039     NOP
474:           
475:           		//reset pozycji kolejki (liczba cykli i pozycje zostaj¹ deaktywowane)
476:           		nC=(*(*Klj[j].KL).KOut).nCykli;
3258  503A     MOVF _PFNf_LIN_STR, W, ACCESS
325A  D9DF     RCALL PL8
325C  0E06     MOVLW 0x6
325E  DA05     RCALL PL18
3260  D9F9     RCALL PL16
3262  DA5D     RCALL PL316
3264  DA53     RCALL PL286
3266  0008     TBLRD*
3268  CFF5     MOVFF TABLAT, _PFNf_LIN_ENDO
326A  F033     NOP
477:           		if((KInd[j].reset)||(nC&&KTim[j].cykl>=nC))						//wylaczenie/minal czas ekspozycji kolejki?
326C  503A     MOVF _PFNf_LIN_STR, W, ACCESS
326E  D9E3     RCALL __end_ofPL8
3270  0101     MOVLB 0x1
3272  B6DF     BTFSC INDF2, 3, ACCESS
3274  D007     BRA 0x3284
3276  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
3278  E01D     BZ 0x32B4
327A  503A     MOVF _PFNf_LIN_STR, W, ACCESS
327C  DA1D     RCALL PL112
327E  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
3280  5CDE     SUBWF POSTINC2, W, ACCESS
3282  E318     BNC 0x32B4
478:           		{																//dla kolejek z ogr. czasem eksp. po uplynieciu czasu deaktywowane sa wszystkie pozycje kol.
479:           			KTim[j].cykl=0;
3284  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3286  DA18     RCALL PL112
3288  6ADF     CLRF INDF2, ACCESS
480:           			KInd[j].reset=0;
328A  503A     MOVF _PFNf_LIN_STR, W, ACCESS
328C  D9D4     RCALL __end_ofPL8
328E  96DF     BCF INDF2, 3, ACCESS
481:           			for(i=0;i<Klj[j].nPzc;i++) (*Klj[j].KL).KFc[i].focus=0;		
3290  6A37     CLRF _PFNf_LIN_PBCO, ACCESS
3292  D009     BRA 0x32A6
3294  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3296  D9C1     RCALL PL8
3298  0E04     MOVLW 0x4
329A  D9E7     RCALL PL18
329C  D9DB     RCALL PL16
329E  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
32A0  DA24     RCALL PL276
32A2  90DF     BCF INDF2, 0, ACCESS
32A4  2A37     INCF _PFNf_LIN_PBCO, F, ACCESS
32A6  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32A8  D9E4     RCALL PL24
32AA  D9CD     RCALL PL14
32AC  0009     TBLRD*+
32AE  50F5     MOVF TABLAT, W, ACCESS
32B0  5C37     SUBWF _PFNf_LIN_PBCO, W, ACCESS
32B2  E3F0     BNC 0x3294
482:           		}
483:           		//restart kolejki z ograniczonym czasem ekspozycji (liczba cykli zerowana i wszystkie pozycje zostaj¹ aktywowane)
484:           		if((KInd[j].restart||KInd[j].restart1)&&nC)											//start kolejki z okreslonym czasem eksp.?
32B4  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32B6  D9BF     RCALL __end_ofPL8
32B8  0101     MOVLB 0x1
32BA  B4DF     BTFSC INDF2, 2, ACCESS
32BC  D004     BRA 0x32C6
32BE  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32C0  D9BA     RCALL __end_ofPL8
32C2  A2DF     BTFSS INDF2, 1, ACCESS
32C4  D017     BRA 0x32F4
32C6  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
32C8  E015     BZ 0x32F4
485:           		{
486:           			KTim[j].cykl=0;
32CA  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32CC  D9F5     RCALL PL112
32CE  6ADF     CLRF INDF2, ACCESS
487:           			for(i=0;i<Klj[j].nPzc;i++) (*Klj[j].KL).KFc[i].focus=1;		//dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.
32D0  6A37     CLRF _PFNf_LIN_PBCO, ACCESS
32D2  D009     BRA 0x32E6
32D4  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32D6  D9A1     RCALL PL8
32D8  0E04     MOVLW 0x4
32DA  D9C7     RCALL PL18
32DC  D9BB     RCALL PL16
32DE  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
32E0  DA04     RCALL PL276
32E2  80DF     BSF INDF2, 0, ACCESS
32E4  2A37     INCF _PFNf_LIN_PBCO, F, ACCESS
32E6  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32E8  D9C4     RCALL PL24
32EA  D9AD     RCALL PL14
32EC  0009     TBLRD*+
32EE  50F5     MOVF TABLAT, W, ACCESS
32F0  5C37     SUBWF _PFNf_LIN_PBCO, W, ACCESS
32F2  E3F0     BNC 0x32D4
488:           		}
489:           #if LCD4D==0
490:           		//jezeli pozycja jest nieaktywna to jest zerowana 
491:           		if(KInd[j].restart||!((*cadr).St.focus))	//kolejka nieaktywna lub restart kolejki?
492:           		{
493:           			KInd[j].restart=0;
494:           			#if RSNFRS!=0
495:           			if(!nC)
496:           			{
497:           				KInd[j].indeks=0;											
498:           				KTim[j].ncS=0;
499:           				KTim[j].ndS=0;
500:           			}
501:           			#else
502:           				KInd[j].indeks=0;											
503:           				KTim[j].ncS=0;
504:           				KTim[j].ndS=0;
505:           			#endif
506:           			if(KInd[j].restart2) KInd[j].indeks=1;
507:           		}
508:           		(*cadr).St.focus=0;						//wstepna deaktywacja calej kolejki w tablicy priorytetow wyswietlania PWD
509:           #else
510:           		if(KInd[j].restart||((!(*cadr).St.focus)&&(!(*cadr).St2.focus)))	//kolejka nieaktywna lub restart kolejki?
32F4  503A     MOVF _PFNf_LIN_STR, W, ACCESS
32F6  D99F     RCALL __end_ofPL8
32F8  0101     MOVLB 0x1
32FA  B4DF     BTFSC INDF2, 2, ACCESS
32FC  D006     BRA 0x330A
32FE  DA1D     RCALL PL418
3300  B0DF     BTFSC INDF2, 0, ACCESS
3302  D01C     BRA 0x333C
3304  D9EB     RCALL PL224
3306  B0DF     BTFSC INDF2, 0, ACCESS
3308  D019     BRA 0x333C
511:           		{
512:           			KInd[j].restart=0;
330A  503A     MOVF _PFNf_LIN_STR, W, ACCESS
330C  D994     RCALL __end_ofPL8
330E  94DF     BCF INDF2, 2, ACCESS
513:           			#if RSNFRS!=0
514:           			if(!nC)
515:           			{
516:           				KInd[j].indeks=0;											
517:           				KTim[j].ncS=0;
518:           				KTim[j].ndS=0;
519:           			}
520:           			#else
521:           				KInd[j].indeks=0;											
3310  D9B6     RCALL PL44
3312  0EC0     MOVLW 0xC0
3314  16DF     ANDWF INDF2, F, ACCESS
522:           				KTim[j].ncS=0;
3316  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3318  D9BB     RCALL PL82
331A  6ADF     CLRF INDF2, ACCESS
523:           				KTim[j].ndS=0;
331C  503A     MOVF _PFNf_LIN_STR, W, ACCESS
331E  D9C4     RCALL PL110
3320  6ADF     CLRF INDF2, ACCESS
524:           			#endif
525:           			if(KInd[j].restart1&&KInd[j].restart2) KInd[j].indeks=1;
3322  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3324  D988     RCALL __end_ofPL8
3326  A2DF     BTFSS INDF2, 1, ACCESS
3328  D009     BRA 0x333C
332A  503A     MOVF _PFNf_LIN_STR, W, ACCESS
332C  D984     RCALL __end_ofPL8
332E  A0DF     BTFSS INDF2, 0, ACCESS
3330  D005     BRA 0x333C
3332  D9A5     RCALL PL44
3334  50DF     MOVF INDF2, W, ACCESS
3336  0BC0     ANDLW 0xC0
3338  0901     IORLW 0x1
333A  6EDF     MOVWF INDF2, ACCESS
526:           		}
527:           		(*cadr).St.focus=0;						//wstepna deaktywacja calej kolejki w tablicy priorytetow wyswietlania PWD
333C  D9FE     RCALL PL418
333E  90DF     BCF INDF2, 0, ACCESS
3340  D9CD     RCALL PL224
528:           		(*cadr).St2.focus=0;						//wstepna deaktywacja calej kolejki w tablicy priorytetow wyswietlania PWD
3342  90DF     BCF INDF2, 0, ACCESS
3344  D99C     RCALL PL44
529:           #endif
530:           		for(i=KInd[j].indeks;i<Klj[j].nPzc;i++)							//autoaktywacja kolejki nastapi przy aktywnej conajmniej jednej pozycji w kol.
3346  50DF     MOVF INDF2, W, ACCESS
3348  0B3F     ANDLW 0x3F
334A  6E37     MOVWF _PFNf_LIN_PBCO, ACCESS
334C  D159     BRA 0x3600
35FE  2A37     INCF _PFNf_LIN_PBCO, F, ACCESS
3600  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3602  D837     RCALL PL24
3604  D820     RCALL PL14
3606  0009     TBLRD*+
3608  50F5     MOVF TABLAT, W, ACCESS
360A  5C37     SUBWF _PFNf_LIN_PBCO, W, ACCESS
360C  E201     BC 0x3610
360E  D69F     BRA 0x334E
531:           		{
532:           			padr=((*Klj[j].KL).KAP[i]).PAdr;
334E  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3350  D964     RCALL PL8
3352  D980     RCALL PL16
3354  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
3356  D9CF     RCALL PL280
3358  CFF5     MOVFF TABLAT, _PFNf_KnfDisErr
335A  F02F     NOP
335C  000A     TBLRD*-
335E  CFF5     MOVFF TABLAT, _PFNf_LIN_CK
3360  F030     NOP
533:           			//poszukuj kolejke o aktywnej przynajmniej jednej pozycji
534:           			if (!(*Klj[j].KL).KFc[i].focus)								//pozycja nieaktywna?
3362  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3364  D95A     RCALL PL8
3366  0E04     MOVLW 0x4
3368  D980     RCALL PL18
336A  D974     RCALL PL16
336C  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
336E  D9BD     RCALL PL276
3370  B0DF     BTFSC INDF2, 0, ACCESS
3372  D01C     BRA 0x33AC
535:           			{
536:           				if(i>=Klj[j].nPzc-1)
3374  D995     RCALL PL96
3376  D97D     RCALL PL24
3378  D966     RCALL PL14
337A  D9D6     RCALL PL364
337C  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
337E  6E2C     MOVWF _PFNf_EnLIN, ACCESS
3380  6A2D     CLRF _PFNf_FLIN, ACCESS
3382  502A     MOVF _PFNf_EnAleg, W, ACCESS
3384  5C2C     SUBWF _PFNf_EnLIN, W, ACCESS
3386  502D     MOVF _PFNf_FLIN, W, ACCESS
3388  0A80     XORLW 0x80
338A  6E2E     MOVWF _PFNf_FOT, ACCESS
338C  502B     MOVF _PFNf_EnF10V, W, ACCESS
338E  0A80     XORLW 0x80
3390  582E     SUBWFB _PFNf_FOT, W, ACCESS
3392  E201     BC 0x3396
3394  D134     BRA 0x35FE
3396  D973     RCALL PL44
537:           				{
538:           					KInd[j].indeks=0;
3398  0EC0     MOVLW 0xC0
339A  0101     MOVLB 0x1
339C  16DF     ANDWF INDF2, F, ACCESS
539:           					if(nC) KTim[j].cykl++;
339E  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
33A0  E101     BNZ 0x33A4
33A2  D12D     BRA 0x35FE
33A4  503A     MOVF _PFNf_LIN_STR, W, ACCESS
33A6  D988     RCALL PL112
33A8  2ADF     INCF INDF2, F, ACCESS
33AA  D129     BRA 0x35FE
540:           				}
541:           				continue;					
542:           			}
543:           			//znaleziono kolejke o aktywnej przynajmniej jednej pozycji
544:           			KInd[j].indeks=i;											//zapamietaj nr aktualnie wyswietlanej pozycji
33AC  D968     RCALL PL44
33AE  0101     MOVLB 0x1
33B0  50DF     MOVF INDF2, W, ACCESS
33B2  1837     XORWF _PFNf_LIN_PBCO, W, ACCESS
33B4  0BC0     ANDLW 0xC0
33B6  1837     XORWF _PFNf_LIN_PBCO, W, ACCESS
33B8  6EDF     MOVWF INDF2, ACCESS
545:           			#if DKLPNC!=0
546:           			//deaktywuj wszystkie pozycje kolejek o nizszym priorytecie i ograniczonym czasie ekspozycji kolejki
547:           			for(k=j+1;k<NKOL;k++)										
33BA  283A     INCF _PFNf_LIN_STR, W, ACCESS
33BC  6E36     MOVWF _PFNf_LIN_KSK, ACCESS
33BE  0E02     MOVLW 0x2
33C0  6436     CPFSGT _PFNf_LIN_KSK, ACCESS
33C2  D001     BRA 0x33C6
33C4  D021     BRA 0x3408
3404  2A36     INCF _PFNf_LIN_KSK, F, ACCESS
3406  D7DB     BRA 0x33BE
548:           				if((*(*Klj[k].KL).KOut).nCykli)							//okreslony czas ekspozycji?
33C6  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
33C8  D928     RCALL PL8
33CA  0E06     MOVLW 0x6
33CC  D94E     RCALL PL18
33CE  D942     RCALL PL16
33D0  D9A6     RCALL PL316
33D2  D99C     RCALL PL286
33D4  0008     TBLRD*
33D6  50F5     MOVF TABLAT, W, ACCESS
33D8  E015     BZ 0x3404
549:           				{
550:           					for(l=0;l<Klj[k].nPzc;l++) (*Klj[k].KL).KFc[l].focus=0;		//wylacz wszystkie pozycje kolejki
33DA  6A32     CLRF _PFNf_LIN_DPGD, ACCESS
33DC  D009     BRA 0x33F0
33DE  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
33E0  D91C     RCALL PL8
33E2  0E04     MOVLW 0x4
33E4  D942     RCALL PL18
33E6  D936     RCALL PL16
33E8  5032     MOVF _PFNf_LIN_DPGD, W, ACCESS
33EA  D97F     RCALL PL276
33EC  90DF     BCF INDF2, 0, ACCESS
33EE  2A32     INCF _PFNf_LIN_DPGD, F, ACCESS
33F0  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
33F2  D93F     RCALL PL24
33F4  D928     RCALL PL14
33F6  0009     TBLRD*+
33F8  50F5     MOVF TABLAT, W, ACCESS
33FA  5C32     SUBWF _PFNf_LIN_DPGD, W, ACCESS
33FC  E3F0     BNC 0x33DE
551:           					KTim[k].cykl=0;
33FE  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
3400  D95B     RCALL PL112
3402  6ADF     CLRF INDF2, ACCESS
552:           				}
553:           			#endif
554:           			#if RSAKLP!=0
555:           			//zatrzymanie wszystkich kolejek (o nizszym priorytecie od obecnie wyswietlanej) na pierwszej pozycji (autorestart)
556:           			for(k=j+1;k<NKOL;k++)
3408  283A     INCF _PFNf_LIN_STR, W, ACCESS
340A  6E36     MOVWF _PFNf_LIN_KSK, ACCESS
340C  0E02     MOVLW 0x2
340E  6436     CPFSGT _PFNf_LIN_KSK, ACCESS
3410  D001     BRA 0x3414
3412  D013     BRA 0x343A
3436  2A36     INCF _PFNf_LIN_KSK, F, ACCESS
3438  D7E9     BRA 0x340C
557:           			{
558:           				KInd[k].indeks=0;											
3414  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
3416  0D02     MULLW 0x2
3418  0E9B     MOVLW 0x9B
341A  24F3     ADDWF PROD, W, ACCESS
341C  6ED9     MOVWF FSR2, ACCESS
341E  0E01     MOVLW 0x1
3420  20F4     ADDWFC PRODH, W, ACCESS
3422  6EDA     MOVWF FSR2H, ACCESS
3424  0EC0     MOVLW 0xC0
3426  0101     MOVLB 0x1
3428  16DF     ANDWF INDF2, F, ACCESS
559:           				KTim[k].ncS=0;
342A  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
342C  D931     RCALL PL82
342E  6ADF     CLRF INDF2, ACCESS
560:           				KTim[k].ndS=0;
3430  5036     MOVF _PFNf_LIN_KSK, W, ACCESS
3432  D93A     RCALL PL110
3434  6ADF     CLRF INDF2, ACCESS
561:           			}
562:           			#endif
563:           #if LCD4D==0
564:           			//realizacja czasu ekspozycji pojedynczej pozycji kolejki 
565:           			(*cadr).St.focus=1;											//autoaktywacja kolejki - aktywna conajmniej jedna pozycja w kol.
566:           			if (KTim[j].ndS<(*Klj[j].KL).KWP[i].delay)					//jeszcze nie uplynal czas ekspozycji pozycji?
567:           			{
568:           				KTim[j].ncS++;
569:           				if (KTim[j].ncS>=10) 
570:           				{
571:           					KTim[j].ncS=0;
572:           					KTim[j].ndS++;										//odliczaj czas ekspozycji
573:           				}
574:           #if RSPADR!=0
575:           				if(padr==0)													//nie podano adresu zmiennej dynamicznej?
576:           				{
577:           					if(!KInd[j].restart1)								//kolejka z podtrzymaniem pierwszej pozycji na ekranie przy obsludze znakow dla kolejnych pozycji?
578:           					{
579:           						(*cadr).St=(*Klj[j].KL).KFP[i].PFrm;	//zapisz w tablicy PWD pod pozycja odpowiadajaca kolejce dana do wyswietlenia
580:           						(*cadr).Dt=(*Klj[j].KL).KWP[i].PWrt;
581:           					}
582:           					else
583:           					{
584:           						if(!i) KInd[j].restart1=0;	//podtrzymanie znacznika az do aktywacji pierwszej pozycji kolejki
585:           						(*cadr).St=(*Klj[j].KL).KFP[0].PFrm;
586:           						(*cadr).St.sdiode=(*Klj[j].KL).KFP[i].PFrm.sdiode;
587:           						(*cadr).St.rdiode=(*Klj[j].KL).KFP[i].PFrm.rdiode;
588:           						(*cadr).St.sdiode=(*Klj[j].KL).KFP[i].PFrm.sbdid;
589:           						(*cadr).St.rdiode=(*Klj[j].KL).KFP[i].PFrm.rbdid;
590:           						(*cadr).Dt=(*Klj[j].KL).KWP[0].PWrt;
591:           					}
592:           				}
593:           				else 
594:           #endif
595:           				{
596:           					if(!KInd[j].restart1)	//aktywny tryb kolejki wylacznie dla znakow graficznych?
597:           					{
598:           						*cadr=*padr;													//w przeciwnym przypadku pobierz dana z adresu zmiennej dynamicznej
599:           					}
600:           					else
601:           					{
602:           						if(!i) KInd[j].restart1=0;	//podtrzymanie znacznika az do aktywacji pierwszej pozycji kolejki
603:           						*cadr=*((*Klj[j].KL).KAP[0].PAdr);				//dana pobierana zawsze z pierwszej pozycji kolejki
604:           						(*cadr).St.sdiode=(*padr).St.sdiode; //aktyalizacja stanu znaków dla kolejnych pozycji kolejki
605:           						(*cadr).St.rdiode=(*padr).St.rdiode;
606:           						(*cadr).St.sbdid=(*padr).St.sbdid;
607:           						(*cadr).St.rbdid=(*padr).St.rbdid;
608:           					}
609:           				}
610:           				(*cadr).St.focus=1;										//odtworzenie nadpisanego bitu autoaktywacji
611:           				break;
612:           			}else
613:           			{
614:           				KTim[j].ncS=0;
615:           				KTim[j].ndS=0;											//wyzeruj czas ekspozycji
616:           				if (KInd[j].indeks>=Klj[j].nPzc-1) 
617:           				{
618:           					KInd[j].indeks=0;
619:           					if(nC) KTim[j].cykl++;
620:           				}
621:           			}
622:           #else
623:           			//realizacja czasu ekspozycji pojedynczej pozycji kolejki 
624:           			(*cadr).St.focus=1;										//autoaktywacja kolejki - aktywna conajmniej jedna pozycja w kol.
343A  C038     MOVFF _PFNf_LIN_PBCW, FSR2
343C  FFD9     NOP
343E  D96B     RCALL PL288
3440  D94D     RCALL PL224
625:           			(*cadr).St2.focus=1;									//autoaktywacja kolejki - aktywna conajmniej jedna pozycja w kol.
3442  80DF     BSF INDF2, 0, ACCESS
626:           			if (KTim[j].ndS<(*Klj[j].KL).KWP[i].delay)					//jeszcze nie uplynal czas ekspozycji pozycji?
3444  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3446  D930     RCALL PL110
3448  50DF     MOVF INDF2, W, ACCESS
344A  6E28     MOVWF _PFNf_10V_RT, ACCESS
344C  503A     MOVF _PFNf_LIN_STR, W, ACCESS
344E  0D03     MULLW 0x3
3450  D8FA     RCALL PL14
3452  0009     TBLRD*+
3454  CFF5     MOVFF TABLAT, _PFNf_10V_nPCO
3456  F029     NOP
3458  0009     TBLRD*+
345A  CFF5     MOVFF TABLAT, _PFNf_EnAleg
345C  F02A     NOP
345E  0E02     MOVLW 0x2
3460  2629     ADDWF _PFNf_10V_nPCO, F, ACCESS
3462  0E00     MOVLW 0x0
3464  222A     ADDWFC _PFNf_EnAleg, F, ACCESS
3466  C029     MOVFF _PFNf_10V_nPCO, TBLPTR
3468  FFF6     NOP
346A  C02A     MOVFF _PFNf_EnAleg, TBLPTRH
346C  FFF7     NOP
346E  0009     TBLRD*+
3470  CFF5     MOVFF TABLAT, _PFNf_EnF10V
3472  F02B     NOP
3474  0009     TBLRD*+
3476  CFF5     MOVFF TABLAT, _PFNf_EnLIN
3478  F02C     NOP
347A  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
347C  262B     ADDWF _PFNf_EnF10V, F, ACCESS
347E  0E00     MOVLW 0x0
3480  222C     ADDWFC _PFNf_EnLIN, F, ACCESS
3482  C02B     MOVFF _PFNf_EnF10V, TBLPTR
3484  FFF6     NOP
3486  C02C     MOVFF _PFNf_EnLIN, TBLPTRH
3488  FFF7     NOP
348A  0008     TBLRD*
348C  50F5     MOVF TABLAT, W, ACCESS
348E  5C28     SUBWF _PFNf_10V_RT, W, ACCESS
3490  E301     BNC 0x3494
3492  D099     BRA 0x35C6
627:           			{
628:           				KTim[j].ncS++;
3494  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3496  D8FC     RCALL PL82
3498  2ADF     INCF INDF2, F, ACCESS
629:           				if (KTim[j].ncS>=10) 
349A  503A     MOVF _PFNf_LIN_STR, W, ACCESS
349C  D8F9     RCALL PL82
349E  0E09     MOVLW 0x9
34A0  64DF     CPFSGT INDF2, ACCESS
34A2  D006     BRA 0x34B0
630:           				{
631:           					KTim[j].ncS=0;
34A4  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34A6  D8F4     RCALL PL82
34A8  6ADF     CLRF INDF2, ACCESS
632:           					KTim[j].ndS++;										//odliczaj czas ekspozycji
34AA  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34AC  D8FD     RCALL PL110
34AE  2ADF     INCF INDF2, F, ACCESS
633:           				}
634:           #if RSPADR!=0
635:           				if(padr==0)							//nie podano adresu zmiennej dynamicznej?
636:           				{
637:           					if(!KInd[j].restart1)								//kolejka z podtrzymaniem pierwszej pozycji na ekranie przy obsludze znakow dla kolejnych pozycji?
638:           					{
639:           						(*cadr).St=(*Klj[j].KL).KFP[i].PFrm;	//zapisz w tablicy PWD pod pozycja odpowiadajaca kolejce dana do wyswietlenia
640:           						(*cadr).Dt=(*Klj[j].KL).KWP[i].PWrt;
641:           						(*cadr).St2=(*Klj[j].KL).KFP[i].PFrm2;	//zapisz w tablicy PWD pod pozycja odpowiadajaca kolejce dana do wyswietlenia
642:           						(*cadr).Dt2=(*Klj[j].KL).KWP[i].PWrt2;
643:           					}
644:           					else
645:           					{
646:           						if(!i) KInd[j].restart1=0;	//podtrzymanie znacznika az do aktywacji pierwszej pozycji kolejki
647:           						(*cadr).Dt=(*Klj[j].KL).KWP[0].PWrt;
648:           						(*cadr).St=(*Klj[j].KL).KFP[0].PFrm;
649:           						(*cadr).St.sdiode=(*Klj[j].KL).KFP[i].PFrm.sdiode;
650:           						(*cadr).St.rdiode=(*Klj[j].KL).KFP[i].PFrm.rdiode;
651:           						(*cadr).St.sdiode=(*Klj[j].KL).KFP[i].PFrm.sbdid;
652:           						(*cadr).St.rdiode=(*Klj[j].KL).KFP[i].PFrm.rbdid;
653:           						(*cadr).Dt2=(*Klj[j].KL).KWP[0].PWrt2;
654:           						(*cadr).St2=(*Klj[j].KL).KFP[0].PFrm2;
655:           						(*cadr).St2.sdiode=(*Klj[j].KL).KFP[i].PFrm2.sdiode;
656:           						(*cadr).St2.rdiode=(*Klj[j].KL).KFP[i].PFrm2.rdiode;
657:           						(*cadr).St2.sdiode=(*Klj[j].KL).KFP[i].PFrm2.sbdid;
658:           						(*cadr).St2.rdiode=(*Klj[j].KL).KFP[i].PFrm2.rbdid;
659:           					}
660:           				}
661:           				else
662:           #endif
663:           				{
664:           					if(!KInd[j].restart1)		//aktywny tryb kolejki wylacznie dla znakow graficznych?
34B0  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34B2  D8C1     RCALL __end_ofPL8
34B4  0101     MOVLB 0x1
34B6  B2DF     BTFSC INDF2, 1, ACCESS
34B8  D00A     BRA 0x34CE
665:           					{
666:           						*cadr=*padr;
34BA  C02F     MOVFF _PFNf_KnfDisErr, FSR2
34BC  FFD9     NOP
34BE  C030     MOVFF _PFNf_LIN_CK, FSR2H
34C0  FFDA     NOP
34C2  D940     RCALL PL562
34C4  CFDB     MOVFF PLUSW2, PLUSW1
34C6  FFE3     NOP
34C8  06E8     DECF WREG, F, ACCESS
34CA  E2FC     BC 0x34C4
667:           					}
34CC  D076     BRA 0x35BA
668:           					else
669:           					{
670:           						if(!i) {KInd[j].restart1=0;KInd[j].restart2=0;}	//podtrzymanie znacznika az do aktywacji pierwszej pozycji kolejki
34CE  5037     MOVF _PFNf_LIN_PBCO, W, ACCESS
34D0  E106     BNZ 0x34DE
34D2  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34D4  D8B0     RCALL __end_ofPL8
34D6  92DF     BCF INDF2, 1, ACCESS
34D8  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34DA  D8AD     RCALL __end_ofPL8
34DC  90DF     BCF INDF2, 0, ACCESS
671:           						*cadr=*((*Klj[j].KL).KAP[0].PAdr);				//dana pobierana zawsze z pierwszej pozycji kolejki
34DE  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34E0  D89C     RCALL PL8
34E2  D8B8     RCALL PL16
34E4  D913     RCALL PL286
34E6  0009     TBLRD*+
34E8  CFF5     MOVFF TABLAT, FSR2
34EA  FFD9     NOP
34EC  0009     TBLRD*+
34EE  CFF5     MOVFF TABLAT, FSR2H
34F0  FFDA     NOP
34F2  D928     RCALL PL562
34F4  CFDB     MOVFF PLUSW2, PLUSW1
34F6  FFE3     NOP
34F8  06E8     DECF WREG, F, ACCESS
34FA  E2FC     BC 0x34F4
672:           						if(!KInd[j].restart2)							//zacznij od drugiej pozycji?
34FC  503A     MOVF _PFNf_LIN_STR, W, ACCESS
34FE  D89B     RCALL __end_ofPL8
3500  B0DF     BTFSC INDF2, 0, ACCESS
3502  D003     BRA 0x350A
673:           						{	
674:           							kk=i;
3504  C037     MOVFF _PFNf_LIN_PBCO, _PFNf_LIN_CW
3506  F031     NOP
675:           						}
3508  D002     BRA 0x350E
676:           						else
677:           						{
678:           							kk=1;
350A  0E01     MOVLW 0x1
350C  6E31     MOVWF _PFNf_LIN_CW, ACCESS
679:           						}
680:           						padr2=((*Klj[j].KL).KAP[kk]).PAdr;
350E  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3510  D884     RCALL PL8
3512  D8A0     RCALL PL16
3514  5031     MOVF _PFNf_LIN_CW, W, ACCESS
3516  D8EF     RCALL PL280
3518  CFF5     MOVFF TABLAT, _PFNf_LIN_EPBCO
351A  F034     NOP
351C  000A     TBLRD*-
351E  CFF5     MOVFF TABLAT, _PFNf_LIN_EPBCW
3520  F035     NOP
681:           						(*cadr).St.sdiode=(*padr2).St.sdiode; //aktyalizacja stanu znaków dla kolejnych pozycji kolejki
3522  EE20     LFSR 2, 0x1
3524  F001     NOP
3526  D8D5     RCALL PL218
3528  EE10     LFSR 1, 0x1
352A  F001     NOP
352C  D8CD     RCALL PL208
352E  B4DF     BTFSC INDF2, 2, ACCESS
3530  D002     BRA 0x3536
3532  94E7     BCF INDF1, 2, ACCESS
3534  D001     BRA 0x3538
3536  84E7     BSF INDF1, 2, ACCESS
682:           						(*cadr).St.rdiode=(*padr2).St.rdiode;
3538  EE20     LFSR 2, 0x1
353A  F001     NOP
353C  D8CA     RCALL PL218
353E  EE10     LFSR 1, 0x1
3540  F001     NOP
3542  D8C2     RCALL PL208
3544  B6DF     BTFSC INDF2, 3, ACCESS
3546  D002     BRA 0x354C
3548  96E7     BCF INDF1, 3, ACCESS
354A  D001     BRA 0x354E
354C  86E7     BSF INDF1, 3, ACCESS
683:           						(*cadr).St.sbdid=(*padr2).St.sbdid;
354E  EE20     LFSR 2, 0x4
3550  F004     NOP
3552  D8BF     RCALL PL218
3554  EE10     LFSR 1, 0x4
3556  F004     NOP
3558  D8B7     RCALL PL208
355A  CFDF     MOVFF INDF2, INDF1
355C  FFE7     NOP
684:           						(*cadr).St.rbdid=(*padr2).St.rbdid;
355E  EE20     LFSR 2, 0x5
3560  F005     NOP
3562  D8B7     RCALL PL218
3564  EE10     LFSR 1, 0x5
3566  F005     NOP
3568  D8AF     RCALL PL208
356A  CFDF     MOVFF INDF2, INDF1
356C  FFE7     NOP
685:           						(*cadr).St2.sdiode=(*padr2).St2.sdiode; //aktyalizacja stanu znaków dla kolejnych pozycji kolejki
356E  EE20     LFSR 2, 0xB
3570  F00B     NOP
3572  D8AF     RCALL PL218
3574  EE10     LFSR 1, 0xB
3576  F00B     NOP
3578  D8A7     RCALL PL208
357A  B4DF     BTFSC INDF2, 2, ACCESS
357C  D002     BRA 0x3582
357E  94E7     BCF INDF1, 2, ACCESS
3580  D001     BRA 0x3584
3582  84E7     BSF INDF1, 2, ACCESS
686:           						(*cadr).St2.rdiode=(*padr2).St2.rdiode;
3584  EE20     LFSR 2, 0xB
3586  F00B     NOP
3588  D8A4     RCALL PL218
358A  EE10     LFSR 1, 0xB
358C  F00B     NOP
358E  D89C     RCALL PL208
3590  B6DF     BTFSC INDF2, 3, ACCESS
3592  D002     BRA 0x3598
3594  96E7     BCF INDF1, 3, ACCESS
3596  D001     BRA 0x359A
3598  86E7     BSF INDF1, 3, ACCESS
687:           						(*cadr).St2.sbdid=(*padr2).St2.sbdid;
359A  EE20     LFSR 2, 0xE
359C  F00E     NOP
359E  D899     RCALL PL218
35A0  EE10     LFSR 1, 0xE
35A2  F00E     NOP
35A4  D891     RCALL PL208
35A6  CFDF     MOVFF INDF2, INDF1
35A8  FFE7     NOP
688:           						(*cadr).St2.rbdid=(*padr2).St2.rbdid;	
35AA  EE20     LFSR 2, 0xF
35AC  F00F     NOP
35AE  D891     RCALL PL218
35B0  EE10     LFSR 1, 0xF
35B2  F00F     NOP
35B4  D889     RCALL PL208
35B6  CFDF     MOVFF INDF2, INDF1
35B8  FFE7     NOP
689:           					}
690:           				}
691:           				(*cadr).St.focus=1;										//odtworzenie nadpisanego bitu autoaktywacji
35BA  C038     MOVFF _PFNf_LIN_PBCW, FSR2
35BC  FFD9     NOP
35BE  D8AB     RCALL PL288
35C0  D88D     RCALL PL224
692:           				(*cadr).St2.focus=1;									//odtworzenie nadpisanego bitu autoaktywacji
35C2  80DF     BSF INDF2, 0, ACCESS
693:           				break;
35C4  D025     BRA 0x3610
694:           			}else
695:           			{
696:           				KTim[j].ncS=0;
35C6  503A     MOVF _PFNf_LIN_STR, W, ACCESS
35C8  D863     RCALL PL82
35CA  6ADF     CLRF INDF2, ACCESS
697:           				KTim[j].ndS=0;											//wyzeruj czas ekspozycji
35CC  503A     MOVF _PFNf_LIN_STR, W, ACCESS
35CE  D86C     RCALL PL110
35D0  6ADF     CLRF INDF2, ACCESS
35D2  D866     RCALL PL96
35D4  D84E     RCALL PL24
35D6  D837     RCALL PL14
35D8  D8A7     RCALL PL364
35DA  D851     RCALL PL44
698:           				if (KInd[j].indeks>=Klj[j].nPzc-1) 
35DC  0101     MOVLB 0x1
35DE  50DF     MOVF INDF2, W, ACCESS
35E0  0B3F     ANDLW 0x3F
35E2  6E2C     MOVWF _PFNf_EnLIN, ACCESS
35E4  6A2D     CLRF _PFNf_FLIN, ACCESS
35E6  502A     MOVF _PFNf_EnAleg, W, ACCESS
35E8  5C2C     SUBWF _PFNf_EnLIN, W, ACCESS
35EA  502D     MOVF _PFNf_FLIN, W, ACCESS
35EC  0A80     XORLW 0x80
35EE  6E2E     MOVWF _PFNf_FOT, ACCESS
35F0  502B     MOVF _PFNf_EnF10V, W, ACCESS
35F2  0A80     XORLW 0x80
35F4  582E     SUBWFB _PFNf_FOT, W, ACCESS
35F6  E303     BNC 0x35FE
35F8  D842     RCALL PL44
699:           				{
700:           					KInd[j].indeks=0;
35FA  0EC0     MOVLW 0xC0
35FC  D6CF     BRA 0x339C
35FE  2A37     INCF _PFNf_LIN_PBCO, F, ACCESS
3600  503A     MOVF _PFNf_LIN_STR, W, ACCESS
3602  D837     RCALL PL24
3604  D820     RCALL PL14
3606  0009     TBLRD*+
3608  50F5     MOVF TABLAT, W, ACCESS
360A  5C37     SUBWF _PFNf_LIN_PBCO, W, ACCESS
360C  E201     BC 0x3610
360E  D69F     BRA 0x334E
3610  2A3A     INCF _PFNf_LIN_STR, F, ACCESS
3612  0E02     MOVLW 0x2
3614  643A     CPFSGT _PFNf_LIN_STR, ACCESS
3616  D614     BRA 0x3240
3618  0C02     RETLW 0x2
701:           					if(nC) KTim[j].cykl++;
702:           				}
703:           			}
704:           #endif
705:           		}
706:           	}	
707:           }
708:           #endif
709:           /*--------------------------------------------------------------*/
710:           //Aktywacja/deaktywacja obslugi kolejnych znakow graficznych (KMark[i].focus) ktorym nadajemy okreslony stan
711:           // wartoscia KMark[i].m lub wymuszamy migotanie wartoscia KMark[i].p=1;
712:           #if NMZNK!=0
713:           void KolMark(void)
714:           {
715:           	static unsigned char c,d,fl;
716:           	unsigned char i;
717:           
718:           	//odlicz interwal czasu
719:           	c++;
A3C2  0101     MOVLB 0x1
A3C4  2BAA     INCF f, F, BANKED
720:           	if (c>=10) 			//odliczaj czas
A3C6  0E09     MOVLW 0x9
A3C8  65AA     CPFSGT f, BANKED
A3CA  D002     BRA 0xA3D0
721:           	{
722:           		c=0;
A3CC  6BAA     CLRF f, BANKED
723:           		d++;			 
A3CE  2BAB     INCF 0xAB, F, BANKED
724:           	}
725:           	if(d>=6)			//odlicz interwal pulsacji	
A3D0  0E05     MOVLW 0x5
A3D2  65AB     CPFSGT 0xAB, BANKED
A3D4  D007     BRA 0xA3E4
726:           	{
727:           		d=0;
A3D6  6BAB     CLRF 0xAB, BANKED
728:            		if(fl) fl=0;	//ustaw znacznik wygaszenia
A3D8  51AC     MOVF 0xAC, W, BANKED
A3DA  E002     BZ 0xA3E0
A3DC  6BAC     CLRF 0xAC, BANKED
A3DE  D002     BRA 0xA3E4
729:           		else fl=1;		//ustaw znacznik zapalenia
A3E0  0E01     MOVLW 0x1
A3E2  6FAC     MOVWF 0xAC, BANKED
730:           	}
731:           	//dla aktywnej pulsacji wysteruj/wygas znak
732:           	for(i=0;i<NMZNK;i++)
A3E4  6A28     CLRF _PFNf_10V_RT, ACCESS
A418  2A28     INCF _PFNf_10V_RT, F, ACCESS
733:           	{
734:           		if(KMark[i].focus)	//aktywna pozycja kolejki?
A3E6  0EE2     MOVLW 0xE2
A3E8  2428     ADDWF _PFNf_10V_RT, W, ACCESS
A3EA  D81B     RCALL PL172
A3EC  0103     MOVLB 0x3
A3EE  A0DF     BTFSS INDF2, 0, ACCESS
A3F0  D013     BRA 0xA418
735:           		{
736:           			if(KMark[i].p)	//aktywny znacznik pulsacji?
A3F2  0EE2     MOVLW 0xE2
A3F4  2428     ADDWF _PFNf_10V_RT, W, ACCESS
A3F6  D815     RCALL PL172
A3F8  A4DF     BTFSS INDF2, 2, ACCESS
A3FA  D00E     BRA 0xA418
737:           			{
738:           				//przejmij sterowanie znakiem graficznym
739:           				if(fl) KMark[i].m=1;	//wysteruj znak	
A3FC  0101     MOVLB 0x1
A3FE  51AC     MOVF 0xAC, W, BANKED
A400  E006     BZ 0xA40E
A402  0EE2     MOVLW 0xE2
A404  2428     ADDWF _PFNf_10V_RT, W, ACCESS
A406  D80D     RCALL PL172
A408  0103     MOVLB 0x3
A40A  82DF     BSF INDF2, 1, ACCESS
A40C  D005     BRA 0xA418
740:           				else KMark[i].m=0;		//wygas znak
A40E  0EE2     MOVLW 0xE2
A410  2428     ADDWF _PFNf_10V_RT, W, ACCESS
A412  D807     RCALL PL172
A414  0103     MOVLB 0x3
A416  92DF     BCF INDF2, 1, ACCESS
A418  2A28     INCF _PFNf_10V_RT, F, ACCESS
A41A  0E0F     MOVLW 0xF
A41C  6428     CPFSGT _PFNf_10V_RT, ACCESS
A41E  D7E3     BRA 0xA3E6
A420  0C0F     RETLW 0xF
741:           			}
742:           		}
743:           	}
744:           }
745:           #endif
746:           /*--------------------------------------------------------------*/
747:           //Pobranie danej do wyswietlenia (poczynajac od najwyzszego priorytetu pierwsza
748:           //z ustawiona flaga focus).
749:           //Kolejno 0 - najwyzszy priorytet,...,(NPWD-1) - najnizszy priorytet
750:           void SetPrWswData(void)
751:           {
752:           	unsigned char i;
753:           
754:           #if LCD4D!=0
755:           	for(i=0;i<NPWD-1;i++)
A04C  6A28     CLRF _PFNf_10V_RT, ACCESS
A072  2A28     INCF _PFNf_10V_RT, F, ACCESS
A074  0E03     MOVLW 0x3
A076  6428     CPFSGT _PFNf_10V_RT, ACCESS
A078  D7EA     BRA 0xA04E
756:           	{
757:           		if(PWD[i].St.focus||PWD[i].St2.focus)				//ustawiona flaga focus?
A04E  5028     MOVF _PFNf_10V_RT, W, ACCESS
A050  D827     RCALL PL254
A052  B0DF     BTFSC INDF2, 0, ACCESS
A054  D004     BRA 0xA05E
A056  5028     MOVF _PFNf_10V_RT, W, ACCESS
A058  D82B     RCALL PL432
A05A  A0DF     BTFSS INDF2, 0, ACCESS
A05C  D00A     BRA 0xA072
758:           		{
759:           			WswData=PWD[i];
A05E  5028     MOVF _PFNf_10V_RT, W, ACCESS
A060  D81F     RCALL PL254
A062  EE14     LFSR 1, 0x42C
A064  F02C     NOP
A066  0E0F     MOVLW 0xF
A068  CFDB     MOVFF PLUSW2, PLUSW1
A06A  FFE3     NOP
A06C  06E8     DECF WREG, F, ACCESS
A06E  E2FC     BC 0xA068
A070  0012     RETURN 0
760:           			return;
761:           		};
762:           	}
763:           #else
764:           	for(i=0;i<NPWD-1;i++)
765:           	{
766:           		if(PWD[i].St.focus)				//ustawiona flaga focus?
767:           		{
768:           			WswData=PWD[i];
769:           			return;
770:           		};
771:           	}
772:           #endif
773:           	WswData=PWD[NPWD-1];									//wyswietl dana o najnizszym priorytecie
A07A  EE23     LFSR 2, 0x3A0
A07C  F0A0     NOP
A07E  EE14     LFSR 1, 0x42C
A080  F02C     NOP
A082  0E0F     MOVLW 0xF
A084  CFDB     MOVFF PLUSW2, PLUSW1
A086  FFE3     NOP
A088  06E8     DECF WREG, F, ACCESS
A08A  E2FC     BC 0xA084
774:           	bfWswData=PWD[NPWD-1];
A08C  EE23     LFSR 2, 0x3A0
A08E  F0A0     NOP
A090  EE14     LFSR 1, 0x43C
A092  F03C     NOP
A094  0E0F     MOVLW 0xF
A096  CFDB     MOVFF PLUSW2, PLUSW1
A098  FFE3     NOP
A09A  06E8     DECF WREG, F, ACCESS
A09C  E2FC     BC 0xA096
775:           }
A09E  0012     RETURN 0
776:           /*--------------------------------------------------------------*/
777:           void SetLedData(WData Dt,WStatus St,volatile LedPack *LedData,const unsigned char gr)
778:           {
779:           	volatile unsigned char *dLed1,*dLed0;
780:           #if LCD4D!=0
781:           	dLed1=(!gr)?&(*LedData).dLed1:&(*LedData).dLed3;
67FC  5035     MOVF _PFNf_LIN_EPBCW, W, ACCESS
67FE  E002     BZ 0x6804
6800  2834     INCF _PFNf_LIN_EPBCO, W, ACCESS
6802  D002     BRA 0x6808
6804  5034     MOVF _PFNf_LIN_EPBCO, W, ACCESS
6806  0F03     ADDLW 0x3
6808  6E3B     MOVWF _PFNf_LINres, ACCESS
782:           	dLed0=(!gr)?&(*LedData).dLed0:&(*LedData).dLed2;
680A  5035     MOVF _PFNf_LIN_EPBCW, W, ACCESS
680C  E003     BZ 0x6814
680E  5034     MOVF _PFNf_LIN_EPBCO, W, ACCESS
6810  0F02     ADDLW 0x2
6812  D002     BRA 0x6818
6814  5034     MOVF _PFNf_LIN_EPBCO, W, ACCESS
6816  0F04     ADDLW 0x4
6818  6E3A     MOVWF _PFNf_LIN_STR, ACCESS
783:           #else
784:           	dLed1=&(*LedData).dLed1;
785:           	dLed0=&(*LedData).dLed0;
786:           #endif
787:           	if(St.hex)										//konwersja hex na kod led
681A  A42E     BTFSS _PFNf_FOT, 2, ACCESS
681C  D008     BRA 0x682E
788:           	{
789:           		*dLed1=Znak[(Dt.Data0&0xF0)>>4];
681E  382D     SWAPF _PFNf_FLIN, W, ACCESS
6820  0B0F     ANDLW 0xF
6822  D875     RCALL PL198
6824  503B     MOVF _PFNf_LINres, W, ACCESS
6826  D87C     RCALL PL380
790:           		*dLed0=Znak[Dt.Data0&0x0F];
6828  502D     MOVF _PFNf_FLIN, W, ACCESS
682A  0B0F     ANDLW 0xF
682C  D013     BRA 0x6854
791:           	}else
792:           	if(St.dec)										//konwersja dec na kod led
682E  A22E     BTFSS _PFNf_FOT, 1, ACCESS
6830  D015     BRA 0x685C
793:           	{
794:           		if(Dt.Data0>99) Dt.Data0=99;
6832  0E63     MOVLW 0x63
6834  642D     CPFSGT _PFNf_FLIN, ACCESS
6836  D001     BRA 0x683A
6838  6E2D     MOVWF _PFNf_FLIN, ACCESS
795:           		*dLed1=Znak[Dt.Data0/10];		
683A  0E0A     MOVLW 0xA
683C  6E28     MOVWF _PFNf_10V_RT, ACCESS
683E  502D     MOVF _PFNf_FLIN, W, ACCESS
6840  ECE7     CALL 0xB5CE, 0
6842  F05A     NOP
6844  D864     RCALL PL198
6846  503B     MOVF _PFNf_LINres, W, ACCESS
6848  D86B     RCALL PL380
796:           		*dLed0=Znak[Dt.Data0%10];
684A  0E0A     MOVLW 0xA
684C  6E28     MOVWF _PFNf_10V_RT, ACCESS
684E  502D     MOVF _PFNf_FLIN, W, ACCESS
6850  EC51     CALL 0xBAA2, 0
6852  F05D     NOP
6854  D85C     RCALL PL198
6856  503A     MOVF _PFNf_LIN_STR, W, ACCESS
6858  D863     RCALL PL380
797:           	}else
685A  D00A     BRA 0x6870
798:           	{
799:           		*dLed1=Dt.Data1;						//bezposrednio dane w kodzie LED	
685C  503B     MOVF _PFNf_LINres, W, ACCESS
685E  6ED9     MOVWF FSR2, ACCESS
6860  6ADA     CLRF FSR2H, ACCESS
6862  C02C     MOVFF _PFNf_EnLIN, INDF2
6864  FFDF     NOP
800:           		*dLed0=Dt.Data0;
6866  503A     MOVF _PFNf_LIN_STR, W, ACCESS
6868  6ED9     MOVWF FSR2, ACCESS
686A  6ADA     CLRF FSR2H, ACCESS
686C  C02D     MOVFF _PFNf_FLIN, INDF2
686E  FFDF     NOP
801:           	}
802:           	if (St.autoOFF&&(*dLed1==Znak[0]))	//auto wygaszenie starszej cyfry gdy == 0 
6870  A62E     BTFSS _PFNf_FOT, 3, ACCESS
6872  D00F     BRA 0x6892
6874  503B     MOVF _PFNf_LINres, W, ACCESS
6876  6ED9     MOVWF FSR2, ACCESS
6878  6ADA     CLRF FSR2H, ACCESS
687A  50DF     MOVF INDF2, W, ACCESS
687C  6E36     MOVWF _PFNf_LIN_KSK, ACCESS
687E  0EA4     MOVLW 0xA4
6880  6EF6     MOVWF TBLPTR, ACCESS
6882  0EFF     MOVLW 0xFF
6884  6EF7     MOVWF TBLPTRH, ACCESS
6886  0008     TBLRD*
6888  50F5     MOVF TABLAT, W, ACCESS
688A  1836     XORWF _PFNf_LIN_KSK, W, ACCESS
688C  E102     BNZ 0x6892
803:           								*dLed1=BLACK; 	
688E  503B     MOVF _PFNf_LINres, W, ACCESS
6890  D84D     RCALL PL534
804:           	if (St.kropka0) 								//zapalenie mlodszej kropki
6892  A82E     BTFSS _PFNf_FOT, 4, ACCESS
6894  D005     BRA 0x68A0
805:           								*dLed0=*dLed0|KROPKA;
6896  503A     MOVF _PFNf_LIN_STR, W, ACCESS
6898  6ED9     MOVWF FSR2, ACCESS
689A  6ADA     CLRF FSR2H, ACCESS
689C  503A     MOVF _PFNf_LIN_STR, W, ACCESS
689E  D84A     RCALL PL558
806:           	if (St.kropka1) 								//zapalenie starszej kropki
68A0  AA2E     BTFSS _PFNf_FOT, 5, ACCESS
68A2  D005     BRA 0x68AE
807:           								*dLed1=*dLed1|KROPKA;
68A4  503B     MOVF _PFNf_LINres, W, ACCESS
68A6  6ED9     MOVWF FSR2, ACCESS
68A8  6ADA     CLRF FSR2H, ACCESS
68AA  503B     MOVF _PFNf_LINres, W, ACCESS
68AC  D843     RCALL PL558
808:           	if (St.wygas0||(*LedData).setOff)					//wygaszenie mlodszej cyfry	
68AE  BC2E     BTFSC _PFNf_FOT, 6, ACCESS
68B0  D003     BRA 0x68B8
68B2  D857     RCALL PL810
68B4  A0DF     BTFSS INDF2, 0, ACCESS
68B6  D002     BRA 0x68BC
809:           								*dLed0=BLACK;
68B8  503A     MOVF _PFNf_LIN_STR, W, ACCESS
68BA  D838     RCALL PL534
810:           	if (St.wygas1||(*LedData).setOff)					//wygaszenie starszej cyfry 	
68BC  BE2E     BTFSC _PFNf_FOT, 7, ACCESS
68BE  D003     BRA 0x68C6
68C0  D850     RCALL PL810
68C2  A0DF     BTFSS INDF2, 0, ACCESS
68C4  D005     BRA 0x68D0
811:           								*dLed1=BLACK;
68C6  503B     MOVF _PFNf_LINres, W, ACCESS
68C8  6ED9     MOVWF FSR2, ACCESS
68CA  6ADA     CLRF FSR2H, ACCESS
68CC  0E00     MOVLW 0x0
68CE  6EDF     MOVWF INDF2, ACCESS
812:           
813:           	//Sterowanie z poziomu kolejki znakami graficznymi (do 8 znakow z priorytetem wyswietlania)
814:           	//gdzie: 
815:           	//St.sdiode - znacznik informujacy ze beda przez pozycje kolejki zapalane znaki graficzne okreslone w St.sbdid (do 8 znakow)
816:           	//St.rdiode - znacznik informujacy ze beda przez pozycje kolejki wygaszane znaki graficzne okreslone w St.rbdid (do 8 znakow)
817:           	if (St.sdiode&&St.sbdid)
68D0  A42F     BTFSS _PFNf_KnfDisErr, 2, ACCESS
68D2  D006     BRA 0x68E0
68D4  5032     MOVF _PFNf_LIN_DPGD, W, ACCESS
68D6  E004     BZ 0x68E0
818:           	{
819:           			(*LedData).mask|=(0x00ff&St.sbdid);		//aktywuj obsluge znaku			
68D8  D839     RCALL PL600
68DA  D83E     RCALL PL682
820:           			(*LedData).mark|=(0x00ff&St.sbdid);		//zapal wybrane znaki
68DC  D831     RCALL PL588
68DE  D83C     RCALL PL682
821:           	}
822:           	if (St.rdiode&&St.rbdid)
68E0  A62F     BTFSS _PFNf_KnfDisErr, 3, ACCESS
68E2  0012     RETURN 0
68E4  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
68E6  B4D8     BTFSC STATUS, 2, ACCESS
68E8  0012     RETURN 0
68EA  D830     RCALL PL600
823:           	{
824:           			(*LedData).mask|=(0x00ff&St.rbdid);		//aktywuj obsluge znaku
68EC  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
68EE  12DE     IORWF POSTINC2, F, ACCESS
68F0  0E00     MOVLW 0x0
68F2  12DD     IORWF POSTDEC2, F, ACCESS
825:           			(*LedData).mark&=~(0x00ff&St.rbdid);	//wygas wybrane znaki
68F4  5033     MOVF _PFNf_LIN_ENDO, W, ACCESS
68F6  6E36     MOVWF _PFNf_LIN_KSK, ACCESS
68F8  6A37     CLRF _PFNf_LIN_PBCO, ACCESS
68FA  1C36     COMF _PFNf_LIN_KSK, W, ACCESS
68FC  6E38     MOVWF _PFNf_LIN_PBCW, ACCESS
68FE  1C37     COMF _PFNf_LIN_PBCO, W, ACCESS
6900  6E39     MOVWF _PFNf_LIN_RT, ACCESS
6902  D81E     RCALL PL588
6904  5038     MOVF _PFNf_LIN_PBCW, W, ACCESS
6906  16DE     ANDWF POSTINC2, F, ACCESS
6908  5039     MOVF _PFNf_LIN_RT, W, ACCESS
690A  16DD     ANDWF POSTDEC2, F, ACCESS
826:           	}
827:           }
690C  0012     RETURN 0
828:           /*--------------------------------------------------------------*/
829:           //Przygotowanie danej do wyswietlenia
830:           void FormatWswData(void)
831:           {
832:           	unsigned char i;
833:           	unsigned int msk;
834:           //-----------------------------------------------------
835:           	//Sterowanie globalne znakami graficznymi (do 16 znakow - do pierwszych 8 znakow moze pokryc kolejka ktora ma priorytet)
836:           	//gdzie: LedData.mask okresla ktore znaki brane sa pod uwage a LedData.mark zawiera informacje o oczekiwanym stanie znaku
837:           	#if NMZNK!=0
838:           		msk=0b0000000000000001;
7442  0100     MOVLB 0x0
7444  6B63     CLRF 0x63, BANKED
7446  0E01     MOVLW 0x1
7448  6F62     MOVWF msk, BANKED
839:           		for(i=0;i<NMZNK;i++)
744A  6B64     CLRF i, BANKED
7492  2B64     INCF i, F, BANKED
7494  0E0F     MOVLW 0xF
7496  6564     CPFSGT i, BANKED
7498  D7D9     BRA 0x744C
840:           		{
841:           			if(KMark[i].focus) {LedData.mask|=msk;}			//ustaw maske dla znakow graficznych
744C  0EE2     MOVLW 0xE2
744E  2564     ADDWF i, W, BANKED
7450  EC11     CALL 0xA422, 0
7452  F052     NOP
7454  A0DF     BTFSS INDF2, 0, ACCESS
7456  D006     BRA 0x7464
7458  0100     MOVLB 0x0
745A  5162     MOVF msk, W, BANKED
745C  13E7     IORWF 0xE7, F, BANKED
745E  5163     MOVF 0x63, W, BANKED
7460  13E8     IORWF 0xE8, F, BANKED
7462  D004     BRA 0x746C
842:           			else LedData.mask&=~msk;
7464  D880     RCALL PL498
7466  17E7     ANDWF 0xE7, F, BANKED
7468  5161     MOVF 0x61, W, BANKED
746A  17E8     ANDWF 0xE8, F, BANKED
843:           			if(KMark[i].m) LedData.mark|=msk;				//zapal wygas znaki graficzne
746C  0EE2     MOVLW 0xE2
746E  2564     ADDWF i, W, BANKED
7470  EC11     CALL 0xA422, 0
7472  F052     NOP
7474  A2DF     BTFSS INDF2, 1, ACCESS
7476  D006     BRA 0x7484
7478  0100     MOVLB 0x0
747A  5162     MOVF msk, W, BANKED
747C  13E5     IORWF 0xE5, F, BANKED
747E  5163     MOVF 0x63, W, BANKED
7480  13E6     IORWF 0xE6, F, BANKED
7482  D004     BRA 0x748C
844:           			else LedData.mark&=~msk;
7484  D870     RCALL PL498
7486  17E5     ANDWF 0xE5, F, BANKED
7488  5161     MOVF 0x61, W, BANKED
748A  17E6     ANDWF 0xE6, F, BANKED
845:           			msk=msk<<1;				
748C  90D8     BCF STATUS, 0, ACCESS
748E  3762     RLCF msk, F, BANKED
7490  3763     RLCF 0x63, F, BANKED
846:           		}
847:           	#endif
848:           #if LCD4D!=0
849:           //-----------------------------------------------------
850:           //dwie mlodsze cyfry
851:           	if(WswData.St2.dyn) SetLedData(DynData.Dt,DynData.St,&LedData,0);		//najmlodsze pobierz z bufora dynamicznego
749A  0104     MOVLB 0x4
749C  A937     BTFSS _PFNf_LIN_PBCO, 4, BANKED
749E  D009     BRA 0x74B2
74A0  D859     RCALL PL308
74A2  CFDB     MOVFF PLUSW2, PLUSW0
74A4  FFEB     NOP
74A6  06E8     DECF WREG, F, ACCESS
74A8  E2FC     BC 0x74A2
74AA  D864     RCALL PL510
74AC  ECFE     CALL 0x67FC, 0
74AE  F033     NOP
74B0  D024     BRA 0x74FA
852:           	else 
853:           	if(WswData.St2.only) SetLedData(bfWswData.Dt,bfWswData.St,&LedData,0);	//najmlodsze pobierz z najnizszego poziomu wyswietlania
74B2  5138     MOVF _PFNf_LIN_PBCW, W, BANKED
74B4  1139     IORWF _PFNf_LIN_RT, W, BANKED
74B6  E011     BZ 0x74DA
74B8  C442     MOVFF 0x442, _PFNf_EnLIN
74BA  F02C     NOP
74BC  C443     MOVFF 0x443, _PFNf_FLIN
74BE  F02D     NOP
74C0  EE24     LFSR 2, 0x43C
74C2  F03C     NOP
74C4  EE00     LFSR 0, 0x2E
74C6  F02E     NOP
74C8  0E05     MOVLW 0x5
74CA  CFDB     MOVFF PLUSW2, PLUSW0
74CC  FFEB     NOP
74CE  06E8     DECF WREG, F, ACCESS
74D0  E2FC     BC 0x74CA
74D2  D850     RCALL PL510
74D4  ECFE     CALL 0x67FC, 0
74D6  F033     NOP
74D8  D010     BRA 0x74FA
854:           	else SetLedData(WswData.Dt,WswData.St,&LedData,0);
74DA  C432     MOVFF 0x432, _PFNf_EnLIN
74DC  F02C     NOP
74DE  C433     MOVFF 0x433, _PFNf_FLIN
74E0  F02D     NOP
74E2  EE24     LFSR 2, 0x42C
74E4  F02C     NOP
74E6  EE00     LFSR 0, 0x2E
74E8  F02E     NOP
74EA  0E05     MOVLW 0x5
74EC  CFDB     MOVFF PLUSW2, PLUSW0
74EE  FFEB     NOP
74F0  06E8     DECF WREG, F, ACCESS
74F2  E2FC     BC 0x74EC
74F4  D83F     RCALL PL510
74F6  ECFE     CALL 0x67FC, 0
74F8  F033     NOP
855:           //-----------------------------------------------------
856:           //dwie starsze cyfry
857:           	if(WswData.St.dyn) SetLedData(DynData.Dt,DynData.St,&LedData,1);		//najstarsze pobierz z bufora dynamicznego
74FA  0104     MOVLB 0x4
74FC  A92D     BTFSS _PFNf_FLIN, 4, BANKED
74FE  D006     BRA 0x750C
7500  D829     RCALL PL308
7502  CFDB     MOVFF PLUSW2, PLUSW0
7504  FFEB     NOP
7506  06E8     DECF WREG, F, ACCESS
7508  E2FC     BC 0x7502
750A  D01E     BRA 0x7548
858:           	else 
859:           	if(WswData.St.only) SetLedData(bfWswData.Dt2,bfWswData.St2,&LedData,1);	//najstarsze pobierz z najnizszego poziomu wyswietlania
750C  512E     MOVF _PFNf_FOT, W, BANKED
750E  112F     IORWF _PFNf_KnfDisErr, W, BANKED
7510  E00E     BZ 0x752E
7512  C444     MOVFF 0x444, _PFNf_EnLIN
7514  F02C     NOP
7516  C445     MOVFF 0x445, _PFNf_FLIN
7518  F02D     NOP
751A  EE24     LFSR 2, 0x446
751C  F046     NOP
751E  EE00     LFSR 0, 0x2E
7520  F02E     NOP
7522  0E05     MOVLW 0x5
7524  CFDB     MOVFF PLUSW2, PLUSW0
7526  FFEB     NOP
7528  06E8     DECF WREG, F, ACCESS
752A  E2FC     BC 0x7524
752C  D00D     BRA 0x7548
860:           	else SetLedData(WswData.Dt2,WswData.St2,&LedData,1);
752E  C434     MOVFF 0x434, _PFNf_EnLIN
7530  F02C     NOP
7532  C435     MOVFF 0x435, _PFNf_FLIN
7534  F02D     NOP
7536  EE24     LFSR 2, 0x436
7538  F036     NOP
753A  EE00     LFSR 0, 0x2E
753C  F02E     NOP
753E  0E05     MOVLW 0x5
7540  CFDB     MOVFF PLUSW2, PLUSW0
7542  FFEB     NOP
7544  06E8     DECF WREG, F, ACCESS
7546  E2FC     BC 0x7540
7548  0EE0     MOVLW 0xE0
754A  6E34     MOVWF _PFNf_LIN_EPBCO, ACCESS
754C  0E01     MOVLW 0x1
754E  6E35     MOVWF _PFNf_LIN_EPBCW, ACCESS
7550  EFFE     GOTO 0x67FC
7552  F033     NOP
861:           
862:           	//if(!WswData.St.dyn) SetLedData(WswData.Dt2,WswData.St2,&LedData,1);
863:           	//else SetLedData(DynData.Dt,DynData.St,&LedData,1);
864:           #else
865:           //-----------------------------------------------------
866:           //dwie mlodsze cyfry
867:           	SetLedData(WswData.Dt,WswData.St,&LedData,0); 
868:           #endif
869:           }
870:           /*--------------------------------------------------------------*/
871:           //Wyslanie danej na wyswietlacz
872:           void PrintWswData(void)
873:           {
874:           	//----------------------------------------------------------------
875:           	//CYFRY
876:           
877:           	//pierwsza cyfra
878:           	_LCD_1A=(LedData.dLed0&0b00000001)?1:0;
5A1A  0100     MOVLB 0x0
5A1C  A1E4     BTFSS 0xE4, 0, BANKED
5A1E  D002     BRA 0x5A24
5A20  8EBD     BSF LCDDATA2, 7, ACCESS
5A22  D001     BRA 0x5A26
5A24  9EBD     BCF LCDDATA2, 7, ACCESS
879:           	_LCD_1B=(LedData.dLed0&0b00000010)?1:0;
5A26  0100     MOVLB 0x0
5A28  A3E4     BTFSS 0xE4, 1, BANKED
5A2A  D002     BRA 0x5A30
5A2C  8E6E     BSF LCDDATA8, 7, ACCESS
5A2E  D001     BRA 0x5A32
5A30  9E6E     BCF LCDDATA8, 7, ACCESS
880:           	_LCD_1C=(LedData.dLed0&0b00000100)?1:0;
5A32  0100     MOVLB 0x0
5A34  A5E4     BTFSS 0xE4, 2, BANKED
5A36  D002     BRA 0x5A3C
5A38  8E74     BSF LCDDATA14, 7, ACCESS
5A3A  D001     BRA 0x5A3E
5A3C  9E74     BCF LCDDATA14, 7, ACCESS
881:           	_LCD_1D=(LedData.dLed0&0b00001000)?1:0;
5A3E  0100     MOVLB 0x0
5A40  A7E4     BTFSS 0xE4, 3, BANKED
5A42  D002     BRA 0x5A48
5A44  8E7A     BSF LCDDATA20, 7, ACCESS
5A46  D001     BRA 0x5A4A
5A48  9E7A     BCF LCDDATA20, 7, ACCESS
882:           	_LCD_1E=(LedData.dLed0&0b00010000)?1:0;
5A4A  0100     MOVLB 0x0
5A4C  A9E4     BTFSS 0xE4, 4, BANKED
5A4E  D002     BRA 0x5A54
5A50  8C7A     BSF LCDDATA20, 6, ACCESS
5A52  D001     BRA 0x5A56
5A54  9C7A     BCF LCDDATA20, 6, ACCESS
883:           	_LCD_1F=(LedData.dLed0&0b00100000)?1:0;
5A56  0100     MOVLB 0x0
5A58  ABE4     BTFSS 0xE4, 5, BANKED
5A5A  D002     BRA 0x5A60
5A5C  8C6E     BSF LCDDATA8, 6, ACCESS
5A5E  D001     BRA 0x5A62
5A60  9C6E     BCF LCDDATA8, 6, ACCESS
884:           	_LCD_1G=(LedData.dLed0&0b01000000)?1:0;
5A62  0100     MOVLB 0x0
5A64  ADE4     BTFSS 0xE4, 6, BANKED
5A66  D002     BRA 0x5A6C
5A68  8C74     BSF LCDDATA14, 6, ACCESS
5A6A  D001     BRA 0x5A6E
5A6C  9C74     BCF LCDDATA14, 6, ACCESS
885:           
886:           	//druga cyfra
887:           	_LCD_2A=(LedData.dLed1&0b00000001)?1:0;
5A6E  0100     MOVLB 0x0
5A70  A1E3     BTFSS 0xE3, 0, BANKED
5A72  D002     BRA 0x5A78
5A74  8ABD     BSF LCDDATA2, 5, ACCESS
5A76  D001     BRA 0x5A7A
5A78  9ABD     BCF LCDDATA2, 5, ACCESS
888:           	_LCD_2B=(LedData.dLed1&0b00000010)?1:0;
5A7A  0100     MOVLB 0x0
5A7C  A3E3     BTFSS 0xE3, 1, BANKED
5A7E  D002     BRA 0x5A84
5A80  8A6E     BSF LCDDATA8, 5, ACCESS
5A82  D001     BRA 0x5A86
5A84  9A6E     BCF LCDDATA8, 5, ACCESS
889:           	_LCD_2C=(LedData.dLed1&0b00000100)?1:0;
5A86  0100     MOVLB 0x0
5A88  A5E3     BTFSS 0xE3, 2, BANKED
5A8A  D002     BRA 0x5A90
5A8C  8A74     BSF LCDDATA14, 5, ACCESS
5A8E  D001     BRA 0x5A92
5A90  9A74     BCF LCDDATA14, 5, ACCESS
890:           	_LCD_2D=(LedData.dLed1&0b00001000)?1:0;
5A92  0100     MOVLB 0x0
5A94  A7E3     BTFSS 0xE3, 3, BANKED
5A96  D002     BRA 0x5A9C
5A98  8A7A     BSF LCDDATA20, 5, ACCESS
5A9A  D001     BRA 0x5A9E
5A9C  9A7A     BCF LCDDATA20, 5, ACCESS
891:           	_LCD_2E=(LedData.dLed1&0b00010000)?1:0;
5A9E  0100     MOVLB 0x0
5AA0  A9E3     BTFSS 0xE3, 4, BANKED
5AA2  D002     BRA 0x5AA8
5AA4  887A     BSF LCDDATA20, 4, ACCESS
5AA6  D001     BRA 0x5AAA
5AA8  987A     BCF LCDDATA20, 4, ACCESS
892:           	_LCD_2F=(LedData.dLed1&0b00100000)?1:0;
5AAA  0100     MOVLB 0x0
5AAC  ABE3     BTFSS 0xE3, 5, BANKED
5AAE  D002     BRA 0x5AB4
5AB0  886E     BSF LCDDATA8, 4, ACCESS
5AB2  D001     BRA 0x5AB6
5AB4  986E     BCF LCDDATA8, 4, ACCESS
893:           	_LCD_2G=(LedData.dLed1&0b01000000)?1:0;
5AB6  0100     MOVLB 0x0
5AB8  ADE3     BTFSS 0xE3, 6, BANKED
5ABA  D002     BRA 0x5AC0
5ABC  8874     BSF LCDDATA14, 4, ACCESS
5ABE  D001     BRA 0x5AC2
5AC0  9874     BCF LCDDATA14, 4, ACCESS
894:           #if LCD4D!=0
895:           	//trzecia cyfra
896:           	_LCD_3A=(LedData.dLed2&0b00000001)?1:0;
5AC2  0100     MOVLB 0x0
5AC4  A1E2     BTFSS 0xE2, 0, BANKED
5AC6  D002     BRA 0x5ACC
5AC8  8CBB     BSF LCDDATA0, 6, ACCESS
5ACA  D001     BRA 0x5ACE
5ACC  9CBB     BCF LCDDATA0, 6, ACCESS
897:           	_LCD_3B=(LedData.dLed2&0b00000010)?1:0;
5ACE  0100     MOVLB 0x0
5AD0  A3E2     BTFSS 0xE2, 1, BANKED
5AD2  D002     BRA 0x5AD8
5AD4  8C6C     BSF LCDDATA6, 6, ACCESS
5AD6  D001     BRA 0x5ADA
5AD8  9C6C     BCF LCDDATA6, 6, ACCESS
898:           	_LCD_3C=(LedData.dLed2&0b00000100)?1:0;
5ADA  0100     MOVLB 0x0
5ADC  A5E2     BTFSS 0xE2, 2, BANKED
5ADE  D002     BRA 0x5AE4
5AE0  8C72     BSF LCDDATA12, 6, ACCESS
5AE2  D001     BRA 0x5AE6
5AE4  9C72     BCF LCDDATA12, 6, ACCESS
899:           	_LCD_3D=(LedData.dLed2&0b00001000)?1:0;
5AE6  0100     MOVLB 0x0
5AE8  A7E2     BTFSS 0xE2, 3, BANKED
5AEA  D002     BRA 0x5AF0
5AEC  8C78     BSF LCDDATA18, 6, ACCESS
5AEE  D001     BRA 0x5AF2
5AF0  9C78     BCF LCDDATA18, 6, ACCESS
900:           	_LCD_3E=(LedData.dLed2&0b00010000)?1:0;
5AF2  0100     MOVLB 0x0
5AF4  A9E2     BTFSS 0xE2, 4, BANKED
5AF6  D002     BRA 0x5AFC
5AF8  8A78     BSF LCDDATA18, 5, ACCESS
5AFA  D001     BRA 0x5AFE
5AFC  9A78     BCF LCDDATA18, 5, ACCESS
901:           	_LCD_3F=(LedData.dLed2&0b00100000)?1:0;
5AFE  0100     MOVLB 0x0
5B00  ABE2     BTFSS 0xE2, 5, BANKED
5B02  D002     BRA 0x5B08
5B04  8A6C     BSF LCDDATA6, 5, ACCESS
5B06  D001     BRA 0x5B0A
5B08  9A6C     BCF LCDDATA6, 5, ACCESS
902:           	_LCD_3G=(LedData.dLed2&0b01000000)?1:0;
5B0A  0100     MOVLB 0x0
5B0C  ADE2     BTFSS 0xE2, 6, BANKED
5B0E  D002     BRA 0x5B14
5B10  8A72     BSF LCDDATA12, 5, ACCESS
5B12  D001     BRA 0x5B16
5B14  9A72     BCF LCDDATA12, 5, ACCESS
903:           
904:           	//czwarta cyfra
905:           	_LCD_4A=(LedData.dLed3&0b00000001)?1:0;
5B16  0100     MOVLB 0x0
5B18  A1E1     BTFSS 0xE1, 0, BANKED
5B1A  D002     BRA 0x5B20
5B1C  88BB     BSF LCDDATA0, 4, ACCESS
5B1E  D001     BRA 0x5B22
5B20  98BB     BCF LCDDATA0, 4, ACCESS
906:           	_LCD_4B=(LedData.dLed3&0b00000010)?1:0;
5B22  0100     MOVLB 0x0
5B24  A3E1     BTFSS 0xE1, 1, BANKED
5B26  D002     BRA 0x5B2C
5B28  886C     BSF LCDDATA6, 4, ACCESS
5B2A  D001     BRA 0x5B2E
5B2C  986C     BCF LCDDATA6, 4, ACCESS
907:           	_LCD_4C=(LedData.dLed3&0b00000100)?1:0;
5B2E  0100     MOVLB 0x0
5B30  A5E1     BTFSS 0xE1, 2, BANKED
5B32  D002     BRA 0x5B38
5B34  8872     BSF LCDDATA12, 4, ACCESS
5B36  D001     BRA 0x5B3A
5B38  9872     BCF LCDDATA12, 4, ACCESS
908:           	_LCD_4D=(LedData.dLed3&0b00001000)?1:0;
5B3A  0100     MOVLB 0x0
5B3C  A7E1     BTFSS 0xE1, 3, BANKED
5B3E  D002     BRA 0x5B44
5B40  8878     BSF LCDDATA18, 4, ACCESS
5B42  D001     BRA 0x5B46
5B44  9878     BCF LCDDATA18, 4, ACCESS
909:           	_LCD_4E=(LedData.dLed3&0b00010000)?1:0;
5B46  0100     MOVLB 0x0
5B48  A9E1     BTFSS 0xE1, 4, BANKED
5B4A  D002     BRA 0x5B50
5B4C  8678     BSF LCDDATA18, 3, ACCESS
5B4E  D001     BRA 0x5B52
5B50  9678     BCF LCDDATA18, 3, ACCESS
910:           	_LCD_4F=(LedData.dLed3&0b00100000)?1:0;
5B52  0100     MOVLB 0x0
5B54  ABE1     BTFSS 0xE1, 5, BANKED
5B56  D002     BRA 0x5B5C
5B58  866C     BSF LCDDATA6, 3, ACCESS
5B5A  D001     BRA 0x5B5E
5B5C  966C     BCF LCDDATA6, 3, ACCESS
911:           	_LCD_4G=(LedData.dLed3&0b01000000)?1:0;
5B5E  0100     MOVLB 0x0
5B60  ADE1     BTFSS 0xE1, 6, BANKED
5B62  D002     BRA 0x5B68
5B64  8672     BSF LCDDATA12, 3, ACCESS
5B66  D001     BRA 0x5B6A
5B68  9672     BCF LCDDATA12, 3, ACCESS
912:           #endif
913:           	//kropka
914:           	_LCD_P1=(LedData.dLed1&0b10000000)?1:0;
5B6A  0100     MOVLB 0x0
5B6C  AFE3     BTFSS 0xE3, 7, BANKED
5B6E  D002     BRA 0x5B74
5B70  807B     BSF LCDDATA21, 0, ACCESS
5B72  D001     BRA 0x5B76
5B74  907B     BCF LCDDATA21, 0, ACCESS
915:           
916:           	//----------------------------------------------------------------
917:           	//ZNAKI GRAFICZNE
918:           
919:           	//znaki graficzne wyzwalane globalnie lub z poziomu kolejki
920:           	//wyzwolenie z poziomu kolejki ma priorytet (przeslania wyzwalanie globalne)
921:           	//pierwsze 8 znakow moze byc wyzwolonych z priorytetem kolejki (0b0000000011111111)
922:           	//wszystkie znaki mozna wyzwolic globalnie (ostatnie osiem 8 wylacznie ta metoda)
923:           
924:           	//Pierwsze 8 znakow (od 0b0000000000000001 do 0b0000000010000000)
925:           	if(LedData.mask&0b0000000000000001) _LCD_KAL=(LedData.mark&0b0000000000000001)?1:0;		//0- znak kaloryfer
5B76  0100     MOVLB 0x0
5B78  A1E7     BTFSS 0xE7, 0, BANKED
5B7A  D005     BRA 0x5B86
5B7C  A1E5     BTFSS 0xE5, 0, BANKED
5B7E  D002     BRA 0x5B84
5B80  82BE     BSF LCDDATA3, 1, ACCESS
5B82  D001     BRA 0x5B86
5B84  92BE     BCF LCDDATA3, 1, ACCESS
926:           	if(LedData.mask&0b0000000000000010) _LCD_KRN=(LedData.mark&0b0000000000000010)?1:0;		//1- znak kran
5B86  0100     MOVLB 0x0
5B88  A3E7     BTFSS 0xE7, 1, BANKED
5B8A  D005     BRA 0x5B96
5B8C  A3E5     BTFSS 0xE5, 1, BANKED
5B8E  D002     BRA 0x5B94
5B90  84BB     BSF LCDDATA0, 2, ACCESS
5B92  D001     BRA 0x5B96
5B94  94BB     BCF LCDDATA0, 2, ACCESS
927:           	if(LedData.mask&0b0000000000000100) _LCD_SRV=(LedData.mark&0b0000000000000100)?1:0;		//2- znak serwis
5B96  0100     MOVLB 0x0
5B98  A5E7     BTFSS 0xE7, 2, BANKED
5B9A  D005     BRA 0x5BA6
5B9C  A5E5     BTFSS 0xE5, 2, BANKED
5B9E  D002     BRA 0x5BA4
5BA0  8472     BSF LCDDATA12, 2, ACCESS
5BA2  D001     BRA 0x5BA6
5BA4  9472     BCF LCDDATA12, 2, ACCESS
928:           	if(LedData.mask&0b0000000000001000) _LCD_RES=(LedData.mark&0b0000000000001000)?1:0;		//3- znak reset
5BA6  0100     MOVLB 0x0
5BA8  A7E7     BTFSS 0xE7, 3, BANKED
5BAA  D005     BRA 0x5BB6
5BAC  A7E5     BTFSS 0xE5, 3, BANKED
5BAE  D002     BRA 0x5BB4
5BB0  8E72     BSF LCDDATA12, 7, ACCESS
5BB2  D001     BRA 0x5BB6
5BB4  9E72     BCF LCDDATA12, 7, ACCESS
929:           	if(LedData.mask&0b0000000000010000) _LCD_TCO=(LedData.mark&0b0000000000010000)?1:0;		//4- znak C dla co
5BB6  0100     MOVLB 0x0
5BB8  A9E7     BTFSS 0xE7, 4, BANKED
5BBA  D005     BRA 0x5BC6
5BBC  A9E5     BTFSS 0xE5, 4, BANKED
5BBE  D002     BRA 0x5BC4
5BC0  806F     BSF LCDDATA9, 0, ACCESS
5BC2  D001     BRA 0x5BC6
5BC4  906F     BCF LCDDATA9, 0, ACCESS
930:           	if(LedData.mask&0b0000000000100000) _LCD_TCW=(LedData.mark&0b0000000000100000)?1:0;		//5- znak C dla cw
5BC6  0100     MOVLB 0x0
5BC8  ABE7     BTFSS 0xE7, 5, BANKED
5BCA  D005     BRA 0x5BD6
5BCC  ABE5     BTFSS 0xE5, 5, BANKED
5BCE  D002     BRA 0x5BD4
5BD0  8EBB     BSF LCDDATA0, 7, ACCESS
5BD2  D001     BRA 0x5BD6
5BD4  9EBB     BCF LCDDATA0, 7, ACCESS
931:           	if(LedData.mask&0b0000000001000000) _LCD_BAR=(LedData.mark&0b0000000001000000)?1:0;		//6- znak bar
5BD6  0100     MOVLB 0x0
5BD8  ADE7     BTFSS 0xE7, 6, BANKED
5BDA  D005     BRA 0x5BE6
5BDC  ADE5     BTFSS 0xE5, 6, BANKED
5BDE  D002     BRA 0x5BE4
5BE0  8075     BSF LCDDATA15, 0, ACCESS
5BE2  D001     BRA 0x5BE6
5BE4  9075     BCF LCDDATA15, 0, ACCESS
932:           	if(LedData.mask&0b0000000010000000) _LCD_PGD=(LedData.mark&0b0000000010000000)?1:0;		//7- znak pogoda
5BE6  0100     MOVLB 0x0
5BE8  AFE7     BTFSS 0xE7, 7, BANKED
5BEA  D005     BRA 0x5BF6
5BEC  AFE5     BTFSS 0xE5, 7, BANKED
5BEE  D002     BRA 0x5BF4
5BF0  8275     BSF LCDDATA15, 1, ACCESS
5BF2  D001     BRA 0x5BF6
5BF4  9275     BCF LCDDATA15, 1, ACCESS
933:           	//Drugie 8 znakow (od 0b0000000100000000 do 0b1000000000000000)
934:           	if(LedData.mask&0b0000000100000000) _LCD_PLC=(LedData.mark&0b0000000100000000)?1:0;		//8- znak plomien co_LCD_PLC
5BF6  0100     MOVLB 0x0
5BF8  A1E8     BTFSS 0xE8, 0, BANKED
5BFA  D005     BRA 0x5C06
5BFC  A1E6     BTFSS 0xE6, 0, BANKED
5BFE  D002     BRA 0x5C04
5C00  827B     BSF LCDDATA21, 1, ACCESS
5C02  D001     BRA 0x5C06
5C04  927B     BCF LCDDATA21, 1, ACCESS
935:           	if(LedData.mask&0b0000001000000000) _LCD_PLW=(LedData.mark&0b0000001000000000)?1:0;		//9- znak plomien cw
5C06  0100     MOVLB 0x0
5C08  A3E8     BTFSS 0xE8, 1, BANKED
5C0A  D005     BRA 0x5C16
5C0C  A3E6     BTFSS 0xE6, 1, BANKED
5C0E  D002     BRA 0x5C14
5C10  8478     BSF LCDDATA18, 2, ACCESS
5C12  D001     BRA 0x5C16
5C14  9478     BCF LCDDATA18, 2, ACCESS
936:           	if(LedData.mask&0b0000010000000000) _LCD_OFF=(LedData.mark&0b0000010000000000)?1:0;		//10- znak off
5C16  0100     MOVLB 0x0
5C18  A5E8     BTFSS 0xE8, 2, BANKED
5C1A  D005     BRA 0x5C26
5C1C  A5E6     BTFSS 0xE6, 2, BANKED
5C1E  D002     BRA 0x5C24
5C20  8E6C     BSF LCDDATA6, 7, ACCESS
5C22  D001     BRA 0x5C26
5C24  9E6C     BCF LCDDATA6, 7, ACCESS
937:           	if(LedData.mask&0b0000100000000000) _LCD_MXW=(LedData.mark&0b0000100000000000)?1:0;		//11- znak maxcw
5C26  0100     MOVLB 0x0
5C28  A7E8     BTFSS 0xE8, 3, BANKED
5C2A  D005     BRA 0x5C36
5C2C  A7E6     BTFSS 0xE6, 3, BANKED
5C2E  D002     BRA 0x5C34
5C30  86BB     BSF LCDDATA0, 3, ACCESS
5C32  D001     BRA 0x5C36
5C34  96BB     BCF LCDDATA0, 3, ACCESS
938:           	if(LedData.mask&0b0001000000000000) _LCD_MNW=(LedData.mark&0b0001000000000000)?1:0;		//12- znak mincw
5C36  0100     MOVLB 0x0
5C38  A9E8     BTFSS 0xE8, 4, BANKED
5C3A  D005     BRA 0x5C46
5C3C  A9E6     BTFSS 0xE6, 4, BANKED
5C3E  D002     BRA 0x5C44
5C40  8ABB     BSF LCDDATA0, 5, ACCESS
5C42  D001     BRA 0x5C46
5C44  9ABB     BCF LCDDATA0, 5, ACCESS
939:           	if(LedData.mask&0b0010000000000000) _LCD_MXC=(LedData.mark&0b0010000000000000)?1:0;		//13- znak maxco
5C46  0100     MOVLB 0x0
5C48  ABE8     BTFSS 0xE8, 5, BANKED
5C4A  D005     BRA 0x5C56
5C4C  ABE6     BTFSS 0xE6, 5, BANKED
5C4E  D002     BRA 0x5C54
5C50  88BD     BSF LCDDATA2, 4, ACCESS
5C52  D001     BRA 0x5C56
5C54  98BD     BCF LCDDATA2, 4, ACCESS
940:           	if(LedData.mask&0b0100000000000000) _LCD_MNC=(LedData.mark&0b0100000000000000)?1:0;		//14- znak minco
5C56  0100     MOVLB 0x0
5C58  ADE8     BTFSS 0xE8, 6, BANKED
5C5A  D005     BRA 0x5C66
5C5C  ADE6     BTFSS 0xE6, 6, BANKED
5C5E  D002     BRA 0x5C64
5C60  8CBD     BSF LCDDATA2, 6, ACCESS
5C62  D001     BRA 0x5C66
5C64  9CBD     BCF LCDDATA2, 6, ACCESS
941:           	//-------------------------
942:           	//Stale elementy graficzne zawsze wysterowane/wygaszone
943:           	_LCD_KRS=1;		//znak kreski stale zapalony
5C66  826F     BSF LCDDATA9, 1, ACCESS
944:           }
5C68  0012     RETURN 0
945:           /*--------------------------------------------------------------*/
946:           /*--------------------------------------------------------------*/
947:           /*--------------------------------------------------------------*/
948:           /*--------------------------------------------------------------*/
949:           //Bezwarunkowe wygaszenie wyswietlacza
950:           void WswOff(void)
951:           {
952:           	LedData.setOff=1;
953:           }
954:           //Wyjscie z bezwarunkowego wygaszenia wyswietlacza
955:           void WswOn(void)
956:           {
957:           	LedData.setOff=0;
958:           }
959:           /*--------------------------------------------------------------*/
960:           /*--------------------------------------------------------------*/
961:           //Wprowadzenie danej pod wskazany adres (typ WPack)
962:           //np. SetData(&PWD[2],0,35);
963:           void SetData(volatile WData *Dt,const unsigned char wdt1,const unsigned char wdt0)
964:           {
965:           	(*Dt).Data1=wdt1;
BD7E  C074     MOVFF _PFNf_prODP, FSR2
BD80  FFD9     NOP
BD82  C075     MOVFF _PFNf_prn_cs, FSR2H
BD84  FFDA     NOP
BD86  C076     MOVFF _PFNf_prn_in, INDF2
BD88  FFDF     NOP
966:           	(*Dt).Data0=wdt0;
BD8A  EE20     LFSR 2, 0x1
BD8C  F001     NOP
BD8E  5174     MOVF _PFNf_prODP, W, BANKED
BD90  26D9     ADDWF FSR2, F, ACCESS
BD92  5175     MOVF _PFNf_prn_cs, W, BANKED
BD94  22DA     ADDWFC FSR2H, F, ACCESS
BD96  C077     MOVFF _PFNf_prn_pg, INDF2
BD98  FFDF     NOP
967:           }
BD9A  0012     RETURN 0
968:           /*--------------------------------------------------------------*/
969:           //Okreslenie formatu danej pod wskazanym adresem (typ WPack)
970:           //Dla danej:
971:           //Pod uwage brane sa tylko pozycje okreslone w danej mask,z tych
972:           //ustawiane sa pozycje okreslone w danej wst pozostale sa zerowane.
973:           //Dla znaku graficznego:
974:           //zapalane sa pozycje okreslone w danej sbdid (zapala dla sdiode=1)
975:           //wygaszane sa pozycje okreslone w danej rbdid (wygasza dla rdiode=1)
976:           //np. SetStatus(&PWD[_WS_TCW],tDEC|tSDID|tFOCUS,tALL,_KZ_TMP_C,0); //wskaz temp. ze znakim graf C
977:           void SetStatus(volatile WStatus *St,const unsigned int wst,const unsigned int mask,const unsigned char sbdid, const unsigned char rbdid)
978:           {
979:           	if (mask&0b1000000000000000)(*St).focus=(wst&0b1000000000000000)?1:0;
627C  AF79     BTFSS _PFNf_prn_res, 7, BANKED
627E  D009     BRA 0x6292
6280  AF77     BTFSS _PFNf_prn_pg, 7, BANKED
6282  D003     BRA 0x628A
6284  6B7C     CLRF _PFNf_setKey, BANKED
6286  2B7C     INCF _PFNf_setKey, F, BANKED
6288  D002     BRA 0x628E
628A  0100     MOVLB 0x0
628C  6B7C     CLRF _PFNf_setKey, BANKED
628E  D8CB     RCALL PL236
6290  D8E2     RCALL PL580
980:           	if (mask&0b0100000000000000)(*St).dec=(wst&0b0100000000000000)?1:0;
6292  AD79     BTFSS _PFNf_prn_res, 6, BANKED
6294  D009     BRA 0x62A8
6296  AD77     BTFSS _PFNf_prn_pg, 6, BANKED
6298  D003     BRA 0x62A0
629A  6B7C     CLRF _PFNf_setKey, BANKED
629C  2B7C     INCF _PFNf_setKey, F, BANKED
629E  D002     BRA 0x62A4
62A0  0100     MOVLB 0x0
62A2  6B7C     CLRF _PFNf_setKey, BANKED
62A4  D8C0     RCALL PL236
62A6  D8C9     RCALL PL450
981:           	if (mask&0b0010000000000000)(*St).hex=(wst&0b0010000000000000)?1:0;
62A8  AB79     BTFSS _PFNf_prn_res, 5, BANKED
62AA  D00A     BRA 0x62C0
62AC  AB77     BTFSS _PFNf_prn_pg, 5, BANKED
62AE  D003     BRA 0x62B6
62B0  6B7C     CLRF _PFNf_setKey, BANKED
62B2  2B7C     INCF _PFNf_setKey, F, BANKED
62B4  D002     BRA 0x62BA
62B6  0100     MOVLB 0x0
62B8  6B7C     CLRF _PFNf_setKey, BANKED
62BA  D8B5     RCALL PL236
62BC  D8B9     RCALL PL346
62BE  D8D1     RCALL PL786
982:           	if (mask&0b0001000000000000)(*St).autoOFF=(wst&0b0001000000000000)?1:0;
62C0  A979     BTFSS _PFNf_prn_res, 4, BANKED
62C2  D00B     BRA 0x62DA
62C4  A977     BTFSS _PFNf_prn_pg, 4, BANKED
62C6  D003     BRA 0x62CE
62C8  6B7C     CLRF _PFNf_setKey, BANKED
62CA  2B7C     INCF _PFNf_setKey, F, BANKED
62CC  D002     BRA 0x62D2
62CE  0100     MOVLB 0x0
62D0  6B7C     CLRF _PFNf_setKey, BANKED
62D2  D8A9     RCALL PL236
62D4  477C     RLNCF _PFNf_setKey, F, BANKED
62D6  D8AC     RCALL PL346
62D8  D8C8     RCALL PL832
983:           	if (mask&0b0000100000000000)(*St).kropka0=(wst&0b0000100000000000)?1:0;
62DA  A779     BTFSS _PFNf_prn_res, 3, BANKED
62DC  D009     BRA 0x62F0
62DE  A777     BTFSS _PFNf_prn_pg, 3, BANKED
62E0  D003     BRA 0x62E8
62E2  6B7C     CLRF _PFNf_setKey, BANKED
62E4  2B7C     INCF _PFNf_setKey, F, BANKED
62E6  D002     BRA 0x62EC
62E8  0100     MOVLB 0x0
62EA  6B7C     CLRF _PFNf_setKey, BANKED
62EC  D89C     RCALL PL236
62EE  D8AC     RCALL PL454
984:           	if (mask&0b0000010000000000)(*St).kropka1=(wst&0b0000010000000000)?1:0;
62F0  A579     BTFSS _PFNf_prn_res, 2, BANKED
62F2  D00F     BRA 0x6312
62F4  A577     BTFSS _PFNf_prn_pg, 2, BANKED
62F6  D003     BRA 0x62FE
62F8  6B7C     CLRF _PFNf_setKey, BANKED
62FA  2B7C     INCF _PFNf_setKey, F, BANKED
62FC  D002     BRA 0x6302
62FE  0100     MOVLB 0x0
6300  6B7C     CLRF _PFNf_setKey, BANKED
6302  D891     RCALL PL236
6304  3B7C     SWAPF _PFNf_setKey, F, BANKED
6306  477C     RLNCF _PFNf_setKey, F, BANKED
6308  50DF     MOVF INDF2, W, ACCESS
630A  197C     XORWF _PFNf_setKey, W, BANKED
630C  0BDF     ANDLW 0xDF
630E  197C     XORWF _PFNf_setKey, W, BANKED
6310  6EDF     MOVWF INDF2, ACCESS
985:           	if (mask&0b0000001000000000)(*St).wygas0=(wst&0b0000001000000000)?1:0;
6312  A379     BTFSS _PFNf_prn_res, 1, BANKED
6314  D00D     BRA 0x6330
6316  A377     BTFSS _PFNf_prn_pg, 1, BANKED
6318  D003     BRA 0x6320
631A  6B7C     CLRF _PFNf_setKey, BANKED
631C  2B7C     INCF _PFNf_setKey, F, BANKED
631E  D002     BRA 0x6324
6320  0100     MOVLB 0x0
6322  6B7C     CLRF _PFNf_setKey, BANKED
6324  D880     RCALL PL236
6326  3B7C     SWAPF _PFNf_setKey, F, BANKED
6328  D883     RCALL PL346
632A  0BBF     ANDLW 0xBF
632C  197C     XORWF _PFNf_setKey, W, BANKED
632E  6EDF     MOVWF INDF2, ACCESS
986:           	if (mask&0b0000000100000000)(*St).wygas1=(wst&0b0000000100000000)?1:0;
6330  A179     BTFSS _PFNf_prn_res, 0, BANKED
6332  D00F     BRA 0x6352
6334  A177     BTFSS _PFNf_prn_pg, 0, BANKED
6336  D003     BRA 0x633E
6338  6B7C     CLRF _PFNf_setKey, BANKED
633A  2B7C     INCF _PFNf_setKey, F, BANKED
633C  D002     BRA 0x6342
633E  0100     MOVLB 0x0
6340  6B7C     CLRF _PFNf_setKey, BANKED
6342  D871     RCALL PL236
6344  337C     RRCF _PFNf_setKey, F, BANKED
6346  337C     RRCF _PFNf_setKey, F, BANKED
6348  50DF     MOVF INDF2, W, ACCESS
634A  197C     XORWF _PFNf_setKey, W, BANKED
634C  0B7F     ANDLW 0x7F
634E  197C     XORWF _PFNf_setKey, W, BANKED
6350  6EDF     MOVWF INDF2, ACCESS
987:           	if (mask&0b0000000010000000)(*St).led0=(wst&0b0000000010000000)?1:0;
6352  AF78     BTFSS _PFNf_prn_pp, 7, BANKED
6354  D009     BRA 0x6368
6356  AF76     BTFSS _PFNf_prn_in, 7, BANKED
6358  D003     BRA 0x6360
635A  6B7C     CLRF _PFNf_setKey, BANKED
635C  2B7C     INCF _PFNf_setKey, F, BANKED
635E  D002     BRA 0x6364
6360  0100     MOVLB 0x0
6362  6B7C     CLRF _PFNf_setKey, BANKED
6364  D854     RCALL __end_of_SetStatus
6366  D877     RCALL PL580
988:           	if (mask&0b0000000001000000)(*St).led1=(wst&0b0000000001000000)?1:0;
6368  AD78     BTFSS _PFNf_prn_pp, 6, BANKED
636A  D009     BRA 0x637E
636C  AD76     BTFSS _PFNf_prn_in, 6, BANKED
636E  D003     BRA 0x6376
6370  6B7C     CLRF _PFNf_setKey, BANKED
6372  2B7C     INCF _PFNf_setKey, F, BANKED
6374  D002     BRA 0x637A
6376  0100     MOVLB 0x0
6378  6B7C     CLRF _PFNf_setKey, BANKED
637A  D849     RCALL __end_of_SetStatus
637C  D85E     RCALL PL450
989:           	if (mask&0b0000000000100000)(*St).sdiode=(wst&0b0000000000100000)?1:0;	//czy razem z dana ma byc wyswietlany wybrany znak graficzny?
637E  AB78     BTFSS _PFNf_prn_pp, 5, BANKED
6380  D00A     BRA 0x6396
6382  AB76     BTFSS _PFNf_prn_in, 5, BANKED
6384  D003     BRA 0x638C
6386  6B7C     CLRF _PFNf_setKey, BANKED
6388  2B7C     INCF _PFNf_setKey, F, BANKED
638A  D002     BRA 0x6390
638C  0100     MOVLB 0x0
638E  6B7C     CLRF _PFNf_setKey, BANKED
6390  D83E     RCALL __end_of_SetStatus
6392  D84E     RCALL PL346
6394  D866     RCALL PL786
990:           	if (mask&0b0000000000010000)(*St).rdiode=(wst&0b0000000000010000)?1:0;	//czy razem z dana ma byc wygaszany wybrany znak graficzny?
6396  A978     BTFSS _PFNf_prn_pp, 4, BANKED
6398  D00B     BRA 0x63B0
639A  A976     BTFSS _PFNf_prn_in, 4, BANKED
639C  D003     BRA 0x63A4
639E  6B7C     CLRF _PFNf_setKey, BANKED
63A0  2B7C     INCF _PFNf_setKey, F, BANKED
63A2  D002     BRA 0x63A8
63A4  0100     MOVLB 0x0
63A6  6B7C     CLRF _PFNf_setKey, BANKED
63A8  D832     RCALL __end_of_SetStatus
63AA  477C     RLNCF _PFNf_setKey, F, BANKED
63AC  D841     RCALL PL346
63AE  D85D     RCALL PL832
991:           	if (mask&0b0000000000001000)(*St).dyn=(wst&0b0000000000001000)?1:0;		//dana ma byc zaladowana na pozostale 2 cyfry z bufora wspolnego?
63B0  A778     BTFSS _PFNf_prn_pp, 3, BANKED
63B2  D009     BRA 0x63C6
63B4  A776     BTFSS _PFNf_prn_in, 3, BANKED
63B6  D003     BRA 0x63BE
63B8  6B7C     CLRF _PFNf_setKey, BANKED
63BA  2B7C     INCF _PFNf_setKey, F, BANKED
63BC  D002     BRA 0x63C2
63BE  0100     MOVLB 0x0
63C0  6B7C     CLRF _PFNf_setKey, BANKED
63C2  D825     RCALL __end_of_SetStatus
63C4  D841     RCALL PL454
992:           	if (mask&0b0000000000000100)(*St).only=(wst&0b0000000000000100)?1:0;		//dana ma byc zaladowana na pozostale 2 cyfry z bufora wspolnego?
63C6  A578     BTFSS _PFNf_prn_pp, 2, BANKED
63C8  D00C     BRA 0x63E2
63CA  0E01     MOVLW 0x1
63CC  A576     BTFSS _PFNf_prn_in, 2, BANKED
63CE  0E00     MOVLW 0x0
63D0  6F7C     MOVWF _PFNf_setKey, BANKED
63D2  6B7D     CLRF _PFNf_set_aleg, BANKED
63D4  EE20     LFSR 2, 0x2
63D6  F002     NOP
63D8  D821     RCALL PL154
63DA  C07C     MOVFF _PFNf_setKey, POSTINC2
63DC  FFDE     NOP
63DE  C07D     MOVFF _PFNf_set_aleg, POSTDEC2
63E0  FFDD     NOP
63E2  D815     RCALL __end_of_SetStatus
993:           	//jezeli aktywne jest polecenie zapalenia/wygaszenia znaku graficznego i slowo wskazujace znaku jest niezerowe
994:           	if(((*St).sdiode)&&sbdid)
63E4  A4DF     BTFSS INDF2, 2, ACCESS
63E6  D007     BRA 0x63F6
63E8  517A     MOVF _PFNf_res, W, BANKED
63EA  E005     BZ 0x63F6
995:           	{
996:           		(*St).sbdid=sbdid;				//bierze pod uwage tylko wybrane pozycje (zapala dla sdiode=1 gasi dla rdiode=1)
63EC  EE20     LFSR 2, 0x4
63EE  F004     NOP
63F0  D815     RCALL PL154
63F2  C07A     MOVFF _PFNf_res, INDF2
63F4  FFDF     NOP
997:           	}
63F6  D80B     RCALL __end_of_SetStatus
998:           	if(((*St).rdiode)&&rbdid)
63F8  A6DF     BTFSS INDF2, 3, ACCESS
63FA  0012     RETURN 0
63FC  517B     MOVF _PFNf_rozruch, W, BANKED
63FE  B4D8     BTFSC STATUS, 2, ACCESS
6400  0012     RETURN 0
999:           	{
1000:          		(*St).rbdid=rbdid;				//bierze pod uwage tylko wybrane pozycje (zapala dla sdiode=1 gasi dla rdiode=1)
6402  EE20     LFSR 2, 0x5
6404  F005     NOP
6406  D80A     RCALL PL154
6408  C07B     MOVFF _PFNf_rozruch, INDF2
640A  FFDF     NOP
1001:          	}
1002:          }
640C  0012     RETURN 0
1003:          /*--------------------------------------------------------------*/
1004:          //Zapalenie wybranego symbolu graficznego (uwaga - aktywny wskaz kolejki ma priorytet wyswietlania)
1005:          //gdzie focus oresla aktywnosc znaku, pulse wlacza jego pulsacje a gdy pulse=0 stan znaku okresla wrt.
1006:          //np. SetMark(&KMark[_GZ_DCO],1,1,1);
1007:          #if NMZNK!=0
1008:          void SetMark(volatile WMark *wData,const unsigned char focus,const unsigned char pulse, const unsigned char wrt)
1009:          {
1010:          	(*wData).focus=(focus)?1:0;
A628  5176     MOVF _PFNf_prn_in, W, BANKED
A62A  E003     BZ 0xA632
A62C  6B79     CLRF _PFNf_prn_res, BANKED
A62E  2B79     INCF _PFNf_prn_res, F, BANKED
A630  D002     BRA 0xA636
A632  0100     MOVLB 0x0
A634  6B79     CLRF _PFNf_prn_res, BANKED
A636  D823     RCALL PL506
A638  50DF     MOVF INDF2, W, ACCESS
A63A  1979     XORWF _PFNf_prn_res, W, BANKED
A63C  0BFE     ANDLW 0xFE
A63E  1979     XORWF _PFNf_prn_res, W, BANKED
A640  6EDF     MOVWF INDF2, ACCESS
1011:          	(*wData).p=(pulse)?1:0;
A642  5177     MOVF _PFNf_prn_pg, W, BANKED
A644  E003     BZ 0xA64C
A646  6B79     CLRF _PFNf_prn_res, BANKED
A648  2B79     INCF _PFNf_prn_res, F, BANKED
A64A  D002     BRA 0xA650
A64C  0100     MOVLB 0x0
A64E  6B79     CLRF _PFNf_prn_res, BANKED
A650  D816     RCALL PL506
A652  4779     RLNCF _PFNf_prn_res, F, BANKED
A654  4779     RLNCF _PFNf_prn_res, F, BANKED
A656  50DF     MOVF INDF2, W, ACCESS
A658  1979     XORWF _PFNf_prn_res, W, BANKED
A65A  0BFB     ANDLW 0xFB
A65C  1979     XORWF _PFNf_prn_res, W, BANKED
A65E  6EDF     MOVWF INDF2, ACCESS
1012:          	(*wData).m=(wrt)?1:0;
A660  5178     MOVF _PFNf_prn_pp, W, BANKED
A662  E003     BZ 0xA66A
A664  6B79     CLRF _PFNf_prn_res, BANKED
A666  2B79     INCF _PFNf_prn_res, F, BANKED
A668  D002     BRA 0xA66E
A66A  0100     MOVLB 0x0
A66C  6B79     CLRF _PFNf_prn_res, BANKED
A66E  D807     RCALL PL506
A670  4779     RLNCF _PFNf_prn_res, F, BANKED
A672  50DF     MOVF INDF2, W, ACCESS
A674  1979     XORWF _PFNf_prn_res, W, BANKED
A676  0BFD     ANDLW 0xFD
A678  1979     XORWF _PFNf_prn_res, W, BANKED
A67A  6EDF     MOVWF INDF2, ACCESS
1013:          }
A67C  0012     RETURN 0
1014:          //-----------------------------------------------------
1015:          //Wygaszenie wszystkich symboli na wyswietlaczu (uwaga - aktywny wskaz kolejki ma (jak zwykle) priorytet wyswietlania)
1016:          void ClrAllMarks(void)
1017:          {
1018:          	unsigned char i;
1019:          	for(i=0;i<NMZNK;i++)
B78A  0100     MOVLB 0x0
B78C  6B74     CLRF _PFNf_prODP, BANKED
B7AE  2B74     INCF _PFNf_prODP, F, BANKED
1020:          	{
1021:          		KMark[i].focus=1;
B78E  0EE2     MOVLW 0xE2
B790  2574     ADDWF _PFNf_prODP, W, BANKED
B792  EC11     CALL 0xA422, 0
B794  F052     NOP
B796  80DF     BSF INDF2, 0, ACCESS
1022:          		KMark[i].p=0;
B798  0EE2     MOVLW 0xE2
B79A  0100     MOVLB 0x0
B79C  2574     ADDWF _PFNf_prODP, W, BANKED
B79E  EC11     CALL 0xA422, 0
B7A0  F052     NOP
B7A2  94DF     BCF INDF2, 2, ACCESS
1023:          		KMark[i].m=0;			
B7A4  0EE2     MOVLW 0xE2
B7A6  2574     ADDWF _PFNf_prODP, W, BANKED
B7A8  EC11     CALL 0xA422, 0
B7AA  F052     NOP
B7AC  92DF     BCF INDF2, 1, ACCESS
B7AE  2B74     INCF _PFNf_prODP, F, BANKED
B7B0  0E0F     MOVLW 0xF
B7B2  6574     CPFSGT _PFNf_prODP, BANKED
B7B4  D7EC     BRA 0xB78E
B7B6  0C0F     RETLW 0xF
1024:          	}
1025:          }
1026:          #endif
1027:          //-----------------------------------------------------
1028:          //-----------------------------------------------------
1029:          #if NKOL!=0
1030:          //Zwraca stan pozycji nrpoz w kolejce nrkol
1031:          bit GetPoz(const unsigned char nrkol,const unsigned char nrpoz)
1032:          {
1033:          	if ((nrkol>=NKOL)||(nrpoz>=Klj[nrkol].nPzc)) asm("RESET");			//obsluga sytuacji wyjatkowej
1034:          	return (*Klj[nrkol].KL).KFc[nrpoz].focus; 
1035:          }
1036:          //Aktywacja pozycji nrpoz w kolejce nrkol
1037:          void SetPoz(const unsigned char nrkol,const unsigned char nrpoz)
A358  6F79     MOVWF _PFNf_prn_res, BANKED
1038:          {
1039:          	if ((nrkol>=NKOL)||(nrpoz>=Klj[nrkol].nPzc)) asm("RESET");			//obsluga sytuacji wyjatkowej
A35A  0E03     MOVLW 0x3
A35C  0100     MOVLB 0x0
A35E  6179     CPFSLT _PFNf_prn_res, BANKED
A360  D009     BRA 0xA374
A362  5179     MOVF _PFNf_prn_res, W, BANKED
A364  EC39     CALL 0x3672, 0
A366  F01B     NOP
A368  EC23     CALL 0x3646, 0
A36A  F01B     NOP
A36C  0009     TBLRD*+
A36E  50F5     MOVF TABLAT, W, ACCESS
A370  5D74     SUBWF _PFNf_prODP, W, BANKED
A372  E301     BNC 0xA376
A374  00FF     RESET
1040:          	(*Klj[nrkol].KL).KFc[nrpoz].focus=1; 
A376  0100     MOVLB 0x0
A378  5179     MOVF _PFNf_prn_res, W, BANKED
A37A  0D03     MULLW 0x3
A37C  EC23     CALL 0x3646, 0
A37E  F01B     NOP
A380  0009     TBLRD*+
A382  CFF5     MOVFF TABLAT, _PFNf_prn_cs
A384  F075     NOP
A386  0009     TBLRD*+
A388  CFF5     MOVFF TABLAT, _PFNf_prn_in
A38A  F076     NOP
A38C  0E04     MOVLW 0x4
A38E  2775     ADDWF _PFNf_prn_cs, F, BANKED
A390  0E00     MOVLW 0x0
A392  2376     ADDWFC _PFNf_prn_in, F, BANKED
A394  C075     MOVFF _PFNf_prn_cs, TBLPTR
A396  FFF6     NOP
A398  C076     MOVFF _PFNf_prn_in, TBLPTRH
A39A  FFF7     NOP
A39C  0009     TBLRD*+
A39E  CFF5     MOVFF TABLAT, _PFNf_prn_pg
A3A0  F077     NOP
A3A2  0009     TBLRD*+
A3A4  CFF5     MOVFF TABLAT, _PFNf_prn_pp
A3A6  F078     NOP
A3A8  5174     MOVF _PFNf_prODP, W, BANKED
A3AA  2577     ADDWF _PFNf_prn_pg, W, BANKED
A3AC  6ED9     MOVWF FSR2, ACCESS
A3AE  0E00     MOVLW 0x0
A3B0  2178     ADDWFC _PFNf_prn_pp, W, BANKED
A3B2  6EDA     MOVWF FSR2H, ACCESS
A3B4  80DF     BSF INDF2, 0, ACCESS
1041:          	KInd[nrkol].reset=0;			//jezeli wczesniej ustawiono flage resetu kolejki - nalezy ja wyzerowac
A3B6  5179     MOVF _PFNf_prn_res, W, BANKED
A3B8  EC1B     CALL 0x3636, 0
A3BA  F01B     NOP
A3BC  0101     MOVLB 0x1
A3BE  96DF     BCF INDF2, 3, ACCESS
1042:          }
A3C0  0012     RETURN 0
1043:          //Deaktywacja pozycji nrpoz w kolejce nrkol
1044:          void ResetPoz(const unsigned char nrkol,const unsigned char nrpoz)
1045:          {
1046:          	if ((nrkol>=NKOL)||(nrpoz>=Klj[nrkol].nPzc)) asm("RESET");			//obsluga sytuacji wyjatkowej
1047:          	(*Klj[nrkol].KL).KFc[nrpoz].focus=0; 
1048:          }
1049:          //Deaktywacja wszystkich pozycji kolejki nr nrkol
1050:          void ResetKol(const unsigned char nrkol)
BE1E  0100     MOVLB 0x0
BE20  6F74     MOVWF _PFNf_prODP, BANKED
1051:          {
1052:          	if (nrkol>=NKOL) asm("RESET");	//obsluga sytuacji wyjatkowej
BE22  0E02     MOVLW 0x2
BE24  6574     CPFSGT _PFNf_prODP, BANKED
BE26  D001     BRA 0xBE2A
BE28  00FF     RESET
1053:          	KInd[nrkol].reset=1;
BE2A  0100     MOVLB 0x0
BE2C  5174     MOVF _PFNf_prODP, W, BANKED
BE2E  EC1B     CALL 0x3636, 0
BE30  F01B     NOP
BE32  0101     MOVLB 0x1
BE34  86DF     BSF INDF2, 3, ACCESS
1054:          }
BE36  0012     RETURN 0
1055:          //Start/Restart kolejki nr nrkol
1056:          //(dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.)
1057:          void RestartKol(const unsigned char nrkol)
BD9C  0100     MOVLB 0x0
BD9E  6F74     MOVWF _PFNf_prODP, BANKED
1058:          {
1059:          	if (nrkol>=NKOL) asm("RESET");	//obsluga sytuacji wyjatkowej
BDA0  0E02     MOVLW 0x2
BDA2  6574     CPFSGT _PFNf_prODP, BANKED
BDA4  D001     BRA 0xBDA8
BDA6  00FF     RESET
1060:          	KInd[nrkol].restart=1;
BDA8  0100     MOVLB 0x0
BDAA  5174     MOVF _PFNf_prODP, W, BANKED
BDAC  EC1B     CALL 0x3636, 0
BDAE  F01B     NOP
BDB0  0101     MOVLB 0x1
BDB2  84DF     BSF INDF2, 2, ACCESS
1061:          }
BDB4  0012     RETURN 0
1062:          //Start/Restart kolejki nr nrkol (znaki graficzne pracuj¹ niezaleznie)
1063:          //(dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.)
1064:          void RestartKol1(const unsigned char nrkol)
BE04  6F74     MOVWF _PFNf_prODP, BANKED
1065:          {
1066:          	if (nrkol>=NKOL) asm("RESET");	//obsluga sytuacji wyjatkowej
BE06  0E02     MOVLW 0x2
BE08  0100     MOVLB 0x0
BE0A  6574     CPFSGT _PFNf_prODP, BANKED
BE0C  D001     BRA 0xBE10
BE0E  00FF     RESET
1067:          	KInd[nrkol].restart1=1;
BE10  0100     MOVLB 0x0
BE12  5174     MOVF _PFNf_prODP, W, BANKED
BE14  EC1B     CALL 0x3636, 0
BE16  F01B     NOP
BE18  0101     MOVLB 0x1
BE1A  82DF     BSF INDF2, 1, ACCESS
1068:          }
BE1C  0012     RETURN 0
1069:          //Start/Restart kolejki nr nrkol (znaki graficzne pracuja niezaleznie, rozpoczyna od drugiej pozycji kolejki)
1070:          //(dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.)
1071:          void RestartKol2(const unsigned char nrkol)
BB7E  6F74     MOVWF _PFNf_prODP, BANKED
1072:          {
1073:          	if (nrkol>=NKOL) asm("RESET");	//obsluga sytuacji wyjatkowej
BB80  0E02     MOVLW 0x2
BB82  0100     MOVLB 0x0
BB84  6574     CPFSGT _PFNf_prODP, BANKED
BB86  D001     BRA 0xBB8A
BB88  00FF     RESET
1074:          	KInd[nrkol].restart1=1;
BB8A  0100     MOVLB 0x0
BB8C  5174     MOVF _PFNf_prODP, W, BANKED
BB8E  EC1B     CALL 0x3636, 0
BB90  F01B     NOP
BB92  82DF     BSF INDF2, 1, ACCESS
1075:          	KInd[nrkol].restart2=1;
BB94  5174     MOVF _PFNf_prODP, W, BANKED
BB96  EC1B     CALL 0x3636, 0
BB98  F01B     NOP
BB9A  0101     MOVLB 0x1
BB9C  80DF     BSF INDF2, 0, ACCESS
1076:          }
BB9E  0012     RETURN 0
1077:          //Ustawia wszystkie kolejki na pierwsze pozycje
1078:          void AllKolToFirstPoz(void)
1079:          {
1080:          	unsigned char j;
1081:          	for(j=0;j<NKOL;j++)
1082:          	{
1083:          		KInd[j].indeks=0;											
1084:          		KTim[j].ncS=0;
1085:          		KTim[j].ndS=0;
1086:          	}	
1087:          }
1088:          #endif
1089:          //-----------------------------------------------------
1090:          //-----------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/timer3.c  -------------------
1:             /*--------------------------------------------------------------*/
2:             /*timer1.c*/
3:             /*obsluga i konfiguracja modulu Timer1*/
4:             /*--------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"					//parametry globalne
8:             #include "timer3.h"					//parametry lokalne
9:             /*--------------------------------------------------------------*/
10:            /*-----------------------------PROTECTED DATA-------------------*/
11:            
12:            const unsigned int RldT3 = _RLT3; //wartosc poczatkowa timera
13:            
14:            /*--------------------------------------------------------------*/
15:            //konfiguracja modulu Timer1
16:            
17:            void InitTimer3(void)
BD24  D809     RCALL PL644
18:            {
19:                //----------------------
20:                //wartosc poczatkowa dla Timer1
21:                TMR3H = (unsigned char)(RldT3 >> 8);
22:                TMR3L = (unsigned char)(RldT3 & 0xFF);
23:                //----------------------
24:                //Intrerrupt
25:                TMR3IF = 0; //PIR tmr1 overflow interrupt flag bit
BD26  92A1     BCF PIR2, 1, ACCESS
26:                TMR3IE = 1; //PIE tmr1 overflow interrupt enable bit
BD28  82A0     BSF PIE2, 1, ACCESS
27:                TMR3IP = 1; //IPR tmr1 overflow interrupt is a high priority
BD2A  82A2     BSF IPR2, 1, ACCESS
28:                //----------------------
29:                //T1CON
30:                T3CONbits.T3RD16 = 1; //16 -bt Read/Write mode enable bt
BD2C  8EB1     BSF T3CON, 7, ACCESS
31:                
32:                //Prescaler
33:            #if _PRE3==1
34:                T3CONbits.T3CKPS1 = 0; //timer1 input clock prescale select bt
35:                T3CONbits.T1CKPS0 = 0;
36:            #endif	
37:            #if _PRE3==2
38:                T3CONbits.T3CKPS1 = 0;
39:                T3CONbits.T3CKPS0 = 1;
40:            #endif
41:            #if _PRE3==4
42:                T3CONbits.T3CKPS1 = 1;
BD2E  8AB1     BSF T3CON, 5, ACCESS
43:                T3CONbits.T3CKPS0 = 0;
BD30  98B1     BCF T3CON, 4, ACCESS
44:            #endif	
45:            #if _PRE3==8
46:                T3CONbits.T3CKPS1 = 1;
47:                T3CONbits.T3CKPS0 = 1;
48:            #endif
49:                T3CONbits.TMR3CS = 0; //internal clock
BD32  92B1     BCF T3CON, 1, ACCESS
50:                T3CONbits.TMR3ON = 1; //enables timer1
BD34  80B1     BSF T3CON, 0, ACCESS
51:                //----------------------
52:            }
BD36  0CDF     RETLW 0xDF
53:            /*--------------------------------------------------------------*/
54:            //wartosc poczatkowa dla Timer1
55:            
56:            void ReloadTimer3(void)
57:            {
58:                TMR3H = (unsigned char)(RldT3 >> 8);
C278  EC9C     CALL 0xBD38, 0
C27A  F05E     NOP
59:                TMR3L = (unsigned char)(RldT3 & 0xFF);
60:            }
C27C  0CDF     RETLW 0xDF
61:            /*--------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/timer1.c  -------------------
1:             /*--------------------------------------------------------------*/
2:             /*timer1.c*/
3:             /*obsluga i konfiguracja modulu Timer1*/
4:             /*--------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"					//parametry globalne
8:             #include "timer1.h"					//parametry lokalne
9:             
10:            /*--------------------------------------------------------------*/
11:            /*-----------------------------PROTECTED DATA-------------------*/
12:            
13:            const unsigned int RldT1=_RLT1;		//wartosc poczatkowa timera
14:            
15:            /*--------------------------------------------------------------*/
16:            //konfiguracja modulu Timer1
17:            void InitTimer1(void)
BD42  D809     RCALL PL654
18:            {
19:            //----------------------
20:            //wartosc poczatkowa dla Timer1
21:            	TMR1H=(unsigned char)(RldT1>>8);
22:            	TMR1L=(unsigned char)(RldT1&0xFF);
23:            //----------------------	
24:            //Intrerrupt
25:            	TMR1IF=0;			//PIR tmr1 overflow interrupt flag bit
BD44  909E     BCF PIR1, 0, ACCESS
26:            	TMR1IE=1;			//PIE tmr1 overflow interrupt enable bit
BD46  809D     BSF PIE1, 0, ACCESS
27:            	TMR1IP=0;			//IPR tmr1 overflow interrupt is a low priority
BD48  909F     BCF IPR1, 0, ACCESS
28:            //----------------------
29:            //T1CON
30:            	T1RD16=1;				//16 -bt Read/Write mode enable bt
BD4A  8ECD     BSF T1CON, 7, ACCESS
31:            	
32:            //Prescaler
33:            #if _PRE==1
34:            	T1CKPS1=0;			//timer1 input clock prescale select bt
35:            	T1CKPS0=0;
36:            #endif	
37:            #if _PRE==2
38:            	T1CKPS1=0;
BD4C  9ACD     BCF T1CON, 5, ACCESS
39:            	T1CKPS0=1;
BD4E  88CD     BSF T1CON, 4, ACCESS
40:            #endif
41:            #if _PRE==4
42:            	T1CKPS1=1;
43:            	T1CKPS0=0;
44:            #endif	
45:            #if _PRE==8
46:            	T1CKPS1=1;
47:            	T1CKPS0=1;
48:            #endif
49:            	TMR1CS=0;			//internal clock
BD50  92CD     BCF T1CON, 1, ACCESS
50:            	TMR1ON=1;			//enables timer1
BD52  80CD     BSF T1CON, 0, ACCESS
51:            //----------------------
52:            }
BD54  0CBF     RETLW 0xBF
53:            /*--------------------------------------------------------------*/
54:            //wartosc poczatkowa dla Timer1
55:            void ReloadTimer1(void)
56:            {
57:            	TMR1H=(unsigned char)(RldT1>>8);
C272  ECAB     CALL 0xBD56, 0
C274  F05E     NOP
58:            	TMR1L=(unsigned char)(RldT1&0xFF);
59:            }
C276  0CBF     RETLW 0xBF
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/timer0.c  -------------------
1:             /*--------------------------------------------------------------*/
2:             /*timer0.c*/
3:             /*obsluga i konfiguracja modulu Timer0*/
4:             /*--------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"					//parametry globalne
7:             #include "timer0.h"					//parametry lokalne
8:             #if (_EXT_BOARD>=3)
9:             /*--------------------------------------------------------------*/
10:            /*-----------------------------PROTECTED DATA-------------------*/
11:            const unsigned int RldT0=0;		//wartosc poczatkowa timera
12:            volatile unsigned char Tim0Type=0;  //tryb przerwania od timer0
13:            
14:            extern volatile bit PFNf_firstEdge;		//pierwsze zbocze
15:            //extern volatile bit PFNf_dataReady;		//pierwsze zbocze
16:            //extern volatile bit PFNf_TimPeriod;     //znacznik przerwania po czasie TimPeriod
17:            //extern volatile unsigned long data1;
18:            extern volatile unsigned char db;
19:            
20:            //konfiguracja modulu Timer1
21:            //pojedynczy impuls co 4u
22:            void InitTimer0(void)
23:            {
24:            //----------------------
25:            //wartosc poczatkowa dla Timer1
26:            	TMR0H=(unsigned char)(RldT0>>8);
BD60  6AD7     CLRF TMR0H, ACCESS
27:            	TMR0L=(unsigned char)(RldT0&0xFF);
BD62  6AD6     CLRF TMR0, ACCESS
28:            
29:            //----------------------
30:            //T1CON
31:            	T08BIT=0;           //16 -bit
BD64  9CD5     BCF T0CON, 6, ACCESS
32:                T0CS=0;             //taktowany z internal clock    
BD66  9AD5     BCF T0CON, 5, ACCESS
33:            #if _PRE0==0
34:                PSA=1               //prescaler wylaczony
35:            #else        
36:                PSA=0;              //prescaler aktywny
BD68  96D5     BCF T0CON, 3, ACCESS
37:                //Prescaler
38:                #if _PRE0==2
39:                    T0PS2=0;			//timer1 input clock prescale select bt
40:                    T0PS1=0;			//timer1 input clock prescale select bt
41:                    T0PS0=0;			//timer1 input clock prescale select bt        
42:                #endif	
43:                #if _PRE0==4
44:                    T0PS2=0;			//timer1 input clock prescale select bt
45:                    T0PS1=0;			//timer1 input clock prescale select bt
46:                    T0PS0=1;			//timer1 input clock prescale select bt
47:                #endif
48:                #if _PRE0==8
49:                    T0PS2=0;			//timer1 input clock prescale select bt
50:                    T0PS1=1;			//timer1 input clock prescale select bt
51:                    T0PS0=0;			//timer1 input clock prescale select bt
52:                #endif	
53:                #if _PRE0==16
54:                    T0PS2=0;			//timer1 input clock prescale select bt
55:                    T0PS1=1;			//timer1 input clock prescale select bt
56:                    T0PS0=1;			//timer1 input clock prescale select bt
57:                #endif
58:                #if _PRE0==32
59:                    T0PS2=1;			//timer1 input clock prescale select bt
BD6A  84D5     BSF T0CON, 2, ACCESS
60:                    T0PS1=0;			//timer1 input clock prescale select bt
BD6C  92D5     BCF T0CON, 1, ACCESS
61:                    T0PS0=0;			//timer1 input clock prescale select bt
BD6E  90D5     BCF T0CON, 0, ACCESS
62:                #endif
63:                #if _PRE0==64
64:                    T0PS2=1;			//timer1 input clock prescale select bt
65:                    T0PS1=0;			//timer1 input clock prescale select bt
66:                    T0PS0=1;			//timer1 input clock prescale select bt
67:                #endif
68:                #if _PRE0==128
69:                    T0PS2=1;			//timer1 input clock prescale select bt
70:                    T0PS1=1;			//timer1 input clock prescale select bt
71:                    T0PS0=0;			//timer1 input clock prescale select bt
72:                #endif
73:                #if _PRE0==256
74:                    T0PS2=1;			//timer1 input clock prescale select bt
75:                    T0PS1=1;			//timer1 input clock prescale select bt
76:                    T0PS0=1;			//timer1 input clock prescale select bt
77:                #endif
78:            #endif
79:            //----------------------	
80:            	TMR0=0;             //internal clock        
BD70  6AD6     CLRF TMR0, ACCESS
BD72  6AD7     CLRF TMR0H, ACCESS
81:                    
82:            //Intrerrupt
83:            	TMR0IF=0;			//PIR tmr1 overflow interrupt flag bit
BD74  94F2     BCF INTCON, 2, ACCESS
84:            	TMR0IP=1;			//IPR tmr1 overflow interrupt is a high priority
BD76  84F1     BSF INTCON2, 2, ACCESS
85:            	TMR0IE=0;			//PIE tmr1 overflow interrupt enable bit    
BD78  9AF2     BCF INTCON, 5, ACCESS
86:                
87:            //----------------------    
88:            	TMR0ON=1;			//enables timer0
BD7A  8ED5     BSF T0CON, 7, ACCESS
89:            }
BD7C  0012     RETURN 0
90:            unsigned int ReadTMR0(void)
91:            {
92:                unsigned int tm;
93:                
94:                if(TMR0ON==1)
BC28  AED5     BTFSS T0CON, 7, ACCESS
BC2A  D004     BRA 0xBC34
95:                {
96:                    TMR0ON=0;			//disable timer0
BC2C  9ED5     BCF T0CON, 7, ACCESS
97:                    tm=TMR0;
BC2E  D808     RCALL PL636
98:                    TMR0ON=1;			//enable/disable timer0
BC30  8ED5     BSF T0CON, 7, ACCESS
99:                }
BC32  D001     BRA 0xBC36
100:               else
BC34  D805     RCALL PL636
101:               {
102:                   tm=TMR0;
103:               }
104:               return tm;
BC36  C017     MOVFF _LIN1f_ERRR, _LIN1f_Busy
BC38  F015     NOP
BC3A  C018     MOVFF _LIN1f_FAdta, _LIN1f_CHK
BC3C  F016     NOP
105:           }
BC3E  0012     RETURN 0
106:           volatile unsigned char h,l;
107:           /*
108:           void WrtTMR0(volatile unsigned int tm)
109:           {  
110:               if(TMR0ON==1)
111:               {
112:                   while(TMR0!=tm)
113:                   {
114:                       TMR0ON=0;			//disable timer0 
115:                       TMR0H=(unsigned char)((tm&0xFF00)>>8);
116:                       TMR0L=(unsigned char)(tm&0x00FF);       
117:                       TMR0=tm;
118:                   }
119:                   TMR0ON=1;			//enable/disable timer0
120:               }
121:               else
122:               {
123:                   while(TMR0!=tm)
124:                   {        
125:                       TMR0H=(unsigned char)((tm&0xFF00)>>8);
126:                       TMR0L=(unsigned char)(tm&0x00FF);    
127:                       TMR0=tm;
128:                   }
129:               }
130:           }*/
131:           void ReloadTMR0(volatile unsigned int tm)
132:           {  
133:               if(TMR0ON==1)
B022  AED5     BTFSS T0CON, 7, ACCESS
B024  D010     BRA 0xB046
B026  D004     BRA 0xB030
B0A2  AED5     BTFSS T0CON, 7, ACCESS
B122  AED5     BTFSS T0CON, 7, ACCESS
134:               {
135:                   while(TMR0!=tm)
B030  5174     MOVF _PFNf_prODP, W, BANKED
B032  18D6     XORWF TMR0, W, ACCESS
B034  E1F9     BNZ 0xB028
B036  5175     MOVF _PFNf_prn_cs, W, BANKED
B038  18D7     XORWF TMR0H, W, ACCESS
B03A  E1F6     BNZ 0xB028
B0B0  5028     MOVF _PFNf_10V_RT, W, ACCESS
B0B2  18D6     XORWF TMR0, W, ACCESS
B0B4  E1F9     BNZ 0xB0A8
B0B6  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
B0B8  18D7     XORWF TMR0H, W, ACCESS
B0BA  E1F6     BNZ 0xB0A8
B130  5015     MOVF _LIN1f_Busy, W, ACCESS
B132  18D6     XORWF TMR0, W, ACCESS
B134  E1F9     BNZ 0xB128
B136  5016     MOVF _LIN1f_CHK, W, ACCESS
B138  18D7     XORWF TMR0H, W, ACCESS
B13A  E1F6     BNZ 0xB128
136:                   {
137:                       TMR0ON=0;			//disable timer0 
B028  9ED5     BCF T0CON, 7, ACCESS
B0A8  9ED5     BCF T0CON, 7, ACCESS
B128  9ED5     BCF T0CON, 7, ACCESS
138:                       TMR0H=(unsigned char)((tm&0xFF00)>>8);
B02A  C075     MOVFF _PFNf_prn_cs, TMR0H
B02C  FFD7     NOP
B0AA  C029     MOVFF _PFNf_10V_nPCO, TMR0H
B0AC  FFD7     NOP
B12A  C016     MOVFF _LIN1f_CHK, TMR0H
B12C  FFD7     NOP
139:                       TMR0L=(unsigned char)(tm&0x00FF);       
B02E  D812     RCALL PL492
B0AE  D812     RCALL PL472
B12E  D812     RCALL PL494
140:                       TMR0=tm;
141:                   }
142:                   TMR0ON=1;			//enable/disable timer0
B03C  8ED5     BSF T0CON, 7, ACCESS
B0BC  8ED5     BSF T0CON, 7, ACCESS
B13C  8ED5     BSF T0CON, 7, ACCESS
143:               }
B03E  0012     RETURN 0
B0BE  0012     RETURN 0
B13E  0012     RETURN 0
144:               else
145:               {
146:                   while(TMR0!=tm)
B046  5174     MOVF _PFNf_prODP, W, BANKED
B048  18D6     XORWF TMR0, W, ACCESS
B04A  E1FA     BNZ 0xB040
B04C  5175     MOVF _PFNf_prn_cs, W, BANKED
B04E  18D7     XORWF TMR0H, W, ACCESS
B050  E1F7     BNZ 0xB040
B0C6  5028     MOVF _PFNf_10V_RT, W, ACCESS
B0C8  18D6     XORWF TMR0, W, ACCESS
B0CA  E1FA     BNZ 0xB0C0
B0CC  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
B0CE  18D7     XORWF TMR0H, W, ACCESS
B0D0  E1F7     BNZ 0xB0C0
B146  5015     MOVF _LIN1f_Busy, W, ACCESS
B148  18D6     XORWF TMR0, W, ACCESS
B14A  E1FA     BNZ 0xB140
B14C  5016     MOVF _LIN1f_CHK, W, ACCESS
B14E  18D7     XORWF TMR0H, W, ACCESS
B150  E1F7     BNZ 0xB140
147:                   {        
148:                       TMR0H=(unsigned char)((tm&0xFF00)>>8);
B040  C075     MOVFF _PFNf_prn_cs, TMR0H
B042  FFD7     NOP
B044  D807     RCALL PL492
B0C0  C029     MOVFF _PFNf_10V_nPCO, TMR0H
B0C2  FFD7     NOP
B0C4  D807     RCALL PL472
B140  C016     MOVFF _LIN1f_CHK, TMR0H
B142  FFD7     NOP
B144  D807     RCALL PL494
149:                       TMR0L=(unsigned char)(tm&0x00FF);    
150:                       TMR0=tm;
151:                   }
152:               }
153:           }
B052  0012     RETURN 0
B0D2  0012     RETURN 0
B152  0012     RETURN 0
154:           /*---------------------------------------------------------------------------------*/
155:           #endif //(_EXT_BOARD>=3)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/rtimer.c  -------------------
1:             /*--------------------------------------------------------------*/
2:             /*rtime.c*/
3:             /*zestaw zegarow czasu rzeczywistego*/
4:             /*typy danych i parametry konfiguracyjne zdefiniowano w pliku rtimer.h*/
5:             /*--------------------------------------------------------------*/
6:             //#include <pic18.h>
7:             #include <xc.h>
8:             #include "global.h"			//parametry globalne
9:             #include "rtimer.h"			//parametry lokalne
10:            
11:            //(!) Timery zarezerwowane dla nast. plikow projektu
12:            //RTdS(0)		pwron.c
13:            //RTdS(1)		keypad.c
14:            //RTS(0)		konfig.c, main.c(rozruch)
15:            
16:            /*---------------------------------------------------------------------------------*/
17:            /*-----------------------------PROTECTED DATA--------------------------------------*/
18:            
19:            #if (_NRT_M)||(_NRT_G)||(_NRT_S)
20:            volatile static near RTcomm		CommRT;
21:            #endif
22:            #if _NRT_cS
23:            volatile near RTcSekundy	cSk[_NRT_cS];
24:            #endif
25:            #if _NRT_dS
26:            volatile near RTdSekundy	dSk[_NRT_dS];
27:            #endif
28:            #if _NRT_S
29:            volatile near RTsekundy	Sk[_NRT_S];
30:            #endif
31:            #if _NRT_M
32:            volatile near RTminuty	Mn[_NRT_M];
33:            #endif
34:            #if _NRT_G
35:            volatile near RTgodziny	Gd[_NRT_G];
36:            #endif
37:            
38:            /*--------------------------------------------------------------*/
39:            /*Funkcje obslugi timerow centy sekund*/
40:            #if _NRT_cS
41:            void StartRTcS(const unsigned char Index)
C006  6F74     MOVWF _PFNf_prODP, BANKED
42:            {
43:            	if (Index>_NRT_cS-1) asm("RESET");	//obsluga sytuacji wyjatkowej
C008  0100     MOVLB 0x0
C00A  5174     MOVF _PFNf_prODP, W, BANKED
C00C  E001     BZ 0xC010
C00E  00FF     RESET
44:            	cSk[Index]=0;
C010  0100     MOVLB 0x0
C012  5174     MOVF _PFNf_prODP, W, BANKED
C014  0F4A     ADDLW 0x4A
C016  EF39     GOTO 0x6072
C018  F030     NOP
45:            }
46:            unsigned char RTcS(const unsigned char Index)
BEFE  6F74     MOVWF _PFNf_prODP, BANKED
47:            {
48:            	if (Index>_NRT_cS-1) asm("RESET");	//obsluga sytuacji wyjatkowej
BF00  0100     MOVLB 0x0
BF02  5174     MOVF _PFNf_prODP, W, BANKED
BF04  E001     BZ 0xBF08
BF06  00FF     RESET
49:            	return cSk[Index];
BF08  0100     MOVLB 0x0
BF0A  5174     MOVF _PFNf_prODP, W, BANKED
BF0C  0F4A     ADDLW 0x4A
BF0E  6ED9     MOVWF FSR2, ACCESS
BF10  6ADA     CLRF FSR2H, ACCESS
BF12  50DF     MOVF INDF2, W, ACCESS
50:            }
BF14  0012     RETURN 0
51:            #endif
52:            /*--------------------------------------------------------------*/
53:            /*Funkcje obslugi timerow decy sekund*/
54:            #if _NRT_dS
55:            void StartRTdS(const unsigned char Index)
BCAA  0100     MOVLB 0x0
BCAC  6F74     MOVWF _PFNf_prODP, BANKED
56:            {
57:            	if (Index>_NRT_dS-1) asm("RESET");	//obsluga sytuacji wyjatkowej
BCAE  0E0B     MOVLW 0xB
BCB0  6574     CPFSGT _PFNf_prODP, BANKED
BCB2  D001     BRA 0xBCB6
BCB4  00FF     RESET
58:            	dSk[Index].cS=0;
BCB6  0100     MOVLB 0x0
BCB8  5174     MOVF _PFNf_prODP, W, BANKED
BCBA  ECD1     CALL 0x77A2, 0
BCBC  F03B     NOP
BCBE  6ADF     CLRF INDF2, ACCESS
59:            	dSk[Index].dS=0;
BCC0  5174     MOVF _PFNf_prODP, W, BANKED
BCC2  ECD9     CALL 0x77B2, 0
BCC4  F03B     NOP
BCC6  6ADF     CLRF INDF2, ACCESS
60:            }
BCC8  0C00     RETLW 0x0
61:            unsigned char RTdS(const unsigned char Index)
BF16  0100     MOVLB 0x0
BF18  6F74     MOVWF _PFNf_prODP, BANKED
62:            {
63:            	if (Index>_NRT_dS-1) asm("RESET");	//obsluga sytuacji wyjatkowej
BF1A  0E0B     MOVLW 0xB
BF1C  6574     CPFSGT _PFNf_prODP, BANKED
BF1E  D001     BRA 0xBF22
BF20  00FF     RESET
64:            	return dSk[Index].dS;
BF22  0100     MOVLB 0x0
BF24  5174     MOVF _PFNf_prODP, W, BANKED
BF26  ECD9     CALL 0x77B2, 0
BF28  F03B     NOP
BF2A  50DF     MOVF INDF2, W, ACCESS
65:            }
BF2C  0012     RETURN 0
66:            #endif
67:            /*--------------------------------------------------------------*/
68:            /*Funkcje obslugi timerow sekund*/
69:            #if _NRT_S
70:            void StartRTS(const unsigned char Index)
BC8A  0100     MOVLB 0x0
BC8C  6F74     MOVWF _PFNf_prODP, BANKED
71:            {
72:            	if (Index>_NRT_S-1) asm("RESET");		//obsluga sytuacji wyjatkowej
BC8E  0E04     MOVLW 0x4
BC90  6574     CPFSGT _PFNf_prODP, BANKED
BC92  D001     BRA 0xBC96
BC94  00FF     RESET
73:            	Sk[Index].dS=0;
BC96  0100     MOVLB 0x0
BC98  5174     MOVF _PFNf_prODP, W, BANKED
BC9A  ECB1     CALL 0x7762, 0
BC9C  F03B     NOP
BC9E  6ADF     CLRF INDF2, ACCESS
74:            	Sk[Index].S=0;
BCA0  5174     MOVF _PFNf_prODP, W, BANKED
BCA2  ECB9     CALL 0x7772, 0
BCA4  F03B     NOP
BCA6  6ADF     CLRF INDF2, ACCESS
75:            }
BCA8  0C00     RETLW 0x0
76:            unsigned char RTS(const unsigned char Index)
BEE6  0100     MOVLB 0x0
BEE8  6F74     MOVWF _PFNf_prODP, BANKED
77:            {
78:            	if (Index>_NRT_S-1) asm("RESET");		//obsluga sytuacji wyjatkowej
BEEA  0E04     MOVLW 0x4
BEEC  6574     CPFSGT _PFNf_prODP, BANKED
BEEE  D001     BRA 0xBEF2
BEF0  00FF     RESET
79:            	return Sk[Index].S;
BEF2  0100     MOVLB 0x0
BEF4  5174     MOVF _PFNf_prODP, W, BANKED
BEF6  ECB9     CALL 0x7772, 0
BEF8  F03B     NOP
BEFA  50DF     MOVF INDF2, W, ACCESS
80:            }
BEFC  0012     RETURN 0
81:            #endif
82:            /*--------------------------------------------------------------*/
83:            /*Funkcje obslugi timerow minut*/
84:            #if _NRT_M
85:            void StartRTM(const unsigned char Index)
BC4A  6F74     MOVWF _PFNf_prODP, BANKED
86:            {
87:            	if (Index>_NRT_M-1) asm("RESET");		//obsluga sytuacji wyjatkowej
BC4C  0E03     MOVLW 0x3
BC4E  0100     MOVLB 0x0
BC50  6574     CPFSGT _PFNf_prODP, BANKED
BC52  D001     BRA 0xBC56
BC54  00FF     RESET
88:            	Mn[Index].S=0;
BC56  0100     MOVLB 0x0
BC58  5174     MOVF _PFNf_prODP, W, BANKED
BC5A  ECC1     CALL 0x7782, 0
BC5C  F03B     NOP
BC5E  6ADF     CLRF INDF2, ACCESS
89:            	Mn[Index].M=0;
BC60  5174     MOVF _PFNf_prODP, W, BANKED
BC62  ECC9     CALL 0x7792, 0
BC64  F03B     NOP
BC66  6ADF     CLRF INDF2, ACCESS
90:            }
BC68  0C00     RETLW 0x0
91:            unsigned char RTM(const unsigned char Index)
BE86  0100     MOVLB 0x0
BE88  6F74     MOVWF _PFNf_prODP, BANKED
92:            {
93:            	if (Index>_NRT_M-1) asm("RESET");		//obsluga sytuacji wyjatkowej
BE8A  0E03     MOVLW 0x3
BE8C  6574     CPFSGT _PFNf_prODP, BANKED
BE8E  D001     BRA 0xBE92
BE90  00FF     RESET
94:            	return Mn[Index].M;
BE92  0100     MOVLB 0x0
BE94  5174     MOVF _PFNf_prODP, W, BANKED
BE96  ECC9     CALL 0x7792, 0
BE98  F03B     NOP
BE9A  50DF     MOVF INDF2, W, ACCESS
95:            }
BE9C  0012     RETURN 0
96:            unsigned char RTMs(const unsigned char Index)
97:            {
98:            	if (Index>_NRT_M-1) asm("RESET");		//obsluga sytuacji wyjatkowej
99:            	return Mn[Index].S;
100:           }
101:           #endif
102:           /*--------------------------------------------------------------*/
103:           /*Funkcje obslugi timerow godzin*/
104:           #if _NRT_G
105:           void StartRTG(const unsigned char Index)
106:           {
107:           	if (Index>_NRT_G-1) asm("RESET");		//obsluga sytuacji wyjatkowej
108:           	Gd[Index].M=0;
109:           	Gd[Index].G=0;
110:           }
111:           unsigned char RTG(const unsigned char Index)
112:           {
113:           	if (Index>_NRT_G-1) asm("RESET");		//obsluga sytuacji wyjatkowej
114:           	return Gd[Index].G;
115:           }
116:           #endif
117:           
118:           /*---------------------------------------------------------------*/
119:           /*Glowna funkcja obslugi timerow*/
120:           void IncRTimer(void)
121:           {
122:           		#if (_NRT_M)||(_NRT_G)||(_NRT_S)||(_NRT_dS)||(_NRT_cS)
123:           		unsigned char i;
124:           		#endif
125:           		
126:           /*zakres czasu od 0,01 do 2,55 sek. z krokiem 0,01 sek. blad=+/-0,01 sek*/
127:           
128:           		#if _NRT_cS
129:           		for(i=0;i<_NRT_cS;i++)
76A6  6A29     CLRF _PFNf_10V_nPCO, ACCESS
76B2  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
76B4  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76B6  E0F8     BZ 0x76A8
130:           			if(cSk[i]<255) cSk[i]++;
76A8  D88C     RCALL PL730
76AA  28DE     INCF POSTINC2, W, ACCESS
76AC  E002     BZ 0x76B2
76AE  D889     RCALL PL730
76B0  2ADF     INCF INDF2, F, ACCESS
131:           		#endif
132:           
133:           /*zakres czasu od 0,1 do 25,5 sek. z krokiem 0,1 sek. blad=+/-0,01 sek*/
134:           
135:           		#if _NRT_dS
136:           		for(i=0;i<_NRT_dS;i++)
76B8  6A29     CLRF _PFNf_10V_nPCO, ACCESS
76DE  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
76E0  0E0B     MOVLW 0xB
76E2  6429     CPFSGT _PFNf_10V_nPCO, ACCESS
76E4  D7EA     BRA 0x76BA
137:           		{
138:           			dSk[i].cS++;
76BA  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76BC  D872     RCALL PL168
76BE  2ADF     INCF INDF2, F, ACCESS
139:           			if(dSk[i].cS>9)
76C0  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76C2  D86F     RCALL PL168
76C4  0E09     MOVLW 0x9
76C6  64DF     CPFSGT INDF2, ACCESS
76C8  D00A     BRA 0x76DE
140:           			{
141:           				dSk[i].cS=0;
76CA  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76CC  D86A     RCALL PL168
76CE  6ADF     CLRF INDF2, ACCESS
142:           				if(dSk[i].dS<255) dSk[i].dS++;
76D0  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76D2  D86F     RCALL PL170
76D4  28DE     INCF POSTINC2, W, ACCESS
76D6  E003     BZ 0x76DE
76D8  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76DA  D86B     RCALL PL170
76DC  2ADF     INCF INDF2, F, ACCESS
143:           			}
144:           		}
145:           		#endif
146:           
147:           		#if (_NRT_S)||(_NRT_M)||(_NRT_G)
148:           		
149:           		CommRT.cS++;
76E6  2A45     INCF CommRT, F, ACCESS
150:           		if(CommRT.cS>9)
76E8  0E09     MOVLW 0x9
76EA  6445     CPFSGT CommRT, ACCESS
76EC  0C09     RETLW 0x9
151:           		{
152:           			CommRT.cS=0;
76EE  6A45     CLRF CommRT, ACCESS
153:           			CommRT.dS++;
76F0  2A46     INCF 0x46, F, ACCESS
154:           			
155:           /*zakres czasu od 1 do 255 sek. z krokiem 1 sek. blad=+/-0,1 sek*/
156:           
157:           			#if _NRT_S
158:           			for(i=0;i<_NRT_S;i++)
76F2  6A29     CLRF _PFNf_10V_nPCO, ACCESS
7718  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
771A  0E04     MOVLW 0x4
771C  6429     CPFSGT _PFNf_10V_nPCO, ACCESS
771E  D7EA     BRA 0x76F4
159:           			{
160:           				Sk[i].dS++;
76F4  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76F6  D835     RCALL PL156
76F8  2ADF     INCF INDF2, F, ACCESS
161:           				if(Sk[i].dS>9)
76FA  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
76FC  D832     RCALL PL156
76FE  0E09     MOVLW 0x9
7700  64DF     CPFSGT INDF2, ACCESS
7702  D00A     BRA 0x7718
162:           				{
163:           					Sk[i].dS=0;
7704  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
7706  D82D     RCALL PL156
7708  6ADF     CLRF INDF2, ACCESS
164:           					if(Sk[i].S<255) Sk[i].S++;
770A  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
770C  D832     RCALL PL158
770E  28DE     INCF POSTINC2, W, ACCESS
7710  E003     BZ 0x7718
7712  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
7714  D82E     RCALL PL158
7716  2ADF     INCF INDF2, F, ACCESS
165:           				}
166:           			}
167:           			#endif
168:           			
169:           			if(CommRT.dS>9)
7720  0E09     MOVLW 0x9
7722  6446     CPFSGT 0x46, ACCESS
7724  0C09     RETLW 0x9
170:           			{
171:           				CommRT.dS=0;
7726  6A46     CLRF 0x46, ACCESS
172:           				CommRT.S++;
7728  2A47     INCF 0x47, F, ACCESS
173:           				
174:           /*zakres czasu od 1 do 255 min. z krokiem 1 min. blad=+/- 1 sek*/
175:           
176:           				#if _NRT_M
177:           				for(i=0;i<_NRT_M;i++)
772A  6A29     CLRF _PFNf_10V_nPCO, ACCESS
7750  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
7752  0E03     MOVLW 0x3
7754  6429     CPFSGT _PFNf_10V_nPCO, ACCESS
7756  D7EA     BRA 0x772C
178:           				{
179:           					Mn[i].S++;
772C  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
772E  D829     RCALL PL160
7730  2ADF     INCF INDF2, F, ACCESS
180:           					if(Mn[i].S>59)
7732  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
7734  D826     RCALL PL160
7736  0E3B     MOVLW 0x3B
7738  64DF     CPFSGT INDF2, ACCESS
773A  D00A     BRA 0x7750
181:           					{
182:           						Mn[i].S=0;
773C  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
773E  D821     RCALL PL160
7740  6ADF     CLRF INDF2, ACCESS
183:           						if(Mn[i].M<255) Mn[i].M++;
7742  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
7744  D826     RCALL PL166
7746  28DE     INCF POSTINC2, W, ACCESS
7748  E003     BZ 0x7750
774A  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
774C  D822     RCALL PL166
774E  2ADF     INCF INDF2, F, ACCESS
184:           					}
185:           				}
186:           				#endif
187:           
188:           				if (CommRT.S>59)
7758  0E3B     MOVLW 0x3B
775A  6447     CPFSGT 0x47, ACCESS
775C  0C3B     RETLW 0x3B
189:           				{
190:           					CommRT.S=0;
775E  6A47     CLRF 0x47, ACCESS
191:           					
192:           /*zakres czasu od 1 do 255 godzin z krokiem 1 godz. blad=+/- 1 min*/
193:           
194:           					#if _NRT_G
195:           					for(i=0;i<_NRT_G;i++)
196:           					{
197:           						Gd[i].M++;
198:           						if(Gd[i].M>59)
199:           						{
200:           							Gd[i].M=0;
201:           							if(Gd[i].G<255) Gd[i].G++;
202:           						}
203:           					}
204:           					#endif
205:           				}
206:           			}
207:           
208:           		}
209:           		#endif
210:           	
211:           }
7760  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/readdtal.c  -----------------
1:             /*readdta.c*/
2:             //Funkcja odczytu danej z keypadu
3:             // (!) Bazuje na funkcjach z plikow:  lcd8.c, keypad.c
4:             /*---------------------------------------------------------------------------------*/
5:             //include <pic18.h>
6:             #include <xc.h>
7:             #include <stdio.h>
8:             #include "global.h"			//parametry globalne
9:             #include "readdtal.h"		//parametry lokalne
10:            
11:            extern volatile StPin xxky[];
12:            extern volatile unsigned char x;
13:            /*---------------------------------------------------------------------------------*/
14:            //Odczyt danej z keypadu z potwierdzeniem
15:            //dt - wskaznik do modyfikowanego parametru
16:            //min - minimalna wartosc jaka moze przyjac parametr
17:            //max - maksymalna wartosc jaka moze przyjac parametr
18:            //step - krok z jakim odbywa sie inkrementacja/dekrementacja
19:            //np. akceptacja=ReadData(&x,1,3,1,wr);
20:            #if (_ENRDT)
21:            unsigned char ReadData(unsigned char k,volatile StPin *ky,unsigned char *dt,unsigned char min,unsigned char max,const unsigned char step,unsigned char wrn)
22:            {
23:            	static unsigned char bd;
24:            	static bit dtmo=0,okvi=0;
25:            	
26:            	if(!dtmo) 						//pierwsze uruchomienie procedury
27:            	{
28:            		bd=*dt;
29:            		dtmo=1;
30:            		okvi=0;
31:            	}
32:            	if(!okvi)						//akceptacja danej?
33:            	{
34:            		if(bd<min) bd=min;
35:            		if(ExPresKey(k,ky,_RDTOFS,_RDKRFS)) 
36:            		{
37:            			bd=bd+step;
38:            		}
39:            		if(bd>max) bd=min;
40:            		PrintCO(bd);
41:            	
42:            		if(wrn) okvi=1;				//spelniony warunek wyjscia?
43:            	}
44:            	else
45:            	{
46:            		dtmo=0;
47:            		okvi=0;
48:            		*dt=bd;
49:            		return 1;					//zwroc znacznik potwierdzenia
50:            	}	
51:            	return 0x00;
52:            }
53:            #endif
54:            /*---------------------------------------------------------------------------------*/
55:            //Odczyt danej z keypadu z potwierdzeniem /regulowany krok - wersja dla danych o duzych wartosciach/
56:            //dt - wskaznik do modyfikowanego parametru
57:            //min - minimalna wartosc jaka moze przyjac parametr
58:            //max - maksymalna wartosc jaka moze przyjac parametr
59:            //step - krok z jakim odbywa sie inkrementacja/dekrementacja przy pojedynczym nacisnieciu przycisku
60:            //step2 - krok z jakim odbywa sie inkrementacja/dekrementacja przy wcisnietym przycisku
61:            //np. akceptacja=ReadDataX(&x,1,100,1,5,wr);
62:            #if (_ENRDTX)
63:            unsigned char ReadDataX(unsigned char k,volatile StPin *ky,unsigned char *dt,unsigned char min,unsigned char max,const unsigned char step,const unsigned char step2,unsigned char wrn)
64:            {
65:            	static bit dtmo=0,okvi=0;
66:            	static unsigned char bd,iu;
67:            	static unsigned char ktu;
68:            	char key=0;
69:            	
70:            	if(!dtmo) 						//pierwsze uruchomienie procedury
71:            	{
72:            		iu=0;
73:            		ktu=0;
74:            		dtmo=1;
75:            		okvi=0;
76:            		bd=*dt;
77:            	}
78:            	if(!okvi)						//akceptacja danej?
79:            	{
80:            		if(bd<min) bd=min;
81:            		if(key=ExxPresKey1(k,ky,_RDTOFSX,ktu)) 
82:            		{
83:            			if(key==1)
84:            			{
85:            				iu=0;
86:            				ktu=5;
87:            				bd=bd+step;
88:            			}
89:            			if(key==2) 
90:            			{
91:            				if (iu<(_RDKRFSX-1)*_VKRFSX) iu++;
92:            				ktu=_RDKRFSX-iu/_VKRFSX;
93:            				bd=bd+step2;
94:            			}
95:            		}
96:            		else 
97:            		{
98:            			iu=0;
99:            			ktu=5;
100:           		}
101:           		if(bd>max) bd=min;		
102:           		PrintCO(bd);
103:           
104:           		if(wrn) okvi=1;				//spelniony warunek wyjscia?
105:           	}
106:           	else
107:           	{
108:           		dtmo=0;
109:           		okvi=0;
110:           		*dt=bd;
111:           		return 1;							//zwroc znacznik potwierdzenia
112:           	}
113:           	return 0x00;
114:           }
115:           #endif
116:           /*---------------------------------------------------------------------------------*/
117:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie")
118:           //dt - wskaznik do modyfikowanego parametru
119:           //min - minimalna wartosc jaka moze przyjac parametr
120:           //max - maksymalna wartosc jaka moze przyjac parametr
121:           //step - krok z jakim odbywa sie inkrementacja/dekrementacja
122:           //np. akceptacja=ReadData(&x,1,100,1,wr);
123:           #if (_ENRDTONL)
124:           unsigned char ReadDataONL(unsigned char k,volatile StPin *ky,unsigned char *dt,unsigned char min,unsigned char max,const unsigned char step,unsigned char wrn)
125:           {
126:           	if(*dt<min) *dt=min;
127:           	if(ExPresKey(k,ky,_RDTOFSNL,_RDKRFSNL)) 
128:           	{
129:           		if(*dt>=max) *dt=min;
130:           		else
131:           		if(*dt+step<=max) *dt=*dt+step;
132:           	}
133:           	if(*dt>max) *dt=min;
134:           	if(wrn) return 1;			//spelniony warunek wyjscia?
135:           	return 0x00;
136:           }
137:           #endif
138:           /*---------------------------------------------------------------------------------*/
139:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
140:           //dt - wskaznik do modyfikowanego parametru
141:           //min - minimalna wartosc jaka moze przyjac parametr
142:           //max - maksymalna wartosc jaka moze przyjac parametr
143:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
144:           //step2 - krok z jakim odbywa sie inkrementacja przy wcisnietym przycisku
145:           //np. akceptacja=ReadDataXONL(&x,1,100,1,5,wr);
146:           #if (_ENRDTOXL)
147:           unsigned char ReadDataXONL(unsigned char k,volatile StPin *ky,unsigned char *dt,unsigned char min,unsigned char max,const unsigned char step,const unsigned char step2,unsigned char wrn)
148:           {
149:           	static bit dtmo=0;
150:           	static unsigned char ktu,iu;
151:           	char key=0;
152:           
153:           	if(!dtmo) 						//pierwsze uruchomienie procedury
154:           	{
155:           		dtmo=1;
156:           		ktu=0;
157:           		iu=0;
158:           	}
159:           	if(*dt<min) *dt=min;
160:           	if(key=ExxPresKey(k,ky,_RDTOFSXL,ktu)) 
161:           	{
162:           		if(key==1)
163:           		{
164:           			iu=0;
165:           			ktu=5;
166:           			if(*dt>=max) *dt=min;
167:           			else
168:           			if(*dt+step<=max) *dt=*dt+step;
169:           		}
170:           		if(key==2) 
171:           		{
172:           			if (iu<=(_RDKRFSXL-1)*_VKRFSXL) iu++;
173:           			ktu=_RDKRFSXL-iu/_VKRFSXL;				//czas miedzy kolejnymi impulsami inkrementacji
174:           			if(*dt>=max) *dt=min;
175:           			else
176:           			if(*dt+step2<=max) *dt=*dt+step2;
177:           		}
178:           	}
179:           	else 
180:           	{
181:           		iu=0;
182:           		ktu=5;
183:           	}
184:           	if(*dt>max) *dt=min;
185:           	if(wrn)					//spelniony warunek wyjscia?
186:           	{
187:           		dtmo=0;
188:           		return 1;			//OK key?
189:           	}
190:           	return 0x00;
191:           }
192:           #endif
193:           /*---------------------------------------------------------------------------------*/
194:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
195:           //dt - wskaznik do modyfikowanego parametru
196:           //ovf - dla 1 inkrementacja/dekrementacja na okraglo
197:           //min - minimalna wartosc jaka moze przyjac parametr
198:           //max - maksymalna wartosc jaka moze przyjac parametr
199:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
200:           //step2 - krok z jakim docelowo odbywa sie inkrementacja przy wcisnietym przycisku (dla fst=1)
201:           //fst - aktywacja funkcji zwiekszania czestotliwosci kroków oraz zwiekszania ich amplitudy z poziomu step do step2 przy wcisnietym przycisku
202:           //ReadDataXONLI(RdPrt(S_KUP),&xxky[S_KUP],&param,&ov,max,1,stp,1);
203:           //ReadDataXONLD(RdPrt(S_KDW),&xxky[S_KDW],&param,&ov,min,1,stp,1);
204:           #if (_ENRDTOXLI!=0)
205:           //INKREMENTACJA
206:           unsigned char ReadDataXONLI(unsigned char k,volatile StPin *ky,unsigned int *dt,unsigned char *ovf,unsigned int max,const unsigned char step,const unsigned char step2,const unsigned char fst)
207:           {
208:           	static bit dtmo=0;
209:           	static unsigned char ktu,iu,pp,es2;
210:           	char key=0;
211:           
212:           	if(!dtmo) 						//pierwsze uruchomienie procedury
213:           	{
214:           		dtmo=1;
215:           		ktu=0;
216:           		iu=0;
217:           		es2=0;
218:           		pp=step;
219:           	}
220:           //-------
221:           	if(key=ExxPresKey(k,ky,_RDTOFSXLI,ktu)) 
222:           	{
223:           		if(key==1||((key==2)&&!fst))
224:           		{
225:           			iu=0;
226:           			ktu=5;
227:           			es2=0;
228:           			pp=step;
229:           			if((*dt+pp)>max) *ovf=1;
230:           			else *ovf=0;
231:           			if(*dt+pp<=max) *dt=*dt+pp;
232:           			else *dt=max;
233:           	
234:           		}
235:           		if(key==2&&fst) 
236:           		{
237:           			if (iu<=(_RDKRFSXLI-1)*_VKRFSXLI) iu++;
238:           			ktu=_RDKRFSXLI-iu/_VKRFSXLI;				//czas miedzy kolejnymi impulsami inkrementacji
239:           			if (iu>(_RDKRFSXLI-1)*_VKRFSXLI)			//przytrzymany przycisk przez dluzszy czas?
240:           			{
241:           				if(es2)
242:           				{
243:           					if(pp<step2) pp++;
244:           				}
245:           				else pp=step;
246:           				if((*dt%10)==0) es2=1;
247:           			}
248:           			else
249:           			{
250:           				es2=0;
251:           				pp=step;
252:           			}
253:           			if((*dt+pp)>max) *ovf=1;
254:           			else *ovf=0;
255:           			if(*dt+pp<=max) *dt=*dt+pp;
256:           			else *dt=max;
257:           		}
258:           		if(*dt>max) *dt=max;
259:           		return 1;
260:           	}
261:           	else 
262:           	{
263:           		iu=0;
264:           		ktu=5;
265:           		es2=0;
266:           		pp=step;
267:           	}
268:           	return 0x00;
269:           }
270:           #endif
271:           #if (_ENRDTOXLD!=0)
272:           //DEKREMENTACJA
273:           unsigned char ReadDataXONLD(unsigned char k,volatile StPin *ky,unsigned int *dt,unsigned char *ovf, unsigned int min,const unsigned char step,const unsigned char step2,const unsigned char fst)
274:           {
275:           	static bit dtmo=0;
276:           	static unsigned char ktu,iu,pp,es2;
277:           	char key=0;
278:           
279:           	if(!dtmo) 						//pierwsze uruchomienie procedury
280:           	{
281:           		dtmo=1;
282:           		ktu=0;
283:           		iu=0;
284:           		es2=0;
285:           		pp=step;
286:           	}
287:           //-------
288:           	if(key=ExxPresKey(k,ky,_RDTOFSXLD,ktu)) 
289:           	{
290:           		if(key==1||((key==2)&&!fst))
291:           		{
292:           			iu=0;
293:           			ktu=5;
294:           			es2=0;
295:           			pp=step;
296:           			if(!*dt||((*dt-pp)<min)) *ovf=1;
297:           			else *ovf=0;
298:           			if(*dt&&((*dt-pp)>min)) *dt=*dt-pp;
299:           			else *dt=min;
300:           		}
301:           		if(key==2&&fst)  
302:           		{
303:           			if (iu<=(_RDKRFSXLD-1)*_VKRFSXLD) iu++;
304:           			ktu=_RDKRFSXLD-iu/_VKRFSXLD;				//czas miedzy kolejnymi impulsami inkrementacji
305:           			if (iu>(_RDKRFSXLD-1)*_VKRFSXLD)
306:           			{
307:           				if(es2)
308:           				{
309:           					if(pp<step2) pp++;
310:           				}
311:           				else pp=step;
312:           				if((*dt%10)==0) es2=1;
313:           			}
314:           			else
315:           			{
316:           				es2=0;
317:           				pp=step;
318:           			}
319:           			if(!*dt||((*dt-pp)<min)) *ovf=1;
320:           			else *ovf=0;
321:           			if(*dt&&((*dt-pp)>min)) *dt=*dt-pp;
322:           			else *dt=min;
323:           		}
324:           		if(*dt<min) *dt=min;
325:           		return 1;
326:           	}
327:           	else 
328:           	{
329:           		iu=0;
330:           		ktu=5;
331:           		es2=0;
332:           		pp=step;
333:           	}
334:           	return 0x00;
335:           }
336:           #endif
337:           /*---------------------------------------------------------------------------------*/
338:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
339:           //dt - wskaznik do modyfikowanego parametru
340:           //min - minimalna wartosc jaka moze przyjac parametr
341:           //max - maksymalna wartosc jaka moze przyjac parametr
342:           //ovf - dla 1 inkrementacja/dekrementacja na okraglo
343:           //tid - dla 1 inkrementacja dla 0 dekrementacja
344:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
345:           //step2 - krok z jakim docelowo odbywa sie inkrementacja przy wcisnietym przycisku (dla fst=1)
346:           //fst - aktywacja funkcji zwiekszania czestotliwosci kroków oraz zwiekszania ich amplitudy z poziomu step do step2 przy wcisnietym przycisku
347:           //ReadDataXONLID(RdPrt(S_KDW),&xxky[S_KDW],param,&ov,0,min,max,1,stp,fst);
348:           #if (_ENRDTOXLID!=0)
349:           unsigned char ReadDataXONLID(unsigned char k,volatile StPin *ky,unsigned int *dt,unsigned char *ovf, unsigned char tid, unsigned int min, unsigned int max, const unsigned char step,const unsigned char step2,const unsigned char fst)
57C6  6F8D     MOVWF _PWMf_ENPWM2, BANKED
350:           {
351:           	static bit dtmo=0;
352:           	static unsigned char ktu,iu,pp,es2;
353:           	char key=0;
354:           
355:           	if(!dtmo) 						//pierwsze uruchomienie procedury
57C8  B001     BTFSC DtCOf_err_CO, 0, ACCESS
57CA  D005     BRA 0x57D6
356:           	{
357:           		dtmo=1;
57CC  8001     BSF DtCOf_err_CO, 0, ACCESS
358:           		ktu=0;
57CE  0101     MOVLB 0x1
57D0  6BBE     CLRF 0xBE, BANKED
359:           		iu=0;
57D2  6BBD     CLRF 0xBD, BANKED
360:           		es2=0;
57D4  D91E     RCALL PL790
361:           		pp=step;
362:           	}
363:           //-------
364:           	if(key=ExxPresKey(k,ky,_RDTOFSXLID,ktu)) 
57D6  C07C     MOVFF _PFNf_setKey, _PFNf_prn_in
57D8  F076     NOP
57DA  C07D     MOVFF _PFNf_set_aleg, _PFNf_prn_pg
57DC  F077     NOP
57DE  0E05     MOVLW 0x5
57E0  0100     MOVLB 0x0
57E2  6F78     MOVWF _PFNf_prn_pp, BANKED
57E4  C1BE     MOVFF ktu, _PFNf_prn_res
57E6  F079     NOP
57E8  518D     MOVF _PWMf_ENPWM2, W, BANKED
57EA  EC76     CALL 0x78EC, 0
57EC  F03C     NOP
57EE  6F8E     MOVWF _RSDT1f_NewLIDN, BANKED
57F0  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
57F2  E101     BNZ 0x57F6
57F4  D0AF     BRA 0x5954
365:           	{
366:           		if(key==1||((key==2)&&!fst))
57F6  058E     DECF _RSDT1f_NewLIDN, W, BANKED
57F8  E005     BZ 0x5804
57FA  0E02     MOVLW 0x2
57FC  198E     XORWF _RSDT1f_NewLIDN, W, BANKED
57FE  E133     BNZ 0x5866
5800  5188     MOVF _PFNf_toInit, W, BANKED
5802  E131     BNZ 0x5866
367:           		{
368:           			iu=0;
5804  D8E0     RCALL PL408
369:           			ktu=5;
370:           			es2=0;
371:           			pp=step;
372:           			if(!tid)
5806  0100     MOVLB 0x0
5808  5181     MOVF _PFNf_set_ncw, W, BANKED
580A  E118     BNZ 0x583C
373:           			{
374:           				if(!*dt||((*dt-pp)<min)) *ovf=1;
580C  D8B1     RCALL PL32
580E  50DE     MOVF POSTINC2, W, ACCESS
5810  10DE     IORWF POSTINC2, W, ACCESS
5812  E003     BZ 0x581A
5814  D8A0     RCALL PL26
5816  D8E9     RCALL PL650
5818  E202     BC 0x581E
581A  D8CA     RCALL PL290
581C  D001     BRA 0x5820
375:           				else *ovf=0;
581E  D8CE     RCALL PL406
376:           				if(*dt&&((*dt-pp)>min)) *dt=*dt-pp;
5820  D8A7     RCALL PL32
5822  50DE     MOVF POSTINC2, W, ACCESS
5824  10DE     IORWF POSTINC2, W, ACCESS
5826  E007     BZ 0x5836
5828  D896     RCALL PL26
582A  D8E4     RCALL PL722
582C  E204     BC 0x5836
582E  D893     RCALL PL26
5830  D89F     RCALL PL32
5832  D8EA     RCALL PL734
5834  D018     BRA 0x5866
377:           				else *dt=min;
5836  D89C     RCALL PL32
5838  D8CE     RCALL PL512
583A  D015     BRA 0x5866
378:           			}
379:           			else
380:           			{
381:           				if((*dt+pp)>max) *ovf=1;
583C  D899     RCALL PL32
583E  CFDE     MOVFF POSTINC2, _PFNf_trbECO
5840  F089     NOP
5842  D89B     RCALL PL54
5844  E202     BC 0x584A
5846  D8B4     RCALL PL290
5848  D001     BRA 0x584C
382:           				else *ovf=0;
584A  D8B8     RCALL PL406
383:           				if(*dt+pp<=max) *dt=*dt+pp;
584C  D891     RCALL PL32
584E  CFDE     MOVFF POSTINC2, _PFNf_trbECO
5850  F089     NOP
5852  D893     RCALL PL54
5854  E306     BNC 0x5862
5856  D88C     RCALL PL32
5858  D8A6     RCALL PL268
585A  D89D     RCALL PL74
585C  D889     RCALL PL32
585E  D8CF     RCALL PL728
5860  D002     BRA 0x5866
384:           				else *dt=max;
5862  D886     RCALL PL32
5864  D8BD     RCALL PL536
385:           			}
386:           		}
387:           		if(key==2&&fst)  
5866  0E02     MOVLW 0x2
5868  198E     XORWF _RSDT1f_NewLIDN, W, BANKED
586A  E163     BNZ 0x5932
586C  5188     MOVF _PFNf_toInit, W, BANKED
586E  E061     BZ 0x5932
388:           		{
389:           			if (iu<=(_RDKRFSXLID-1)*_VKRFSXLID) iu++;
5870  0E0D     MOVLW 0xD
5872  0101     MOVLB 0x1
5874  61BD     CPFSLT 0xBD, BANKED
5876  D001     BRA 0x587A
5878  2BBD     INCF 0xBD, F, BANKED
390:           			ktu=_RDKRFSXLID-iu/_VKRFSXLID;				//czas miedzy kolejnymi impulsami inkrementacji
587A  0E03     MOVLW 0x3
587C  0100     MOVLB 0x0
587E  6F74     MOVWF _PFNf_prODP, BANKED
5880  0101     MOVLB 0x1
5882  51BD     MOVF 0xBD, W, BANKED
5884  EC62     CALL 0xB4C4, 0
5886  F05A     NOP
5888  6F89     MOVWF _PFNf_trbECO, BANKED
588A  5189     MOVF _PFNf_trbECO, W, BANKED
588C  0805     SUBLW 0x5
588E  0101     MOVLB 0x1
5890  6FBE     MOVWF 0xBE, BANKED
391:           			if (iu>(_RDKRFSXLID-1)*_VKRFSXLID)
5892  0E0C     MOVLW 0xC
5894  65BD     CPFSGT 0xBD, BANKED
5896  D01C     BRA 0x58D0
392:           			{
393:           				if(es2)
5898  51BC     MOVF 0xBC, W, BANKED
589A  E006     BZ 0x58A8
394:           				{
395:           					if(pp<step2) pp++;
589C  0100     MOVLB 0x0
589E  5187     MOVF _PFNf_tmpZW, W, BANKED
58A0  5DDC     SUBWF pp, W, BANKED
58A2  E204     BC 0x58AC
58A4  2BDC     INCF pp, F, BANKED
58A6  D002     BRA 0x58AC
396:           				}
397:           				else pp=step;
58A8  C086     MOVFF _PFNf_timZAS, pp
58AA  F0DC     NOP
398:           				if((*dt%10)==0) es2=1;
58AC  D861     RCALL PL32
58AE  CFDE     MOVFF POSTINC2, _PFNf_prODP
58B0  F074     NOP
58B2  CFDD     MOVFF POSTDEC2, _PFNf_prn_cs
58B4  F075     NOP
58B6  0100     MOVLB 0x0
58B8  6B77     CLRF _PFNf_prn_pg, BANKED
58BA  0E0A     MOVLW 0xA
58BC  6F76     MOVWF _PFNf_prn_in, BANKED
58BE  ECB1     CALL 0xB162, 0
58C0  F058     NOP
58C2  5174     MOVF _PFNf_prODP, W, BANKED
58C4  1175     IORWF _PFNf_prn_cs, W, BANKED
58C6  E105     BNZ 0x58D2
58C8  0E01     MOVLW 0x1
58CA  0101     MOVLB 0x1
58CC  6FBC     MOVWF 0xBC, BANKED
58CE  D001     BRA 0x58D2
399:           			}
400:           			else
58D0  D8A0     RCALL PL790
401:           			{
402:           				es2=0;
403:           				pp=step;
404:           			}
405:           			if(!tid)
58D2  0100     MOVLB 0x0
58D4  5181     MOVF _PFNf_set_ncw, W, BANKED
58D6  E118     BNZ 0x5908
58D8  D84B     RCALL PL32
406:           			{
407:           				if(!*dt||((*dt-pp)<min)) *ovf=1;
58DA  50DE     MOVF POSTINC2, W, ACCESS
58DC  10DE     IORWF POSTINC2, W, ACCESS
58DE  E003     BZ 0x58E6
58E0  D83A     RCALL PL26
58E2  D883     RCALL PL650
58E4  E202     BC 0x58EA
58E6  D864     RCALL PL290
58E8  D001     BRA 0x58EC
408:           				else *ovf=0;
58EA  D868     RCALL PL406
409:           				if(*dt&&((*dt-pp)>min)) *dt=*dt-pp;
58EC  D841     RCALL PL32
58EE  50DE     MOVF POSTINC2, W, ACCESS
58F0  10DE     IORWF POSTINC2, W, ACCESS
58F2  E007     BZ 0x5902
58F4  D830     RCALL PL26
58F6  D87E     RCALL PL722
58F8  E204     BC 0x5902
58FA  D82D     RCALL PL26
58FC  D839     RCALL PL32
58FE  D884     RCALL PL734
5900  D018     BRA 0x5932
410:           				else *dt=min;
5902  D836     RCALL PL32
5904  D868     RCALL PL512
5906  D015     BRA 0x5932
411:           			}
412:           			else
413:           			{
414:           				if((*dt+pp)>max) *ovf=1;
5908  D833     RCALL PL32
590A  CFDE     MOVFF POSTINC2, _PFNf_trbECO
590C  F089     NOP
590E  D835     RCALL PL54
5910  E202     BC 0x5916
5912  D84E     RCALL PL290
5914  D001     BRA 0x5918
415:           				else *ovf=0;
5916  D852     RCALL PL406
416:           				if(*dt+pp<=max) *dt=*dt+pp;
5918  D82B     RCALL PL32
591A  CFDE     MOVFF POSTINC2, _PFNf_trbECO
591C  F089     NOP
591E  D82D     RCALL PL54
5920  E306     BNC 0x592E
5922  D826     RCALL PL32
5924  D840     RCALL PL268
5926  D837     RCALL PL74
5928  D823     RCALL PL32
592A  D869     RCALL PL728
592C  D002     BRA 0x5932
417:           				else *dt=max;
592E  D820     RCALL PL32
5930  D857     RCALL PL536
418:           			}
419:           
420:           		}
421:           		if(*dt<min) *dt=min;
5932  D81E     RCALL PL32
5934  5182     MOVF _PFNf_str_nco, W, BANKED
5936  5CDE     SUBWF POSTINC2, W, ACCESS
5938  5183     MOVF _PFNf_str_ncw, W, BANKED
593A  58DE     SUBWFB POSTINC2, W, ACCESS
593C  E202     BC 0x5942
593E  D818     RCALL PL32
5940  D84A     RCALL PL512
422:           		if(*dt>max) *dt=max;
5942  D816     RCALL PL32
5944  50DE     MOVF POSTINC2, W, ACCESS
5946  5D84     SUBWF _PFNf_tdzCO, W, BANKED
5948  50DE     MOVF POSTINC2, W, ACCESS
594A  5985     SUBWFB _PFNf_tdzCW, W, BANKED
594C  B0D8     BTFSC STATUS, 0, ACCESS
594E  0012     RETURN 0
5950  D80F     RCALL PL32
5952  D046     BRA PL536
423:           		return 1;
424:           	}
425:           	else 
5954  D038     BRA PL408
426:           	{
427:           		iu=0;
428:           		ktu=5;
429:           		es2=0;
430:           		pp=step;
431:           	}
432:           	return 0x00;
433:           }
434:           #endif
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/pwron.c  --------------------
1:             /*pwron.c*/
2:             //#include <pic18.h>
3:             #include <xc.h>
4:             #include "global.h"			//parametry globalne
5:             #include "pwron.h"			//parametry lokalne
6:             
7:             //Procedura oparta o zegar RTdS(_RTON) ktory musi byc zadeklarowany w pliku rtimer.c/h
8:             void PwrOnDelay(void)
9:             {
10:            	StartRTdS(_RTON);
BDB6  0E00     MOVLW 0x0
BDB8  EC55     CALL 0xBCAA, 0
BDBA  F05E     NOP
11:            	while(RTdS(_RTON)<_TPWRON)
BDBC  D001     BRA 0xBDC0
BDC0  0E00     MOVLW 0x0
12:            	{
13:            		CLRWDT();
BDBE  0004     CLRWDT
BDC0  0E00     MOVLW 0x0
BDC2  EC8B     CALL 0xBF16, 0
BDC4  F05F     NOP
BDC6  6F75     MOVWF _PFNf_prn_cs, BANKED
BDC8  0E0E     MOVLW 0xE
BDCA  6575     CPFSGT _PFNf_prn_cs, BANKED
BDCC  D7F8     BRA 0xBDBE
BDCE  0C0E     RETLW 0xE
14:            	};
15:            					
16:            }
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/pwm2.c  ---------------------
1:             /*pwm2.c*/
2:             //Procedury zwiazane z modulem CCP (tryb pracy = PWM)
3:             /*---------------------------------------------------------------------------------*/
4:             //#include <pic18.h>
5:             #include <xc.h>
6:             #include "global.h"					//parametry globalne
7:             #include "pwm2.h"					//parametry lokalne
8:             
9:             volatile DtPWM PWM;							//czeste operacje na danych
10:            /*---------------------------------------------------------------------------------*/
11:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
12:            void WritePWM2(const unsigned char tpwm);
13:            void InitPWM2(void)
14:            {
15:            //pwm2 (LCD)
16:            	CCP2CON=0;						//reset CCP1 module
B894  6A65     CLRF CCP2CON, ACCESS
17:            	CCPR2L=0;
B896  6A66     CLRF CCPR2, ACCESS
18:            	CCPR2H=0;
B898  6A67     CLRF CCPR2H, ACCESS
19:            	CCP2CON=0b00001100;				//set PWM mode
B89A  0E0C     MOVLW 0xC
B89C  6E65     MOVWF CCP2CON, ACCESS
20:                    CCP2IP=0;
B89E  94A5     BCF IPR3, 2, ACCESS
21:            //timer2
22:            	TMR2=0;
B8A0  6ACC     CLRF TMR2, ACCESS
23:            	T2CON=_WT2CON;					//new timer2 prescale value
B8A2  0E02     MOVLW 0x2
B8A4  6ECA     MOVWF T2CON, ACCESS
24:            	PR2=_WPR2;					//PWM period
B8A6  0E7C     MOVLW 0x7C
B8A8  6ECB     MOVWF PR2, ACCESS
25:                    TMR2IP=0;					//low priority interrupt
B8AA  929F     BCF IPR1, 1, ACCESS
26:            	TMR2IE=1;					//enable interrupt timer2
B8AC  829D     BSF PIE1, 1, ACCESS
27:            	TMR2ON=1;					//start timer2
B8AE  84CA     BSF T2CON, 2, ACCESS
28:            									//nalezy jeszcze ustawic pin CCP1 jako wyjscie
29:            
30:            #if(_WPR2<0x40)
31:            	#if(((_WPR2+1)<<2)<0xFF)
32:            		PWM.HIPWM=(_WPR2+1)<<2;			//gorna bezwgledna granica wypelnienia
33:            	#else
34:            		PWM.HIPWM=0xFF;					//gorna bezwgledna granica wypelnienia
35:            	#endif
36:            #endif
37:            #if(_WPR2>0x40 && _WPR2<0x80)
38:            	#if(((_WPR2+1)<<1)<0xFF)
39:            		PWM.HIPWM=(_WPR2+1)<<1;			//gorna bezwgledna granica wypelnienia
B8B0  0EFA     MOVLW 0xFA
B8B2  6FD0     MOVWF 0xD0, BANKED
40:            	#else
41:            		PWM.HIPWM=0xFF;					//gorna bezwgledna granica wypelnienia
42:            	#endif
43:            #endif
44:            #if(_WPR2>0x80)
45:            	#if((_WPR2+1)<0xFF)
46:            		PWM.HIPWM=(_WPR2+1);			//gorna bezwgledna granica wypelnienia		
47:            	#else
48:            		PWM.HIPWM=0xFF;					//gorna bezwgledna granica wypelnienia
49:            	#endif
50:            #endif
51:            
52:            	PWM.BufPWM2=0;
B8B4  6BCE     CLRF PWM, BANKED
53:            	PWM.NewPWM2=0;						
B8B6  6BCF     CLRF 0xCF, BANKED
54:            	WritePWM2(PWM.HIPWM);
B8B8  51D0     MOVF 0xD0, W, BANKED
B8BA  EFBC     GOTO 0xC178
B8BC  F060     NOP
55:            }
56:            /*---------------------------------------------------------------------------------*/
57:            /*---------------------------------------------------------------------------------*/
58:            /*---------------------------------------------------------------------------------*/
59:            //Zapisz wartosc do PWM2
60:            void WritePWM2(const unsigned char tpwm)
C178  6F74     MOVWF _PFNf_prODP, BANKED
61:            {
62:            	PWMf_ENPWM2=0;
C17A  9A11     BCF PFNf_zima, 5, ACCESS
63:            	PWM.BufPWM2=tpwm;
C17C  C074     MOVFF _PFNf_prODP, PWM
C17E  F0CE     NOP
64:            	PWMf_ENPWM2=1;
C180  8A11     BSF PFNf_zima, 5, ACCESS
65:            }
C182  0012     RETURN 0
66:            /*---------------------------------------------------------------------------------*/
67:            /*---------------------------------------------------------------------------------*/
68:            /*-----------------------------PROTECTED DATA--------------------------------------*/
69:            /*---------------------------------------------------------------------------------*/
70:            //Modyfikacja stanu wyjscia PWM
71:            //UWAGA - procedura wykonywana w przerwaniu
72:            /*if((TMR2IF)&&(TMR2IE))
73:            	{
74:            		TMR2IF=0;
75:            		IntPwm();			//nowe wypelnienie PWM1
76:            		IntPwm2();			//nowe wypelnienie PWM2
77:            	}*/
78:            //---------------------------------------
79:            //PWM2 - pompa
80:            void IntPWM2(void)
81:            {
82:            	if(PWMf_ENPWM2)					//nowa wartosc PWM gotowa do pobrania?
BA54  BA11     BTFSC PFNf_zima, 5, ACCESS
83:            	{
84:            		PWM.NewPWM2=PWM.BufPWM2;
BA56  C0CE     MOVFF PWM, 0xCF
BA58  F0CF     NOP
85:            	}
86:            	if(PWM.NewPWM2>PWM.HIPWM) PWM.NewPWM2=PWM.HIPWM;
BA5A  0100     MOVLB 0x0
BA5C  51CF     MOVF 0xCF, W, BANKED
BA5E  5DD0     SUBWF 0xD0, W, BANKED
BA60  E202     BC 0xBA66
BA62  C0D0     MOVFF 0xD0, 0xCF
BA64  F0CF     NOP
87:            #if _NEG_PWM2==1
88:            	PWM.NewPWM2=~PWM.NewPWM2;
89:            #endif	
90:            #if _PSHIFT>=2
91:            	DC2B1=((PWM.NewPWM2&0b00000010)>0)?1:0;
92:            	DC2B0=((PWM.NewPWM2&0b00000001)>0)?1:0;
93:            	CCPR2L=PWM.NewPWM2>>2;
94:            #endif
95:            #if _PSHIFT==1
96:            	DC2B1=((PWM.NewPWM2&0b00000001)>0)?1:0;
BA66  A1CF     BTFSS 0xCF, 0, BANKED
BA68  D002     BRA 0xBA6E
BA6A  8A65     BSF CCP2CON, 5, ACCESS
BA6C  D001     BRA 0xBA70
BA6E  9A65     BCF CCP2CON, 5, ACCESS
97:            	DC2B0=0;
BA70  9865     BCF CCP2CON, 4, ACCESS
98:            	CCPR2L=PWM.NewPWM2>>1;
BA72  0100     MOVLB 0x0
BA74  90D8     BCF STATUS, 0, ACCESS
BA76  31CF     RRCF 0xCF, W, BANKED
BA78  6E66     MOVWF CCPR2, ACCESS
99:            #endif
100:           #if _PSHIFT==0
101:           	DC2B1=0;
102:           	DC2B0=0;
103:           	CCPR2L=PWM.NewPWM2;
104:           #endif
105:           }
BA7A  0012     RETURN 0
106:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/print.c  --------------------
1:             /*---------------------------------------------------------------------------------*/
2:             /*print.c*/
3:             /*Funkcje zapisu danych do 2 segmentowego wyswietlacza typu LED*/
4:             /*w oparciu o procedury obslugi wyswietlacza zawarte w pliku wsw.c*/
5:             /*Sposob reprezentacji danych - ITALY*/
6:             /*---------------------------------------------------------------------------------*/
7:             //#include <pic18.h>
8:             #include <xc.h>
9:             #include "global.h"				//parametry globalne
10:            #include "print.h"				//parametry lokalne
11:            #include "main.tp.h"
12:            
13:            extern DataPFN PFN;
14:            extern volatile unsigned char x;
15:            //wsw.c
16:            extern volatile WPack PWD[];		//tablica priorytetow wyswietlania PWD[n] (n=0 - najwyzszy priorytet)
17:            extern volatile WPack DWD[];		//tablica danych modyfikowanych dynamicznie wystepujacych wylacznie w kolejkach
18:            extern volatile WDyn DynData;	//bufor wspolny wyswietlania
19:            
20:            extern const unsigned char Znak[];
21:            extern volatile WMark KMark[];;
22:            //---------------------------------------------------------
23:            //---------------------------------------------------------
24:            //Funkcje wyswietlania wg waznosci.
25:            //ClsScr
26:            //-PrintErr
27:            //--PrintPR,PrintWPR
28:            //---PrintNstCW
29:            //----PrintNstCO
30:            //----PrintNstKT
31:            //-----PrintMsg
32:            //------PrintTDZ
33:            //-------PrintOFF
34:            //--------PrintCS
35:            //---------PrintCW
36:            //----------PrintCO
37:            
38:            //---------------------------------------------------------
39:            //---------------------------------------------------------
40:            //Deaktywacja (wygaszenie) wyswietlacza
41:            void ClsScr(void)
42:            {
43:            	WswOff();
44:            	//UpdateWSW();
45:            }
46:            //Aktywacja wyswietlacza, ustawienie wszystkich kolejek na pozycji pierwszej
47:            void EndClsScr(void)
48:            {
49:            	AllKolToFirstPoz();
50:            	WswOn();
51:            	//UpdateWSW();
52:            }
53:            //---------------------------------------------------------
54:            //---------------------------------------------------------
55:            //wyswietla migajacy/staly kod bledu
56:            //lkod - kod led oznaczenia literowego bledu
57:            //nkod - wartosc liczbowa bledu
58:            //pls - dla 1 migajacy kod, dla 0 kod sta³y
59:            /*
60:            void PrintErr(const unsigned char lkod,unsigned char nkod, const unsigned char pls, const unsigned char res)
61:            {
62:            	unsigned int fk,fl,fm;
63:            	fl=(!res)?0:_KZ_RES;
64:            	fk=(res)?0:_KZ_RES;
65:            	fm=(fl)?tSDID:0;
66:            #if LCD4D==0
67:            	if(nkod>0xf) nkod=0xf;
68:            	SetData(&(DWD[0].Dt),lkod,Znak[nkod]);
69:            	if(!pls)
70:            	{
71:            		SetData(&&(DWD[1].Dt),lkod,Znak[nkod]);
72:            		SetStatus(&(DWD[0].St),tLED|fm|tRDID,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_DCO|_KZ_PLC|_KZ_BAR);					//kod bledu
73:            		SetStatus(&(DWD[1].St),tLED|fm|tRDID,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_DCO|_KZ_PLC|_KZ_BAR);
74:            	}
75:            	else
76:            	{
77:            		SetData(&&(DWD[1].Dt),BLACK,BLACK);
78:            		SetStatus(&(DWD[0].St),tLED|tSDID|tRDID,tALL,fl|_KZ_SRV,fk|_KZ_TCO|_KZ_BAR);//_KZ_TCO|_KZ_DCO|_KZ_BAR);					//kod bledu
79:            		SetStatus(&(DWD[1].St),tLED|tSDID|tRDID,tALL,_KZ_SRV,fk|fl|_KZ_TCO|_KZ_BAR);//_KZ_TCO|_KZ_DCO|_KZ_BAR|_KZ_RES);
80:            	}
81:            #else
82:            	SetData(&(DWD[0].Dt2),BLACK,lkod);
83:            	SetData(&(DWD[0].Dt),0,nkod);
84:            
85:            	if(!pls)
86:            	{
87:            		SetStatus(&(DWD[0].St),tDEC|fm|tRDID|tFOCUS,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);	
88:            		SetStatus(&(DWD[0].St2),tLED|fm|tRDID|tFOCUS,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
89:            		SetData(&(DWD[1].Dt2),BLACK,lkod);
90:            		SetStatus(&(DWD[1].St2),tLED|fm|tRDID|tFOCUS,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
91:            		SetData(&(DWD[1].Dt),0,nkod);
92:            		SetStatus(&(DWD[1].St),tDEC|fm|tRDID|tFOCUS,tALL,fl,fk|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
93:            	}
94:            	else
95:            	{
96:            		SetStatus(&(DWD[0].St),tDEC|tSDID|tRDID|tFOCUS,tALL,fl|_KZ_SRV,fk|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);	
97:            		SetStatus(&(DWD[0].St2),tLED|tSDID|tRDID|tFOCUS,tALL,fl|_KZ_SRV,fk|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
98:            		SetData(&(DWD[1].Dt2),BLACK,BLACK);
99:            		SetStatus(&(DWD[1].St2),tLED|tSDID|tRDID|tFOCUS,tALL,_KZ_SRV,fk|fl|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_RES|_KZ_PGD);
100:           		SetData(&(DWD[1].Dt),BLACK,BLACK);
101:           		SetStatus(&(DWD[1].St),tLED|tSDID|tRDID|tFOCUS,tALL,_KZ_SRV,fk|fl|_KZ_TCO|_KZ_TCW|_KZ_BAR);//_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_RES|_KZ_PGD);
102:           	}
103:           #endif
104:           	SetPoz(_KL_ERR,0);
105:           	SetPoz(_KL_ERR,1);
106:           }*/
107:           //usuwa migajacy kod bledu
108:           void EndErr(void)
109:           {
110:           	ResetKol(_KL_MSG);
C184  0E02     MOVLW 0x2
C186  EC0F     CALL 0xBE1E, 0
C188  F05F     NOP
111:           	ResetKol(_KL_ERR);
C18A  0E00     MOVLW 0x0
C18C  EF0F     GOTO 0xBE1E
C18E  F05F     NOP
112:           }
113:           //---------------------------------------------------------
114:           //---------------------------------------------------------
115:           //wyswietla migajacy kod procedury awaryjnej naprzemiennie z temp. lub cisnieniem
116:           //id - 0 - kod error, 4 - kod message
117:           //lkod - kod led oznaczenia literowego bledu
118:           //nkod - wartosc liczbowa bledu
119:           //tm - dla 1 wyswietla naprzemiennie z temp.
120:           //cs - dla 1 wyswietla naprzemiennie z cisnieniem.
121:           //dla cs=0,tm=0 wyswietla migajacy kod z migajacym znakiem klucza
122:           //dla cs=1,tm=1 wyswietla staly kod bez znaku klucza
123:           void PrintErrMsg(const unsigned char id, const unsigned char lkod,unsigned char nkod,unsigned char tm,unsigned char cs, unsigned char res)
489C  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
124:           {
125:           	unsigned int fk,fl,gk,gl,fm;
126:           
127:           
128:           	fk=(tm&&cs)?_KZ_SRV:0;
489E  0100     MOVLB 0x0
48A0  5180     MOVF _PFNf_set_nco, W, BANKED
48A2  E002     BZ 0x48A8
48A4  5181     MOVF _PFNf_set_ncw, W, BANKED
48A6  E103     BNZ 0x48AE
48A8  6B85     CLRF _PFNf_tdzCW, BANKED
48AA  6B86     CLRF _PFNf_timZAS, BANKED
48AC  D004     BRA 0x48B6
48AE  0E00     MOVLW 0x0
48B0  6F86     MOVWF _PFNf_timZAS, BANKED
48B2  0E04     MOVLW 0x4
48B4  6F85     MOVWF _PFNf_tdzCW, BANKED
129:           	fl=(tm&&cs)?0:_KZ_SRV;
48B6  5180     MOVF _PFNf_set_nco, W, BANKED
48B8  E002     BZ 0x48BE
48BA  5181     MOVF _PFNf_set_ncw, W, BANKED
48BC  E105     BNZ 0x48C8
48BE  0E00     MOVLW 0x0
48C0  6F8C     MOVWF _PFNf_zima, BANKED
48C2  0E04     MOVLW 0x4
48C4  6F8B     MOVWF _PFNf_zcfm, BANKED
48C6  D002     BRA 0x48CC
48C8  6B8B     CLRF _PFNf_zcfm, BANKED
48CA  6B8C     CLRF _PFNf_zima, BANKED
130:           
131:           	gl=(!res)?0:_KZ_RES;
48CC  5182     MOVF _PFNf_str_nco, W, BANKED
48CE  E005     BZ 0x48DA
48D0  0E00     MOVLW 0x0
48D2  6F8E     MOVWF _RSDT1f_NewLIDN, BANKED
48D4  0E08     MOVLW 0x8
48D6  6F8D     MOVWF _PWMf_ENPWM2, BANKED
48D8  D002     BRA 0x48DE
48DA  6B8D     CLRF _PWMf_ENPWM2, BANKED
48DC  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
132:           	gk=(res)?0:_KZ_RES;
48DE  5182     MOVF _PFNf_str_nco, W, BANKED
48E0  E104     BNZ 0x48EA
48E2  6B88     CLRF _PFNf_toInit, BANKED
48E4  0E08     MOVLW 0x8
48E6  6F87     MOVWF _PFNf_tmpZW, BANKED
48E8  D002     BRA 0x48EE
48EA  6B87     CLRF _PFNf_tmpZW, BANKED
48EC  6B88     CLRF _PFNf_toInit, BANKED
133:           
134:           	fm=(fl||gl)?tSDID:0;
48EE  518B     MOVF _PFNf_zcfm, W, BANKED
48F0  118C     IORWF _PFNf_zima, W, BANKED
48F2  E106     BNZ 0x4900
48F4  518D     MOVF _PWMf_ENPWM2, W, BANKED
48F6  118E     IORWF _RSDT1f_NewLIDN, W, BANKED
48F8  E103     BNZ 0x4900
48FA  6B89     CLRF _PFNf_trbECO, BANKED
48FC  6B8A     CLRF _PFNf_vnt, BANKED
48FE  D003     BRA 0x4906
4900  6B8A     CLRF _PFNf_vnt, BANKED
4902  0E20     MOVLW 0x20
4904  6F89     MOVWF _PFNf_trbECO, BANKED
135:           
136:           #if LCD4D==0
137:           	if(nkod>0xf) nkod=0xf;
138:           	SetData(&(DWD[id].Dt),lkod,Znak[nkod]);
139:           	SetStatus(&(DWD[id].St),tLED|fm|tRDID,tALL,fl|gl,fk|gk|_KZ_TCO|_KZ_BAR);
140:           
141:           	if(tm)		//naprzemiennie z temperatura
142:           	{
143:           		if(!PFNf_fL3)		//aktywna blokada L3?
144:           		{
145:           			if(!PFNf_errCO&&!PFNf_oflato)
146:           			{
147:           				SetData(&(DWD[id+1].Dt),0,PFN.CO);
148:           				SetStatus(&(DWD[id+1].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_RES|_KZ_SRV|_KZ_BAR);
149:           			}
150:           			else
151:           			{
152:           				SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_BAR);
153:           				if(!PFNf_oflato) SetData(&(DWD[id+1].Dt),KRESKA,KRESKA);
154:           				else SetData(&(DWD[id+1].Dt),BLACK,BLACK);
155:           			}
156:           		}
157:           		else
158:           		{
159:           			SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_BAR|_KZ_TCO);
160:           			SetData(&(DWD[id+1].Dt),led_L,led_3);
161:           		}
162:           	}
163:           	else			
164:           	if(cs)		//naprzemiennie z cisnieniem
165:           	{
166:           		if(!PFNf_errCS&&!PFNf_fnoCS)
167:           		{
168:           			SetData(&(DWD[id+1].Dt),0,PFN.CS);
169:           			SetStatus(&(DWD[id+1].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_RES|_KZ_SRV|_KZ_TCO);
170:           		}
171:           		else
172:           		{
173:           			SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_BAR);
174:           			SetData(&(DWD[id+1].Dt),KRESKA,KRESKA);
175:           		}
176:           	}
177:           	else
178:           	{
179:           		SetStatus(&(DWD[id+1].St),tLED|tRDID,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_BAR);
180:           		if(tm==1&&cs==1)//staly kod bez znaku klucza
181:           		{
182:           			SetData(&(DWD[id+1].Dt),lkod,Znak[nkod]);
183:           		}
184:           		else
185:           		if(!tm&&!cs)	//migajacy kod ze znakiem klucza
186:           		{
187:           			SetData(&(DWD[id+1].Dt),BLACK,BLACK);
188:           		}
189:           	}	
190:           #else
191:           	SetData(&(DWD[id].Dt2),BLACK,lkod);		//kod E
4906  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
4908  0D10     MULLW 0x10
490A  0E54     MOVLW 0x54
490C  24F3     ADDWF PROD, W, ACCESS
490E  6F74     MOVWF _PFNf_prODP, BANKED
4910  0E04     MOVLW 0x4
4912  20F4     ADDWFC PRODH, W, ACCESS
4914  6F75     MOVWF _PFNf_prn_cs, BANKED
4916  6B76     CLRF _PFNf_prn_in, BANKED
4918  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
491A  F077     NOP
491C  ECBF     CALL 0xBD7E, 0
491E  F05E     NOP
192:           	SetData(&(DWD[id].Dt),0,nkod);			//nr bledu
4920  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
4922  0D10     MULLW 0x10
4924  0E52     MOVLW 0x52
4926  24F3     ADDWF PROD, W, ACCESS
4928  6F74     MOVWF _PFNf_prODP, BANKED
492A  0E04     MOVLW 0x4
492C  20F4     ADDWFC PRODH, W, ACCESS
492E  6F75     MOVWF _PFNf_prn_cs, BANKED
4930  D969     RCALL PL808
4932  ECBF     CALL 0xBD7E, 0
4934  F05E     NOP
193:           	SetStatus(&(DWD[id].St2),tLED|fm|tRDID|tFOCUS,tALL,fl|gl,fk|gk|_KZ_TCO|_KZ_TCW|_KZ_BAR);
4936  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
4938  0D10     MULLW 0x10
493A  0E56     MOVLW 0x56
493C  24F3     ADDWF PROD, W, ACCESS
493E  6F74     MOVWF _PFNf_prODP, BANKED
4940  0E04     MOVLW 0x4
4942  D950     RCALL PL566
4944  0E80     MOVLW 0x80
4946  D938     RCALL PL266
4948  EC3E     CALL 0x627C, 0
494A  F031     NOP
194:           	SetStatus(&(DWD[id].St),tDEC|fm|tRDID|tFOCUS,tALL,fl|gl,fk|gk|_KZ_TCO|_KZ_TCW|_KZ_BAR);
494C  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
494E  0D10     MULLW 0x10
4950  0E4C     MOVLW 0x4C
4952  24F3     ADDWF PROD, W, ACCESS
4954  6F74     MOVWF _PFNf_prODP, BANKED
4956  0E04     MOVLW 0x4
4958  D945     RCALL PL566
495A  0EC0     MOVLW 0xC0
495C  D92D     RCALL PL266
495E  EC3E     CALL 0x627C, 0
4960  F031     NOP
195:           	if((tm&&!cs)||(cs&&!tm))
4962  5180     MOVF _PFNf_set_nco, W, BANKED
4964  E002     BZ 0x496A
4966  5181     MOVF _PFNf_set_ncw, W, BANKED
4968  E006     BZ 0x4976
496A  5181     MOVF _PFNf_set_ncw, W, BANKED
496C  E101     BNZ 0x4970
496E  D0A1     BRA 0x4AB2
4970  5180     MOVF _PFNf_set_nco, W, BANKED
4972  E001     BZ 0x4976
4974  D09E     BRA 0x4AB2
196:           	{	
197:           		if(!PFNf_off)
4976  AA0C     BTFSS PFNf_off, 5, ACCESS
198:           		{
199:           			if(PFNf_obgCW)
4978  A80C     BTFSS PFNf_off, 4, ACCESS
497A  D026     BRA 0x49C8
200:           			{
201:           				if(!PFNf_errCW)
497C  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
497E  D011     BRA 0x49A2
202:           				{
203:           					SetStatus(&(DWD[id+1].St2),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCW,_KZ_RES|_KZ_SRV);
4980  D8E5     RCALL PL2
4982  D90D     RCALL PL222
4984  D92C     RCALL PL508
4986  D905     RCALL PL120
4988  0E20     MOVLW 0x20
498A  6F7A     MOVWF _PFNf_res, BANKED
498C  0E0C     MOVLW 0xC
498E  6F7B     MOVWF _PFNf_rozruch, BANKED
4990  EC3E     CALL 0x627C, 0
4992  F031     NOP
4994  D8DB     RCALL PL2
204:           					SetData(&(DWD[id+1].Dt2),0,PFN.CW);
4996  D908     RCALL PL262
4998  C1D9     MOVFF 0x1D9, _PFNf_prn_pg
499A  F077     NOP
499C  ECBF     CALL 0xBD7E, 0
499E  F05E     NOP
205:           				}
49A0  D01B     BRA 0x49D8
206:           				else
207:           				{
208:           					SetStatus(&(DWD[id+1].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCW);
49A2  D8D4     RCALL PL2
49A4  D8FC     RCALL PL222
49A6  D8E6     RCALL __end_ofPL6
49A8  D8DE     RCALL PL6
49AA  0E2C     MOVLW 0x2C
49AC  6F7B     MOVWF _PFNf_rozruch, BANKED
49AE  EC3E     CALL 0x627C, 0
49B0  F031     NOP
49B2  D8CC     RCALL PL2
209:           					SetData(&(DWD[id+1].Dt2),KRESKA,KRESKA);
49B4  0E64     MOVLW 0x64
49B6  2583     ADDWF _PFNf_str_ncw, W, BANKED
49B8  6F74     MOVWF _PFNf_prODP, BANKED
49BA  0E04     MOVLW 0x4
49BC  2184     ADDWFC _PFNf_tdzCO, W, BANKED
49BE  EC8E     CALL 0x9B1C, 0
49C0  F04D     NOP
49C2  ECBF     CALL 0xBD7E, 0
49C4  F05E     NOP
49C6  D008     BRA 0x49D8
210:           				}
211:           			}
212:           			else
213:           			{
214:           					SetStatus(&(DWD[id+1].St2),tWYGAS|tRDID,tALL,0,_KZ_TCW);			
49C8  D8C1     RCALL PL2
49CA  D8E9     RCALL PL222
49CC  D901     RCALL PL310
49CE  D8CB     RCALL PL6
49D0  0E20     MOVLW 0x20
49D2  6F7B     MOVWF _PFNf_rozruch, BANKED
49D4  EC3E     CALL 0x627C, 0
49D6  F031     NOP
215:           			}
216:           		}
217:           		else
218:           		{
219:           			SetStatus(&(DWD[id+1].St2),tWYGAS|tRDID,tALL,0,_KZ_TCW);
220:           		}
221:           		if(tm)		//naprzemiennie z temperatura
49D8  5180     MOVF _PFNf_set_nco, W, BANKED
49DA  E045     BZ 0x4A66
222:           		{
223:           			if(!PFNf_off)
49DC  AA0C     BTFSS PFNf_off, 5, ACCESS
224:           			{
225:           				if(!PFNf_obgCW)
49DE  B80C     BTFSC PFNf_off, 4, ACCESS
49E0  D039     BRA 0x4A54
226:           				{
227:           					if(!PFNf_fL3)		//aktywna blokada L3?
49E2  B00A     BTFSC PFNf_firstEdge, 0, ACCESS
49E4  D029     BRA 0x4A38
228:           					{
229:           						
230:           						if(!PFNf_errCO&&!PFNf_oflato)
49E6  A809     BTFSS PFNf_b_str_nco, 4, ACCESS
49E8  BC0C     BTFSC PFNf_off, 6, ACCESS
49EA  D00F     BRA 0x4A0A
49EC  D8AF     RCALL PL2
231:           						{
232:           							SetStatus(&(DWD[id+1].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
49EE  D8C5     RCALL PL78
49F0  D8F6     RCALL PL508
49F2  D8CF     RCALL PL120
49F4  D8FD     RCALL PL624
49F6  EC3E     CALL 0x627C, 0
49F8  F031     NOP
49FA  D8A8     RCALL PL2
233:           							SetData(&(DWD[id+1].Dt),0,PFN.CO);
49FC  D8C3     RCALL PL80
49FE  6B76     CLRF _PFNf_prn_in, BANKED
4A00  C1D8     MOVFF 0x1D8, _PFNf_prn_pg
4A02  F077     NOP
4A04  ECBF     CALL 0xBD7E, 0
4A06  F05E     NOP
234:           						}
4A08  D08B     BRA 0x4B20
235:           						else
236:           						{
237:           							SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
4A0A  D8A0     RCALL PL2
4A0C  D8B6     RCALL PL78
4A0E  D8B2     RCALL __end_ofPL6
4A10  D8AA     RCALL PL6
4A12  0E50     MOVLW 0x50
4A14  6F7B     MOVWF _PFNf_rozruch, BANKED
4A16  EC3E     CALL 0x627C, 0
4A18  F031     NOP
238:           							if(!PFNf_oflato) SetData(&(DWD[id+1].Dt),KRESKA,KRESKA);
4A1A  BC0C     BTFSC PFNf_off, 6, ACCESS
4A1C  D006     BRA 0x4A2A
4A1E  D896     RCALL PL2
4A20  D8B1     RCALL PL80
4A22  D8D9     RCALL PL330
4A24  ECBF     CALL 0xBD7E, 0
4A26  F05E     NOP
4A28  D07B     BRA 0x4B20
239:           							else SetData(&(DWD[id+1].Dt),BLACK,BLACK);
4A2A  D890     RCALL PL2
4A2C  D8AB     RCALL PL80
4A2E  6B76     CLRF _PFNf_prn_in, BANKED
4A30  6B77     CLRF _PFNf_prn_pg, BANKED
4A32  ECBF     CALL 0xBD7E, 0
4A34  F05E     NOP
4A36  D074     BRA 0x4B20
240:           						}
241:           					}
242:           					else
243:           					{
244:           						SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);
4A38  D889     RCALL PL2
4A3A  D89F     RCALL PL78
4A3C  D89B     RCALL __end_ofPL6
4A3E  D893     RCALL PL6
4A40  0E50     MOVLW 0x50
4A42  6F7B     MOVWF _PFNf_rozruch, BANKED
4A44  EC3E     CALL 0x627C, 0
4A46  F031     NOP
4A48  D881     RCALL PL2
4A4A  D89C     RCALL PL80
4A4C  D8D6     RCALL PL742
245:           						SetData(&(DWD[id+1].Dt),led_L,led_3);
4A4E  ECBF     CALL 0xBD7E, 0
4A50  F05E     NOP
4A52  D066     BRA 0x4B20
246:           					}
247:           				}
248:           				else
249:           				{
250:           					SetStatus(&(DWD[id+1].St),tWYGAS|tRDID,tALL,0,_KZ_BAR|_KZ_TCO);
4A54  D87B     RCALL PL2
4A56  D891     RCALL PL78
4A58  D8BB     RCALL PL310
4A5A  D885     RCALL PL6
4A5C  0E50     MOVLW 0x50
4A5E  6F7B     MOVWF _PFNf_rozruch, BANKED
4A60  EC3E     CALL 0x627C, 0
4A62  F031     NOP
4A64  D05D     BRA 0x4B20
251:           				}
252:           			}
253:           			else
254:           			{
255:           				SetStatus(&(DWD[id+1].St),tWYGAS|tRDID,tALL,0,_KZ_BAR|_KZ_TCO);
256:           			}
257:           		}
258:           		else
259:           		if(cs)		//naprzemiennie z cisnieniem
4A66  5181     MOVF _PFNf_set_ncw, W, BANKED
4A68  E05B     BZ 0x4B20
260:           		{
261:           			if(!PFNf_errCS&&!PFNf_fnoCS)
4A6A  AA09     BTFSS PFNf_b_str_nco, 5, ACCESS
4A6C  B80A     BTFSC PFNf_firstEdge, 4, ACCESS
4A6E  D013     BRA 0x4A96
4A70  D86D     RCALL PL2
4A72  D883     RCALL PL78
262:           			{
263:           				SetStatus(&(DWD[id+1].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);			//cisnienie
4A74  2184     ADDWFC _PFNf_tdzCO, W, BANKED
4A76  6F75     MOVWF _PFNf_prn_cs, BANKED
4A78  0EC4     MOVLW 0xC4
4A7A  D88B     RCALL PL120
4A7C  0E40     MOVLW 0x40
4A7E  EC46     CALL 0x9C8C, 0
4A80  F04E     NOP
4A82  EC3E     CALL 0x627C, 0
4A84  F031     NOP
4A86  D862     RCALL PL2
4A88  D87D     RCALL PL80
264:           				SetData(&(DWD[id+1].Dt),0,PFN.CS);
4A8A  6B76     CLRF _PFNf_prn_in, BANKED
4A8C  C1DA     MOVFF 0x1DA, _PFNf_prn_pg
4A8E  F077     NOP
4A90  ECBF     CALL 0xBD7E, 0
4A92  F05E     NOP
265:           			}
4A94  D045     BRA 0x4B20
266:           			else
267:           			{
268:           				SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
4A96  D85A     RCALL PL2
4A98  D870     RCALL PL78
4A9A  D86C     RCALL __end_ofPL6
4A9C  D864     RCALL PL6
4A9E  0E50     MOVLW 0x50
4AA0  6F7B     MOVWF _PFNf_rozruch, BANKED
4AA2  EC3E     CALL 0x627C, 0
4AA4  F031     NOP
4AA6  D852     RCALL PL2
4AA8  D86D     RCALL PL80
4AAA  D895     RCALL PL330
269:           				SetData(&(DWD[id+1].Dt),KRESKA,KRESKA);
4AAC  ECBF     CALL 0xBD7E, 0
4AAE  F05E     NOP
4AB0  D037     BRA 0x4B20
270:           			}
271:           		}
272:           	}
273:           	else
274:           	{
275:           		SetStatus(&(DWD[id+1].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);
4AB2  D84C     RCALL PL2
4AB4  D874     RCALL PL222
4AB6  D85E     RCALL __end_ofPL6
4AB8  D856     RCALL PL6
4ABA  0E7C     MOVLW 0x7C
4ABC  6F7B     MOVWF _PFNf_rozruch, BANKED
4ABE  EC3E     CALL 0x627C, 0
4AC0  F031     NOP
276:           		if(tm==1&&cs==1)//staly kod bez znaku klucza
4AC2  0580     DECF _PFNf_set_nco, W, BANKED
4AC4  E116     BNZ 0x4AF2
4AC6  0581     DECF _PFNf_set_ncw, W, BANKED
4AC8  E114     BNZ 0x4AF2
4ACA  D840     RCALL PL2
4ACC  D856     RCALL PL78
4ACE  D887     RCALL PL508
4AD0  D84A     RCALL PL6
277:           		{
278:           			SetStatus(&(DWD[id+1].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);
4AD2  0E7C     MOVLW 0x7C
4AD4  6F7B     MOVWF _PFNf_rozruch, BANKED
4AD6  EC3E     CALL 0x627C, 0
4AD8  F031     NOP
4ADA  D838     RCALL PL2
4ADC  D865     RCALL PL262
279:           			SetData(&(DWD[id+1].Dt2),BLACK,lkod);		//kod E
4ADE  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
4AE0  F077     NOP
4AE2  ECBF     CALL 0xBD7E, 0
4AE4  F05E     NOP
4AE6  D832     RCALL PL2
4AE8  D84D     RCALL PL80
4AEA  D88C     RCALL PL808
280:           			SetData(&(DWD[id+1].Dt),0,nkod);			//nr bledu
4AEC  ECBF     CALL 0xBD7E, 0
4AEE  F05E     NOP
281:           	
282:           		}
4AF0  D017     BRA 0x4B20
283:           		else
284:           		if(!tm&&!cs)	//migajacy kod ze znakiem klucza
4AF2  5180     MOVF _PFNf_set_nco, W, BANKED
4AF4  E115     BNZ 0x4B20
4AF6  5181     MOVF _PFNf_set_ncw, W, BANKED
4AF8  E113     BNZ 0x4B20
4AFA  D828     RCALL PL2
4AFC  D83E     RCALL PL78
4AFE  D83A     RCALL __end_ofPL6
4B00  D832     RCALL PL6
285:           		{
286:           			SetStatus(&(DWD[id+1].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_RES|_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_BAR);
4B02  0E7C     MOVLW 0x7C
4B04  6F7B     MOVWF _PFNf_rozruch, BANKED
4B06  EC3E     CALL 0x627C, 0
4B08  F031     NOP
4B0A  D820     RCALL PL2
4B0C  D84D     RCALL PL262
287:           			SetData(&(DWD[id+1].Dt2),BLACK,BLACK);
4B0E  6B77     CLRF _PFNf_prn_pg, BANKED
4B10  ECBF     CALL 0xBD7E, 0
4B12  F05E     NOP
4B14  D81B     RCALL PL2
4B16  D836     RCALL PL80
288:           			SetData(&(DWD[id+1].Dt),BLACK,BLACK);
4B18  6B76     CLRF _PFNf_prn_in, BANKED
4B1A  6B77     CLRF _PFNf_prn_pg, BANKED
4B1C  ECBF     CALL 0xBD7E, 0
4B1E  F05E     NOP
289:           		}
290:           	}
291:           #endif
292:           	if(!id)
4B20  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
4B22  E10A     BNZ 0x4B38
293:           	{
294:           		SetPoz(_KL_ERR,0);
4B24  0E00     MOVLW 0x0
4B26  6B74     CLRF _PFNf_prODP, BANKED
4B28  ECAC     CALL 0xA358, 0
4B2A  F051     NOP
295:           		SetPoz(_KL_ERR,1);
4B2C  0E01     MOVLW 0x1
4B2E  0100     MOVLB 0x0
4B30  6F74     MOVWF _PFNf_prODP, BANKED
4B32  0E00     MOVLW 0x0
4B34  EFAC     GOTO 0xA358
4B36  F051     NOP
296:           	}
297:           	else
298:           	{
299:           		SetPoz(_KL_MSG,0);
4B38  6B74     CLRF _PFNf_prODP, BANKED
4B3A  0E02     MOVLW 0x2
4B3C  ECAC     CALL 0xA358, 0
4B3E  F051     NOP
300:           		SetPoz(_KL_MSG,1);
4B40  0E01     MOVLW 0x1
4B42  0100     MOVLB 0x0
4B44  6F74     MOVWF _PFNf_prODP, BANKED
4B46  0E02     MOVLW 0x2
4B48  EFAC     GOTO 0xA358
4B4A  F051     NOP
301:           	}
302:           }
303:           /*
304:           void PrintMsg(const unsigned char lkod,unsigned char nkod)
305:           {
306:           	unsigned int fk,fl,fm;
307:           	fm=(nkod==1||nkod==3||nkod==5)?0:tSDID;
308:           	fl=(!fm)?0:_KZ_SRV;
309:           
310:           #if LCD4D==0
311:           	if(nkod>0xf) nkod=0xf;
312:           	SetData(&(DWD[4].Dt),lkod,Znak[nkod]);
313:           	SetStatus(&(DWD[4].St),tLED|fm|tRDID,tALL,fl,_KZ_TCO|_KZ_BAR);
314:           	if(nkod!=7&&nkod!=9)
315:           	{
316:           		SetData(&&(DWD[5].Dt),lkod,Znak[nkod]);
317:           		SetStatus(&(DWD[5].St),tLED|tRDID,tALL,0,fl|_KZ_TCO|_KZ_BAR);
318:           	}
319:           	else
320:           	{
321:           		if(nkod==7&&!PFNf_errCO)		//naprzemiennie z temperatura
322:           		{
323:           			SetData(&&(DWD[5].Dt),0,tm);
324:           			SetStatus(&(DWD[5].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,fl|_KZ_BAR);
325:           		}
326:           		else			
327:           		if(nkod==9&&!PFNf_errCS)		//naprzemiennie z cisnieniem
328:           		{
329:           			SetData(&&(DWD[5].Dt),0,cs);
330:           			SetStatus(&(DWD[5].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,fl|_KZ_TCO);
331:           		}
332:           		else
333:           		{
334:           			SetData(&&(DWD[5].Dt),lkod,Znak[nkod]);
335:           			SetStatus(&(DWD[5].St),tLED|tRDID,tALL,0,fl|_KZ_TCO|_KZ_BAR);
336:           		}	
337:           	}
338:           #else
339:           	SetData(&(DWD[4].Dt2),BLACK,lkod);		//kod E
340:           	SetData(&(DWD[4].Dt),0,nkod);			//nr bledu
341:           	SetStatus(&(DWD[4].St2),tLED|fm|tRDID|tFOCUS,tALL,fl,_KZ_TCO|_KZ_TCW|_KZ_BAR);
342:           	SetStatus(&(DWD[4].St),tDEC|fm|tRDID|tFOCUS,tALL,fl,_KZ_TCO|_KZ_TCW|_KZ_BAR);	
343:           	if(nkod!=7&&nkod!=9)
344:           	{
345:           		SetData(&(DWD[5].Dt2),BLACK,lkod);
346:           		SetData(&(DWD[5].Dt),0,nkod);
347:           		SetStatus(&(DWD[5].St2),tLED|tRDID|tFOCUS,tALL,0,fl|_KZ_TCO|_KZ_TCW|_KZ_BAR);
348:           		SetStatus(&(DWD[5].St),tDEC|tRDID|tFOCUS,tALL,0,fl|_KZ_TCO|_KZ_TCW|_KZ_BAR);
349:           	}
350:           	else
351:           	{
352:           		if(!PFNf_errCW)
353:           		{
354:           			SetStatus(&(DWD[5].St2),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCW,fl);
355:           			SetData(&(DWD[5].Dt2),0,PFN.CW);
356:           		}
357:           		else
358:           		{
359:           			SetStatus(&(DWD[5].St2),tLED|tRDID|tFOCUS,tALL,0,fl|_KZ_TCW);
360:           			SetData(&(DWD[5].Dt2),KRESKA,KRESKA);
361:           		}
362:           		if(nkod==7)		//naprzemiennie z temperatura
363:           		{
364:           			if(!PFNf_fL3)		//aktywna blokada L3?
365:           			{
366:           				if(!PFNf_errCO&&!PFNf_oflato)
367:           				{
368:           					SetStatus(&(DWD[5].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
369:           					SetData(&(DWD[5].Dt),0,PFN.CO);
370:           				}
371:           				else
372:           				{
373:           					SetStatus(&(DWD[5].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);//_KZ_SRV|_KZ_TCO|_KZ_TCW|_KZ_DCO|_KZ_DCW|_KZ_BAR|_KZ_PGD);
374:           					if(!PFNf_oflato) SetData(&(DWD[5].Dt),KRESKA,KRESKA);
375:           					else SetData(&(DWD[5].Dt),BLACK,BLACK);
376:           				}
377:           			}
378:           			else
379:           			{
380:           				SetStatus(&(DWD[5].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);
381:           				SetData(&(DWD[5].Dt),led_L,led_3);
382:           			}
383:           		}
384:           		else
385:           		if(nkod==9)		//naprzemiennie z cisnieniem
386:           		{
387:           			if(!PFNf_errCS&&!PFNf_fnoCS)
388:           			{
389:           				SetStatus(&(DWD[5].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);			//cisnienie
390:           				SetData(&(DWD[5].Dt),0,PFN.CS);
391:           			}
392:           			else
393:           			{
394:           				SetStatus(&(DWD[5].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
395:           				SetData(&(DWD[5].Dt),KRESKA,KRESKA);
396:           			}
397:           		}
398:           	}
399:           #endif
400:           	SetPoz(_KL_MSG,0);
401:           	SetPoz(_KL_MSG,1);
402:           }*/
403:           //---------------------------------------------------------
404:           //---------------------------------------------------------
405:           
406:           /*
407:           //---------------------------------------------------------
408:           //---------------------------------------------------------
409:           //Kod b³edu naprzemiennie z cisnieniem
410:           //lkod - kod led oznaczenia literowego bledu
411:           //nkod - wartosc liczbowa bledu
412:           //tm - temperatura wskacywana naprzemiennie z kodem bledu
413:           void PrintErrCs(const unsigned char lkod,unsigned char nkod,const unsigned char cs)
414:           {
415:           #if LCD4D==0
416:           	if(nkod>0xf) nkod=0xf;
417:           	SetData(&DWD[0],lkod,Znak[nkod]);
418:           	SetData(&DWD[1],0,cs);
419:           	SetStatus(&DWD[0],tLED|tRDID,tALL,0,_KZ_TCO);					//kod bledu/cisnienie
420:           	SetStatus(&DWD[1],tDEC|tKROPKA1|tRDID,tALL,0,_KZ_TCO);					//temperatura
421:           #else
422:           	SetData2(&DWD[0],BLACK,lkod);
423:           	SetStatus2(&DWD[0],tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO);
424:           	SetData(&DWD[0],0,nkod);
425:           	SetStatus(&DWD[0],tDEC|tRDID|tFOCUS,tALL,0,_KZ_TCO);
426:           	SetData(&DWD[1],0,cs);
427:           	SetStatus(&DWD[1],tDEC|tKROPKA1|tRDID,tALL,0,_KZ_TCO);					//temperatura
428:           	SetData2(&DWD[1],BLACK,BLACK);
429:           	SetStatus2(&DWD[1],tLED,tALL,0,0);								//temperatura
430:           	//SetStatus2(&DWD[1],tLED|tRDID,tALL,0,_KZ_TCOW);				//temperatura
431:           #endif
432:           	SetPoz(_WS_ERR,0);
433:           	SetPoz(_WS_ERR,1);
434:           }
435:           //---------------------------------------------------------
436:           //---------------------------------------------------------
437:           //Kod b³edu naprzemiennie z temperatura
438:           //lkod - kod led oznaczenia literowego bledu
439:           //nkod - wartosc liczbowa bledu
440:           //tm - temperatura wskacywana naprzemiennie z kodem bledu
441:           //pls - znacznik czy ma byc wskazana temp CO (0) czy CW (1)
442:           void PrintErrTm(const unsigned char lkod,unsigned char nkod,const unsigned char tm, const unsigned char pls)
443:           {
444:           #if LCD4D==0
445:           	if(nkod>0xf) nkod=0xf;
446:           	SetData(&DWD[0],lkod,Znak[nkod]);
447:           	SetData(&DWD[1],0,tm);
448:           	SetStatus(&DWD[0],tLED|tRDID,tALL,0,_KZ_TCO);					//kod bledu/cisnienie
449:           	SetStatus(&DWD[1],tDEC|tSDID,tALL,_KZ_TCO,0);					//temperatura
450:           #else
451:           	SetData2(&DWD[0],BLACK,lkod);
452:           	SetStatus2(&DWD[0],tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO);
453:           	SetData(&DWD[0],0,nkod);
454:           	SetStatus(&DWD[0],tDEC|tRDID|tFOCUS,tALL,0,_KZ_TCO);
455:           	if(!pls)
456:           	{
457:           		SetData(&DWD[1],0,tm);
458:           		SetStatus(&DWD[1],tDEC|tSDID,tALL,_KZ_TCO,0);					//temperatura
459:           		SetData2(&DWD[1],BLACK,BLACK);
460:           		SetStatus2(&DWD[1],tLED,tALL,0,0);								//temperatura
461:           		//SetStatus2(&DWD[1],tLED|tRDID,tALL,0,_KZ_TCOW);				//temperatura
462:           	}
463:           	else
464:           	{
465:           		SetData(&DWD[1],BLACK,BLACK);
466:           		SetStatus(&DWD[1],tLED,tALL,0,0);				//temperatura
467:           		//SetStatus(&DWD[1],tLED|tRDID,tALL,0,_KZ_TCOO);				//temperatura
468:           		SetData2(&DWD[1],0,tm);
469:           		SetStatus2(&DWD[1],tDEC|tSDID,tALL,_KZ_TCO,0);					//temperatura
470:           	}
471:           #endif
472:           	SetPoz(_WS_ERR,0);
473:           	SetPoz(_WS_ERR,1);
474:           }
475:           */
476:           
477:           
478:           //---------------------------------------------------------
479:           //---------------------------------------------------------
480:           //Wyswietla wskaz skladajacy sie z oznaczenia literowego i cyfry od 0 do 9
481:           //WYSWIETLANIE 2 CYFROWE
482:           //lkod - dowolny znak w kodzie led wyswietlany na starszej cyfrze
483:           //dla tryb=0:
484:           //nkod - liczba zakresu 0-F wyswietlana na mlodszej cyfrze
485:           //dla tryb=1:
486:           //nkod - dowolny znak w kodzie led wyswietlany na mlodszej cyfrze
487:           //WYSWIETLANIE 4 CYFROWE
488:           //lkod - dowolny znak w kodzie led wyswietlany na 3 cyfrze
489:           //nkod - liczba zakresu 0-99 wyswietlana na 2 najmlodszych cyfrach
490:           void PrintPR(const unsigned char lkod,unsigned char nkod,unsigned char tryb)
9E76  6F80     MOVWF _PFNf_set_nco, BANKED
491:           {
492:           #if LCD4D==0
493:           	if((nkod>0xf)&&!tryb) nkod=0xf;
494:           	SetData(&(PWD[_WS_PRM].Dt),lkod,(!tryb)?Znak[nkod]:nkod);
495:           	SetStatus(&(PWD[_WS_PRM].St),tLED|tSDID|tFOCUS,tALL,_KZ_SRV,0);
496:           #else
497:           	if((nkod>99)&&!tryb) nkod=99;
9E78  0E63     MOVLW 0x63
9E7A  0100     MOVLB 0x0
9E7C  657E     CPFSGT _PFNf_set_eco, BANKED
9E7E  D004     BRA 0x9E88
9E80  517F     MOVF _PFNf_set_fnserw, W, BANKED
9E82  E102     BNZ 0x9E88
9E84  0E63     MOVLW 0x63
9E86  6F7E     MOVWF _PFNf_set_eco, BANKED
498:           	SetData(&(PWD[_WS_PRM].Dt2),BLACK,lkod);
9E88  0E78     MOVLW 0x78
9E8A  D82B     RCALL PL670
9E8C  C080     MOVFF _PFNf_set_nco, _PFNf_prn_pg
9E8E  F077     NOP
9E90  ECBF     CALL 0xBD7E, 0
9E92  F05E     NOP
9E94  D81B     RCALL PL542
499:           	SetStatus(&(PWD[_WS_PRM].St2),tLED|tFOCUS,tALL,0,0);
9E96  0E80     MOVLW 0x80
9E98  ECC9     CALL 0x9B92, 0
9E9A  F04D     NOP
9E9C  EC3E     CALL 0x627C, 0
9E9E  F031     NOP
9EA0  D81A     RCALL PL606
500:           	SetData(&(PWD[_WS_PRM].Dt),0,nkod);
9EA2  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
9EA4  F077     NOP
9EA6  ECBF     CALL 0xBD7E, 0
9EA8  F05E     NOP
9EAA  D802     RCALL PL232
501:           	SetStatus(&(PWD[_WS_PRM].St),tDEC|tSDID|tFOCUS,tALL,_KZ_SRV,0);
9EAC  EF3E     GOTO 0x627C
9EAE  F031     NOP
502:           #endif
503:           	//UpdateWSW();
504:           }
505:           //----------
506:           //wyswietla wartosc parametru
507:           void PrintWPR(unsigned char hi_wr,unsigned char lo_wr)
B566  6F7F     MOVWF _PFNf_set_fnserw, BANKED
508:           {
509:           #if LCD4D==0
510:           	SetData(&(PWD[_WS_PRM].Dt),0,lo_wr);
511:           	SetStatus(&(PWD[_WS_PRM].St),tDEC|tSDID|tFOCUS,tALL,_KZ_SRV,0);
512:           #else
513:           	SetData(&(PWD[_WS_PRM].Dt2),0,hi_wr);//wr/100);
B568  0E78     MOVLW 0x78
B56A  0100     MOVLB 0x0
B56C  EC71     CALL 0x9EE2, 0
B56E  F04F     NOP
B570  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_pg
B572  F077     NOP
B574  ECBF     CALL 0xBD7E, 0
B576  F05E     NOP
514:           	SetStatus(&(PWD[_WS_PRM].St2),tDEC|tFOCUS,tALL,0,0);
B578  EC66     CALL 0x9ECC, 0
B57A  F04F     NOP
B57C  0EC0     MOVLW 0xC0
B57E  ECC9     CALL 0x9B92, 0
B580  F04D     NOP
B582  EC3E     CALL 0x627C, 0
B584  F031     NOP
515:           	SetData(&(PWD[_WS_PRM].Dt),0,lo_wr);//%100);
B586  EC6B     CALL 0x9ED6, 0
B588  F04F     NOP
B58A  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
B58C  F077     NOP
B58E  ECBF     CALL 0xBD7E, 0
B590  F05E     NOP
516:           	SetStatus(&(PWD[_WS_PRM].St),tDEC|tSDID|tFOCUS,tALL,_KZ_SRV,0);
B592  EC58     CALL 0x9EB0, 0
B594  F04F     NOP
B596  EF3E     GOTO 0x627C
B598  F031     NOP
517:           #endif
518:           	//UpdateWSW();
519:           }
520:           //----------
521:           //usuwa wskaz parametru
522:           void EndPR(void)
523:           {
524:           #if LCD4D==0
525:           	SetStatus(&(PWD[_WS_PRM].St),tDEC,tALL,0,0);
526:           #else
527:           	SetStatus(&(PWD[_WS_PRM].St),tDEC,tALL,0,0);
BBC2  0E70     MOVLW 0x70
BBC4  0100     MOVLB 0x0
BBC6  6F74     MOVWF _PFNf_prODP, BANKED
BBC8  0E03     MOVLW 0x3
BBCA  6F75     MOVWF _PFNf_prn_cs, BANKED
BBCC  0E40     MOVLW 0x40
BBCE  ECC9     CALL 0x9B92, 0
BBD0  F04D     NOP
BBD2  EC3E     CALL 0x627C, 0
BBD4  F031     NOP
BBD6  EC66     CALL 0x9ECC, 0
BBD8  F04F     NOP
528:           	SetStatus(&(PWD[_WS_PRM].St2),tDEC,tALL,0,0);
BBDA  0E40     MOVLW 0x40
BBDC  ECC9     CALL 0x9B92, 0
BBDE  F04D     NOP
BBE0  EF3E     GOTO 0x627C
BBE2  F031     NOP
529:           #endif
530:           	//UpdateWSW();
531:           }
532:           //---------------------------------------------------------
533:           //---------------------------------------------------------
534:           /*
535:           //natychmiastowa aktualizacja wskazu nastawy
536:           void RNst(const unsigned char nst)
537:           {
538:           	SetData(&(DWD[2].Dt),0,nst);							//nastawa CO/CW/Kt
539:           	SetData(&(DWD[3].Dt),0,nst);							//nastawa CO/CW/Kt
540:           	UpdateWSW();
541:           }
542:           //----------
543:           #if LCD4D!=0
544:           void RNst2(const unsigned char nst)
545:           {
546:           	SetData(&(DWD[2].Dt2),0,nst);							//nastawa CO/CW/Kt
547:           	SetData(&(DWD[3].Dt2),0,nst);							//nastawa CO/CW/Kt
548:           	UpdateWSW();
549:           }
550:           #endif
551:           */
552:           //----------
553:           //wyswietla nastawe temp. CW
554:           void PrintNstCW(const unsigned char nst,const unsigned char only)
8D32  0100     MOVLB 0x0
8D34  6F83     MOVWF _PFNf_str_ncw, BANKED
555:           {
556:           	unsigned int fl;
557:           	fl=(!only)?0:tONL;
8D36  5182     MOVF _PFNf_str_nco, W, BANKED
8D38  E004     BZ 0x8D42
8D3A  6B85     CLRF _PFNf_tdzCW, BANKED
8D3C  0E04     MOVLW 0x4
8D3E  6F84     MOVWF _PFNf_tdzCO, BANKED
8D40  D002     BRA 0x8D46
8D42  6B84     CLRF _PFNf_tdzCO, BANKED
8D44  6B85     CLRF _PFNf_tdzCW, BANKED
558:           	SetData(&(DWD[2].Dt2),0,nst);							//nastawa CW
8D46  EC06     CALL 0x7C0C, 0
8D48  F03E     NOP
8D4A  6B76     CLRF _PFNf_prn_in, BANKED
8D4C  C083     MOVFF _PFNf_str_ncw, _PFNf_prn_pg
8D4E  F077     NOP
8D50  ECBF     CALL 0xBD7E, 0
8D52  F05E     NOP
8D54  ECF5     CALL 0x7BEA, 0
8D56  F03D     NOP
559:           	SetData(&(DWD[3].Dt2),BLACK,BLACK);
8D58  ECBF     CALL 0xBD7E, 0
8D5A  F05E     NOP
8D5C  ECFC     CALL 0x7BF8, 0
8D5E  F03D     NOP
560:           	SetStatus(&(DWD[2].St2),fl|tDEC|tSDID|tFOCUS,tALL,_KZ_TCW|_KZ_DCW,0);
8D60  0E20     MOVLW 0x20
8D62  1184     IORWF _PFNf_tdzCO, W, BANKED
8D64  6F76     MOVWF _PFNf_prn_in, BANKED
8D66  0EC0     MOVLW 0xC0
8D68  1185     IORWF _PFNf_tdzCW, W, BANKED
8D6A  D82F     RCALL PL458
8D6C  EC3E     CALL 0x627C, 0
8D6E  F031     NOP
8D70  EC01     CALL 0x7C02, 0
8D72  F03E     NOP
561:           	SetStatus(&(DWD[3].St2),fl|tLED|tRDID,tALL,0,_KZ_DCW|_KZ_TCW);
8D74  0E10     MOVLW 0x10
8D76  1184     IORWF _PFNf_tdzCO, W, BANKED
8D78  6F76     MOVWF _PFNf_prn_in, BANKED
8D7A  5185     MOVF _PFNf_tdzCW, W, BANKED
8D7C  D821     RCALL PL332
8D7E  0E22     MOVLW 0x22
8D80  6F7B     MOVWF _PFNf_rozruch, BANKED
8D82  EC3E     CALL 0x627C, 0
8D84  F031     NOP
562:           	MarkMinMax(1,0);
8D86  6B7C     CLRF _PFNf_setKey, BANKED
8D88  0E01     MOVLW 0x1
8D8A  EC2F     CALL 0x945E, 0
8D8C  F04A     NOP
563:           #if LCD4D!=0
564:           	if(!only)
8D8E  5182     MOVF _PFNf_str_nco, W, BANKED
8D90  E110     BNZ 0x8DB2
565:           	{
566:           		SetStatus(&(DWD[2].St),tWYGAS|tRDID,tALL,0,_KZ_PGD|_KZ_TCO|_KZ_BAR);
8D92  0E6C     MOVLW 0x6C
8D94  D811     RCALL PL246
8D96  ECB3     CALL 0x4B66, 0
8D98  F025     NOP
8D9A  0ED0     MOVLW 0xD0
8D9C  6F7B     MOVWF _PFNf_rozruch, BANKED
8D9E  EC3E     CALL 0x627C, 0
8DA0  F031     NOP
8DA2  ECF0     CALL 0x7BE0, 0
8DA4  F03D     NOP
8DA6  ECB3     CALL 0x4B66, 0
8DA8  F025     NOP
567:           		SetStatus(&(DWD[3].St),tWYGAS|tRDID,tALL,0,_KZ_PGD|_KZ_TCO|_KZ_BAR);
8DAA  0ED0     MOVLW 0xD0
8DAC  6F7B     MOVWF _PFNf_rozruch, BANKED
8DAE  EC3E     CALL 0x627C, 0
8DB0  F031     NOP
568:           	}
569:           #endif
570:           	RestartKol1(_KL_NCWCO);
8DB2  0E01     MOVLW 0x1
8DB4  EF02     GOTO 0xBE04
8DB6  F05F     NOP
571:           }
572:           void ClrMarkMinMax(void);
573:           void PrintNstCW2(const unsigned char nst,const unsigned char min, const unsigned char only)
7B24  0100     MOVLB 0x0
7B26  6F84     MOVWF _PFNf_tdzCO, BANKED
574:           {
575:           	unsigned int fl;
576:           	fl=(!only)?0:tONL;
7B28  5183     MOVF _PFNf_str_ncw, W, BANKED
7B2A  E004     BZ 0x7B34
7B2C  6B86     CLRF _PFNf_timZAS, BANKED
7B2E  0E04     MOVLW 0x4
7B30  6F85     MOVWF _PFNf_tdzCW, BANKED
7B32  D002     BRA 0x7B38
7B34  6B85     CLRF _PFNf_tdzCW, BANKED
7B36  6B86     CLRF _PFNf_timZAS, BANKED
577:           	if(nst>min)
7B38  5184     MOVF _PFNf_tdzCO, W, BANKED
7B3A  5D82     SUBWF _PFNf_str_nco, W, BANKED
7B3C  E221     BC 0x7B80
7B3E  D866     RCALL PL412
578:           	{
579:           		SetData(&(DWD[2].Dt2),0,nst);							//nastawa CW
7B40  6B76     CLRF _PFNf_prn_in, BANKED
7B42  C084     MOVFF _PFNf_tdzCO, _PFNf_prn_pg
7B44  F077     NOP
7B46  ECBF     CALL 0xBD7E, 0
7B48  F05E     NOP
7B4A  D84F     RCALL PL228
580:           		SetData(&(DWD[3].Dt2),BLACK,BLACK);
7B4C  ECBF     CALL 0xBD7E, 0
7B4E  F05E     NOP
7B50  D853     RCALL PL334
581:           		SetStatus(&(DWD[2].St2),fl|tDEC|tSDID|tFOCUS,tALL,_KZ_TCW|_KZ_DCW,0);
7B52  0E20     MOVLW 0x20
7B54  1185     IORWF _PFNf_tdzCW, W, BANKED
7B56  6F76     MOVWF _PFNf_prn_in, BANKED
7B58  0EC0     MOVLW 0xC0
7B5A  1186     IORWF _PFNf_timZAS, W, BANKED
7B5C  ECE5     CALL 0x8DCA, 0
7B5E  F046     NOP
7B60  EC3E     CALL 0x627C, 0
7B62  F031     NOP
582:           		SetStatus(&(DWD[3].St2),fl|tLED|tRDID,tALL,0,_KZ_DCW|_KZ_TCW);
7B64  D84E     RCALL PL342
7B66  0E10     MOVLW 0x10
7B68  D85E     RCALL PL464
7B6A  ECE0     CALL 0x8DC0, 0
7B6C  F046     NOP
7B6E  0E22     MOVLW 0x22
7B70  6F7B     MOVWF _PFNf_rozruch, BANKED
7B72  EC3E     CALL 0x627C, 0
7B74  F031     NOP
583:           		MarkMinMax(1,0);
7B76  6B7C     CLRF _PFNf_setKey, BANKED
7B78  0E01     MOVLW 0x1
7B7A  EC2F     CALL 0x945E, 0
7B7C  F04A     NOP
584:           	}
7B7E  D01B     BRA 0x7BB6
585:           	else
586:           	{
587:           		SetData(&(DWD[2].Dt2),KRESKA,KRESKA);							//nastawa CW
7B80  0E74     MOVLW 0x74
7B82  6F74     MOVWF _PFNf_prODP, BANKED
7B84  0E04     MOVLW 0x4
7B86  EC8E     CALL 0x9B1C, 0
7B88  F04D     NOP
7B8A  ECBF     CALL 0xBD7E, 0
7B8C  F05E     NOP
7B8E  D82D     RCALL PL228
588:           		SetData(&(DWD[3].Dt2),BLACK,BLACK);
7B90  ECBF     CALL 0xBD7E, 0
7B92  F05E     NOP
7B94  D831     RCALL PL334
589:           		SetStatus(&(DWD[2].St2),fl|tLED|tSDID|tRDID|tFOCUS,tALL,_KZ_DCW,_KZ_TCW);
7B96  0E30     MOVLW 0x30
7B98  1185     IORWF _PFNf_tdzCW, W, BANKED
7B9A  6F76     MOVWF _PFNf_prn_in, BANKED
7B9C  0E80     MOVLW 0x80
7B9E  1186     IORWF _PFNf_timZAS, W, BANKED
7BA0  D83A     RCALL PL414
7BA2  EC3E     CALL 0x627C, 0
7BA4  F031     NOP
7BA6  D82D     RCALL PL342
590:           		SetStatus(&(DWD[3].St2),fl|tLED|tSDID|tRDID,tALL,_KZ_DCW,_KZ_TCW);
7BA8  0E30     MOVLW 0x30
7BAA  D83D     RCALL PL464
7BAC  D834     RCALL PL414
7BAE  EC3E     CALL 0x627C, 0
7BB0  F031     NOP
591:           		ClrMarkMinMax();
7BB2  EC03     CALL 0xBC06, 0
7BB4  F05E     NOP
592:           	}
593:           #if LCD4D!=0
594:           	if(!only)
7BB6  5183     MOVF _PFNf_str_ncw, W, BANKED
7BB8  E110     BNZ 0x7BDA
595:           	{
596:           		SetStatus(&(DWD[2].St),tWYGAS|tRDID,tALL,0,_KZ_PGD|_KZ_TCO|_KZ_BAR);
7BBA  0E6C     MOVLW 0x6C
7BBC  ECDC     CALL 0x8DB8, 0
7BBE  F046     NOP
7BC0  ECB3     CALL 0x4B66, 0
7BC2  F025     NOP
7BC4  0ED0     MOVLW 0xD0
7BC6  6F7B     MOVWF _PFNf_rozruch, BANKED
7BC8  EC3E     CALL 0x627C, 0
7BCA  F031     NOP
7BCC  D809     RCALL PL128
7BCE  ECB3     CALL 0x4B66, 0
7BD0  F025     NOP
597:           		SetStatus(&(DWD[3].St),tWYGAS|tRDID,tALL,0,_KZ_PGD|_KZ_TCO|_KZ_BAR);
7BD2  0ED0     MOVLW 0xD0
7BD4  6F7B     MOVWF _PFNf_rozruch, BANKED
7BD6  EC3E     CALL 0x627C, 0
7BD8  F031     NOP
598:           	}
599:           #endif
600:           	RestartKol1(_KL_NCWCO);
7BDA  0E01     MOVLW 0x1
7BDC  EF02     GOTO 0xBE04
7BDE  F05F     NOP
601:           }
602:           //----------
603:           //wyswietla nastawe temp. CO
604:           void PrintNstCO(const unsigned char nst,const unsigned char kt,const unsigned char only)
77CC  0100     MOVLB 0x0
77CE  6F86     MOVWF _PFNf_timZAS, BANKED
605:           {
606:           	unsigned int fl,fk,fm,fn,fo;
607:           	fl=(!only)?0:tONL;
77D0  5183     MOVF _PFNf_str_ncw, W, BANKED
77D2  E005     BZ 0x77DE
77D4  0E00     MOVLW 0x0
77D6  6F90     MOVWF _RSDT1f_OdpLIDN, BANKED
77D8  0E04     MOVLW 0x4
77DA  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
77DC  D002     BRA 0x77E2
77DE  6B8F     CLRF _RSDT1f_NoRespToLIN, BANKED
77E0  6B90     CLRF _RSDT1f_OdpLIDN, BANKED
608:           	fk=(!kt)?0:tKROPKA1;
77E2  5182     MOVF _PFNf_str_nco, W, BANKED
77E4  E005     BZ 0x77F0
77E6  0E04     MOVLW 0x4
77E8  6F88     MOVWF _PFNf_toInit, BANKED
77EA  0E00     MOVLW 0x0
77EC  6F87     MOVWF _PFNf_tmpZW, BANKED
77EE  D002     BRA 0x77F4
77F0  6B87     CLRF _PFNf_tmpZW, BANKED
77F2  6B88     CLRF _PFNf_toInit, BANKED
609:           	fm=(!kt)?_KZ_TCO:_KZ_PGD;
77F4  5182     MOVF _PFNf_str_nco, W, BANKED
77F6  E004     BZ 0x7800
77F8  0E00     MOVLW 0x0
77FA  6F8A     MOVWF _PFNf_vnt, BANKED
77FC  0E80     MOVLW 0x80
77FE  D003     BRA 0x7806
7800  0E00     MOVLW 0x0
7802  6F8A     MOVWF _PFNf_vnt, BANKED
7804  0E10     MOVLW 0x10
7806  6F89     MOVWF _PFNf_trbECO, BANKED
610:           	fn=(!kt)?0:_KZ_TCO;
7808  5182     MOVF _PFNf_str_nco, W, BANKED
780A  E005     BZ 0x7816
780C  0E00     MOVLW 0x0
780E  6F8C     MOVWF _PFNf_zima, BANKED
7810  0E10     MOVLW 0x10
7812  6F8B     MOVWF _PFNf_zcfm, BANKED
7814  D002     BRA 0x781A
7816  6B8B     CLRF _PFNf_zcfm, BANKED
7818  6B8C     CLRF _PFNf_zima, BANKED
611:           	fo=(!kt)?0:_KZ_PGD;
781A  5182     MOVF _PFNf_str_nco, W, BANKED
781C  E004     BZ 0x7826
781E  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
7820  0E80     MOVLW 0x80
7822  6F8D     MOVWF _PWMf_ENPWM2, BANKED
7824  D002     BRA 0x782A
7826  6B8D     CLRF _PWMf_ENPWM2, BANKED
7828  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
612:           	SetData(&(DWD[2].Dt),0,nst);							//nastawa CO
782A  D85A     RCALL PL572
782C  C086     MOVFF _PFNf_timZAS, _PFNf_prn_pg
782E  F077     NOP
7830  ECBF     CALL 0xBD7E, 0
7832  F05E     NOP
7834  D851     RCALL PL490
7836  D847     RCALL PL400
613:           	SetData(&(DWD[3].Dt),BLACK,BLACK);						//nastawa Kt
7838  ECBF     CALL 0xBD7E, 0
783A  F05E     NOP
783C  D848     RCALL PL426
614:           	SetStatus(&(DWD[2].St),fl|fk|tDEC|tSDID|tRDID|tFOCUS,tALL,fm|_KZ_DCO,fn|_KZ_BAR);
783E  5187     MOVF _PFNf_tmpZW, W, BANKED
7840  118F     IORWF _RSDT1f_NoRespToLIN, W, BANKED
7842  6F84     MOVWF _PFNf_tdzCO, BANKED
7844  5188     MOVF _PFNf_toInit, W, BANKED
7846  1190     IORWF _RSDT1f_OdpLIDN, W, BANKED
7848  6F85     MOVWF _PFNf_tdzCW, BANKED
784A  0E30     MOVLW 0x30
784C  1184     IORWF _PFNf_tdzCO, W, BANKED
784E  6F76     MOVWF _PFNf_prn_in, BANKED
7850  0EC0     MOVLW 0xC0
7852  1185     IORWF _PFNf_tdzCW, W, BANKED
7854  6F77     MOVWF _PFNf_prn_pg, BANKED
7856  6979     SETF _PFNf_prn_res, BANKED
7858  6978     SETF _PFNf_prn_pp, BANKED
785A  5189     MOVF _PFNf_trbECO, W, BANKED
785C  0901     IORLW 0x1
785E  6F7A     MOVWF _PFNf_res, BANKED
7860  518B     MOVF _PFNf_zcfm, W, BANKED
7862  0940     IORLW 0x40
7864  6F7B     MOVWF _PFNf_rozruch, BANKED
7866  EC3E     CALL 0x627C, 0
7868  F031     NOP
615:           	SetStatus(&(DWD[3].St),fl|tLED|tRDID,tALL,0,fo|_KZ_TCO|_KZ_DCO|_KZ_BAR);
786A  0E7C     MOVLW 0x7C
786C  6F74     MOVWF _PFNf_prODP, BANKED
786E  0E04     MOVLW 0x4
7870  6F75     MOVWF _PFNf_prn_cs, BANKED
7872  0E10     MOVLW 0x10
7874  118F     IORWF _RSDT1f_NoRespToLIN, W, BANKED
7876  6F76     MOVWF _PFNf_prn_in, BANKED
7878  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
787A  ECE0     CALL 0x8DC0, 0
787C  F046     NOP
787E  518D     MOVF _PWMf_ENPWM2, W, BANKED
7880  0951     IORLW 0x51
7882  6F7B     MOVWF _PFNf_rozruch, BANKED
7884  EC3E     CALL 0x627C, 0
7886  F031     NOP
616:           	MarkMinMax(0,1);
7888  0E01     MOVLW 0x1
788A  6F7C     MOVWF _PFNf_setKey, BANKED
788C  0E00     MOVLW 0x0
788E  EC2F     CALL 0x945E, 0
7890  F04A     NOP
617:           #if LCD4D!=0
618:           	if(!only)
7892  5183     MOVF _PFNf_str_ncw, W, BANKED
7894  E111     BNZ 0x78B8
7896  ECFC     CALL 0x7BF8, 0
7898  F03D     NOP
619:           	{	
620:           		SetStatus(&(DWD[2].St2),tWYGAS|tRDID,tALL,0,_KZ_TCW);
789A  0E03     MOVLW 0x3
789C  ECB3     CALL 0x4B66, 0
789E  F025     NOP
78A0  0E20     MOVLW 0x20
78A2  6F7B     MOVWF _PFNf_rozruch, BANKED
78A4  EC3E     CALL 0x627C, 0
78A6  F031     NOP
621:           		SetStatus(&(DWD[3].St2),tWYGAS|tRDID,tALL,0,_KZ_TCW);
78A8  0E86     MOVLW 0x86
78AA  D809     RCALL PL242
78AC  ECB3     CALL 0x4B66, 0
78AE  F025     NOP
78B0  0E20     MOVLW 0x20
78B2  6F7B     MOVWF _PFNf_rozruch, BANKED
78B4  EC3E     CALL 0x627C, 0
78B6  F031     NOP
622:           	}
623:           #endif
624:           	RestartKol1(_KL_NCWCO);
78B8  0E01     MOVLW 0x1
78BA  EF02     GOTO 0xBE04
78BC  F05F     NOP
625:           }
626:           //----------
627:           //wyswietla nastawe ECO
628:           void PrintNstECO(const unsigned char nst)
9688  0100     MOVLB 0x0
968A  6F7E     MOVWF _PFNf_set_eco, BANKED
629:           {
630:           	//unsigned int fl,fk,fm,fn,fo;
631:           
632:           	SetData(&(DWD[2].Dt),0,nst);							//wsp.ECO
968C  EC70     CALL 0x78E0, 0
968E  F03C     NOP
9690  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
9692  F077     NOP
9694  ECBF     CALL 0xBD7E, 0
9696  F05E     NOP
633:           	SetData(&(DWD[3].Dt),BLACK,BLACK);						//Ec
9698  EC6C     CALL 0x78D8, 0
969A  F03C     NOP
969C  EC63     CALL 0x78C6, 0
969E  F03C     NOP
96A0  ECBF     CALL 0xBD7E, 0
96A2  F05E     NOP
634:           	SetData(&(DWD[2].Dt2),led_E,led_c);							//wsp.ECO
96A4  EC06     CALL 0x7C0C, 0
96A6  F03E     NOP
96A8  0E79     MOVLW 0x79
96AA  6F76     MOVWF _PFNf_prn_in, BANKED
96AC  0E58     MOVLW 0x58
96AE  6F77     MOVWF _PFNf_prn_pg, BANKED
96B0  ECBF     CALL 0xBD7E, 0
96B2  F05E     NOP
635:           	SetData(&(DWD[3].Dt2),BLACK,BLACK);						//Ec
96B4  ECF5     CALL 0x7BEA, 0
96B6  F03D     NOP
96B8  ECBF     CALL 0xBD7E, 0
96BA  F05E     NOP
636:           	//SetData(&(DWD[3].Dt2),led_E,led_c);
637:           	SetStatus(&(DWD[2].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_PGD|_KZ_DCO,_KZ_TCO|_KZ_BAR);
96BC  EC67     CALL 0x78CE, 0
96BE  F03C     NOP
96C0  0EC4     MOVLW 0xC4
96C2  ECC9     CALL 0x4B92, 0
96C4  F025     NOP
96C6  0E81     MOVLW 0x81
96C8  6F7A     MOVWF _PFNf_res, BANKED
96CA  0E50     MOVLW 0x50
96CC  6F7B     MOVWF _PFNf_rozruch, BANKED
96CE  EC3E     CALL 0x627C, 0
96D0  F031     NOP
638:           	SetStatus(&(DWD[3].St),tWYGAS|tRDID,tALL,0,_KZ_PGD|_KZ_TCO|_KZ_DCO|_KZ_BAR);
96D2  ECF0     CALL 0x7BE0, 0
96D4  F03D     NOP
96D6  ECB3     CALL 0x4B66, 0
96D8  F025     NOP
96DA  0ED1     MOVLW 0xD1
96DC  6F7B     MOVWF _PFNf_rozruch, BANKED
96DE  EC3E     CALL 0x627C, 0
96E0  F031     NOP
639:           	SetStatus(&(DWD[2].St2),tLED|tRDID,tALL,0,_KZ_TCW);
96E2  ECFC     CALL 0x7BF8, 0
96E4  F03D     NOP
96E6  6B77     CLRF _PFNf_prn_pg, BANKED
96E8  0E10     MOVLW 0x10
96EA  6F76     MOVWF _PFNf_prn_in, BANKED
96EC  EC25     CALL 0xA84A, 0
96EE  F054     NOP
96F0  EC3E     CALL 0x627C, 0
96F2  F031     NOP
640:           	SetStatus(&(DWD[3].St2),tWYGAS|tRDID,tALL,0,_KZ_TCW);
96F4  0E86     MOVLW 0x86
96F6  EC5F     CALL 0x78BE, 0
96F8  F03C     NOP
96FA  ECB3     CALL 0x4B66, 0
96FC  F025     NOP
96FE  0E20     MOVLW 0x20
9700  6F7B     MOVWF _PFNf_rozruch, BANKED
9702  EC3E     CALL 0x627C, 0
9704  F031     NOP
641:           	//SetStatus(&(DWD[3].St2),tLED|tRDID,tALL,0,_KZ_TCW);
642:           	MarkMinMaxECO();
9706  EC00     CALL 0xAE00, 0
9708  F057     NOP
643:           	RestartKol1(_KL_NCWCO);
970A  0E01     MOVLW 0x1
970C  EF02     GOTO 0xBE04
970E  F05F     NOP
644:           }
645:           //----------
646:           //usuwa wskaz nastawy CW/CO
647:           void EndNst(void)
648:           {
649:           	ResetKol(_KL_NCWCO);
C26C  0E01     MOVLW 0x1
C26E  EF0F     GOTO 0xBE1E
C270  F05F     NOP
650:           }
651:           //---------------------------------------------------------
652:           //---------------------------------------------------------
653:           //wyswietla kod L3 naprzemiennie z temperatura CO
654:           /*
655:           void PrintL3(void)
656:           {
657:           	SetData(&DWD[5],led_L,led_3);
658:           	SetStatus(&DWD[5],tLED|tFOCUS,tALL);				//L
659:           	if(DtCO._err_CO)
660:           	{
661:           		SetData(&DWD[6],led_L,led_3);
662:           		SetStatus(&DWD[6],tLED|tFOCUS,tALL);				//3
663:           	}
664:           	else
665:           	{
666:           		SetData(&DWD[6],0,DtCO.SCO);
667:           		SetStatus(&DWD[6],tDEC|tFOCUS,tALL);				//3
668:           	}
669:           	SetPoz(_KL_MSG,0);
670:           	SetPoz(_KL_MSG,1);
671:           }
672:           //----------
673:           //usuwa wskaz komunikatu
674:           void EndL3(void)
675:           {
676:           	ResetKol(_KL_MSG);
677:           }
678:           */
679:           //---------------------------------------------------------
680:           //---------------------------------------------------------
681:           //Wysterowuje znak z 
682:           //dla s=0 wygaszenie
683:           //dla s=1 zapalenie
684:           //dla s>1 pulsacja
685:           void Mark(unsigned char z,unsigned char s)
B83E  0100     MOVLB 0x0
B840  6F7B     MOVWF _PFNf_rozruch, BANKED
686:           {
687:           	SetMark(&KMark[z],1,s>1,s);		//zapal znak
B842  0EE2     MOVLW 0xE2
B844  257B     ADDWF _PFNf_rozruch, W, BANKED
B846  6F74     MOVWF _PFNf_prODP, BANKED
B848  6B75     CLRF _PFNf_prn_cs, BANKED
B84A  0E03     MOVLW 0x3
B84C  2375     ADDWFC _PFNf_prn_cs, F, BANKED
B84E  0E01     MOVLW 0x1
B850  6F76     MOVWF _PFNf_prn_in, BANKED
B852  0E02     MOVLW 0x2
B854  617A     CPFSLT _PFNf_res, BANKED
B856  D001     BRA 0xB85A
B858  D002     BRA 0xB85E
B85A  0E01     MOVLW 0x1
B85C  D001     BRA 0xB860
B85E  0E00     MOVLW 0x0
B860  6F77     MOVWF _PFNf_prn_pg, BANKED
B862  C07A     MOVFF _PFNf_res, _PFNf_prn_pp
B864  F078     NOP
B866  EF14     GOTO 0xA628
B868  F053     NOP
688:           	//UpdateWSW();
689:           }
690:           //---------------------------------------------------------
691:           //---------------------------------------------------------
692:           //wysterowanie znakow dla funkcji serwisowej
693:           /*void MarkSVAL(unsigned char s,unsigned char mx,unsigned al)
694:           {
695:           	//static unsigned char bs;
696:           
697:           	//Mark(_GZ_SRV,s);
698:           	if(s)
699:           	{
700:           		if(!al)
701:           		{
702:           			Mark(_GZ_MXCO,mx);
703:           			Mark(_GZ_MNCO,!mx);
704:           		}
705:           		else
706:           		{
707:           			Mark(_GZ_MXCW,1);	//zapal max dla antylegionella
708:           		}
709:           	}
710:           	else
711:           	{
712:           		//if(bs!=s)
713:           		{
714:           			Mark(_GZ_MXCO,0);
715:           			Mark(_GZ_MNCO,0);
716:           			Mark(_GZ_MXCW,0);
717:           		}
718:           	}
719:           	//bs=s;
720:           }*/
721:           void ClrMarkMinMax(void)
722:           {
723:           	Mark(_GZ_MXCO,0);
BC06  0100     MOVLB 0x0
BC08  6B7A     CLRF _PFNf_res, BANKED
BC0A  0E0D     MOVLW 0xD
BC0C  EC1F     CALL 0xB83E, 0
BC0E  F05C     NOP
724:           	Mark(_GZ_MNCO,0);
BC10  6B7A     CLRF _PFNf_res, BANKED
BC12  0E0E     MOVLW 0xE
BC14  EC1F     CALL 0xB83E, 0
BC16  F05C     NOP
725:           	Mark(_GZ_MXCW,0);
BC18  6B7A     CLRF _PFNf_res, BANKED
BC1A  0E0B     MOVLW 0xB
BC1C  EC1F     CALL 0xB83E, 0
BC1E  F05C     NOP
726:           	Mark(_GZ_MNCW,0);
BC20  6B7A     CLRF _PFNf_res, BANKED
BC22  0E0C     MOVLW 0xC
BC24  EF1F     GOTO 0xB83E
BC26  F05C     NOP
727:           }
728:           //---------------------------------------------------------
729:           //---------------------------------------------------------
730:           //---------------------------------------------------------
731:           //---------------------------------------------------------
732:           //---------------------------------------------------------
733:           //---------------------------------------------------------
734:           //wyswietla cisnienie CS
735:           void PrintCS(const unsigned char cs,const unsigned char only)
9574  0100     MOVLB 0x0
9576  6F7F     MOVWF _PFNf_set_fnserw, BANKED
736:           {
737:           	unsigned int fl;
738:           	fl=(!only)?0:tONL;
9578  517E     MOVF _PFNf_set_eco, W, BANKED
957A  E004     BZ 0x9584
957C  6B81     CLRF _PFNf_set_ncw, BANKED
957E  0E04     MOVLW 0x4
9580  6F80     MOVWF _PFNf_set_nco, BANKED
9582  D002     BRA 0x9588
9584  6B80     CLRF _PFNf_set_nco, BANKED
9586  6B81     CLRF _PFNf_set_ncw, BANKED
739:           #if LCD4D==0
740:           	SetStatus(&(PWD[_WS_CS].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);			//| _KZ_DCOcisnienie
741:           	SetData(&(PWD[_WS_CS].Dt),0,cs);
742:           #else
743:               if(!PFNf_errCS&&!PFNf_fnoCS)
9588  AA09     BTFSS PFNf_b_str_nco, 5, ACCESS
958A  B80A     BTFSC PFNf_firstEdge, 4, ACCESS
958C  D012     BRA 0x95B2
958E  D82B     RCALL PL42
744:               {
745:                   SetStatus(&(PWD[_WS_CS].St),fl|tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);			//| _KZ_DCOcisnienie
9590  0E30     MOVLW 0x30
9592  1180     IORWF _PFNf_set_nco, W, BANKED
9594  6F76     MOVWF _PFNf_prn_in, BANKED
9596  0EC4     MOVLW 0xC4
9598  1181     IORWF _PFNf_set_ncw, W, BANKED
959A  6F77     MOVWF _PFNf_prn_pg, BANKED
959C  D829     RCALL PL302
959E  EC3E     CALL 0x627C, 0
95A0  F031     NOP
95A2  EC82     CALL 0x9D04, 0
95A4  F04E     NOP
746:                   SetData(&(PWD[_WS_CS].Dt),0,cs);
95A6  6B76     CLRF _PFNf_prn_in, BANKED
95A8  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_pg
95AA  F077     NOP
95AC  ECBF     CALL 0xBD7E, 0
95AE  F05E     NOP
747:               }
95B0  D010     BRA 0x95D2
748:               else
749:               {
750:                   SetStatus(&(PWD[_WS_CS].St),fl|tLED|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);	//tempetratura IN
95B2  D819     RCALL PL42
95B4  0E30     MOVLW 0x30
95B6  1180     IORWF _PFNf_set_nco, W, BANKED
95B8  6F76     MOVWF _PFNf_prn_in, BANKED
95BA  0E80     MOVLW 0x80
95BC  1181     IORWF _PFNf_set_ncw, W, BANKED
95BE  6F77     MOVWF _PFNf_prn_pg, BANKED
95C0  D817     RCALL PL302
95C2  EC3E     CALL 0x627C, 0
95C4  F031     NOP
95C6  EC82     CALL 0x9D04, 0
95C8  F04E     NOP
95CA  ECEB     CALL 0x4BD6, 0
95CC  F025     NOP
751:                   SetData(&(PWD[_WS_CS].Dt),KRESKA,KRESKA);        
95CE  ECBF     CALL 0xBD7E, 0
95D0  F05E     NOP
752:               }
753:           	if(!only) SetStatus(&(PWD[_WS_CS].St2),tWYGAS|tFOCUS,tALL,0,0);
95D2  517E     MOVF _PFNf_set_eco, W, BANKED
95D4  A4D8     BTFSS STATUS, 2, ACCESS
95D6  0012     RETURN 0
95D8  EC89     CALL 0x9B12, 0
95DA  F04D     NOP
95DC  0E83     MOVLW 0x83
95DE  ECC9     CALL 0x9B92, 0
95E0  F04D     NOP
95E2  EF3E     GOTO 0x627C
95E4  F031     NOP
754:           #endif
755:           	//UpdateWSW();
756:           }
757:           //---------------------------------------------------------
758:           //---------------------------------------------------------
759:           //wyswietla temperature CW gdy aktywne grznie w obiegu CW
760:           //ustawia diode grzania CW w stan aktywny
761:           void PrintCW(const unsigned char tm,const unsigned char only)
AA5E  0100     MOVLB 0x0
AA60  6F7F     MOVWF _PFNf_set_fnserw, BANKED
762:           {
763:           	unsigned int fl;
764:           	fl=(!only)?0:tONL;
AA62  517E     MOVF _PFNf_set_eco, W, BANKED
AA64  E004     BZ 0xAA6E
AA66  6B81     CLRF _PFNf_set_ncw, BANKED
AA68  0E04     MOVLW 0x4
AA6A  6F80     MOVWF _PFNf_set_nco, BANKED
AA6C  D002     BRA 0xAA72
AA6E  6B80     CLRF _PFNf_set_nco, BANKED
AA70  6B81     CLRF _PFNf_set_ncw, BANKED
765:           #if LCD4D==0
766:           	SetStatus(&(PWD[_WS_TCW].St),tDEC|tSDID|tFOCUS,tALL,_KZ_TCW,0);//|_KZ_DCW,0);
767:           	SetData(&(PWD[_WS_TCW].Dt),0,tm);						//tempetratura CW
768:           #else
769:           	SetStatus(&(PWD[_WS_TCW].St2),fl|tDEC|tSDID|tFOCUS,tALL,_KZ_TCW,0);//|_KZ_DCW,0);
AA72  EC89     CALL 0x9B12, 0
AA74  F04D     NOP
AA76  0E20     MOVLW 0x20
AA78  1180     IORWF _PFNf_set_nco, W, BANKED
AA7A  6F76     MOVWF _PFNf_prn_in, BANKED
AA7C  0EC0     MOVLW 0xC0
AA7E  1181     IORWF _PFNf_set_ncw, W, BANKED
AA80  6F77     MOVWF _PFNf_prn_pg, BANKED
AA82  6979     SETF _PFNf_prn_res, BANKED
AA84  6978     SETF _PFNf_prn_pp, BANKED
AA86  0E20     MOVLW 0x20
AA88  6F7A     MOVWF _PFNf_res, BANKED
AA8A  6B7B     CLRF _PFNf_rozruch, BANKED
AA8C  EC3E     CALL 0x627C, 0
AA8E  F031     NOP
AA90  EC41     CALL 0x9C82, 0
AA92  F04E     NOP
770:           	SetData(&(PWD[_WS_TCW].Dt2),0,tm);						//tempetratura CW
AA94  6B76     CLRF _PFNf_prn_in, BANKED
AA96  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_pg
AA98  F077     NOP
AA9A  ECBF     CALL 0xBD7E, 0
AA9C  F05E     NOP
771:           	if(!only) SetStatus(&(PWD[_WS_TCW].St),tWYGAS|tFOCUS,tALL,0,0);
AA9E  517E     MOVF _PFNf_set_eco, W, BANKED
AAA0  A4D8     BTFSS STATUS, 2, ACCESS
AAA2  0012     RETURN 0
AAA4  ECF3     CALL 0x95E6, 0
AAA6  F04A     NOP
AAA8  0E83     MOVLW 0x83
AAAA  ECC9     CALL 0x9B92, 0
AAAC  F04D     NOP
AAAE  EF3E     GOTO 0x627C
AAB0  F031     NOP
772:           #endif
773:           	//UpdateWSW();
774:           }
775:           //---------------------------------------------------------
776:           //---------------------------------------------------------
777:           //wyswietla wersje oprogramowania
778:           //gdzie 
779:           //board- kolejny nr plytki sterujacej (format 0xbn - gdzie n to nr od 1 do 9)
780:           //ver - wersja oprogramowania dla plytki o podanym numerze
781:           void PrintVER(const unsigned char board, const signed char ver,const unsigned char only)
9B26  6F80     MOVWF _PFNf_set_nco, BANKED
782:           {
783:           	SetStatus(&(PWD[_WS_TCW].St2),tHEX|tFOCUS,tALL,0,0);
9B28  0EAA     MOVLW 0xAA
9B2A  0100     MOVLB 0x0
9B2C  6F74     MOVWF _PFNf_prODP, BANKED
9B2E  0E03     MOVLW 0x3
9B30  6F75     MOVWF _PFNf_prn_cs, BANKED
9B32  0EA0     MOVLW 0xA0
9B34  D82E     RCALL __end_of_PrintVER
9B36  EC3E     CALL 0x627C, 0
9B38  F031     NOP
9B3A  EC41     CALL 0x9C82, 0
9B3C  F04E     NOP
784:           	SetData(&(PWD[_WS_TCW].Dt2),0,board);
9B3E  6B76     CLRF _PFNf_prn_in, BANKED
9B40  C080     MOVFF _PFNf_set_nco, _PFNf_prn_pg
9B42  F077     NOP
9B44  ECBF     CALL 0xBD7E, 0
9B46  F05E     NOP
785:               if(ver>=0)
9B48  BF7E     BTFSC _PFNf_set_eco, 7, BANKED
9B4A  D00E     BRA 0x9B68
9B4C  ECF3     CALL 0x95E6, 0
9B4E  F04A     NOP
786:               {
787:                   SetStatus(&(PWD[_WS_TCO].St),tDEC|tFOCUS,tALL,0,0);
9B50  0EC0     MOVLW 0xC0
9B52  D81F     RCALL __end_of_PrintVER
9B54  EC3E     CALL 0x627C, 0
9B56  F031     NOP
9B58  EC82     CALL 0x9D04, 0
9B5A  F04E     NOP
788:                   SetData(&(PWD[_WS_TCO].Dt),0,ver);	//wskaz bez kropki (dla wersji 1 wskaz 01)
9B5C  6B76     CLRF _PFNf_prn_in, BANKED
9B5E  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
9B60  F077     NOP
9B62  ECBF     CALL 0xBD7E, 0
9B64  F05E     NOP
789:               }
9B66  D00C     BRA 0x9B80
790:               else
791:               {
792:                   SetStatus(&(PWD[_WS_TCO].St),tLED|tFOCUS,tALL,0,0);	
9B68  0EA0     MOVLW 0xA0
9B6A  EC7E     CALL 0x9CFC, 0
9B6C  F04E     NOP
9B6E  D811     RCALL __end_of_PrintVER
9B70  EC3E     CALL 0x627C, 0
9B72  F031     NOP
9B74  EC82     CALL 0x9D04, 0
9B76  F04E     NOP
9B78  ECEB     CALL 0x4BD6, 0
9B7A  F025     NOP
793:                   SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);  //w miejscu wersji dwie kreski      
9B7C  ECBF     CALL 0xBD7E, 0
9B7E  F05E     NOP
794:               }
795:           	if(!only) SetStatus(&(PWD[_WS_TCW].St),tWYGAS|tFOCUS,tALL,0,0);
9B80  517F     MOVF _PFNf_set_fnserw, W, BANKED
9B82  A4D8     BTFSS STATUS, 2, ACCESS
9B84  0012     RETURN 0
9B86  ECF3     CALL 0x95E6, 0
9B88  F04A     NOP
9B8A  0E83     MOVLW 0x83
9B8C  D802     RCALL __end_of_PrintVER
9B8E  EF3E     GOTO 0x627C
9B90  F031     NOP
796:           }
797:           //---------------------------------------------------------
798:           //---------------------------------------------------------
799:           //wyswietla predkosc obrotowa gdy pracuje wentylator
800:           void PrintVNT(const unsigned char vn,const unsigned char only)
A7FE  0100     MOVLB 0x0
A800  6F7F     MOVWF _PFNf_set_fnserw, BANKED
801:           {
802:           	unsigned int fl;
803:           	fl=(!only)?0:tONL;
A802  517E     MOVF _PFNf_set_eco, W, BANKED
A804  E004     BZ 0xA80E
A806  6B81     CLRF _PFNf_set_ncw, BANKED
A808  0E04     MOVLW 0x4
A80A  6F80     MOVWF _PFNf_set_nco, BANKED
A80C  D002     BRA 0xA812
A80E  6B80     CLRF _PFNf_set_nco, BANKED
A810  6B81     CLRF _PFNf_set_ncw, BANKED
804:           #if LCD4D==0
805:           	SetStatus(&(PWD[_WS_TCW].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_TCW);//|_KZ_DCW,0);
806:           	SetData(&(PWD[_WS_TCW].Dt),0,vn);						//tempetratura CW
807:           #else
808:           	SetStatus(&(PWD[_WS_TCW].St2),fl|tDEC|tRDID|tFOCUS,tALL,0,_KZ_TCW);//|_KZ_DCW,0);
A812  EC89     CALL 0x9B12, 0
A814  F04D     NOP
A816  0E10     MOVLW 0x10
A818  1180     IORWF _PFNf_set_nco, W, BANKED
A81A  6F76     MOVWF _PFNf_prn_in, BANKED
A81C  0EC0     MOVLW 0xC0
A81E  1181     IORWF _PFNf_set_ncw, W, BANKED
A820  6F77     MOVWF _PFNf_prn_pg, BANKED
A822  D813     RCALL __end_of_PrintVNT
A824  EC3E     CALL 0x627C, 0
A826  F031     NOP
809:           	SetData(&(PWD[_WS_TCW].Dt2),0,vn);						//tempetratura CW
A828  EC41     CALL 0x9C82, 0
A82A  F04E     NOP
A82C  6B76     CLRF _PFNf_prn_in, BANKED
A82E  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_pg
A830  F077     NOP
A832  ECBF     CALL 0xBD7E, 0
A834  F05E     NOP
810:           	if(!only) SetStatus(&(PWD[_WS_TCW].St),tWYGAS|tFOCUS,tALL,0,0);
A836  517E     MOVF _PFNf_set_eco, W, BANKED
A838  A4D8     BTFSS STATUS, 2, ACCESS
A83A  0012     RETURN 0
A83C  ECF3     CALL 0x95E6, 0
A83E  F04A     NOP
A840  0E83     MOVLW 0x83
A842  ECC9     CALL 0x9B92, 0
A844  F04D     NOP
A846  EF3E     GOTO 0x627C
A848  F031     NOP
811:           #endif
812:           	//UpdateWSW();
813:           }
814:           //---------------------------------------------------------
815:           //---------------------------------------------------------
816:           //Wskazy o najnizszym priorytecie wyswietlania
817:           //wyswietla temperature CO
818:           void PrintCO(const unsigned char tm,const unsigned char only, const unsigned char l3)
98A2  0100     MOVLB 0x0
98A4  6F80     MOVWF _PFNf_set_nco, BANKED
819:           {
820:           	unsigned int fl;
821:           	fl=(!only)?0:tONL;
98A6  517E     MOVF _PFNf_set_eco, W, BANKED
98A8  E005     BZ 0x98B4
98AA  0E00     MOVLW 0x0
98AC  6F82     MOVWF _PFNf_str_nco, BANKED
98AE  0E04     MOVLW 0x4
98B0  6F81     MOVWF _PFNf_set_ncw, BANKED
98B2  D002     BRA 0x98B8
98B4  6B81     CLRF _PFNf_set_ncw, BANKED
98B6  6B82     CLRF _PFNf_str_nco, BANKED
822:           	if(!l3)		//aktywna blokada L3?
98B8  517F     MOVF _PFNf_set_fnserw, W, BANKED
98BA  E11F     BNZ 0x98FA
98BC  ECF3     CALL 0x95E6, 0
98BE  F04A     NOP
823:           	{
824:           	#if LCD4D==0
825:           		SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
826:           		SetData(&(PWD[_WS_TCO].Dt),0,tm);													//tempetratura CO
827:           	#else
828:           		SetStatus(&(PWD[_WS_TCO].St),fl|tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
98C0  0E30     MOVLW 0x30
98C2  1181     IORWF _PFNf_set_ncw, W, BANKED
98C4  6F76     MOVWF _PFNf_prn_in, BANKED
98C6  0EC0     MOVLW 0xC0
98C8  1182     IORWF _PFNf_str_nco, W, BANKED
98CA  6F77     MOVWF _PFNf_prn_pg, BANKED
98CC  6979     SETF _PFNf_prn_res, BANKED
98CE  6978     SETF _PFNf_prn_pp, BANKED
98D0  ECF8     CALL 0x4BF0, 0
98D2  F025     NOP
98D4  EC3E     CALL 0x627C, 0
98D6  F031     NOP
98D8  EC82     CALL 0x9D04, 0
98DA  F04E     NOP
829:           		SetData(&(PWD[_WS_TCO].Dt),0,tm);												//tempetratura CO
98DC  6B76     CLRF _PFNf_prn_in, BANKED
98DE  C080     MOVFF _PFNf_set_nco, _PFNf_prn_pg
98E0  F077     NOP
98E2  ECBF     CALL 0xBD7E, 0
98E4  F05E     NOP
830:           		if(!only) SetStatus(&(PWD[_WS_TCO].St2),tWYGAS|tFOCUS,tALL,0,0);
98E6  517E     MOVF _PFNf_set_eco, W, BANKED
98E8  A4D8     BTFSS STATUS, 2, ACCESS
98EA  0012     RETURN 0
98EC  EC89     CALL 0x9B12, 0
98EE  F04D     NOP
98F0  0E83     MOVLW 0x83
98F2  ECC9     CALL 0x9B92, 0
98F4  F04D     NOP
98F6  EF3E     GOTO 0x627C
98F8  F031     NOP
831:           	#endif
832:           	}
833:           	else
834:           	{
835:           	#if LCD4D==0
836:           		SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);
837:           		SetData(&(PWD[_WS_TCO].Dt),led_L,led_3);										//kod L3
838:           	#else
839:           		SetStatus(&(PWD[_WS_TCO].St),fl|tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);
98FA  ECF3     CALL 0x95E6, 0
98FC  F04A     NOP
98FE  0E10     MOVLW 0x10
9900  1181     IORWF _PFNf_set_ncw, W, BANKED
9902  6F76     MOVWF _PFNf_prn_in, BANKED
9904  0E80     MOVLW 0x80
9906  1182     IORWF _PFNf_str_nco, W, BANKED
9908  ECE0     CALL 0x8DC0, 0
990A  F046     NOP
990C  0E50     MOVLW 0x50
990E  6F7B     MOVWF _PFNf_rozruch, BANKED
9910  EC3E     CALL 0x627C, 0
9912  F031     NOP
9914  EC82     CALL 0x9D04, 0
9916  F04E     NOP
840:           		SetData(&(PWD[_WS_TCO].Dt),led_L,led_3);										//kod L3
9918  ECFD     CALL 0x4BFA, 0
991A  F025     NOP
991C  ECBF     CALL 0xBD7E, 0
991E  F05E     NOP
841:           		if(!only) SetStatus(&(PWD[_WS_TCO].St2),tWYGAS|tFOCUS,tALL,0,0);
9920  517E     MOVF _PFNf_set_eco, W, BANKED
9922  E0E4     BZ 0x98EC
9924  0012     RETURN 0
842:           	#endif
843:           	}
844:           }
845:           
846:           //---------------------------------------------------------
847:           //---------------------------------------------------------
848:           //wyswietla temperature IN 
849:           void PrintIN(const unsigned char tm)
9FD8  0100     MOVLB 0x0
9FDA  6F7E     MOVWF _PFNf_set_eco, BANKED
9FDC  EC89     CALL 0x9B12, 0
9FDE  F04D     NOP
850:           {
851:           #if LCD4D==0
852:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
853:           	SetData(&(PWD[_WS_TCO].Dt),0,tm);												//tempetratura IN
854:           #else
855:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
9FE0  0E80     MOVLW 0x80
9FE2  ECB3     CALL 0x4B66, 0
9FE4  F025     NOP
9FE6  0E20     MOVLW 0x20
9FE8  6F7B     MOVWF _PFNf_rozruch, BANKED
9FEA  EC3E     CALL 0x627C, 0
9FEC  F031     NOP
9FEE  EC41     CALL 0x9C82, 0
9FF0  F04E     NOP
856:           	SetData(&(PWD[_WS_TCW].Dt2),led_I,led_n);
9FF2  0E30     MOVLW 0x30
9FF4  D827     RCALL PL782
9FF6  ECBF     CALL 0xBD7E, 0
9FF8  F05E     NOP
857:               if(!PFNf_errIN)
9FFA  BE09     BTFSC PFNf_b_str_nco, 7, ACCESS
9FFC  D00F     BRA 0xA01C
9FFE  ECF3     CALL 0x95E6, 0
A000  F04A     NOP
858:               {
859:                   SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);	//tempetratura IN
A002  0EC0     MOVLW 0xC0
A004  ECC9     CALL 0x4B92, 0
A006  F025     NOP
A008  D818     RCALL PL626
A00A  EC3E     CALL 0x627C, 0
A00C  F031     NOP
A00E  EC82     CALL 0x9D04, 0
A010  F04E     NOP
860:                   SetData(&(PWD[_WS_TCO].Dt),0,tm);
A012  6B76     CLRF _PFNf_prn_in, BANKED
A014  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
A016  F077     NOP
A018  EFBF     GOTO 0xBD7E
A01A  F05E     NOP
861:               }
862:               else
863:               {
864:                   SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	//tempetratura IN
A01C  0EA0     MOVLW 0xA0
A01E  EC7E     CALL 0x9CFC, 0
A020  F04E     NOP
A022  ECB3     CALL 0x4B66, 0
A024  F025     NOP
A026  0E50     MOVLW 0x50
A028  6F7B     MOVWF _PFNf_rozruch, BANKED
A02A  EC3E     CALL 0x627C, 0
A02C  F031     NOP
A02E  EC82     CALL 0x9D04, 0
A030  F04E     NOP
A032  ECEB     CALL 0x4BD6, 0
A034  F025     NOP
865:                   SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);        
A036  EFBF     GOTO 0xBD7E
A038  F05E     NOP
866:               }
867:           #endif
868:           }
869:           //---------------------------------------------------------
870:           //---------------------------------------------------------
871:           //wyswietla wartosc PP 
872:           void PrintPP(unsigned char pp)
9C94  0100     MOVLB 0x0
9C96  6F7E     MOVWF _PFNf_set_eco, BANKED
873:           {
874:           	if(pp>99) pp=99;
9C98  0E63     MOVLW 0x63
9C9A  657E     CPFSGT _PFNf_set_eco, BANKED
9C9C  D001     BRA 0x9CA0
9C9E  6F7E     MOVWF _PFNf_set_eco, BANKED
875:           #if LCD4D==0
876:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
877:           	SetData(&(PWD[_WS_TCO].Dt),0,pp);												
878:           #else
879:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
9CA0  EC89     CALL 0x9B12, 0
9CA2  F04D     NOP
9CA4  0E80     MOVLW 0x80
9CA6  ECB3     CALL 0x4B66, 0
9CA8  F025     NOP
9CAA  0E20     MOVLW 0x20
9CAC  6F7B     MOVWF _PFNf_rozruch, BANKED
9CAE  EC3E     CALL 0x627C, 0
9CB0  F031     NOP
9CB2  EC41     CALL 0x9C82, 0
9CB4  F04E     NOP
880:           	SetData(&(PWD[_WS_TCW].Dt2),led_P,led_r);
9CB6  0E73     MOVLW 0x73
9CB8  ECA7     CALL 0xAB4E, 0
9CBA  F055     NOP
9CBC  ECBF     CALL 0xBD7E, 0
9CBE  F05E     NOP
881:               if(PFNf_pmpPWM)
9CC0  A20E     BTFSS PFNf_popFN, 1, ACCESS
9CC2  D00F     BRA 0x9CE2
9CC4  ECF3     CALL 0x95E6, 0
9CC6  F04A     NOP
882:               {
883:                   SetStatus(&(PWD[_WS_TCO].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	
9CC8  0EC0     MOVLW 0xC0
9CCA  ECB3     CALL 0x4B66, 0
9CCC  F025     NOP
9CCE  0E50     MOVLW 0x50
9CD0  6F7B     MOVWF _PFNf_rozruch, BANKED
9CD2  EC3E     CALL 0x627C, 0
9CD4  F031     NOP
9CD6  D816     RCALL PL62
884:                   SetData(&(PWD[_WS_TCO].Dt),0,pp);
9CD8  6B76     CLRF _PFNf_prn_in, BANKED
9CDA  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
9CDC  F077     NOP
9CDE  EFBF     GOTO 0xBD7E
9CE0  F05E     NOP
885:               }
886:               else
887:               {
888:                   SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	//tempetratura IN
9CE2  0EA0     MOVLW 0xA0
9CE4  D80B     RCALL PL38
9CE6  ECB3     CALL 0x4B66, 0
9CE8  F025     NOP
9CEA  0E50     MOVLW 0x50
9CEC  6F7B     MOVWF _PFNf_rozruch, BANKED
9CEE  EC3E     CALL 0x627C, 0
9CF0  F031     NOP
9CF2  D808     RCALL PL62
9CF4  ECEB     CALL 0x4BD6, 0
9CF6  F025     NOP
889:                   SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);        
9CF8  EFBF     GOTO 0xBD7E
9CFA  F05E     NOP
890:               }
891:           #endif
892:           }
893:           //---------------------------------------------------------
894:           //---------------------------------------------------------
895:           //wyswietla wartosc PG 
896:           void PrintPG(unsigned char pg)
AB04  0100     MOVLB 0x0
AB06  6F7E     MOVWF _PFNf_set_eco, BANKED
897:           {
898:           	if(pg>99) pg=99;
AB08  0E63     MOVLW 0x63
AB0A  657E     CPFSGT _PFNf_set_eco, BANKED
AB0C  D001     BRA 0xAB10
AB0E  6F7E     MOVWF _PFNf_set_eco, BANKED
899:           #if LCD4D==0
900:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
901:           	SetData(&(PWD[_WS_TCO].Dt),0,pg);												//tempetratura IN
902:           #else
903:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
AB10  EC89     CALL 0x9B12, 0
AB12  F04D     NOP
AB14  0E80     MOVLW 0x80
AB16  ECB3     CALL 0x4B66, 0
AB18  F025     NOP
AB1A  0E20     MOVLW 0x20
AB1C  6F7B     MOVWF _PFNf_rozruch, BANKED
AB1E  EC3E     CALL 0x627C, 0
AB20  F031     NOP
AB22  EC41     CALL 0x9C82, 0
AB24  F04E     NOP
904:           	SetData(&(PWD[_WS_TCW].Dt2),led_F,led_r);						
AB26  0E71     MOVLW 0x71
AB28  D812     RCALL PL814
AB2A  ECBF     CALL 0xBD7E, 0
AB2C  F05E     NOP
AB2E  ECF3     CALL 0x95E6, 0
AB30  F04A     NOP
905:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	
AB32  0EC0     MOVLW 0xC0
AB34  ECB3     CALL 0x4B66, 0
AB36  F025     NOP
AB38  0E50     MOVLW 0x50
AB3A  6F7B     MOVWF _PFNf_rozruch, BANKED
AB3C  EC3E     CALL 0x627C, 0
AB3E  F031     NOP
AB40  EC82     CALL 0x9D04, 0
AB42  F04E     NOP
906:           	SetData(&(PWD[_WS_TCO].Dt),0,pg);
AB44  6B76     CLRF _PFNf_prn_in, BANKED
AB46  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
AB48  F077     NOP
AB4A  EFBF     GOTO 0xBD7E
AB4C  F05E     NOP
907:           #endif
908:           }
909:           //---------------------------------------------------------
910:           //---------------------------------------------------------
911:           //wyswietla temperature CO w trakcie grzania CW po nacisnieciu przycisku RESET 
912:           void PrintCo(const unsigned char tm)
A494  0100     MOVLB 0x0
A496  6F7E     MOVWF _PFNf_set_eco, BANKED
A498  EC89     CALL 0x9B12, 0
A49A  F04D     NOP
913:           {
914:           #if LCD4D==0
915:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
916:           	SetData(&(PWD[_WS_TCO].Dt),0,tm);												//tempetratura IN
917:           #else
918:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
A49C  0E80     MOVLW 0x80
A49E  ECB3     CALL 0x4B66, 0
A4A0  F025     NOP
A4A2  0E20     MOVLW 0x20
A4A4  6F7B     MOVWF _PFNf_rozruch, BANKED
A4A6  EC3E     CALL 0x627C, 0
A4A8  F031     NOP
A4AA  EC41     CALL 0x9C82, 0
A4AC  F04E     NOP
919:           	SetData(&(PWD[_WS_TCW].Dt2),led_C,led_h);	
A4AE  0E39     MOVLW 0x39
A4B0  6F76     MOVWF _PFNf_prn_in, BANKED
A4B2  0E74     MOVLW 0x74
A4B4  6F77     MOVWF _PFNf_prn_pg, BANKED
A4B6  ECBF     CALL 0xBD7E, 0
A4B8  F05E     NOP
920:               if(!PFNf_errCO)
A4BA  B809     BTFSC PFNf_b_str_nco, 4, ACCESS
A4BC  D010     BRA 0xA4DE
A4BE  ECF3     CALL 0x95E6, 0
A4C0  F04A     NOP
921:               {
922:                   SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);	//tempetratura IN
A4C2  0EC0     MOVLW 0xC0
A4C4  ECC9     CALL 0x4B92, 0
A4C6  F025     NOP
A4C8  EC1D     CALL 0xA03A, 0
A4CA  F050     NOP
A4CC  EC3E     CALL 0x627C, 0
A4CE  F031     NOP
A4D0  EC82     CALL 0x9D04, 0
A4D2  F04E     NOP
923:                   SetData(&(PWD[_WS_TCO].Dt),0,tm);
A4D4  6B76     CLRF _PFNf_prn_in, BANKED
A4D6  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
A4D8  F077     NOP
A4DA  EFBF     GOTO 0xBD7E
A4DC  F05E     NOP
924:               }
925:               else
926:               {
927:                   SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	//tempetratura IN
A4DE  0EA0     MOVLW 0xA0
A4E0  EC7E     CALL 0x9CFC, 0
A4E2  F04E     NOP
A4E4  ECB3     CALL 0x4B66, 0
A4E6  F025     NOP
A4E8  0E50     MOVLW 0x50
A4EA  6F7B     MOVWF _PFNf_rozruch, BANKED
A4EC  EC3E     CALL 0x627C, 0
A4EE  F031     NOP
A4F0  EC82     CALL 0x9D04, 0
A4F2  F04E     NOP
A4F4  ECEB     CALL 0x4BD6, 0
A4F6  F025     NOP
928:                   SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);        
A4F8  EFBF     GOTO 0xBD7E
A4FA  F05E     NOP
929:               }
930:           #endif
931:           }
932:           //---------------------------------------------------------
933:           //---------------------------------------------------------
934:           //wyswietla symbol Po i cisnienie CS
935:           void PrintPo(const unsigned char cs)
9C1A  0100     MOVLB 0x0
9C1C  6F7E     MOVWF _PFNf_set_eco, BANKED
9C1E  EC89     CALL 0x9B12, 0
9C20  F04D     NOP
936:           {
937:           #if LCD4D==0
938:           	SetStatus(&(PWD[_WS_CS].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_BAR,_KZ_TCO);			//| _KZ_DCOcisnienie
939:           	SetData(&(PWD[_WS_CS].Dt),0,cs);
940:           #else
941:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
9C22  0E80     MOVLW 0x80
9C24  ECB3     CALL 0x4B66, 0
9C26  F025     NOP
9C28  0E20     MOVLW 0x20
9C2A  6F7B     MOVWF _PFNf_rozruch, BANKED
9C2C  EC3E     CALL 0x627C, 0
9C2E  F031     NOP
9C30  D828     RCALL PL130
942:           	SetData(&(PWD[_WS_TCW].Dt2),led_P,led_o);    
9C32  0E73     MOVLW 0x73
9C34  6F76     MOVWF _PFNf_prn_in, BANKED
9C36  0E5C     MOVLW 0x5C
9C38  6F77     MOVWF _PFNf_prn_pg, BANKED
9C3A  ECBF     CALL 0xBD7E, 0
9C3C  F05E     NOP
943:               if(!PFNf_errCS&&!PFNf_fnoCS)
9C3E  AA09     BTFSS PFNf_b_str_nco, 5, ACCESS
9C40  B80A     BTFSC PFNf_firstEdge, 4, ACCESS
9C42  D010     BRA 0x9C64
9C44  ECF3     CALL 0x95E6, 0
9C46  F04A     NOP
944:               {
945:                   SetStatus(&(PWD[_WS_CS].St),tDEC|tKROPKA1|tSDID|tRDID|tFOCUS,tALL,_KZ_SRV|_KZ_BAR,_KZ_TCO);			//| _KZ_DCOcisnienie
9C48  0EC4     MOVLW 0xC4
9C4A  ECC9     CALL 0x4B92, 0
9C4C  F025     NOP
9C4E  0E44     MOVLW 0x44
9C50  D81D     RCALL PL608
9C52  EC3E     CALL 0x627C, 0
9C54  F031     NOP
946:                   SetData(&(PWD[_WS_CS].Dt),0,cs);
9C56  EC82     CALL 0x9D04, 0
9C58  F04E     NOP
9C5A  6B76     CLRF _PFNf_prn_in, BANKED
9C5C  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
9C5E  F077     NOP
9C60  EFBF     GOTO 0xBD7E
9C62  F05E     NOP
947:               }
948:               else
949:               {
950:                   SetStatus(&(PWD[_WS_CS].St),tLED|tSDID|tRDID|tFOCUS,tALL,_KZ_SRV|_KZ_BAR,_KZ_TCO);	//tempetratura IN
9C64  0EA0     MOVLW 0xA0
9C66  EC7E     CALL 0x9CFC, 0
9C68  F04E     NOP
9C6A  ECC9     CALL 0x4B92, 0
9C6C  F025     NOP
9C6E  0E44     MOVLW 0x44
9C70  D80D     RCALL PL608
9C72  EC3E     CALL 0x627C, 0
9C74  F031     NOP
9C76  EC82     CALL 0x9D04, 0
9C78  F04E     NOP
951:                   SetData(&(PWD[_WS_CS].Dt),KRESKA,KRESKA);        
9C7A  ECEB     CALL 0x4BD6, 0
9C7C  F025     NOP
9C7E  EFBF     GOTO 0xBD7E
9C80  F05E     NOP
952:               }
953:           #endif
954:           }
955:           //---------------------------------------------------------
956:           //---------------------------------------------------------
957:           //wyswietla adres LIN
958:           void PrintLN(const unsigned char laddr)
A562  0100     MOVLB 0x0
A564  6F7E     MOVWF _PFNf_set_eco, BANKED
A566  EC89     CALL 0x9B12, 0
A568  F04D     NOP
959:           {
960:           #if LCD4D==0
961:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,_KZ_TCO,_KZ_BAR);
962:           	SetData(&(PWD[_WS_TCO].Dt),0,tm);												//tempetratura IN
963:           #else
964:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
A56A  0E80     MOVLW 0x80
A56C  ECB3     CALL 0x4B66, 0
A56E  F025     NOP
A570  0E20     MOVLW 0x20
A572  6F7B     MOVWF _PFNf_rozruch, BANKED
A574  EC3E     CALL 0x627C, 0
A576  F031     NOP
A578  EC41     CALL 0x9C82, 0
A57A  F04E     NOP
965:           	SetData(&(PWD[_WS_TCW].Dt2),led_L,led_n);
A57C  0E38     MOVLW 0x38
A57E  EC22     CALL 0xA044, 0
A580  F050     NOP
A582  ECBF     CALL 0xBD7E, 0
A584  F05E     NOP
966:               if(laddr)
A586  517E     MOVF _PFNf_set_eco, W, BANKED
A588  E010     BZ 0xA5AA
A58A  ECF3     CALL 0x95E6, 0
A58C  F04A     NOP
967:               {
968:                   SetStatus(&(PWD[_WS_TCO].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	//tempetratura IN
A58E  0EC0     MOVLW 0xC0
A590  ECB3     CALL 0x4B66, 0
A592  F025     NOP
A594  0E50     MOVLW 0x50
A596  6F7B     MOVWF _PFNf_rozruch, BANKED
A598  EC3E     CALL 0x627C, 0
A59A  F031     NOP
A59C  EC82     CALL 0x9D04, 0
A59E  F04E     NOP
969:                   SetData(&(PWD[_WS_TCO].Dt),0,laddr);
A5A0  6B76     CLRF _PFNf_prn_in, BANKED
A5A2  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_pg
A5A4  F077     NOP
A5A6  EFBF     GOTO 0xBD7E
A5A8  F05E     NOP
970:               }
971:               else
972:               {
973:                   SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_BAR|_KZ_TCO);	//tempetratura IN
A5AA  0EA0     MOVLW 0xA0
A5AC  EC7E     CALL 0x9CFC, 0
A5AE  F04E     NOP
A5B0  ECB3     CALL 0x4B66, 0
A5B2  F025     NOP
A5B4  0E50     MOVLW 0x50
A5B6  6F7B     MOVWF _PFNf_rozruch, BANKED
A5B8  EC3E     CALL 0x627C, 0
A5BA  F031     NOP
A5BC  EC82     CALL 0x9D04, 0
A5BE  F04E     NOP
A5C0  ECEB     CALL 0x4BD6, 0
A5C2  F025     NOP
974:                   SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);
A5C4  EFBF     GOTO 0xBD7E
A5C6  F05E     NOP
975:               }
976:           #endif
977:           }
978:           //---------------------------------------------------------
979:           //---------------------------------------------------------
980:           //wyswietla temperature IN 
981:           /*
982:           void PrintEC(const unsigned char ec)
983:           {
984:           #if LCD4D==0
985:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
986:           	SetData(&(PWD[_WS_TCO].Dt),0,ec);												//tempetratura IN
987:           #else
988:           	SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
989:           	SetData(&(PWD[_WS_TCW].Dt2),led_I,led_n);						
990:           	SetStatus(&(PWD[_WS_TCO].St),tDEC|tSDID|tRDID|tFOCUS,tALL,,_KZ_TCO|_KZ_BAR);	//tempetratura IN
991:           	SetData(&(PWD[_WS_TCO].Dt),0,tm);
992:           #endif
993:           }
994:           */
995:           //---------------------------------------------------------
996:           //---------------------------------------------------------
997:           //Wygasza wybrany wskaz wraz z powiazanymi z nim znacznikami
998:           //gdzie dhigh - wskazuje na dwie starsze cyfry wraz ze znakami
999:           //dlow - wskazuje na dwie mlodsze cyfry wraz ze znakami
1000:          //krs - zamiast cyfr zapalane s¹ dwie kreski
1001:          /*
1002:          void ClrDig(const unsigned char dhigh, const unsigned char dlow, const unsigned char krs)
1003:          {
1004:          #if LCD4D==0
1005:          	if(dlow)
1006:          	{
1007:          		if(!krs) SetStatus(&(PWD[_WS_TCO].St),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_DCO|_KZ_BAR);
1008:          		else
1009:          		{
1010:          			SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);
1011:          			SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_DCO|_KZ_BAR);
1012:          		}		
1013:          	}
1014:          #else
1015:          	if(dlow)
1016:          	{
1017:          		if(!krs) SetStatus(&(PWD[_WS_TCO].St),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_DCO|_KZ_BAR);
1018:          		else
1019:          		{
1020:          			SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);
1021:          			SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_DCO|_KZ_BAR);
1022:          		}
1023:          	}
1024:          	if(dhigh)
1025:          	{
1026:          		if(!krs) SetStatus(&(PWD[_WS_TCO].St2),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCW|_KZ_DCW);
1027:          		else
1028:          		{
1029:          			SetData(&(PWD[_WS_TCO].Dt2),KRESKA,KRESKA);
1030:          			SetStatus(&(PWD[_WS_TCO].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW|_KZ_DCW);
1031:          		}		
1032:          	}
1033:          #endif
1034:          }
1035:          */
1036:          void ClrDig(const unsigned char dhigh, const unsigned char dlow, const unsigned char krs)
9AA8  6F80     MOVWF _PFNf_set_nco, BANKED
1037:          {
1038:          #if LCD4D==0
1039:          	if(dlow)
1040:          	{
1041:          		if(!krs) SetStatus(&(PWD[_WS_TCO].St),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
1042:          		else
1043:          		{
1044:          			SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);
1045:          			SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
1046:          		}		
1047:          	}
1048:          #else
1049:          	if(dlow)
9AAA  0100     MOVLB 0x0
9AAC  517E     MOVF _PFNf_set_eco, W, BANKED
9AAE  E01B     BZ 0x9AE6
1050:          	{
1051:          		if(!krs) SetStatus(&(PWD[_WS_TCO].St),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
9AB0  517F     MOVF _PFNf_set_fnserw, W, BANKED
9AB2  E10A     BNZ 0x9AC8
9AB4  ECF3     CALL 0x95E6, 0
9AB6  F04A     NOP
9AB8  0E83     MOVLW 0x83
9ABA  ECB3     CALL 0x4B66, 0
9ABC  F025     NOP
9ABE  0E50     MOVLW 0x50
9AC0  6F7B     MOVWF _PFNf_rozruch, BANKED
9AC2  EC3E     CALL 0x627C, 0
9AC4  F031     NOP
9AC6  D00F     BRA 0x9AE6
1052:          		else
1053:          		{
1054:          			SetData(&(PWD[_WS_TCO].Dt),KRESKA,KRESKA);
9AC8  EC82     CALL 0x9D04, 0
9ACA  F04E     NOP
9ACC  ECEB     CALL 0x4BD6, 0
9ACE  F025     NOP
9AD0  ECBF     CALL 0xBD7E, 0
9AD2  F05E     NOP
1055:          			SetStatus(&(PWD[_WS_TCO].St),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCO|_KZ_BAR);
9AD4  0EA0     MOVLW 0xA0
9AD6  EC7E     CALL 0x9CFC, 0
9AD8  F04E     NOP
9ADA  ECB3     CALL 0x4B66, 0
9ADC  F025     NOP
9ADE  0E50     MOVLW 0x50
9AE0  6F7B     MOVWF _PFNf_rozruch, BANKED
9AE2  EC3E     CALL 0x627C, 0
9AE4  F031     NOP
1056:          		}
1057:          	}
1058:          	if(dhigh)
9AE6  5180     MOVF _PFNf_set_nco, W, BANKED
9AE8  B4D8     BTFSC STATUS, 2, ACCESS
9AEA  0012     RETURN 0
1059:          	{
1060:          		if(!krs) SetStatus(&(PWD[_WS_TCW].St2),tWYGAS|tRDID|tFOCUS,tALL,0,_KZ_TCW);
9AEC  517F     MOVF _PFNf_set_fnserw, W, BANKED
9AEE  E103     BNZ 0x9AF6
9AF0  D810     RCALL PL20
9AF2  0E83     MOVLW 0x83
9AF4  D008     BRA 0x9B06
1061:          		else
1062:          		{
1063:          			SetData(&(PWD[_WS_TCW].Dt2),KRESKA,KRESKA);
9AF6  0EA8     MOVLW 0xA8
9AF8  6F74     MOVWF _PFNf_prODP, BANKED
9AFA  0E03     MOVLW 0x3
9AFC  D80F     RCALL PL102
9AFE  ECBF     CALL 0xBD7E, 0
9B00  F05E     NOP
9B02  D807     RCALL PL20
1064:          			SetStatus(&(PWD[_WS_TCW].St2),tLED|tRDID|tFOCUS,tALL,0,_KZ_TCW);
9B04  0E80     MOVLW 0x80
9B06  ECB3     CALL 0x4B66, 0
9B08  F025     NOP
9B0A  0E20     MOVLW 0x20
9B0C  6F7B     MOVWF _PFNf_rozruch, BANKED
9B0E  EF3E     GOTO 0x627C
9B10  F031     NOP
1065:          		}		
1066:          	}
1067:          #endif
1068:          	//UpdateWSW();
1069:          }
1070:          //---------------------------------------------------------
1071:          //---------------------------------------------------------
1072:          //Funkcja na potrzeby testow oprogramowania
1073:          /*
1074:          void PrintHex(const unsigned char tm)
1075:          {
1076:          	SetStatus(&(PWD[_WS_TCO].St),tHEX,tALL,0,0);				
1077:          	SetData(&(PWD[_WS_TCO].Dt),0,tm);						//tempetratura CO
1078:          }
1079:          */
1080:          //---------------------------------------------------------
1081:          //---------------------------------------------------------
1082:          //Wysterowanie wszystkich elementow swietlnych wyswietlacza
1083:          void TestScr(void)
B292  ECF3     CALL 0x95E6, 0
B294  F04A     NOP
1084:          {
1085:          	SetStatus(&(PWD[_WS_TCO].St),tLED|tKROPKA1|tKROPKA0,tALL,0,0);				
B296  0E0C     MOVLW 0xC
B298  ECC9     CALL 0x9B92, 0
B29A  F04D     NOP
B29C  EC3E     CALL 0x627C, 0
B29E  F031     NOP
B2A0  EC82     CALL 0x9D04, 0
B2A2  F04E     NOP
1086:          	SetData(&(PWD[_WS_TCO].Dt),FULL,FULL);	//zapal wszystkie segmenty wyswietlacza
B2A4  6976     SETF _PFNf_prn_in, BANKED
B2A6  6977     SETF _PFNf_prn_pg, BANKED
B2A8  ECBF     CALL 0xBD7E, 0
B2AA  F05E     NOP
B2AC  EC89     CALL 0x9B12, 0
B2AE  F04D     NOP
1087:          #if LCD4D!=0
1088:          	SetStatus(&(PWD[_WS_TCO].St2),tLED|tKROPKA1|tKROPKA0,tALL,0,0);				
B2B0  0E0C     MOVLW 0xC
B2B2  ECC9     CALL 0x9B92, 0
B2B4  F04D     NOP
B2B6  EC3E     CALL 0x627C, 0
B2B8  F031     NOP
B2BA  EC41     CALL 0x9C82, 0
B2BC  F04E     NOP
1089:          	SetData(&(PWD[_WS_TCO].Dt2),FULL,FULL);	//zapal wszystkie segmenty wyswietlacza
B2BE  6976     SETF _PFNf_prn_in, BANKED
B2C0  6977     SETF _PFNf_prn_pg, BANKED
B2C2  ECBF     CALL 0xBD7E, 0
B2C4  F05E     NOP
1090:          #endif
1091:          	SetWSW(1); 							//zapal wszystkie znaki wyswietlacza
B2C6  0E01     MOVLW 0x1
B2C8  EFBF     GOTO 0x757E
B2CA  F03A     NOP
1092:          	//UpdateWSW();
1093:          }
1094:          void EndTestScr(void)
B2CC  ECF3     CALL 0x95E6, 0
B2CE  F04A     NOP
1095:          {
1096:          	SetStatus(&(PWD[_WS_TCO].St),tDEC|tWYGAS,tALL,0,0);				
B2D0  0E43     MOVLW 0x43
B2D2  ECC9     CALL 0x9B92, 0
B2D4  F04D     NOP
B2D6  EC3E     CALL 0x627C, 0
B2D8  F031     NOP
B2DA  EC82     CALL 0x9D04, 0
B2DC  F04E     NOP
1097:          	SetData(&(PWD[_WS_TCO].Dt),0,0);			//wygas wszystkie segmenty wyswietlacza
B2DE  6B76     CLRF _PFNf_prn_in, BANKED
B2E0  6B77     CLRF _PFNf_prn_pg, BANKED
B2E2  ECBF     CALL 0xBD7E, 0
B2E4  F05E     NOP
B2E6  EC89     CALL 0x9B12, 0
B2E8  F04D     NOP
1098:          #if LCD4D!=0
1099:          	SetStatus(&(PWD[_WS_TCO].St2),tDEC|tWYGAS,tALL,0,0);				
B2EA  0E43     MOVLW 0x43
B2EC  ECC9     CALL 0x9B92, 0
B2EE  F04D     NOP
B2F0  EC3E     CALL 0x627C, 0
B2F2  F031     NOP
B2F4  EC41     CALL 0x9C82, 0
B2F6  F04E     NOP
1100:          	SetData(&(PWD[_WS_TCO].Dt2),0,0);			//wygas wszystkie segmenty wyswietlacza
B2F8  6B76     CLRF _PFNf_prn_in, BANKED
B2FA  6B77     CLRF _PFNf_prn_pg, BANKED
B2FC  ECBF     CALL 0xBD7E, 0
B2FE  F05E     NOP
1101:          #endif
1102:          	SetWSW(0); 							//wygas wszystkie znaki wyswietlacza
B300  0E00     MOVLW 0x0
B302  EFBF     GOTO 0x757E
B304  F03A     NOP
1103:          	//UpdateWSW();
1104:          }
1105:          /*
1106:          void TestScr(void)
1107:          {
1108:          	SetStatus(&PWD[_WS_TCO],tLED|tKROPKA1|tKROPKA0,tALL,0,0);				
1109:          	SetData(&PWD[_WS_TCO],FULL,FULL);	//zapal wszystkie segmenty wyswietlacza
1110:          #if LCD4D!=0
1111:          	SetStatus2(&PWD[_WS_TCO],tLED|tKROPKA1|tKROPKA0,tALL,0,0);				
1112:          	SetData2(&PWD[_WS_TCO],FULL,FULL);	//zapal wszystkie segmenty wyswietlacza
1113:          #endif
1114:          	SetWSW(1); 							//zapal wszystkie znaki wyswietlacza
1115:          }
1116:          void EndTestScr(void)
1117:          {
1118:          	SetStatus(&PWD[_WS_TCO],tDEC|tWYGAS,tALL,0,0);				
1119:          	SetData(&PWD[_WS_TCO],0,0);			//wygas wszystkie segmenty wyswietlacza
1120:          #if LCD4D!=0
1121:          	SetStatus2(&PWD[_WS_TCO],tDEC|tWYGAS,tALL,0,0);				
1122:          	SetData2(&PWD[_WS_TCO],0,0);			//wygas wszystkie segmenty wyswietlacza
1123:          #endif
1124:          	SetWSW(0); 							//wygas wszystkie znaki wyswietlacza
1125:          }*/
1126:          //---------------------------------------------------------
1127:          //---------------------------------------------------------
1128:          //Wyswietla wskaz skladajacy sie z oznaczenia literowego i cyfry od 0 do 9
1129:          //WYSWIETLANIE 2 CYFROWE
1130:          //lkod - dowolny znak w kodzie led wyswietlany na starszej cyfrze
1131:          //dla tryb=0:
1132:          //nkod - liczba zakresu 0-F wyswietlana na mlodszej cyfrze
1133:          //dla tryb=1:
1134:          //nkod - dowolny znak w kodzie led wyswietlany na mlodszej cyfrze
1135:          //WYSWIETLANIE 4 CYFROWE
1136:          //lkod - dowolny znak w kodzie led wyswietlany na 3 cyfrze
1137:          //nkod - liczba zakresu 0-99 wyswietlana na 2 najmlodszych cyfrach
1138:          /*void PrintGrafH(const unsigned char lkod2,const unsigned char lkod1)
1139:          {
1140:          	SetData(&(PWD[_WS_TCO].Dt2),lkod2,lkod1);
1141:          	SetStatus(&(PWD[_WS_TCO].St2),tLED|tFOCUS,tALL,0,0);
1142:          	//SetData(&(PWD[_WS_PRM].Dt),0,nkod);
1143:          	//SetStatus(&(PWD[_WS_PRM].St),tDEC|tSDID|tFOCUS,tALL,_KZ_SRV,0);
1144:          }*/
1145:          void PrintGrafH(const unsigned char lkod2,const unsigned char lkod1)
1146:          {
1147:          	SetStatus(&(PWD[_WS_TCW].St2),tLED|tSDID|tFOCUS,tALL,0,0);
1148:          	SetData(&(PWD[_WS_TCW].Dt2),lkod2,lkod1);
1149:          	//if(!only) SetStatus(&(PWD[_WS_TCW].St),tWYGAS|tFOCUS,tALL,0,0);
1150:          	//UpdateWSW();
1151:          }
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/port.c  ---------------------
1:             /*port.c*/
2:             //Konfiguracja portow fizycznych mikrokontrolera
3:             //Stabilizacja stanow wejsciowych
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "port.h"			//parametry lokalne
9:             #include "main.tp.h"		//typy danych
10:            
11:            /*---------------------------------------------------------------------------------*/
12:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
13:            // Podaj liczbe portow fizycznych oraz wirtualnych ktore maja byc poddane procesowi 
14:            // filtracji czasowej.
15:            #if _KEY_BBOARD==0 
16:                #define	_NVPORT	7		/*liczba obslugiwanych portow/sygnalow*/
17:            #endif
18:            #if _KEY_BBOARD==1
19:                #define	_NVPORT	10		/*liczba obslugiwanych portow/sygnalow*/
20:            #endif
21:            /*---------------------------------------------------------------------------------*/
22:            // Podaj przypadajace na kazdy port dwie WARTOSCI OPOZNIENIA dla zmian stanu  
23:            // lo/hi oraz hi/lo (wartosci z zakresu [0..0x3F] co daje maks. czas = 0x3F*0.1 sek.)
24:            
25:            #if (_NVPORT!=0)
26:            #if _KEY_BBOARD==0
27:            static const Opoznienie Nastawa[_NVPORT]={	
28:            									1,1,		//port nr 0 czas lo/hi oraz hi\lo
29:            									1,1,		//port nr 1 czas lo/hi oraz hi\lo
30:            									0,0,		//port nr 2 czas lo/hi oraz hi\lo
31:            									0,0,		//port nr 3 czas lo/hi oraz hi\lo
32:            									20,10,		//port nr 4 czas lo/hi oraz hi\lo
33:            									10,10,		//port nr 5 czas lo/hi oraz hi\lo 
34:            									20,10,		//port nr 6 czas lo/hi oraz hi\lo                                    
35:            								 };
36:            #endif
37:            #if _KEY_BBOARD==1
38:            static const Opoznienie Nastawa[_NVPORT]={	
39:            									1,1,		//port nr 0 czas lo/hi oraz hi\lo
40:            									1,1,		//port nr 1 czas lo/hi oraz hi\lo
41:            									1,1,		//port nr 0 czas lo/hi oraz hi\lo                                    
42:            									0,0,		//port nr 2 czas lo/hi oraz hi\lo
43:            									0,0,		//port nr 3 czas lo/hi oraz hi\lo
44:            									0,0,		//port nr 2 czas lo/hi oraz hi\lo
45:            									0,0,		//port nr 3 czas lo/hi oraz hi\lo                                    
46:            									20,10,		//port nr 4 czas lo/hi oraz hi\lo
47:            									10,10,		//port nr 5 czas lo/hi oraz hi\lo 
48:            									20,10,		//port nr 6 czas lo/hi oraz hi\lo                                    
49:            								 };
50:            #endif
51:            /*---------------------------------------------------------------------------------*/
52:            bdata static volatile IOPort SPort[_NVPORT];			//protected volatile
53:            
54:            /*---------------------------------------------------------------------------------*/
55:            //Port fizyczny nalezy przypisac polu SPort[n].Input gdzie 0<=n<_NVPORT.
56:            void RefStan(void)
57:            {
58:            #if _KEY_BBOARD==0    
59:            	//port 0
60:            	SPort[0].Input=(_OFF)?0:1;			//port/sygnal poddany filtracji
61:            	//port 1
62:            	SPort[1].Input=(_SET)?0:1;			//port/sygnal poddany filtracji
63:            	//port 2
64:            	SPort[2].Input=(_KUP)?0:1;			//port/sygnal poddany filtracji
65:            	//port 3
66:            	SPort[3].Input=(_KDW)?0:1;			//port/sygnal poddany filtracji
67:            	//port 4
68:            	SPort[4].Input=PFNf_bEnF10V;		//port/sygnal poddany filtracji
69:            	//port 5
70:            	SPort[5].Input=PFNf_b10V_RT;		//port/sygnal poddany filtracji    
71:            	//port 6
72:            	SPort[6].Input=PFNf_10V_nPCO;			//port/sygnal poddany filtracji    
73:            	//...tak do Prt[NVPORT-1]
74:            #endif
75:            #if _KEY_BBOARD==1    
76:            	//port 0
77:            	SPort[0].Input=(_OFF)?0:1;			//port/sygnal poddany filtracji
8168  B880     BTFSC PORTA, 4, ACCESS
8496  B880     BTFSC PORTA, 4, ACCESS
8498  D003     BRA 0x84A0
849A  6B74     CLRF _PFNf_prODP, BANKED
849C  2B74     INCF _PFNf_prODP, F, BANKED
849E  D002     BRA 0x84A4
84A0  0100     MOVLB 0x0
84A2  6B74     CLRF _PFNf_prODP, BANKED
84A4  0101     MOVLB 0x1
84A6  5176     MOVF _PFNf_prn_in, W, BANKED
84A8  D850     RCALL PL144
84AA  6F76     MOVWF _PFNf_prn_in, BANKED
78:            	//port 1
79:            	SPort[1].Input=(_SET)?0:1;			//port/sygnal poddany filtracji
8180  BA80     BTFSC PORTA, 5, ACCESS
8182  D003     BRA 0x818A
8184  6A28     CLRF _PFNf_10V_RT, ACCESS
8186  2A28     INCF _PFNf_10V_RT, F, ACCESS
8188  D001     BRA 0x818C
818A  6A28     CLRF _PFNf_10V_RT, ACCESS
818C  0101     MOVLB 0x1
818E  5177     MOVF _PFNf_prn_pg, W, BANKED
8190  1828     XORWF _PFNf_10V_RT, W, ACCESS
8192  0BFE     ANDLW 0xFE
8194  1828     XORWF _PFNf_10V_RT, W, ACCESS
8196  6F77     MOVWF _PFNf_prn_pg, BANKED
84AC  BA80     BTFSC PORTA, 5, ACCESS
84AE  D002     BRA 0x84B4
84B0  D852     RCALL PL576
84B2  D002     BRA 0x84B8
84B4  0100     MOVLB 0x0
84B6  6B74     CLRF _PFNf_prODP, BANKED
84B8  0101     MOVLB 0x1
84BA  5177     MOVF _PFNf_prn_pg, W, BANKED
84BC  D846     RCALL PL144
84BE  6F77     MOVWF _PFNf_prn_pg, BANKED
80:            	//port 2
81:            	SPort[2].Input=(_KOM)?0:1;			//port/sygnal poddany filtracji       
8198  B480     BTFSC PORTA, 2, ACCESS
819A  D003     BRA 0x81A2
819C  6A28     CLRF _PFNf_10V_RT, ACCESS
819E  2A28     INCF _PFNf_10V_RT, F, ACCESS
81A0  D001     BRA 0x81A4
81A2  6A28     CLRF _PFNf_10V_RT, ACCESS
81A4  0101     MOVLB 0x1
81A6  5178     MOVF _PFNf_prn_pp, W, BANKED
81A8  1828     XORWF _PFNf_10V_RT, W, ACCESS
81AA  0BFE     ANDLW 0xFE
81AC  1828     XORWF _PFNf_10V_RT, W, ACCESS
81AE  6F78     MOVWF _PFNf_prn_pp, BANKED
84C0  B480     BTFSC PORTA, 2, ACCESS
84C2  D002     BRA 0x84C8
84C4  D848     RCALL PL576
84C6  D002     BRA 0x84CC
84C8  0100     MOVLB 0x0
84CA  6B74     CLRF _PFNf_prODP, BANKED
84CC  0101     MOVLB 0x1
84CE  5178     MOVF _PFNf_prn_pp, W, BANKED
84D0  D83C     RCALL PL144
84D2  6F78     MOVWF _PFNf_prn_pp, BANKED
82:            	//port 3
83:            	SPort[3].Input=(_KUP_CW)?0:1;			//port/sygnal poddany filtracji
81B0  BA81     BTFSC PORTB, 5, ACCESS
81B2  D003     BRA 0x81BA
81B4  6A28     CLRF _PFNf_10V_RT, ACCESS
81B6  2A28     INCF _PFNf_10V_RT, F, ACCESS
81B8  D001     BRA 0x81BC
81BA  6A28     CLRF _PFNf_10V_RT, ACCESS
81BC  0101     MOVLB 0x1
81BE  5179     MOVF _PFNf_prn_res, W, BANKED
81C0  1828     XORWF _PFNf_10V_RT, W, ACCESS
81C2  0BFE     ANDLW 0xFE
81C4  1828     XORWF _PFNf_10V_RT, W, ACCESS
81C6  6F79     MOVWF _PFNf_prn_res, BANKED
84D4  BA81     BTFSC PORTB, 5, ACCESS
84D6  D002     BRA 0x84DC
84D8  D83E     RCALL PL576
84DA  D002     BRA 0x84E0
84DC  0100     MOVLB 0x0
84DE  6B74     CLRF _PFNf_prODP, BANKED
84E0  0101     MOVLB 0x1
84E2  5179     MOVF _PFNf_prn_res, W, BANKED
84E4  D832     RCALL PL144
84E6  6F79     MOVWF _PFNf_prn_res, BANKED
84:            	//port 4
85:            	SPort[4].Input=(_KDW_CW)?0:1;			//port/sygnal poddany filtracji
81C8  B680     BTFSC PORTA, 3, ACCESS
81CA  D003     BRA 0x81D2
81CC  6A28     CLRF _PFNf_10V_RT, ACCESS
81CE  2A28     INCF _PFNf_10V_RT, F, ACCESS
81D0  D001     BRA 0x81D4
81D2  6A28     CLRF _PFNf_10V_RT, ACCESS
81D4  0101     MOVLB 0x1
81D6  517A     MOVF _PFNf_res, W, BANKED
81D8  1828     XORWF _PFNf_10V_RT, W, ACCESS
81DA  0BFE     ANDLW 0xFE
81DC  1828     XORWF _PFNf_10V_RT, W, ACCESS
81DE  6F7A     MOVWF _PFNf_res, BANKED
84E8  B680     BTFSC PORTA, 3, ACCESS
84EA  D002     BRA 0x84F0
84EC  D834     RCALL PL576
84EE  D002     BRA 0x84F4
84F0  0100     MOVLB 0x0
84F2  6B74     CLRF _PFNf_prODP, BANKED
84F4  0101     MOVLB 0x1
84F6  517A     MOVF _PFNf_res, W, BANKED
84F8  D828     RCALL PL144
84FA  6F7A     MOVWF _PFNf_res, BANKED
86:            	//port 5
87:            	SPort[5].Input=(_KUP_CO)?0:1;			//port/sygnal poddany filtracji
81E0  B686     BTFSC PORTG, 3, ACCESS
81E2  D003     BRA 0x81EA
81E4  6A28     CLRF _PFNf_10V_RT, ACCESS
81E6  2A28     INCF _PFNf_10V_RT, F, ACCESS
81E8  D001     BRA 0x81EC
81EA  6A28     CLRF _PFNf_10V_RT, ACCESS
81EC  0101     MOVLB 0x1
81EE  517B     MOVF _PFNf_rozruch, W, BANKED
81F0  1828     XORWF _PFNf_10V_RT, W, ACCESS
81F2  0BFE     ANDLW 0xFE
81F4  1828     XORWF _PFNf_10V_RT, W, ACCESS
81F6  6F7B     MOVWF _PFNf_rozruch, BANKED
84FC  B686     BTFSC PORTG, 3, ACCESS
84FE  D002     BRA 0x8504
8500  D82A     RCALL PL576
8502  D002     BRA 0x8508
8504  0100     MOVLB 0x0
8506  6B74     CLRF _PFNf_prODP, BANKED
8508  0101     MOVLB 0x1
850A  517B     MOVF _PFNf_rozruch, W, BANKED
850C  D81E     RCALL PL144
850E  6F7B     MOVWF _PFNf_rozruch, BANKED
88:            	//port 6
89:            	SPort[6].Input=(_KDW_CO)?0:1;			//port/sygnal poddany filtracji    
81F8  B280     BTFSC PORTA, 1, ACCESS
81FA  D003     BRA 0x8202
81FC  6A28     CLRF _PFNf_10V_RT, ACCESS
81FE  2A28     INCF _PFNf_10V_RT, F, ACCESS
8200  D001     BRA 0x8204
8202  6A28     CLRF _PFNf_10V_RT, ACCESS
8204  0101     MOVLB 0x1
8206  517C     MOVF _PFNf_setKey, W, BANKED
8208  1828     XORWF _PFNf_10V_RT, W, ACCESS
820A  0BFE     ANDLW 0xFE
820C  1828     XORWF _PFNf_10V_RT, W, ACCESS
820E  6F7C     MOVWF _PFNf_setKey, BANKED
8510  B280     BTFSC PORTA, 1, ACCESS
8512  D002     BRA 0x8518
8514  D820     RCALL PL576
8516  D002     BRA 0x851C
8518  0100     MOVLB 0x0
851A  6B74     CLRF _PFNf_prODP, BANKED
851C  0101     MOVLB 0x1
851E  517C     MOVF _PFNf_setKey, W, BANKED
8520  D814     RCALL PL144
8522  6F7C     MOVWF _PFNf_setKey, BANKED
90:            	//port 7
91:            	SPort[7].Input=PFNf_bEnF10V;		//port/sygnal poddany filtracji
8210  A608     BTFSS PFNf_b_set_nco, 3, ACCESS
8212  D002     BRA 0x8218
8214  817D     BSF _PFNf_set_aleg, 0, BANKED
8216  D002     BRA 0x821C
8218  0101     MOVLB 0x1
821A  917D     BCF _PFNf_set_aleg, 0, BANKED
8524  A608     BTFSS PFNf_b_set_nco, 3, ACCESS
8526  D002     BRA 0x852C
8528  817D     BSF _PFNf_set_aleg, 0, BANKED
852A  D002     BRA 0x8530
852C  0101     MOVLB 0x1
852E  917D     BCF _PFNf_set_aleg, 0, BANKED
92:            	//port 8
93:            	SPort[8].Input=PFNf_b10V_RT;		//port/sygnal poddany filtracji    
821C  A408     BTFSS PFNf_b_set_nco, 2, ACCESS
821E  D002     BRA 0x8224
8220  817E     BSF _PFNf_set_eco, 0, BANKED
8222  D002     BRA 0x8228
8224  0101     MOVLB 0x1
8226  917E     BCF _PFNf_set_eco, 0, BANKED
8530  A408     BTFSS PFNf_b_set_nco, 2, ACCESS
8532  D002     BRA 0x8538
8534  817E     BSF _PFNf_set_eco, 0, BANKED
8536  D002     BRA 0x853C
8538  0101     MOVLB 0x1
853A  917E     BCF _PFNf_set_eco, 0, BANKED
94:            	//port 9
95:            	SPort[9].Input=PFNf_10V_nPCO;			//port/sygnal poddany filtracji    
8228  A205     BTFSS PFNf_KnfDisErr, 1, ACCESS
822A  D002     BRA 0x8230
822C  817F     BSF _PFNf_set_fnserw, 0, BANKED
822E  D002     BRA 0x8234
8230  0101     MOVLB 0x1
8232  917F     BCF _PFNf_set_fnserw, 0, BANKED
853C  A205     BTFSS PFNf_KnfDisErr, 1, ACCESS
853E  D002     BRA 0x8544
8540  817F     BSF _PFNf_set_fnserw, 0, BANKED
8542  D002     BRA 0x8548
8544  0101     MOVLB 0x1
8546  917F     BCF _PFNf_set_fnserw, 0, BANKED
96:            	//...tak do Prt[NVPORT-1]
97:            #endif    
98:            }
8234  0012     RETURN 0
8548  0012     RETURN 0
99:            /*---------------------------------------------------------------------------------*/
100:           // Okreslenie stanu poczatkowego portow (procedura wykonywana jednokrotnie przy starcie
101:           // stabilizacji
102:           void FrsStan(void)
103:           {
104:           #if _KEY_BBOARD==0    
105:           	//port 0
106:           	SPort[0].Output=SPort[0].Input;	//stan zgodny ze stanem fizycznym	
107:           	SPort[0].Timer=0;
108:           	
109:           	//port 1
110:           	SPort[1].Output=SPort[1].Input;	//stan zgodny ze stanem fizycznym	
111:           	SPort[1].Timer=0;
112:           	
113:           	//port 2
114:           	SPort[2].Output=SPort[2].Input;	//stan zgodny ze stanem fizycznym	
115:           	SPort[2].Timer=0;
116:           
117:           	//port 3
118:           	SPort[3].Output=SPort[3].Input;	//stan zgodny ze stanem fizycznym	
119:           	SPort[3].Timer=0;
120:               
121:           	//port 4
122:           	SPort[4].Output=SPort[4].Input;	//stan zgodny ze stanem fizycznym	
123:           	SPort[4].Timer=0;
124:           
125:           	//port 5
126:           	SPort[5].Output=SPort[5].Input;	//stan zgodny ze stanem fizycznym	
127:           	SPort[5].Timer=0;
128:               
129:           	//port 6
130:           	SPort[6].Output=SPort[6].Input;	//stan zgodny ze stanem fizycznym	
131:           	SPort[6].Timer=0;    
132:           	//...tak do Prt[_NVPORT-1]
133:           #endif
134:           #if _KEY_BBOARD==1    
135:           	//port 0
136:           	SPort[0].Output=SPort[0].Input;	//stan zgodny ze stanem fizycznym	
8FBE  A176     BTFSS _PFNf_prn_in, 0, BANKED
8FC0  D002     BRA 0x8FC6
8FC2  8376     BSF _PFNf_prn_in, 1, BANKED
8FC4  D002     BRA 0x8FCA
8FC6  0101     MOVLB 0x1
8FC8  9376     BCF _PFNf_prn_in, 1, BANKED
137:           	SPort[0].Timer=0;
8FCA  0E03     MOVLW 0x3
8FCC  1776     ANDWF _PFNf_prn_in, F, BANKED
138:           	
139:           	//port 1
140:           	SPort[1].Output=SPort[1].Input;	//stan zgodny ze stanem fizycznym	
8FCE  A177     BTFSS _PFNf_prn_pg, 0, BANKED
8FD0  D002     BRA 0x8FD6
8FD2  8377     BSF _PFNf_prn_pg, 1, BANKED
8FD4  D002     BRA 0x8FDA
8FD6  0101     MOVLB 0x1
8FD8  9377     BCF _PFNf_prn_pg, 1, BANKED
141:           	SPort[1].Timer=0;
8FDA  0E03     MOVLW 0x3
8FDC  1777     ANDWF _PFNf_prn_pg, F, BANKED
142:           	
143:           	//port 2
144:           	SPort[2].Output=SPort[2].Input;	//stan zgodny ze stanem fizycznym	
8FDE  A178     BTFSS _PFNf_prn_pp, 0, BANKED
8FE0  D002     BRA 0x8FE6
8FE2  8378     BSF _PFNf_prn_pp, 1, BANKED
8FE4  D002     BRA 0x8FEA
8FE6  0101     MOVLB 0x1
8FE8  9378     BCF _PFNf_prn_pp, 1, BANKED
145:           	SPort[2].Timer=0;
8FEA  0E03     MOVLW 0x3
8FEC  1778     ANDWF _PFNf_prn_pp, F, BANKED
146:           
147:           	//port 3
148:           	SPort[3].Output=SPort[3].Input;	//stan zgodny ze stanem fizycznym	
8FEE  A179     BTFSS _PFNf_prn_res, 0, BANKED
8FF0  D002     BRA 0x8FF6
8FF2  8379     BSF _PFNf_prn_res, 1, BANKED
8FF4  D002     BRA 0x8FFA
8FF6  0101     MOVLB 0x1
8FF8  9379     BCF _PFNf_prn_res, 1, BANKED
149:           	SPort[3].Timer=0;
8FFA  0E03     MOVLW 0x3
8FFC  1779     ANDWF _PFNf_prn_res, F, BANKED
150:               
151:           	//port 4
152:           	SPort[4].Output=SPort[4].Input;	//stan zgodny ze stanem fizycznym	
8FFE  A17A     BTFSS _PFNf_res, 0, BANKED
9000  D002     BRA 0x9006
9002  837A     BSF _PFNf_res, 1, BANKED
9004  D002     BRA 0x900A
9006  0101     MOVLB 0x1
9008  937A     BCF _PFNf_res, 1, BANKED
153:           	SPort[4].Timer=0;
900A  0E03     MOVLW 0x3
900C  177A     ANDWF _PFNf_res, F, BANKED
154:           
155:           	//port 5
156:           	SPort[5].Output=SPort[5].Input;	//stan zgodny ze stanem fizycznym	
900E  A17B     BTFSS _PFNf_rozruch, 0, BANKED
9010  D002     BRA 0x9016
9012  837B     BSF _PFNf_rozruch, 1, BANKED
9014  D002     BRA 0x901A
9016  0101     MOVLB 0x1
9018  937B     BCF _PFNf_rozruch, 1, BANKED
157:           	SPort[5].Timer=0;
901A  0E03     MOVLW 0x3
901C  177B     ANDWF _PFNf_rozruch, F, BANKED
158:               
159:           	//port 6
160:           	SPort[6].Output=SPort[6].Input;	//stan zgodny ze stanem fizycznym	
901E  A17C     BTFSS _PFNf_setKey, 0, BANKED
9020  D002     BRA 0x9026
9022  837C     BSF _PFNf_setKey, 1, BANKED
9024  D002     BRA 0x902A
9026  0101     MOVLB 0x1
9028  937C     BCF _PFNf_setKey, 1, BANKED
161:           	SPort[6].Timer=0;  
902A  0E03     MOVLW 0x3
902C  177C     ANDWF _PFNf_setKey, F, BANKED
162:               
163:           	//port 7
164:           	SPort[7].Output=SPort[7].Input;	//stan zgodny ze stanem fizycznym	
902E  A17D     BTFSS _PFNf_set_aleg, 0, BANKED
9030  D002     BRA 0x9036
9032  837D     BSF _PFNf_set_aleg, 1, BANKED
9034  D002     BRA 0x903A
9036  0101     MOVLB 0x1
9038  937D     BCF _PFNf_set_aleg, 1, BANKED
165:           	SPort[7].Timer=0;
903A  0E03     MOVLW 0x3
903C  177D     ANDWF _PFNf_set_aleg, F, BANKED
166:           
167:           	//port 8
168:           	SPort[8].Output=SPort[8].Input;	//stan zgodny ze stanem fizycznym	
903E  A17E     BTFSS _PFNf_set_eco, 0, BANKED
9040  D002     BRA 0x9046
9042  837E     BSF _PFNf_set_eco, 1, BANKED
9044  D002     BRA 0x904A
9046  0101     MOVLB 0x1
9048  937E     BCF _PFNf_set_eco, 1, BANKED
169:           	SPort[8].Timer=0;
904A  0E03     MOVLW 0x3
904C  177E     ANDWF _PFNf_set_eco, F, BANKED
170:               
171:           	//port 9
172:           	SPort[9].Output=SPort[9].Input;	//stan zgodny ze stanem fizycznym	
904E  A17F     BTFSS _PFNf_set_fnserw, 0, BANKED
9050  D002     BRA 0x9056
9052  837F     BSF _PFNf_set_fnserw, 1, BANKED
9054  D002     BRA 0x905A
9056  0101     MOVLB 0x1
9058  937F     BCF _PFNf_set_fnserw, 1, BANKED
173:           	SPort[9].Timer=0;    
905A  0E03     MOVLW 0x3
905C  177F     ANDWF _PFNf_set_fnserw, F, BANKED
174:           	//...tak do Prt[_NVPORT-1]
175:           #endif    
176:           }
905E  0C03     RETLW 0x3
177:           #endif
178:           /*---------------------------------------------------------------------------------*/
179:           /*---------------------------------------------------------------------------------*/
180:           /*-----------------------------PROTECTED DATA--------------------------------------*/
181:           void InitPort(void)
182:           {
183:           #if _PIC_PORT==0
184:           #error _PIC_PORT - niewlasciwa wartosc parametru
185:           #endif
186:           #if _PIC_PORT==3
187:           	PORTA=_VALUEA;
188:           	TRISA=_DIRECTA;
189:           	PORTB=_VALUEB;
190:           	TRISB=_DIRECTB;
191:           	PORTC=_VALUEC;
192:           	TRISC=_DIRECTC;
193:           #endif
194:           #if _PIC_PORT==5
195:           	PORTA=_VALUEA;
196:           	TRISA=_DIRECTA;
197:           	PORTB=_VALUEB;
198:           	TRISB=_DIRECTB;
199:           	PORTC=_VALUEC;
200:           	TRISC=_DIRECTC;	
201:           	PORTD=_VALUED;
202:           	TRISD=_DIRECTD;
203:           	PORTE=_VALUEE;
204:           	TRISE=(TRISE&0b11111000)|(_DIRECTE&0b00000111);
205:           #endif
206:           #if _PIC_PORT==7
207:           	PORTA=_VALUEA;
B458  6A80     CLRF PORTA, ACCESS
208:           	TRISA=_DIRECTA;
B45A  0E3F     MOVLW 0x3F
B45C  6E92     MOVWF TRISA, ACCESS
209:           	PORTB=_VALUEB;
B45E  6A81     CLRF PORTB, ACCESS
210:           	TRISB=_DIRECTB;
B460  0E23     MOVLW 0x23
B462  6E93     MOVWF TRISB, ACCESS
211:           	PORTC=_VALUEC;
B464  6A82     CLRF PORTC, ACCESS
212:           	TRISC=_DIRECTC;	
B466  0E98     MOVLW 0x98
B468  6E94     MOVWF TRISC, ACCESS
213:           	PORTD=_VALUED;
B46A  6A83     CLRF PORTD, ACCESS
214:           	TRISD=_DIRECTD;
B46C  0EFC     MOVLW 0xFC
B46E  6E95     MOVWF TRISD, ACCESS
215:           	PORTE=_VALUEE;
B470  6A84     CLRF PORTE, ACCESS
216:           	TRISE=_DIRECTE;
B472  0E7F     MOVLW 0x7F
B474  6E96     MOVWF TRISE, ACCESS
217:           	PORTF=_VALUEF;
B476  6A85     CLRF PORTF, ACCESS
218:           	TRISF=_DIRECTF;
B478  0EFD     MOVLW 0xFD
B47A  6E97     MOVWF TRISF, ACCESS
219:           	PORTG=_VALUEG;
B47C  6A86     CLRF PORTG, ACCESS
220:           	TRISG=(TRISG&0b11110000)|(_DIRECTG&0b00001111);
B47E  5098     MOVF TRISG, W, ACCESS
B480  0BF0     ANDLW 0xF0
B482  090D     IORLW 0xD
B484  6E98     MOVWF TRISG, ACCESS
221:           #endif
222:           #if _NVPORT!=0 
223:           	RefStan();
B486  EC4B     CALL 0x8496, 0
B488  F042     NOP
224:           	FrsStan();
B48A  EFDF     GOTO 0x8FBE
B48C  F047     NOP
225:           #endif
226:           }
227:           //----------------------------------------------------------------------------------
228:           #if _NVPORT!=0
229:           void StabPort(void)
230:           {
231:           	static unsigned char tim=0;
232:           	unsigned char i,delay;
233:           
234:           	//odliczanie czasu 50m sek (funkcja wywolywana w przerwaniu co 10m sek)
235:           	if(tim++<5) return; //10
7E00  0101     MOVLB 0x1
7E02  2BC2     INCF 0xC2, F, BANKED
7E04  05C2     DECF 0xC2, W, BANKED
7E06  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
7E08  0E05     MOVLW 0x5
7E0A  6029     CPFSLT _PFNf_10V_nPCO, ACCESS
7E0C  D001     BRA 0x7E10
7E0E  0C05     RETLW 0x5
236:           	tim=0;					
7E10  6BC2     CLRF 0xC2, BANKED
237:           	
238:           	//odczyt stanu portow
239:           	RefStan();
7E12  ECB4     CALL 0x8168, 0
7E14  F040     NOP
240:           	
241:           	//aby nowy stan zostal zaakceptowany musi trwac min. przez okreslony w polu Delay czas.
242:           	for(i=0;i<_NVPORT;i++)
7E16  6A2B     CLRF _PFNf_EnF10V, ACCESS
7EB4  2A2B     INCF _PFNf_EnF10V, F, ACCESS
243:           	{
244:           		if(!SPort[i].Timer)								//trwa odliczanie czasu?
7E18  D852     RCALL PL40
7E1A  30DF     RRCF INDF2, W, ACCESS
7E1C  32E8     RRCF WREG, F, ACCESS
7E1E  0B3F     ANDLW 0x3F
7E20  E114     BNZ 0x7E4A
7E22  D84D     RCALL PL40
245:           		{
246:           			if(SPort[i].Output==SPort[i].Input)			//stan portu bez zmian?
7E24  D853     RCALL PL190
7E26  D84B     RCALL PL40
7E28  D856     RCALL PL652
7E2A  E044     BZ 0x7EB4
247:           				 continue;
248:           			else SPort[i].Timer++;						//start odliczania
7E2C  D848     RCALL PL40
7E2E  30DF     RRCF INDF2, W, ACCESS
7E30  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
7E32  3029     RRCF _PFNf_10V_nPCO, W, ACCESS
7E34  0B3F     ANDLW 0x3F
7E36  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
7E38  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
7E3A  3629     RLCF _PFNf_10V_nPCO, F, ACCESS
7E3C  3629     RLCF _PFNf_10V_nPCO, F, ACCESS
7E3E  50DF     MOVF INDF2, W, ACCESS
7E40  1829     XORWF _PFNf_10V_nPCO, W, ACCESS
7E42  0B03     ANDLW 0x3
7E44  1829     XORWF _PFNf_10V_nPCO, W, ACCESS
7E46  6EDF     MOVWF INDF2, ACCESS
7E48  D035     BRA 0x7EB4
249:           		}
250:           		else
251:           		{
252:           			if(!SPort[i].Output) 	delay=Nastawa[i].Delay1;
7E4A  D839     RCALL PL40
7E4C  B2DF     BTFSC INDF2, 1, ACCESS
7E4E  D003     BRA 0x7E56
7E50  502B     MOVF _PFNf_EnF10V, W, ACCESS
7E52  0D02     MULLW 0x2
7E54  D005     BRA 0x7E60
253:           			else 					delay=Nastawa[i].Delay2;
7E56  502B     MOVF _PFNf_EnF10V, W, ACCESS
7E58  0D02     MULLW 0x2
7E5A  2AF3     INCF PROD, F, ACCESS
7E5C  0E00     MOVLW 0x0
7E5E  22F4     ADDWFC PRODH, F, ACCESS
7E60  0E90     MOVLW 0x90
7E62  24F3     ADDWF PROD, W, ACCESS
7E64  6EF6     MOVWF TBLPTR, ACCESS
7E66  0EFF     MOVLW 0xFF
7E68  20F4     ADDWFC PRODH, W, ACCESS
7E6A  6EF7     MOVWF TBLPTRH, ACCESS
7E6C  0008     TBLRD*
7E6E  CFF5     MOVFF TABLAT, _PFNf_EnAleg
7E70  F02A     NOP
7E72  D825     RCALL PL40
254:           			
255:           			if(SPort[i].Timer>=delay)					//minal nastawiony czas?
7E74  30DF     RRCF INDF2, W, ACCESS
7E76  32E8     RRCF WREG, F, ACCESS
7E78  0B3F     ANDLW 0x3F
7E7A  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
7E7C  502A     MOVF _PFNf_EnAleg, W, ACCESS
7E7E  5C29     SUBWF _PFNf_10V_nPCO, W, ACCESS
7E80  E311     BNC 0x7EA4
7E82  D81D     RCALL PL40
256:           			{
257:           				SPort[i].Timer=0;
7E84  0E03     MOVLW 0x3
7E86  16DF     ANDWF INDF2, F, ACCESS
7E88  D81A     RCALL PL40
258:           				SPort[i].Output=SPort[i].Input;			//nowa wartosc stanu wyjsciowego
7E8A  0E76     MOVLW 0x76
7E8C  242B     ADDWF _PFNf_EnF10V, W, ACCESS
7E8E  6EE1     MOVWF FSR1, ACCESS
7E90  6AE2     CLRF FSR1H, ACCESS
7E92  0E01     MOVLW 0x1
7E94  22E2     ADDWFC FSR1H, F, ACCESS
7E96  B0DF     BTFSC INDF2, 0, ACCESS
7E98  D002     BRA 0x7E9E
7E9A  92E7     BCF INDF1, 1, ACCESS
7E9C  D002     BRA 0x7EA2
7E9E  0101     MOVLB 0x1
7EA0  82E7     BSF INDF1, 1, ACCESS
259:           			}
7EA2  D008     BRA 0x7EB4
260:           			else 
261:           			{
262:           				if (SPort[i].Output==SPort[i].Input)	//powrocil do pierwotnego stanu?
7EA4  D80C     RCALL PL40
7EA6  D812     RCALL PL190
7EA8  D80A     RCALL PL40
7EAA  D815     RCALL PL652
7EAC  E1BF     BNZ 0x7E2C
7EAE  D807     RCALL PL40
263:           					 SPort[i].Timer=0;					//restart odliczania
7EB0  0E03     MOVLW 0x3
7EB2  16DF     ANDWF INDF2, F, ACCESS
7EB4  2A2B     INCF _PFNf_EnF10V, F, ACCESS
7EB6  0E09     MOVLW 0x9
7EB8  642B     CPFSGT _PFNf_EnF10V, ACCESS
7EBA  D7AE     BRA 0x7E18
7EBC  0C09     RETLW 0x9
264:           				else SPort[i].Timer++;					//kontynuacja odliczania
265:           			}
266:           		}	
267:           	}
268:           }
269:           //----------------------------------------------------------------------------------
270:           //Odczyt stanu portu nr Index
271:           bit RdPrt(const unsigned char Index)
BA04  0100     MOVLB 0x0
BA06  6F75     MOVWF _PFNf_prn_cs, BANKED
272:           {
273:           	if (Index>_NVPORT-1) asm("RESET");	//obsluga sytuacji wyjatkowej
BA08  0E09     MOVLW 0x9
BA0A  6575     CPFSGT _PFNf_prn_cs, BANKED
BA0C  D001     BRA 0xBA10
BA0E  00FF     RESET
274:           	return SPort[Index].Output;
BA10  0E76     MOVLW 0x76
BA12  0100     MOVLB 0x0
BA14  2575     ADDWF _PFNf_prn_cs, W, BANKED
BA16  ECFB     CALL 0xADF6, 0
BA18  F056     NOP
BA1A  A2DF     BTFSS INDF2, 1, ACCESS
BA1C  D003     BRA 0xBA24
BA1E  6B74     CLRF _PFNf_prODP, BANKED
BA20  2B74     INCF _PFNf_prODP, F, BANKED
BA22  D002     BRA 0xBA28
BA24  0100     MOVLB 0x0
BA26  6B74     CLRF _PFNf_prODP, BANKED
BA28  3174     RRCF _PFNf_prODP, W, BANKED
275:           }
BA2A  0012     RETURN 0
276:           //----------------------------------------------------------------------------------
277:           //Ustaw stan portu nr Index
278:           void SetPrt(const unsigned char Index, const unsigned char nw)
ADB8  6F76     MOVWF _PFNf_prn_in, BANKED
279:           {
280:           	if (Index>_NVPORT-1) asm("RESET");	//obsluga sytuacji wyjatkowej
ADBA  0E09     MOVLW 0x9
ADBC  0100     MOVLB 0x0
ADBE  6576     CPFSGT _PFNf_prn_in, BANKED
ADC0  D001     BRA 0xADC4
ADC2  00FF     RESET
281:           	SPort[Index].Output=((!nw)?0:1);
ADC4  0100     MOVLB 0x0
ADC6  5174     MOVF _PFNf_prODP, W, BANKED
ADC8  E003     BZ 0xADD0
ADCA  6B75     CLRF _PFNf_prn_cs, BANKED
ADCC  2B75     INCF _PFNf_prn_cs, F, BANKED
ADCE  D002     BRA 0xADD4
ADD0  0100     MOVLB 0x0
ADD2  6B75     CLRF _PFNf_prn_cs, BANKED
ADD4  0E76     MOVLW 0x76
ADD6  2576     ADDWF _PFNf_prn_in, W, BANKED
ADD8  D80E     RCALL __end_of_SetPrt
ADDA  4775     RLNCF _PFNf_prn_cs, F, BANKED
ADDC  50DF     MOVF INDF2, W, ACCESS
ADDE  0100     MOVLB 0x0
ADE0  1975     XORWF _PFNf_prn_cs, W, BANKED
ADE2  0BFD     ANDLW 0xFD
ADE4  1975     XORWF _PFNf_prn_cs, W, BANKED
ADE6  6EDF     MOVWF INDF2, ACCESS
282:           	SPort[Index].Timer=0;
ADE8  0E76     MOVLW 0x76
ADEA  2576     ADDWF _PFNf_prn_in, W, BANKED
ADEC  D804     RCALL __end_of_SetPrt
ADEE  0E03     MOVLW 0x3
ADF0  0101     MOVLB 0x1
ADF2  16DF     ANDWF INDF2, F, ACCESS
283:           }
ADF4  0C03     RETLW 0x3
284:           //----------------------------------------------------------------------------------
285:           //Natychmiastowa aktualizacja stanu portu nr Index
286:           void RefPrt(const unsigned char Index)
287:           {
288:           	if (Index>_NVPORT-1) asm("RESET");	//obsluga sytuacji wyjatkowej
289:           	SPort[Index].Output=SPort[Index].Input;
290:           	SPort[Index].Timer=0;
291:           }
292:           //----------------------------------------------------------------------------------
293:           #endif
294:           //----------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/pomiar.c  -------------------
1:             /*pomiar.c*/
2:             //Procedury pomiarowe (oparte na przetworniku AC) UNISTER zmodyfikowany GRZ01
3:             // (!) Bazuje na funkcjach z pliku: ac.c, rtimer.c /RTdS(2)/
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include <math.h>
8:             #include "global.h"				//parametry globalne
9:             #include "pomiar.h"				//parametry lokalne
10:            #include "main.tp.h"
11:            
12:            extern volatile DataPFN PFN;
13:            extern volatile unsigned char xxy,zzz,vvv;
14:            
15:            #if _EXT_BOARD!=0
16:            /*---------------------------------------------------------------------------------*/
17:            /*---------------------------------------------------------------------------------*/
18:            //Inicjalizacja DtCO, DtCW, DtCS, PFN
19:            void InitDataPmr(void)
20:            {
21:                InitTabNTC();
C292  EF34     GOTO 0xB668
C294  F05B     NOP
22:            }
23:            /*---------------------------------------------------------------------------------*/
24:            /*---------------------------------------------------------------------------------*/
25:            static unsigned int tbb[_NMAXTAB]={0};
26:            static unsigned int tbb2[_NMAXTAB2]={0};
27:            
28:            void InitTabNTC(void)
29:            {
30:                volatile unsigned char i;
31:            
32:                for(i=0;i<_NMAXTAB;i++) tbb[i]=0;
B668  0100     MOVLB 0x0
B66A  6B74     CLRF _PFNf_prODP, BANKED
B66C  0E0A     MOVLW 0xA
B66E  6574     CPFSGT _PFNf_prODP, BANKED
B670  D001     BRA 0xB674
B672  D005     BRA 0xB67E
B674  5174     MOVF _PFNf_prODP, W, BANKED
B676  EC7C     CALL 0x54F8, 0
B678  F02A     NOP
B67A  D80B     RCALL PL818
B67C  D7F7     BRA 0xB66C
33:                for(i=0;i<_NMAXTAB2;i++) tbb2[i]=0;
B67E  6B74     CLRF _PFNf_prODP, BANKED
B680  0E32     MOVLW 0x32
B682  6574     CPFSGT _PFNf_prODP, BANKED
B684  D001     BRA 0xB688
B686  0C32     RETLW 0x32
B688  5174     MOVF _PFNf_prODP, W, BANKED
B68A  EC5F     CALL 0x54BE, 0
B68C  F02A     NOP
B68E  D801     RCALL PL818
B690  D7F7     BRA 0xB680
34:            }
35:            /*---------------------------------------------------------------------------------*/
36:            /*---------------------------------------------------------------------------------*/
37:            unsigned int FiltrNTC(const unsigned int pom)
38:            {
39:            #if _NMAXKTAB<_NMAXTAB
40:                volatile unsigned int tmx[_NMAXTAB];
41:            #else
42:                volatile unsigned int tmx[_NMAXKTAB];
43:            #endif    
44:            #if _NMAXTAB<_NMAXTAB2
45:                #if _NMAXKTAB2<_NMAXTAB2
46:                    volatile unsigned char wb[_NMAXTAB2];
47:                #else
48:                    volatile unsigned char wb[_NMAXKTAB2];
49:                #endif
50:            #else
51:                #if _NMAXKTAB<_NMAXTAB
52:                    volatile unsigned char wb[_NMAXTAB];
53:                #else
54:                    volatile unsigned char wb[_NMAXKTAB];
55:                #endif    
56:            #endif    
57:                volatile unsigned char i,j,im,ix;
58:                volatile unsigned int ndat,min,max,wrt;
59:                //------------------------------------------------------------------------
60:                //Poszukiwanie warto?ci "srodkowej" po elininacji wszystkich wartosci granicznych min/max z niepazystej liczby probek
61:                //------------------------------------------------------------------------
62:                ndat=_NMAXTAB;
5274  0106     MOVLB 0x6
5276  6B53     CLRF 0x53, BANKED
5278  0E0B     MOVLW 0xB
527A  D966     RCALL PL796
63:                //zapamietaj wynik pomiaru w tablicy pomiarow
64:                for(i=1;i<ndat;i++) tbb[i-1]=tbb[i];
527C  D00E     BRA 0x529A
527E  0106     MOVLB 0x6
5280  5154     MOVF 0x54, W, BANKED
5282  D93A     RCALL PL256
5284  5154     MOVF 0x54, W, BANKED
5286  D946     RCALL PL462
5288  0E14     MOVLW 0x14
528A  2576     ADDWF _PFNf_prn_in, W, BANKED
528C  6EE1     MOVWF FSR1, ACCESS
528E  0E04     MOVLW 0x4
5290  2177     ADDWFC _PFNf_prn_pg, W, BANKED
5292  ECE4     CALL 0x11C8, 0
5294  F008     NOP
5296  0106     MOVLB 0x6
5298  2B54     INCF 0x54, F, BANKED
529A  D904     RCALL __end_of_FiltrNTC
529C  E3F0     BNC 0x527E
65:                tbb[ndat-1]=pom;	//nadpisz ostatnia pozycje aktualna dana
529E  D941     RCALL PL474
52A0  0E14     MOVLW 0x14
52A2  26D9     ADDWF FSR2, F, ACCESS
52A4  0E04     MOVLW 0x4
52A6  22DA     ADDWFC FSR2H, F, ACCESS
52A8  C074     MOVFF _PFNf_prODP, POSTINC2
52AA  FFDE     NOP
52AC  C075     MOVFF _PFNf_prn_cs, POSTDEC2
52AE  FFDD     NOP
66:                //------------------------------------------------------------
67:                //kopiuj dane do tablicy roboczej
68:                for(i=0;i<ndat;i++) tmx[i]=tbb[i];
52B0  6B54     CLRF 0x54, BANKED
52B2  D00D     BRA 0x52CE
52B4  0106     MOVLB 0x6
52B6  5154     MOVF 0x54, W, BANKED
52B8  D91F     RCALL PL256
52BA  5154     MOVF 0x54, W, BANKED
52BC  0D02     MULLW 0x2
52BE  0E33     MOVLW 0x33
52C0  24F3     ADDWF PROD, W, ACCESS
52C2  6EE1     MOVWF FSR1, ACCESS
52C4  0E06     MOVLW 0x6
52C6  20F4     ADDWFC PRODH, W, ACCESS
52C8  ECE4     CALL 0x11C8, 0
52CA  F008     NOP
52CC  2B54     INCF 0x54, F, BANKED
52CE  D8EA     RCALL __end_of_FiltrNTC
52D0  E3F1     BNC 0x52B4
69:            
70:                //znajdz wartosc minimalna i maksymalna w tablicy i wyzeruj
71:                for(i=0;i<ndat;i++) wb[i]=0;
52D2  0106     MOVLB 0x6
52D4  6B54     CLRF 0x54, BANKED
52D6  D003     BRA 0x52DE
52D8  D8FA     RCALL PL116
52DA  6ADF     CLRF INDF2, ACCESS
52DC  2B54     INCF 0x54, F, BANKED
52DE  D8E2     RCALL __end_of_FiltrNTC
52E0  E3FB     BNC 0x52D8
72:                for(j=0;j<(ndat/2);j++)
52E2  0106     MOVLB 0x6
52E4  6B4F     CLRF 0x4F, BANKED
52E6  D03D     BRA 0x5362
5360  2B4F     INCF 0x4F, F, BANKED
5362  90D8     BCF STATUS, 0, ACCESS
5364  3153     RRCF 0x53, W, BANKED
5366  0100     MOVLB 0x0
5368  6F77     MOVWF _PFNf_prn_pg, BANKED
536A  0106     MOVLB 0x6
536C  3152     RRCF 0x52, W, BANKED
536E  0100     MOVLB 0x0
5370  6F76     MOVWF _PFNf_prn_in, BANKED
5372  0106     MOVLB 0x6
5374  514F     MOVF 0x4F, W, BANKED
5376  0100     MOVLB 0x0
5378  6F78     MOVWF _PFNf_prn_pp, BANKED
537A  6B79     CLRF _PFNf_prn_res, BANKED
537C  5176     MOVF _PFNf_prn_in, W, BANKED
537E  5D78     SUBWF _PFNf_prn_pp, W, BANKED
5380  5177     MOVF _PFNf_prn_pg, W, BANKED
5382  5979     SUBWFB _PFNf_prn_res, W, BANKED
5384  E3B1     BNC 0x52E8
73:                {
74:                        min=0xFFFF;
52E8  0106     MOVLB 0x6
52EA  6949     SETF RSerial, BANKED
52EC  694A     SETF cSk, BANKED
75:                        max=0;
52EE  6B4C     CLRF 0x4C, BANKED
52F0  6B4D     CLRF 0x4D, BANKED
76:                        for(i=0;i<ndat;i++)
52F2  6B54     CLRF 0x54, BANKED
52F4  D014     BRA 0x531E
531C  2B54     INCF 0x54, F, BANKED
531E  D8C2     RCALL __end_of_FiltrNTC
5320  E3EA     BNC 0x52F6
77:                        {
78:                                if(wb[i]) continue;
52F6  D8EB     RCALL PL116
52F8  50DF     MOVF INDF2, W, ACCESS
52FA  E110     BNZ 0x531C
79:                                wrt=tmx[i];
52FC  5154     MOVF 0x54, W, BANKED
52FE  D8EF     RCALL PL162
5300  D903     RCALL PL376
80:                                if(max<wrt)
5302  5D4C     SUBWF 0x4C, W, BANKED
5304  5151     MOVF 0x51, W, BANKED
5306  594D     SUBWFB 0x4D, W, BANKED
5308  E203     BC 0x5310
81:                                {
82:                                        max=wrt;
530A  D919     RCALL PL720
83:                                        ix=i;
530C  C654     MOVFF i, ix
530E  F64B     NOP
84:                                }
85:                                if(min>wrt)
5310  5149     MOVF RSerial, W, BANKED
5312  5D50     SUBWF 0x50, W, BANKED
5314  514A     MOVF cSk, W, BANKED
5316  5951     SUBWFB 0x51, W, BANKED
5318  E201     BC 0x531C
86:                                {
87:                                        min=wrt;
531A  D90A     RCALL PL500
88:                                        im=i;
89:                                }
90:                        }
91:                        if(ix==im)
5322  0106     MOVLB 0x6
5324  514E     MOVF 0x4E, W, BANKED
5326  194B     XORWF 0x4B, W, BANKED
5328  E109     BNZ 0x533C
92:                        {
93:                                im=j;
532A  C64F     MOVFF j, im
532C  F64E     NOP
94:                                ix=(ndat-1-j);
532E  514F     MOVF 0x4F, W, BANKED
5330  5D52     SUBWF 0x52, W, BANKED
5332  0100     MOVLB 0x0
5334  6F76     MOVWF _PFNf_prn_in, BANKED
5336  0576     DECF _PFNf_prn_in, W, BANKED
5338  0106     MOVLB 0x6
533A  6F4B     MOVWF 0x4B, BANKED
95:                        }
96:                        wb[ix]=1;
533C  0E00     MOVLW 0x0
533E  254B     ADDWF 0x4B, W, BANKED
5340  D8D6     RCALL PL220
5342  0E01     MOVLW 0x1
5344  6EDF     MOVWF INDF2, ACCESS
97:                        wb[im]=1;
5346  0E00     MOVLW 0x0
5348  254E     ADDWF 0x4E, W, BANKED
534A  D8D1     RCALL PL220
534C  0E01     MOVLW 0x1
534E  6EDF     MOVWF INDF2, ACCESS
98:                        tmx[ix]=0;
5350  514B     MOVF 0x4B, W, BANKED
5352  D8C5     RCALL PL162
5354  6ADE     CLRF POSTINC2, ACCESS
5356  6ADD     CLRF POSTDEC2, ACCESS
99:                        tmx[im]=0;
5358  514E     MOVF 0x4E, W, BANKED
535A  D8C1     RCALL PL162
535C  6ADE     CLRF POSTINC2, ACCESS
535E  6ADD     CLRF POSTDEC2, ACCESS
100:               }
101:               //znajdz wartosc niezerow?
102:               for(i=0;i<ndat;i++)
5386  0106     MOVLB 0x6
5388  6B54     CLRF 0x54, BANKED
538A  D007     BRA 0x539A
5398  2B54     INCF 0x54, F, BANKED
539A  D884     RCALL __end_of_FiltrNTC
539C  E3F7     BNC 0x538C
103:               {
104:                       wrt=tmx[i];
538C  0106     MOVLB 0x6
538E  5154     MOVF 0x54, W, BANKED
5390  D8A6     RCALL PL162
5392  D8BA     RCALL PL376
105:                       if(wrt) break;
5394  1151     IORWF 0x51, W, BANKED
5396  E103     BNZ 0x539E
106:               }
107:               //------------------------------------------------------------------------
108:               //Histogram
109:               //------------------------------------------------------------------------
110:               ndat=_NMAXTAB2;
539E  0106     MOVLB 0x6
53A0  6B53     CLRF 0x53, BANKED
53A2  0E33     MOVLW 0x33
53A4  D8D1     RCALL PL796
111:               //zapisz dana do tablicy po pierwszym etapie filtracji
112:               for(i=1;i<ndat;i++) tbb2[i-1]=tbb2[i];
53A6  D00E     BRA 0x53C4
53A8  0106     MOVLB 0x6
53AA  5154     MOVF 0x54, W, BANKED
53AC  D888     RCALL PL84
53AE  5154     MOVF 0x54, W, BANKED
53B0  D8B1     RCALL PL462
53B2  0EFE     MOVLW 0xFE
53B4  2576     ADDWF _PFNf_prn_in, W, BANKED
53B6  6EE1     MOVWF FSR1, ACCESS
53B8  0E04     MOVLW 0x4
53BA  2177     ADDWFC _PFNf_prn_pg, W, BANKED
53BC  ECE4     CALL 0x11C8, 0
53BE  F008     NOP
53C0  0106     MOVLB 0x6
53C2  2B54     INCF 0x54, F, BANKED
53C4  D86F     RCALL __end_of_FiltrNTC
53C6  E3F0     BNC 0x53A8
53C8  D8AC     RCALL PL474
113:               tbb2[ndat-1]=wrt;	//nadpisz ostatnia pozycje aktualna dana
53CA  0EFE     MOVLW 0xFE
53CC  26D9     ADDWF FSR2, F, ACCESS
53CE  0E04     MOVLW 0x4
53D0  22DA     ADDWFC FSR2H, F, ACCESS
53D2  C650     MOVFF wrt, POSTINC2
53D4  FFDE     NOP
53D6  C651     MOVFF 0x651, POSTDEC2
53D8  FFDD     NOP
114:           
115:               //zlicz czestosc wystepowania wartosci
116:               for(i=0;i<ndat;i++) wb[i]=0;
53DA  6B54     CLRF 0x54, BANKED
53DC  D003     BRA 0x53E4
53DE  D877     RCALL PL116
53E0  6ADF     CLRF INDF2, ACCESS
53E2  2B54     INCF 0x54, F, BANKED
53E4  D85F     RCALL __end_of_FiltrNTC
53E6  E3FB     BNC 0x53DE
117:               for(j=0;j<ndat;j++)
53E8  0106     MOVLB 0x6
53EA  6B4F     CLRF 0x4F, BANKED
53EC  D01B     BRA 0x5424
5420  0106     MOVLB 0x6
5422  2B4F     INCF 0x4F, F, BANKED
5424  514F     MOVF 0x4F, W, BANKED
5426  0100     MOVLB 0x0
5428  6F76     MOVWF _PFNf_prn_in, BANKED
542A  6B77     CLRF _PFNf_prn_pg, BANKED
542C  0106     MOVLB 0x6
542E  5152     MOVF 0x52, W, BANKED
5430  0100     MOVLB 0x0
5432  5D76     SUBWF _PFNf_prn_in, W, BANKED
5434  0106     MOVLB 0x6
5436  5153     MOVF 0x53, W, BANKED
5438  0100     MOVLB 0x0
543A  5977     SUBWFB _PFNf_prn_pg, W, BANKED
543C  E3D8     BNC 0x53EE
118:               {
119:                       wrt=tbb2[j];
53EE  0106     MOVLB 0x6
53F0  514F     MOVF 0x4F, W, BANKED
53F2  D865     RCALL PL84
53F4  CFDE     MOVFF POSTINC2, wrt
53F6  F650     NOP
53F8  CFDD     MOVFF POSTDEC2, 0x651
53FA  F651     NOP
120:                       for(i=0;i<ndat;i++)
53FC  6B54     CLRF 0x54, BANKED
53FE  D00E     BRA 0x541C
541A  2B54     INCF 0x54, F, BANKED
541C  D843     RCALL __end_of_FiltrNTC
541E  E3F0     BNC 0x5400
121:                       {
122:                               if(wrt==tbb2[i]) wb[j]++;
5400  0106     MOVLB 0x6
5402  5154     MOVF 0x54, W, BANKED
5404  D85C     RCALL PL84
5406  5150     MOVF 0x50, W, BANKED
5408  18DE     XORWF POSTINC2, W, ACCESS
540A  E107     BNZ 0x541A
540C  5151     MOVF 0x51, W, BANKED
540E  18DE     XORWF POSTINC2, W, ACCESS
5410  E104     BNZ 0x541A
5412  0E00     MOVLW 0x0
5414  254F     ADDWF 0x4F, W, BANKED
5416  D86B     RCALL PL220
5418  2ADF     INCF INDF2, F, ACCESS
123:                       }
124:               }
125:               //znajdz najczesciej wystepujaca wartosc
126:               max=0;
543E  0106     MOVLB 0x6
5440  6B4C     CLRF 0x4C, BANKED
5442  6B4D     CLRF 0x4D, BANKED
127:               im=ndat-1;
5444  0552     DECF 0x52, W, BANKED
5446  6F4E     MOVWF 0x4E, BANKED
128:               for(i=0;i<ndat;i++)
5448  6B54     CLRF 0x54, BANKED
544A  D00D     BRA 0x5466
5464  2B54     INCF 0x54, F, BANKED
5466  D81E     RCALL __end_of_FiltrNTC
5468  E3F1     BNC 0x544C
129:               {
130:                       wrt=wb[i];
544C  D840     RCALL PL116
544E  50DF     MOVF INDF2, W, ACCESS
5450  6F50     MOVWF 0x50, BANKED
5452  6B51     CLRF 0x51, BANKED
131:                       if(max<=wrt)
5454  514C     MOVF 0x4C, W, BANKED
5456  5D50     SUBWF 0x50, W, BANKED
5458  514D     MOVF 0x4D, W, BANKED
545A  5951     SUBWFB 0x51, W, BANKED
545C  E303     BNC 0x5464
545E  D86F     RCALL PL720
132:                       {
133:                               max=wrt;
134:                               im=i;
5460  C654     MOVFF i, im
5462  F64E     NOP
135:                       }
136:               }
137:               //znajdz wartosc ninimalna z najczesciej wystepujacych wartosci
138:               min=0xffff;
546A  0106     MOVLB 0x6
546C  6949     SETF RSerial, BANKED
546E  694A     SETF cSk, BANKED
139:               for(i=0;i<ndat;i++)
5470  6B54     CLRF 0x54, BANKED
5472  D00E     BRA 0x5490
548E  2B54     INCF 0x54, F, BANKED
5490  D809     RCALL __end_of_FiltrNTC
5492  E3F0     BNC 0x5474
140:               {
141:                       if(wb[i]==max)
5474  D82C     RCALL PL116
5476  50DF     MOVF INDF2, W, ACCESS
5478  194C     XORWF 0x4C, W, BANKED
547A  114D     IORWF 0x4D, W, BANKED
547C  E108     BNZ 0x548E
142:                       {
143:                               wrt=tbb2[i];
547E  5154     MOVF 0x54, W, BANKED
5480  D81E     RCALL PL84
5482  D842     RCALL PL376
144:                               if(min>=wrt)
5484  5D49     SUBWF RSerial, W, BANKED
5486  5151     MOVF 0x51, W, BANKED
5488  594A     SUBWFB cSk, W, BANKED
548A  E301     BNC 0x548E
548C  D851     RCALL PL500
145:                               {
146:                                       min=wrt;
147:                                       im=i;
148:                               }
149:                       }
150:               }
151:               return tbb2[im];
5494  0106     MOVLB 0x6
5496  514E     MOVF 0x4E, W, BANKED
5498  D812     RCALL PL84
549A  CFDE     MOVFF POSTINC2, _PFNf_prODP
549C  F074     NOP
549E  CFDD     MOVFF POSTDEC2, _PFNf_prn_cs
54A0  F075     NOP
152:           }
54A2  0012     RETURN 0
153:           /*---------------------------------------------------------------------------------*/
154:           /*---------------------------------------------------------------------------------*/
155:           //Nowa wartosc nastawy CO
156:           unsigned char CalkNewPCO10V(float v)
157:           {
158:               float k,p;
159:               if(PFN.SETPmax==PFN.SETPmin) return PFN.SETPmin;
6EFC  0101     MOVLB 0x1
6EFE  51FA     MOVF 0xFA, W, BANKED
6F00  19FB     XORWF 0xFB, W, BANKED
6F02  E102     BNZ 0x6F08
6F04  51FA     MOVF 0xFA, W, BANKED
6F06  0012     RETURN 0
160:               
161:               if (v<_F10V_ON) v=_F10V_ON;//return PFN.minPCO;
6F08  C4E1     MOVFF v, _PFNf_set_nco
6F0A  F080     NOP
6F0C  C4E2     MOVFF 0x4E2, _PFNf_set_ncw
6F0E  F081     NOP
6F10  C4E3     MOVFF 0x4E3, _PFNf_str_nco
6F12  F082     NOP
6F14  0100     MOVLB 0x0
6F16  D898     RCALL PL602
6F18  ECAE     CALL 0xA95C, 0
6F1A  F054     NOP
6F1C  E206     BC 0x6F2A
6F1E  0104     MOVLB 0x4
6F20  6BE1     CLRF 0xE1, BANKED
6F22  0E5C     MOVLW 0x5C
6F24  6FE2     MOVWF 0xE2, BANKED
6F26  0E43     MOVLW 0x43
6F28  6FE3     MOVWF 0xE3, BANKED
162:               if (v>_F10V_MAXPCO) v=_F10V_MAXPCO;//return PFN.maxPCO;
6F2A  0E80     MOVLW 0x80
6F2C  0100     MOVLB 0x0
6F2E  6F80     MOVWF _PFNf_set_nco, BANKED
6F30  0E6D     MOVLW 0x6D
6F32  6F81     MOVWF _PFNf_set_ncw, BANKED
6F34  0E44     MOVLW 0x44
6F36  6F82     MOVWF _PFNf_str_nco, BANKED
6F38  C4E1     MOVFF v, _PFNf_str_ncw
6F3A  F083     NOP
6F3C  C4E2     MOVFF 0x4E2, _PFNf_tdzCO
6F3E  F084     NOP
6F40  C4E3     MOVFF 0x4E3, _PFNf_tdzCW
6F42  F085     NOP
6F44  ECAE     CALL 0xA95C, 0
6F46  F054     NOP
6F48  E207     BC 0x6F58
6F4A  0E80     MOVLW 0x80
6F4C  0104     MOVLB 0x4
6F4E  6FE1     MOVWF 0xE1, BANKED
6F50  0E6D     MOVLW 0x6D
6F52  6FE2     MOVWF 0xE2, BANKED
6F54  0E44     MOVLW 0x44
6F56  6FE3     MOVWF 0xE3, BANKED
163:               k=(_F10V_MAXPCO-_F10V_ON)/(PFN.SETPmax-PFN.SETPmin);
6F58  0101     MOVLB 0x1
6F5A  51FA     MOVF 0xFA, W, BANKED
6F5C  5DFB     SUBWF 0xFB, W, BANKED
6F5E  0100     MOVLB 0x0
6F60  6F76     MOVWF _PFNf_prn_in, BANKED
6F62  6B77     CLRF _PFNf_prn_pg, BANKED
6F64  A0D8     BTFSS STATUS, 0, ACCESS
6F66  0777     DECF _PFNf_prn_pg, F, BANKED
6F68  0E02     MOVLW 0x2
6F6A  6F75     MOVWF _PFNf_prn_cs, BANKED
6F6C  0EDA     MOVLW 0xDA
6F6E  6F74     MOVWF _PFNf_prODP, BANKED
6F70  ECC3     CALL 0x9D86, 0
6F72  F04E     NOP
6F74  EC2F     CALL 0xB65E, 0
6F76  F05B     NOP
6F78  EC11     CALL 0xB422, 0
6F7A  F05A     NOP
6F7C  C07C     MOVFF _PFNf_setKey, k
6F7E  F4E4     NOP
6F80  C07D     MOVFF _PFNf_set_aleg, 0x4E5
6F82  F4E5     NOP
6F84  C07E     MOVFF _PFNf_set_eco, 0x4E6
6F86  F4E6     NOP
164:               
165:               p=PFN.SETPmin+((v-_F10V_ON)/k);
6F88  C4E4     MOVFF k, _UADtf_RData
6F8A  F09D     NOP
6F8C  C4E5     MOVFF 0x4E5, _UADtf_REXT
6F8E  F09E     NOP
6F90  C4E6     MOVFF 0x4E6, _UADtf_REnd
6F92  F09F     NOP
6F94  6B91     CLRF _RSDT1f_RD_KNF, BANKED
6F96  0E5C     MOVLW 0x5C
6F98  6F92     MOVWF _RSDT1f_RD_LIN, BANKED
6F9A  0EC3     MOVLW 0xC3
6F9C  6F93     MOVWF _RSDT1f_RD_STD, BANKED
6F9E  C4E1     MOVFF v, _RSDT1f_NewLIDN
6FA0  F08E     NOP
6FA2  C4E2     MOVFF 0x4E2, _RSDT1f_NoRespToLIN
6FA4  F08F     NOP
6FA6  C4E3     MOVFF 0x4E3, _RSDT1f_OdpLIDN
6FA8  F090     NOP
6FAA  ECD5     CALL 0x71AA, 0
6FAC  F038     NOP
6FAE  C08E     MOVFF _RSDT1f_NewLIDN, _UAD1tf_RFExt
6FB0  F09A     NOP
6FB2  C08F     MOVFF _RSDT1f_NoRespToLIN, _UAD1tf_TFData
6FB4  F09B     NOP
6FB6  C090     MOVFF _RSDT1f_OdpLIDN, _UAD1tf_TFEnd
6FB8  F09C     NOP
6FBA  ECE0     CALL 0x89C0, 0
6FBC  F044     NOP
6FBE  C09A     MOVFF _UAD1tf_RFExt, 0x4E7
6FC0  F4E7     NOP
6FC2  C09B     MOVFF _UAD1tf_TFData, 0x4E8
6FC4  F4E8     NOP
6FC6  C09C     MOVFF _UAD1tf_TFEnd, 0x4E9
6FC8  F4E9     NOP
6FCA  0101     MOVLB 0x1
6FCC  51FA     MOVF 0xFA, W, BANKED
6FCE  EC35     CALL 0xB86A, 0
6FD0  F05C     NOP
6FD2  C07C     MOVFF _PFNf_setKey, _RSDT1f_NewLIDN
6FD4  F08E     NOP
6FD6  C07D     MOVFF _PFNf_set_aleg, _RSDT1f_NoRespToLIN
6FD8  F08F     NOP
6FDA  C07E     MOVFF _PFNf_set_eco, _RSDT1f_OdpLIDN
6FDC  F090     NOP
6FDE  C4E7     MOVFF 0x4E7, _RSDT1f_RD_KNF
6FE0  F091     NOP
6FE2  C4E8     MOVFF 0x4E8, _RSDT1f_RD_LIN
6FE4  F092     NOP
6FE6  C4E9     MOVFF 0x4E9, _RSDT1f_RD_STD
6FE8  F093     NOP
6FEA  ECD5     CALL 0x71AA, 0
6FEC  F038     NOP
6FEE  C08E     MOVFF _RSDT1f_NewLIDN, p
6FF0  F4EA     NOP
6FF2  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x4EB
6FF4  F4EB     NOP
6FF6  C090     MOVFF _RSDT1f_OdpLIDN, 0x4EC
6FF8  F4EC     NOP
166:               if(p<PFN.PCO10V)                //histereza programowa
6FFA  C4EA     MOVFF p, _PFNf_set_nco
6FFC  F080     NOP
6FFE  C4EB     MOVFF 0x4EB, _PFNf_set_ncw
7000  F081     NOP
7002  C4EC     MOVFF 0x4EC, _PFNf_str_nco
7004  F082     NOP
7006  0101     MOVLB 0x1
7008  51F7     MOVF 0xF7, W, BANKED
700A  EC35     CALL 0xB86A, 0
700C  F05C     NOP
700E  EC98     CALL 0x4F30, 0
7010  F027     NOP
7012  ECAE     CALL 0xA95C, 0
7014  F054     NOP
7016  E20E     BC 0x7034
167:               {
168:                   p=round(p);
7018  C4EA     MOVFF p, __pcstackBANK4
701A  F4DE     NOP
701C  C4EB     MOVFF 0x4EB, 0x4DF
701E  F4DF     NOP
7020  C4EC     MOVFF 0x4EC, 0x4E0
7022  F4E0     NOP
7024  EC87     CALL 0x9D0E, 0
7026  F04E     NOP
7028  C4DE     MOVFF __pcstackBANK4, p
702A  F4EA     NOP
702C  C4DF     MOVFF 0x4DF, 0x4EB
702E  F4EB     NOP
7030  C4E0     MOVFF 0x4E0, 0x4EC
7032  F4EC     NOP
169:               }
170:               return (unsigned char)p;
7034  C4EA     MOVFF p, _RSDT1f_NewLIDN
7036  F08E     NOP
7038  C4EB     MOVFF 0x4EB, _RSDT1f_NoRespToLIN
703A  F08F     NOP
703C  C4EC     MOVFF 0x4EC, _RSDT1f_OdpLIDN
703E  F090     NOP
7040  EC6D     CALL 0x86DA, 0
7042  F043     NOP
7044  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
171:           }
7046  0012     RETURN 0
172:           
173:           /*---------------------------------------------------------------------------------*/
174:           /*---------------------------------------------------------------------------------*/
175:           //Pomiar nastawy interfejsu 10V
176:           void Pomiar10V(void)
177:           {
178:               volatile static unsigned int avr=0;
179:               volatile unsigned int pom=0;
6472  0104     MOVLB 0x4
6474  6BF2     CLRF 0xF2, BANKED
6476  6BF3     CLRF 0xF3, BANKED
180:               volatile unsigned int AC_10V;
181:               float volt; 
182:               
183:               pom = ReadAC(0);
6478  0E00     MOVLW 0x0
647A  ECD2     CALL 0xA7A4, 0
647C  F053     NOP
647E  C074     MOVFF _PFNf_prODP, pom
6480  F4F2     NOP
6482  C075     MOVFF _PFNf_prn_cs, 0x4F3
6484  F4F3     NOP
184:               //--------------
185:               pom = FiltrNTC(pom);
6486  C4F2     MOVFF pom, _PFNf_prODP
6488  F074     NOP
648A  C4F3     MOVFF 0x4F3, _PFNf_prn_cs
648C  F075     NOP
648E  EC3A     CALL 0x5274, 0
6490  F029     NOP
6492  C074     MOVFF _PFNf_prODP, pom
6494  F4F2     NOP
6496  C075     MOVFF _PFNf_prn_cs, 0x4F3
6498  F4F3     NOP
186:               //--------------
187:               avr= avr + ((long)pom - (long)avr) / 5;             //5 filtracja 3 stopnia, wartosc srednia pomiaru
649A  0101     MOVLB 0x1
649C  51A5     MOVF f3, W, BANKED
649E  0104     MOVLB 0x4
64A0  5DF2     SUBWF 0xF2, W, BANKED
64A2  0100     MOVLB 0x0
64A4  6F74     MOVWF _PFNf_prODP, BANKED
64A6  0101     MOVLB 0x1
64A8  51A6     MOVF sign, W, BANKED
64AA  0104     MOVLB 0x4
64AC  59F3     SUBWFB 0xF3, W, BANKED
64AE  0100     MOVLB 0x0
64B0  6F75     MOVWF _PFNf_prn_cs, BANKED
64B2  6B76     CLRF _PFNf_prn_in, BANKED
64B4  A0D8     BTFSS STATUS, 0, ACCESS
64B6  0776     DECF _PFNf_prn_in, F, BANKED
64B8  5176     MOVF _PFNf_prn_in, W, BANKED
64BA  6F77     MOVWF _PFNf_prn_pg, BANKED
64BC  0E05     MOVLW 0x5
64BE  6F78     MOVWF _PFNf_prn_pp, BANKED
64C0  6B79     CLRF _PFNf_prn_res, BANKED
64C2  6B7A     CLRF _PFNf_res, BANKED
64C4  6B7B     CLRF _PFNf_rozruch, BANKED
64C6  EC0F     CALL 0x861E, 0
64C8  F043     NOP
64CA  0101     MOVLB 0x1
64CC  51A5     MOVF f3, W, BANKED
64CE  0100     MOVLB 0x0
64D0  2574     ADDWF _PFNf_prODP, W, BANKED
64D2  0101     MOVLB 0x1
64D4  6FA5     MOVWF f3, BANKED
64D6  51A6     MOVF sign, W, BANKED
64D8  0100     MOVLB 0x0
64DA  2175     ADDWFC _PFNf_prn_cs, W, BANKED
64DC  0101     MOVLB 0x1
64DE  6FA6     MOVWF sign, BANKED
188:               //--------------
189:               AC_10V = avr;       //wynik pomiaru
64E0  C1A5     MOVFF avr, AC_10V
64E2  F4F0     NOP
64E4  C1A6     MOVFF 0x1A6, 0x4F1
64E6  F4F1     NOP
190:           
191:               volt=1.02429023794232*AC_10V+14.8517473414396;//temp. z regresji wielomianowej dla NTC:2322 640 5103
64E8  0E1C     MOVLW 0x1C
64EA  0100     MOVLB 0x0
64EC  6F82     MOVWF _PFNf_str_nco, BANKED
64EE  0E83     MOVLW 0x83
64F0  6F83     MOVWF _PFNf_str_ncw, BANKED
64F2  0E3F     MOVLW 0x3F
64F4  6F84     MOVWF _PFNf_tdzCO, BANKED
64F6  C4F0     MOVFF AC_10V, _PFNf_setKey
64F8  F07C     NOP
64FA  C4F1     MOVFF 0x4F1, _PFNf_set_aleg
64FC  F07D     NOP
64FE  EC35     CALL 0xBC6A, 0
6500  F05E     NOP
6502  C07C     MOVFF _PFNf_setKey, _PFNf_set_fnserw
6504  F07F     NOP
6506  C07D     MOVFF _PFNf_set_aleg, _PFNf_set_nco
6508  F080     NOP
650A  C07E     MOVFF _PFNf_set_eco, _PFNf_set_ncw
650C  F081     NOP
650E  ECE7     CALL 0x83CE, 0
6510  F041     NOP
6512  C07F     MOVFF _PFNf_set_fnserw, _RSDT1f_NewLIDN
6514  F08E     NOP
6516  C080     MOVFF _PFNf_set_nco, _RSDT1f_NoRespToLIN
6518  F08F     NOP
651A  C081     MOVFF _PFNf_set_ncw, _RSDT1f_OdpLIDN
651C  F090     NOP
651E  0EA1     MOVLW 0xA1
6520  6F91     MOVWF _RSDT1f_RD_KNF, BANKED
6522  0E6D     MOVLW 0x6D
6524  6F92     MOVWF _RSDT1f_RD_LIN, BANKED
6526  0E41     MOVLW 0x41
6528  6F93     MOVWF _RSDT1f_RD_STD, BANKED
652A  ECD5     CALL 0x71AA, 0
652C  F038     NOP
652E  C08E     MOVFF _RSDT1f_NewLIDN, volt
6530  F4ED     NOP
6532  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x4EE
6534  F4EE     NOP
6536  C090     MOVFF _RSDT1f_OdpLIDN, 0x4EF
6538  F4EF     NOP
192:               //volt=1.02429023794232*AC_NTC+14.3049822501955;//temp. z regresji wielomianowej dla NTC:2322 640 5103
193:               if(volt>1000.0) volt=1000.0;
653A  6B80     CLRF _PFNf_set_nco, BANKED
653C  0E7A     MOVLW 0x7A
653E  6F81     MOVWF _PFNf_set_ncw, BANKED
6540  0E44     MOVLW 0x44
6542  6F82     MOVWF _PFNf_str_nco, BANKED
6544  C4ED     MOVFF volt, _PFNf_str_ncw
6546  F083     NOP
6548  C4EE     MOVFF 0x4EE, _PFNf_tdzCO
654A  F084     NOP
654C  C4EF     MOVFF 0x4EF, _PFNf_tdzCW
654E  F085     NOP
6550  ECAE     CALL 0xA95C, 0
6552  F054     NOP
6554  E206     BC 0x6562
6556  0104     MOVLB 0x4
6558  6BED     CLRF 0xED, BANKED
655A  0E7A     MOVLW 0x7A
655C  6FEE     MOVWF 0xEE, BANKED
655E  0E44     MOVLW 0x44
6560  6FEF     MOVWF 0xEF, BANKED
194:               if(volt<0.0) volt=0.0;
6562  0104     MOVLB 0x4
6564  AFEF     BTFSS 0xEF, 7, BANKED
6566  D003     BRA 0x656E
6568  6BED     CLRF 0xED, BANKED
656A  6BEE     CLRF 0xEE, BANKED
656C  6BEF     CLRF 0xEF, BANKED
195:           
196:               //vvv=(unsigned char)(volt/10);
197:               //-----------------------------------------------------
198:               if(volt>=_F10V_OFF)  
656E  D860     RCALL PL486
6570  0100     MOVLB 0x0
6572  6B83     CLRF _PFNf_str_ncw, BANKED
6574  0EB4     MOVLW 0xB4
6576  6F84     MOVWF _PFNf_tdzCO, BANKED
6578  0E42     MOVLW 0x42
657A  6F85     MOVWF _PFNf_tdzCW, BANKED
657C  ECAE     CALL 0xA95C, 0
657E  F054     NOP
6580  E302     BNC 0x6586
199:               {
200:                   PFNf_bEnF10V=1;         //znacznik do aktywacji interfejsu=1 
6582  8608     BSF PFNf_b_set_nco, 3, ACCESS
201:               }
6584  D001     BRA 0x6588
202:               else
203:               {
204:                   PFNf_bEnF10V=0;         //znacznik do aktywacji interfejsu=0
6586  9608     BCF PFNf_b_set_nco, 3, ACCESS
205:               }
206:               
207:               if(RdPrt(S_bEN_10V))        //aktywacja interfejsu V>=0.9V
6588  0E07     MOVLW 0x7
658A  EC02     CALL 0xBA04, 0
658C  F05D     NOP
658E  E34C     BNC 0x6628
208:               {
209:                   PFNf_EnF10V=1;          //znacznik aktywnosci interfejsu
6590  8605     BSF PFNf_KnfDisErr, 3, ACCESS
6592  D84E     RCALL PL486
210:                   if(volt>=_F10V_ON)
6594  EC24     CALL 0x7048, 0
6596  F038     NOP
6598  ECAE     CALL 0xA95C, 0
659A  F054     NOP
659C  E302     BNC 0x65A2
211:                   {
212:                       PFNf_b10V_RT=1;     //znacznik do aktywacja pobudzenia RT=1
659E  8408     BSF PFNf_b_set_nco, 2, ACCESS
213:                   }
65A0  D001     BRA 0x65A4
214:                   else
215:                   {
216:                       PFNf_b10V_RT=0;     //znacznik do aktywacja pobudzenia RT=0
65A2  9408     BCF PFNf_b_set_nco, 2, ACCESS
217:                   }
218:                   if(!PFNf_10V_RT&&RdPrt(S_b10V_RT)) //wlasnie przekroczono prog pobudzenia RT?
65A4  B005     BTFSC PFNf_KnfDisErr, 0, ACCESS
65A6  D00A     BRA 0x65BC
65A8  0E08     MOVLW 0x8
65AA  EC02     CALL 0xBA04, 0
65AC  F05D     NOP
65AE  E306     BNC 0x65BC
219:                   {
220:                       PFNf_10V_RT=1;          //ustaw znacznik pobudzenia RT
65B0  8005     BSF PFNf_KnfDisErr, 0, ACCESS
221:                       SetPrt(S_10V_nPCO,1);   //aktywuj stan filtra (natychmiastowa aktualizacja nastawy)
65B2  0E01     MOVLW 0x1
65B4  6F74     MOVWF _PFNf_prODP, BANKED
65B6  0E09     MOVLW 0x9
65B8  ECDC     CALL 0xADB8, 0
65BA  F056     NOP
222:                   }
223:                   
224:                   if(PFNf_10V_RT)         //pobudzenie aktywne (przekroczono 2.2V)
65BC  A005     BTFSS PFNf_KnfDisErr, 0, ACCESS
65BE  D03F     BRA PL618
225:                   {
226:                       PFN.PCO10V=CalkNewPCO10V(volt); //nowa wartosc docelowa temperatury
65C0  C4ED     MOVFF volt, v
65C2  F4E1     NOP
65C4  C4EE     MOVFF 0x4EE, 0x4E2
65C6  F4E2     NOP
65C8  C4EF     MOVFF 0x4EF, 0x4E3
65CA  F4E3     NOP
65CC  EC7E     CALL 0x6EFC, 0
65CE  F037     NOP
65D0  0101     MOVLB 0x1
65D2  6FF7     MOVWF 0xF7, BANKED
227:                       if(PFN.PCO10V!=PFN.CONTSETP)         //zmiana wartosci nastawy?
65D4  51F9     MOVF 0xF9, W, BANKED
65D6  19F7     XORWF 0xF7, W, BANKED
65D8  E00E     BZ 0x65F6
228:                       {
229:                           if(PFNf_10V_nPCO&&(PFN.bPCO10V!=PFN.PCO10V))    //kolejna zmiana nastawy?
65DA  A205     BTFSS PFNf_KnfDisErr, 1, ACCESS
65DC  D009     BRA 0x65F0
65DE  51F7     MOVF 0xF7, W, BANKED
65E0  19F8     XORWF 0xF8, W, BANKED
65E2  E006     BZ 0x65F0
230:                           {
231:                               SetPrt(S_10V_nPCO,0);   //restart filtra (odczekaj az wartosc sie ustabilizuje)
65E4  0E00     MOVLW 0x0
65E6  0100     MOVLB 0x0
65E8  6F74     MOVWF _PFNf_prODP, BANKED
65EA  0E09     MOVLW 0x9
65EC  ECDC     CALL 0xADB8, 0
65EE  F056     NOP
232:                           }
233:                           PFNf_10V_nPCO=1;            //znacznik do zmiany nastawy PCO=1   
65F0  8205     BSF PFNf_KnfDisErr, 1, ACCESS
234:                           PFN.bPCO10V=PFN.PCO10V;                    
65F2  C1F7     MOVFF 0x1F7, 0x1F8
65F4  F1F8     NOP
235:                       }
236:                    
237:                       if(RdPrt(S_10V_nPCO))           //uzyskano stabilna wartosc nastawy?
65F6  0E09     MOVLW 0x9
65F8  EC02     CALL 0xBA04, 0
65FA  F05D     NOP
65FC  A0D8     BTFSS STATUS, 0, ACCESS
65FE  0012     RETURN 0
238:                       {
239:                           PFNf_10V_nPCO=0;
6600  9205     BCF PFNf_KnfDisErr, 1, ACCESS
240:                           SetPrt(S_10V_nPCO,0); //restart filtra
6602  0E00     MOVLW 0x0
6604  6F74     MOVWF _PFNf_prODP, BANKED
6606  0E09     MOVLW 0x9
6608  ECDC     CALL 0xADB8, 0
660A  F056     NOP
241:                           if((PFN.PCO10V>=PFN.SETPmin)&&(PFN.PCO10V<=PFN.SETPmax)) 
660C  51FA     MOVF 0xFA, W, BANKED
660E  5DF7     SUBWF 0xF7, W, BANKED
6610  A0D8     BTFSS STATUS, 0, ACCESS
6612  0012     RETURN 0
6614  51F7     MOVF 0xF7, W, BANKED
6616  5DFB     SUBWF 0xFB, W, BANKED
6618  A0D8     BTFSS STATUS, 0, ACCESS
661A  0012     RETURN 0
242:                           {                
243:                               PFN.CONTSETP=PFN.PCO10V;     //nowa wartosc docelowa dla WG
661C  C1F7     MOVFF 0x1F7, 0x1F9
661E  F1F9     NOP
244:                               PFN.bPCO10V=PFN.PCO10V;
6620  C1F7     MOVFF 0x1F7, 0x1F8
6622  F1F8     NOP
6624  0012     RETURN 0
245:                           }  
246:                       }
247:                   }
248:                   else
249:                   {
250:                       PFNf_10V_nPCO=0;    //znacznik do zmiany nastawy PCO=0
6626  D00B     BRA PL618
251:                       PFN.bPCO10V=PFN.SETPmin;
252:                   }
253:               }
254:               else    //deaktywacja interfejsu i pobudzenia
255:               {
256:                   PFNf_EnF10V=0;
6628  9605     BCF PFNf_KnfDisErr, 3, ACCESS
257:                   PFNf_10V_RT=0;
662A  9005     BCF PFNf_KnfDisErr, 0, ACCESS
258:                   
259:                   PFNf_b10V_RT=0;     //znacznik do aktywacja pobudzenia RT=0        
662C  9408     BCF PFNf_b_set_nco, 2, ACCESS
662E  D007     BRA PL618
260:                   PFNf_10V_nPCO=0;    //znacznik do zmiany nastawy PCO=0
261:                   
262:                   PFN.bPCO10V=PFN.SETPmin;
263:               }
264:           }
265:           /*---------------------------------------------------------------------------------*/
266:           /*---------------------------------------------------------------------------------*/
267:           /*---------------------------------------------------------------------------------*/
268:           #endif //_EXT_BOARD!=0
269:           
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/otInterpreter.c  ------------
1:             /*otInterpreter.c*/
2:             //Interpretacja odebranej ramki OT
3:             /*---------------------------------------------------------------------------------*/
4:             //#include <pic18.h>
5:             //#include <htc.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "main.tp.h"			//parametry globalne
9:             #include "otInterpreter.h"				//parametry lokalne
10:            
11:            extern volatile tpOTDta OT;
12:            volatile tpOTMaster OTMaster;
13:            extern volatile DataPFN PFN;
14:            extern tpRSDTA1 RSDT1;
15:            extern volatile unsigned int db;
16:            extern volatile bit MGSDf_NO_ODB;
17:            
18:            volatile unsigned char xxy,zzz,vvv;
19:            #if (_EXT_BOARD>=3)
20:            /*---------------------------------------------------------------------------------*/
21:            //Interpretacja odebranej ramki, 
22:            void OTInterpreter(void)
23:            {
24:                if(OT.ToACK)                                     //odebrano paczke danych, przejdz do interpretacji   
9926  0101     MOVLB 0x1
9928  5134     MOVF _PFNf_LIN_EPBCO, W, BANKED
992A  B4D8     BTFSC STATUS, 2, ACCESS
992C  0012     RETURN 0
25:                {
26:                    if(MGSDf_NO_ODB||PFN.vUNI02<0x09||(PFNf_LIN_KSK&&PFNf_FLIN)||(PFNf_LIN_STR&&PFNf_FLIN))    //brak polaczenia z UNI-02 lub wersja oprogramowania UNI-02<09 lub aktywny interfejs LIN w trybie sterowania?  
992E  BE03     BTFSC LIN1f_NDTA, 7, ACCESS
9930  D00A     BRA 0x9946
9932  0E08     MOVLW 0x8
9934  65EC     CPFSGT 0xEC, BANKED
9936  D007     BRA 0x9946
9938  AC06     BTFSS PFNf_LIN_CW, 6, ACCESS
993A  D002     BRA 0x9940
993C  BA05     BTFSC PFNf_KnfDisErr, 5, ACCESS
993E  D003     BRA 0x9946
9940  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
9942  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
9944  D01D     BRA 0x9980
27:                    {
28:                        OTMaster.Ref.war=0;
9946  6B5E     CLRF 0x5E, BANKED
9948  6B5F     CLRF 0x5F, BANKED
29:                        OTMaster.Status._DHW_enable=0;
994A  9365     BCF 0x65, 1, BANKED
30:                        OTMaster.Status._CH_enable=0;            
994C  9165     BCF 0x65, 0, BANKED
31:                        OT.ACKType=_OT_NO_RESP;
994E  0E02     MOVLW 0x2
9950  D00A     BRA 0x9966
32:                    }
33:                    else
34:                    {
35:                        switch(OT.RFrame.msg_type)
9980  3939     SWAPF _PFNf_LIN_RT, W, BANKED
9982  0B07     ANDLW 0x7
9984  E0E6     BZ 0x9952
9986  0A01     XORLW 0x1
9988  E0F0     BZ 0x996A
998A  D7E1     BRA 0x994E
36:                        {
37:                            case _READ_OT_DATA:
38:                            {
39:                                BitSet2(&RSDT1.inINSTAT,_FOT,1);        //odswiez znacznik komunikacji OT dla ukladu UNI-02                
9952  D820     RCALL PL328
9954  EC6D     CALL 0xACDA, 0
9956  F056     NOP
40:                                PFNf_FOT=1;
9958  8C05     BSF PFNf_KnfDisErr, 6, ACCESS
41:                                StartRTdS(_RTFOT);                
995A  0E0B     MOVLW 0xB
995C  EC55     CALL 0xBCAA, 0
995E  F05E     NOP
42:                                OT.ACKType=OTMSGReadData();
9960  EC05     CALL 0x3C0A, 0
9962  F01E     NOP
9964  D00B     BRA 0x997C
9966  6F35     MOVWF _PFNf_LIN_EPBCW, BANKED
43:                                break;
9968  D011     BRA 0x998C
44:                            }
45:                            case _WRITE_OT_DATA:
46:                            {
47:                                BitSet2(&RSDT1.inINSTAT,_FOT,1);        //odswiez znacznik komunikacji OT dla ukladu UNI-02                
996A  D814     RCALL PL328
996C  EC6D     CALL 0xACDA, 0
996E  F056     NOP
48:                                PFNf_FOT=1;
9970  8C05     BSF PFNf_KnfDisErr, 6, ACCESS
49:                                StartRTdS(_RTFOT);
9972  0E0B     MOVLW 0xB
9974  EC55     CALL 0xBCAA, 0
9976  F05E     NOP
50:                                OT.ACKType=OTMSGWriteData();
9978  EC06     CALL 0x4C0C, 0
997A  F026     NOP
997C  0101     MOVLB 0x1
997E  D7F3     BRA 0x9966
51:                                break;
52:                            }  
53:                            default:
54:                            {
55:                                OT.ACKType=_OT_NO_RESP;
56:                                break;
57:                            }
58:                        }
59:                    }
60:                    if(OT.ACKType!=0) OT.ToACK=0;               //gotowa odpowiedz
998C  5135     MOVF _PFNf_LIN_EPBCW, W, BANKED
998E  A4D8     BTFSS STATUS, 2, ACCESS
9990  6B34     CLRF _PFNf_LIN_EPBCO, BANKED
61:                }   
62:            }
9992  0012     RETURN 0
63:            /*---------------------------------------------------------------------------------*/
64:            /*---------------------------------------------------------------------------------*/
65:            void SetUkownAckRespData(void)
66:            {
67:                OT.TFrame.msg_type=_UNKOWN_ACK_OT_DATA;
BFCA  0E70     MOVLW 0x70
BFCC  0101     MOVLB 0x1
BFCE  133D     IORWF _PFNf_LINresSR, F, BANKED
68:                OT.TFrame.data_id=OT.RFrame.data_id;
BFD0  C138     MOVFF 0x138, 0x13C
BFD2  F13C     NOP
69:                OT.TFrame.data1=OT.RFrame.data1;
BFD4  C137     MOVFF 0x137, 0x13B
BFD6  F13B     NOP
70:                OT.TFrame.data0=OT.RFrame.data0;    
BFD8  C136     MOVFF 0x136, 0x13A
BFDA  F13A     NOP
71:            }
BFDC  0C70     RETLW 0x70
72:            void SetReadAckRespData(void)
73:            {
74:                OT.TFrame.msg_type=_READ_ACK_OT_DATA;
C106  0101     MOVLB 0x1
C108  513D     MOVF _PFNf_LINresSR, W, BANKED
C10A  0B8F     ANDLW 0x8F
C10C  0940     IORLW 0x40
C10E  6F3D     MOVWF _PFNf_LINresSR, BANKED
75:                OT.TFrame.data_id=OT.RFrame.data_id;   
C110  C138     MOVFF 0x138, 0x13C
C112  F13C     NOP
76:            }
C114  0012     RETURN 0
77:            void SetWriteAckRespData(void)
78:            {
79:                OT.TFrame.msg_type=_WRITE_ACK_OT_DATA;
BEB6  0101     MOVLB 0x1
BEB8  513D     MOVF _PFNf_LINresSR, W, BANKED
BEBA  0B8F     ANDLW 0x8F
BEBC  0950     IORLW 0x50
BEBE  6F3D     MOVWF _PFNf_LINresSR, BANKED
80:                OT.TFrame.data_id=OT.RFrame.data_id;
BEC0  C138     MOVFF 0x138, 0x13C
BEC2  F13C     NOP
81:                OT.TFrame.word0.war=OT.RFrame.word0.war;    
BEC4  C136     MOVFF 0x136, 0x13A
BEC6  F13A     NOP
BEC8  C137     MOVFF 0x137, 0x13B
BECA  F13B     NOP
82:            }
BECC  0012     RETURN 0
83:            /*---------------------------------------------------------------------------------*/
84:            /*---------------------------------------------------------------------------------*/
85:            //Interpretacja odebranej ramki z poleceniem odczytu
86:            unsigned char did[50]={0};
87:            unsigned char OTMSGReadData(void)
88:            {
89:                static unsigned char ind=0;//,a=0;
90:                
91:                if(ind<49)ind++;
3C0A  0E31     MOVLW 0x31
3C0C  0101     MOVLB 0x1
3C0E  61BB     CPFSLT 0xBB, BANKED
3C10  D002     BRA 0x3C16
3C12  2BBB     INCF 0xBB, F, BANKED
3C14  D001     BRA 0x3C18
92:                else ind=0;
3C16  6BBB     CLRF 0xBB, BANKED
93:                //a++;
94:                did[ind]=OT.RFrame.data_id;
3C18  0E55     MOVLW 0x55
3C1A  25BB     ADDWF 0xBB, W, BANKED
3C1C  6ED9     MOVWF FSR2, ACCESS
3C1E  6ADA     CLRF FSR2H, ACCESS
3C20  0E06     MOVLW 0x6
3C22  22DA     ADDWFC FSR2H, F, ACCESS
3C24  C138     MOVFF 0x138, INDF2
3C26  FFDF     NOP
95:                //db=a;
96:                switch(OT.RFrame.data_id)
3C28  D133     BRA 0x3E90
3E90  5138     MOVF _PFNf_LIN_PBCW, W, BANKED
97:                {
98:                    //-----------------------------------------
99:                    //Class 1 : Control and Status Information
100:                   case 0:     //Master and slave status flags
101:                   {
102:                       //_WOUTX=1;
103:                       SetReadAckRespData();
3C2A  EC83     CALL 0xC106, 0
3C2C  F060     NOP
104:                       //------------------------------
105:                       //byte1 - Master status
106:                       /*bit: description [ clear/0, set/1]
107:                       0: CH enable [ CH is disabled, CH is enabled]           //pobudzenie RT
108:                       1: DHW enable [ DHW is disabled, DHW is enabled]        //timer zasobnika
109:                       2: Cooling enable [ Cooling is disabled, Cooling is enabled]
110:                       3: OTC active [OTC not active, OTC is active]
111:                       4: CH2 enable [CH2 is disabled, CH2 is enabled]
112:                       5: Summer/winter mode [winter mode active, summer mode active]
113:                       6: DHW blocking [DHW unblocked, DHW blocked]
114:                       7: reserved
115:                        */
116:                       OTMaster.Ref._Status=1;
3C2E  835E     BSF 0x5E, 1, BANKED
117:                       OTMaster.Status.war=OT.RFrame.byte1.war;
3C30  C137     MOVFF 0x137, 0x165
3C32  F165     NOP
118:                       OT.TFrame.byte1.war=OT.RFrame.byte1.war;
3C34  C137     MOVFF 0x137, 0x13B
3C36  F13B     NOP
119:                       //if(RSDT1.inECO<=99) RSDT1.inECO++;
120:                       //else RSDT1.inECO=0;
121:                       //Regulator pogodowy
122:                       /*if(OTMaster.Status._OTC_active)
123:                       {
124:                           PFNf_OT_DPGD=1;                         //deaktywuj wewnetrzny regulator pogodowy
125:                       }
126:                       else
127:                       {
128:                           PFNf_OT_DPGD=0;                                  
129:                       }*/
130:                       //Zmiana ZIMA/LATO
131:                       /*if(!PFNf_pgd||(PFNf_pgd&&!PFNf_pgdTP))                             //przy regulatorze pogodowym w trybie przacy z regulatorem RT zezwol na zmiane stanu pzrelacznika ZIMA/LATO
132:                       {
133:                           if(OTMaster.Status._Summer_winter_mode)
134:                           {
135:                               PFNf_lato=1;
136:                               PFNf_zima=0;                
137:                           }
138:                           else
139:                           {
140:                               PFNf_lato=0;
141:                               PFNf_zima=1;                
142:                           }
143:                       }*/
144:                       //--------------------------------
145:                       //byte0 - Slave status
146:                       /*bit: description [ clear/0, set/1]
147:                       0: fault indication [ no fault, fault ]
148:                       1: CH mode [CH not active, CH active]
149:                       2: DHW mode [ DHW not active, DHW active]
150:                       3: Flame status [ flame off, flame on ]
151:                       4: Cooling status [ cooling mode not active, cooling mode active ]
152:                       5: CH2 mode [CH2 not active, CH2 active]
153:                       6: diagnostic/service indication [no diagnostic/service, diagnostic/service event]
154:                       7: Electricity production [off, on]
155:                        */            
156:                       OT.TFrame.byte0.war=0;
3C38  6B3A     CLRF _PFNf_LIN_STR, BANKED
157:                       if(PFNf_ferr||PFNf_fmsg) OT.TFrame.byte0.b0=1;          //fault indication=1
3C3A  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
3C3C  D002     BRA 0x3C42
3C3E  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
3C40  D002     BRA 0x3C46
3C42  813A     BSF _PFNf_LIN_STR, 0, BANKED
3C44  D001     BRA 0x3C48
158:                       else OT.TFrame.byte0.b0=0;                              //fault indication=0
3C46  913A     BCF _PFNf_LIN_STR, 0, BANKED
159:                       if(PFNf_obgCO) OT.TFrame.byte0.b1=1;                    //CH active
3C48  A60C     BTFSS PFNf_off, 3, ACCESS
3C4A  D002     BRA 0x3C50
3C4C  833A     BSF _PFNf_LIN_STR, 1, BANKED
3C4E  D001     BRA 0x3C52
160:                       else OT.TFrame.byte0.b1=0;                              //CH not active
3C50  933A     BCF _PFNf_LIN_STR, 1, BANKED
161:                       if(PFNf_obgCW) OT.TFrame.byte0.b2=1;                    //DHW active  
3C52  A80C     BTFSS PFNf_off, 4, ACCESS
3C54  D002     BRA 0x3C5A
3C56  853A     BSF _PFNf_LIN_STR, 2, BANKED
3C58  D001     BRA 0x3C5C
162:                       else OT.TFrame.byte0.b2=0;                              //DHW not active 
3C5A  953A     BCF _PFNf_LIN_STR, 2, BANKED
163:                       if(PFNf_plmCW||PFNf_plmCO) OT.TFrame.byte0.b3=1;        //flame status=1
3C5C  B00E     BTFSC PFNf_popFN, 0, ACCESS
3C5E  D002     BRA 0x3C64
3C60  AE0D     BTFSS PFNf_plmCO, 7, ACCESS
3C62  D002     BRA 0x3C68
3C64  873A     BSF _PFNf_LIN_STR, 3, BANKED
3C66  0C01     RETLW 0x1
164:                       else OT.TFrame.byte0.b3=0;                              //flame status=0
3C68  973A     BCF _PFNf_LIN_STR, 3, BANKED
165:                       //--------------------------------
166:                       return _OT_TO_RESP;            
3C6A  0C01     RETLW 0x1
167:                   }
168:                   case 5:     //Application-specific fault flags
169:                   {
170:                       SetReadAckRespData();      
3C6C  EC83     CALL 0xC106, 0
3C6E  F060     NOP
171:                       
172:                       OT.TFrame.byte1.war=0;
3C70  6B3B     CLRF _PFNf_LINres, BANKED
173:                       
174:                       if(PFNf_ferr) OT.TFrame.byte1.b0=1;                 //Service request [service not req?d, service required]
3C72  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3C74  D002     BRA 0x3C7A
3C76  813B     BSF _PFNf_LINres, 0, BANKED
3C78  D001     BRA 0x3C7C
175:                       else OT.TFrame.byte1.b0=0;
3C7A  913B     BCF _PFNf_LINres, 0, BANKED
176:                       if((PFNf_fmsg||PFNf_ferr)&&((PFN.KERR==9)||(PFN.KAWR==9))&&(PFN.CS<=6))
3C7C  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
3C7E  D002     BRA 0x3C84
3C80  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3C82  D00B     BRA 0x3C9A
3C84  0E09     MOVLW 0x9
3C86  19E3     XORWF 0xE3, W, BANKED
3C88  E003     BZ 0x3C90
3C8A  0E09     MOVLW 0x9
3C8C  19E2     XORWF 0xE2, W, BANKED
3C8E  E105     BNZ 0x3C9A
3C90  0E07     MOVLW 0x7
3C92  61DA     CPFSLT 0xDA, BANKED
3C94  D002     BRA 0x3C9A
177:                       {
178:                           OT.TFrame.byte1.b2=1;                           //Low water press [no WP fault, water pressure fault]
3C96  853B     BSF _PFNf_LINres, 2, BANKED
179:                       }
3C98  D001     BRA 0x3C9C
180:                       else OT.TFrame.byte1.b2=0;
3C9A  953B     BCF _PFNf_LINres, 2, BANKED
181:                       if((PFNf_fmsg||PFNf_ferr)&&((PFN.KERR==1)||(PFN.KAWR==1)))
3C9C  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
3C9E  D002     BRA 0x3CA4
3CA0  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3CA2  D006     BRA 0x3CB0
3CA4  05E3     DECF 0xE3, W, BANKED
3CA6  E002     BZ 0x3CAC
3CA8  05E2     DECF 0xE2, W, BANKED
3CAA  E102     BNZ 0x3CB0
182:                       {
183:                           OT.TFrame.byte1.b3=1;                           //Gas/flame fault [ no G/F fault, gas/flame fault ]
3CAC  873B     BSF _PFNf_LINres, 3, BANKED
184:                       }
3CAE  D001     BRA 0x3CB2
185:                       else OT.TFrame.byte1.b3=0;         
3CB0  973B     BCF _PFNf_LINres, 3, BANKED
186:                       if((PFNf_fmsg||PFNf_ferr)&&((PFN.KERR==3)||(PFN.KAWR==3)))
3CB2  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
3CB4  D002     BRA 0x3CBA
3CB6  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3CB8  D008     BRA 0x3CCA
3CBA  0E03     MOVLW 0x3
3CBC  19E3     XORWF 0xE3, W, BANKED
3CBE  E003     BZ 0x3CC6
3CC0  0E03     MOVLW 0x3
3CC2  19E2     XORWF 0xE2, W, BANKED
3CC4  E102     BNZ 0x3CCA
187:                       {
188:                           OT.TFrame.byte1.b4=1;                           //Air press fault [ no AP fault, air pressure fault ]
3CC6  893B     BSF _PFNf_LINres, 4, BANKED
189:                       }
3CC8  D001     BRA 0x3CCC
190:                       else OT.TFrame.byte1.b4=0;   
3CCA  993B     BCF _PFNf_LINres, 4, BANKED
191:                       if((PFNf_fmsg||PFNf_ferr)&&((PFN.KERR==2)||(PFN.KAWR==2)))
3CCC  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
3CCE  D002     BRA 0x3CD4
3CD0  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3CD2  D008     BRA 0x3CE4
3CD4  0E02     MOVLW 0x2
3CD6  19E3     XORWF 0xE3, W, BANKED
3CD8  E003     BZ 0x3CE0
3CDA  0E02     MOVLW 0x2
3CDC  19E2     XORWF 0xE2, W, BANKED
3CDE  E102     BNZ 0x3CE4
192:                       {
193:                           OT.TFrame.byte1.b5=1;                           //Water over-temp [ no OvT fault, over-temperat. Fault]
3CE0  8B3B     BSF _PFNf_LINres, 5, BANKED
194:                       }
3CE2  D001     BRA 0x3CE6
195:                       else OT.TFrame.byte1.b5=0;      
3CE4  9B3B     BCF _PFNf_LINres, 5, BANKED
196:                       if(PFNf_fmsg||PFNf_ferr) 
3CE6  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
3CE8  D002     BRA 0x3CEE
3CEA  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3CEC  D01A     BRA 0x3D22
197:                       {
198:                           if(PFNf_ferr) OT.TFrame.byte0.war=PFN.KERR;     //An OEM-specific fault/error code
3CEE  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
3CF0  D003     BRA 0x3CF8
3CF2  C1E3     MOVFF 0x1E3, 0x13A
3CF4  F13A     NOP
3CF6  0C01     RETLW 0x1
199:                           else OT.TFrame.byte0.war=PFN.KAWR;
3CF8  C1E2     MOVFF 0x1E2, 0x13A
3CFA  F13A     NOP
3CFC  0C01     RETLW 0x1
200:                       }
201:                       else OT.TFrame.byte0.war=0;
202:                       return _OT_TO_RESP;            
203:                   }
204:           
205:                   case 70:    //Status ventilation heat-recovery
206:                   case 72:    //Application-specific fault flags ventilation /heat-recovery   
207:                   case 73:    //OEM diagnostic code ventilation / heat-recovery            
208:                   case 101:   //Solar Storage mode and status 
209:                   case 115:   //OEM diagnostic code            
210:                   {
211:                       SetUkownAckRespData();
3CFE  ECE5     CALL 0xBFCA, 0
3D00  F05F     NOP
3D02  0C01     RETLW 0x1
212:                       return _OT_TO_RESP;
213:                   }
214:                   //--------------------------------------------
215:                   //Class 2 : Configuration Information
216:                   case 3:     //Slave configuration
217:                   {
218:                       SetReadAckRespData();  
3D04  EC83     CALL 0xC106, 0
3D06  F060     NOP
219:                       OT.TFrame.byte1.war=0;
3D08  6B3B     CLRF _PFNf_LINres, BANKED
220:                       OT.TFrame.byte1.b0=1;   //DHW present [ dhw not present, dhw is present ]
3D0A  813B     BSF _PFNf_LINres, 0, BANKED
221:                       //if(!PFNf_EnAleg) OT.TFrame.byte1.b0=0;   //DHW present [ dhw not present, dhw is present ]
222:                       //else OT.TFrame.byte1.b0=1;            
223:                       OT.TFrame.byte1.b1=0;   //Control type [ modulating, on/off ]
3D0C  933B     BCF _PFNf_LINres, 1, BANKED
224:                       OT.TFrame.byte1.b2=0;   //Cooling config [ cooling not supported,cooling supported]  
3D0E  953B     BCF _PFNf_LINres, 2, BANKED
225:                       if(!PFNf_EnAleg) OT.TFrame.byte1.b3=0;   //DHW config [instantaneous or not-specified,storage tank]
3D10  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
3D12  D002     BRA 0x3D18
3D14  973B     BCF _PFNf_LINres, 3, BANKED
3D16  D001     BRA 0x3D1A
226:                       else OT.TFrame.byte1.b3=1;
3D18  873B     BSF _PFNf_LINres, 3, BANKED
227:                       OT.TFrame.byte1.b4=1;   //Master low-off&pump control function [allowed,not allowed]
3D1A  893B     BSF _PFNf_LINres, 4, BANKED
228:                       OT.TFrame.byte1.b5=0;   //CH2 present [CH2 not present, CH2 present]            
3D1C  9B3B     BCF _PFNf_LINres, 5, BANKED
229:                       OT.TFrame.byte1.b6=0;   //Remote water filling function [available or unknown,not available]. Unknown for applications with protocol version 2.2 or older.           
3D1E  9D3B     BCF _PFNf_LINres, 6, BANKED
230:                       OT.TFrame.byte1.b7=1;   //Heat/cool mode control [Heat/cool mode switching can be done by master, Heat/cool mode switching is done by slave]  
3D20  8F3B     BSF _PFNf_LINres, 7, BANKED
231:                       
232:                       OT.TFrame.byte0.war=0;  //MemberID code of the slave
3D22  6B3A     CLRF _PFNf_LIN_STR, BANKED
3D24  0C01     RETLW 0x1
233:                       return _OT_TO_RESP;            
234:                   }
235:                   case 125:     //OpenTherm version Slave
236:                   {
237:                       SetReadAckRespData();
3D26  EC83     CALL 0xC106, 0
3D28  F060     NOP
238:                       
239:                       OT.TFrame.word0.war=DataToF88((float)_OT_VER); //The implemented version of the OpenTherm Protocol Specification in the ventilation / heatrecovery system.          
3D2A  0100     MOVLB 0x0
3D2C  6BA9     CLRF dt, BANKED
3D2E  0E80     MOVLW 0x80
3D30  6FAA     MOVWF f, BANKED
3D32  0E40     MOVLW 0x40
3D34  6FAB     MOVWF 0xAB, BANKED
3D36  ECCD     CALL 0xB59A, 0
3D38  F05A     NOP
3D3A  D0A5     BRA 0x3E86
240:                       return _OT_TO_RESP;            
241:                   } 
242:                   case 127:   //Slave product version number and type
243:                   {
244:                       SetReadAckRespData();
3D3C  EC83     CALL 0xC106, 0
3D3E  F060     NOP
245:                       OT.TFrame.byte1.war=0;    //produkt type
3D40  6B3B     CLRF _PFNf_LINres, BANKED
3D42  D7EF     BRA 0x3D22
246:                       OT.TFrame.byte0.war=0;    //product version          
247:                       return _OT_TO_RESP;            
248:                   }
249:                   case 74:    //OpenTherm version ventilation / heat-recovery 
250:                   case 75:    //Configuration ventilation / heat-recovery       
251:                   case 76:    //Ventilation / heatrecovery product version number and type            
252:                   case 103:   //Solar Storage configuration  
253:                   case 104:   //Solar Storage product version number and type
254:                   {
255:                       SetUkownAckRespData();
256:                       return _OT_TO_RESP;
257:                   } 
258:                   //-----------------------------------------
259:                   //Class 3 : Remote Request
260:                   //-----------------------------------------
261:                   //Class 4 : Sensor and Informational Data
262:                   case 17:     //Relative Modulation Level.
263:                   {
264:                       SetReadAckRespData();
3D44  EC83     CALL 0xC106, 0
3D46  F060     NOP
265:                       
266:                       OT.TFrame.word0.war=DataToF88(PFN.PG);      //Percent modulation between min and max modulation levels. i.e.
3D48  51DD     MOVF MOTFkrk, W, BANKED
3D4A  EC35     CALL 0xB86A, 0
3D4C  F05C     NOP
3D4E  D999     RCALL PL126
3D50  ECCD     CALL 0xB59A, 0
3D52  F05A     NOP
3D54  D098     BRA 0x3E86
267:                                                               //0% = Minimum modulation level
268:                                                               //100% = Maximum modulation level
269:                       return _OT_TO_RESP;            
270:                   }  
271:                   case 18:     //CH water pressure.
272:                   {
273:                       SetReadAckRespData();
3D56  EC83     CALL 0xC106, 0
3D58  F060     NOP
274:                       
275:                       OT.TFrame.word0.war=DataToF88((float)PFN.CS/10.0);   //Water pressure of the boiler CH circuit (bar)
3D5A  51DA     MOVF 0xDA, W, BANKED
3D5C  EC35     CALL 0xB86A, 0
3D5E  F05C     NOP
3D60  C07C     MOVFF _PFNf_setKey, _UAD1tf_RFExt
3D62  F09A     NOP
3D64  C07D     MOVFF _PFNf_set_aleg, _UAD1tf_TFData
3D66  F09B     NOP
3D68  C07E     MOVFF _PFNf_set_eco, _UAD1tf_TFEnd
3D6A  F09C     NOP
3D6C  6B9D     CLRF _UADtf_RData, BANKED
3D6E  0E20     MOVLW 0x20
3D70  6F9E     MOVWF _UADtf_REXT, BANKED
3D72  0E41     MOVLW 0x41
3D74  6F9F     MOVWF _UADtf_REnd, BANKED
3D76  ECE0     CALL 0x89C0, 0
3D78  F044     NOP
3D7A  C09A     MOVFF _UAD1tf_RFExt, dt
3D7C  F0A9     NOP
3D7E  C09B     MOVFF _UAD1tf_TFData, f
3D80  F0AA     NOP
3D82  C09C     MOVFF _UAD1tf_TFEnd, 0xAB
3D84  F0AB     NOP
3D86  ECCD     CALL 0xB59A, 0
3D88  F05A     NOP
3D8A  D07D     BRA 0x3E86
276:                       return _OT_TO_RESP;            
277:                   } 
278:                   /*case 19:     //Water flow rate 
279:                   {
280:                       SetReadAckRespData();
281:                       
282:                       OT.TFrame.word0.war=0;                      //Water flow rate through the DHW circuit (l/min)
283:                       return _OT_TO_RESP;            
284:                   }*/        
285:                   case 25:     //Boiler water temp.
286:                   {
287:                       SetReadAckRespData();
3D8C  EC83     CALL 0xC106, 0
3D8E  F060     NOP
288:                       
289:                       OT.TFrame.word0.war=DataToF88(PFN.CO);      //Flow water temperature from boiler (°C)
3D90  51D8     MOVF 0xD8, W, BANKED
3D92  EC35     CALL 0xB86A, 0
3D94  F05C     NOP
3D96  D975     RCALL PL126
3D98  ECCD     CALL 0xB59A, 0
3D9A  F05A     NOP
3D9C  D074     BRA 0x3E86
290:                       return _OT_TO_RESP;            
291:                   }
292:                   case 26:     //DHW temperature
293:                   {
294:                       SetReadAckRespData();
3D9E  EC83     CALL 0xC106, 0
3DA0  F060     NOP
295:                       
296:                       OT.TFrame.word0.war=DataToF88(PFN.CW);      // Domestic hot water temperature (°C)           
3DA2  51D9     MOVF nrp, W, BANKED
3DA4  EC35     CALL 0xB86A, 0
3DA6  F05C     NOP
3DA8  D96C     RCALL PL126
3DAA  ECCD     CALL 0xB59A, 0
3DAC  F05A     NOP
3DAE  D06B     BRA 0x3E86
297:                       return _OT_TO_RESP;            
298:                   }   
299:                   case 27:   //Outside temperature
300:                   {
301:                       if(PFNf_tmpZW)      //aktywny czujnik zewnetrzny?
3DB0  AE10     BTFSS PFNf_str_nco, 7, ACCESS
3DB2  D011     BRA 0x3DD6
302:                       {
303:                           SetReadAckRespData();
3DB4  EC83     CALL 0xC106, 0
3DB6  F060     NOP
304:                           if(!PFNf_pgd||(PFNf_pgd&&!PFNf_pgdTP))
3DB8  AA0D     BTFSS PFNf_plmCO, 5, ACCESS
3DBA  D003     BRA 0x3DC2
3DBC  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
3DBE  BC0D     BTFSC PFNf_plmCO, 6, ACCESS
3DC0  D002     BRA 0x3DC6
305:                           {
306:                               PFNf_OT_DPGD=1;
3DC2  8E07     BSF PFNf_OTTimeout, 7, ACCESS
307:                           }
3DC4  D001     BRA 0x3DC8
308:                           else
309:                           {
310:                               PFNf_OT_DPGD=0;
3DC6  9E07     BCF PFNf_OTTimeout, 7, ACCESS
311:                           }
312:                           OT.TFrame.word0.war=DataToF88(PFN.ZW);      // Outside temperature (°C)
3DC8  51DE     MOVF ROTFkrk, W, BANKED
3DCA  EC35     CALL 0xB86A, 0
3DCC  F05C     NOP
3DCE  D959     RCALL PL126
3DD0  ECCD     CALL 0xB59A, 0
3DD2  F05A     NOP
3DD4  D058     BRA 0x3E86
313:                           return _OT_TO_RESP;
314:                       }
315:                       else
316:                       {
317:                           SetUkownAckRespData();
3DD6  ECE5     CALL 0xBFCA, 0
3DD8  F05F     NOP
318:                           PFNf_OT_DPGD=0;
3DDA  9E07     BCF PFNf_OTTimeout, 7, ACCESS
3DDC  0C01     RETLW 0x1
319:                           return _OT_TO_RESP;                
320:                       }
321:                   }            
322:                   case 28:     //Return water temperature
323:                   {
324:                       SetReadAckRespData();
3DDE  EC83     CALL 0xC106, 0
3DE0  F060     NOP
325:                       
326:                       OT.TFrame.word0.war=DataToF88(PFN.IN);      // Domestic hot water temperature (°C)
3DE2  51DB     MOVF zmn2, W, BANKED
3DE4  EC35     CALL 0xB86A, 0
3DE6  F05C     NOP
3DE8  D94C     RCALL PL126
3DEA  ECCD     CALL 0xB59A, 0
3DEC  F05A     NOP
3DEE  D04B     BRA 0x3E86
327:                       return _OT_TO_RESP;            
328:                   }        
329:                   case 35:     //Boiler fan speed
330:                   {
331:                       SetReadAckRespData();
3DF0  EC83     CALL 0xC106, 0
3DF2  F060     NOP
332:                       
333:                       OT.TFrame.data1=(unsigned char) (PFN.VNT*100)/60;   //Actual boiler fan speed Setpoint in Hz (RPM/60)
3DF4  D94D     RCALL PL416
3DF6  EC62     CALL 0xB4C4, 0
3DF8  F05A     NOP
3DFA  0101     MOVLB 0x1
3DFC  6F3B     MOVWF _PFNf_LINres, BANKED
3DFE  D948     RCALL PL416
334:                       OT.TFrame.data0=(unsigned char) (PFN.VNT*100)/60;   //Actual boiler fan speed in Hz (RPM/60)           
3E00  EC62     CALL 0xB4C4, 0
3E02  F05A     NOP
3E04  0101     MOVLB 0x1
3E06  6F3A     MOVWF _PFNf_LIN_STR, BANKED
3E08  0C01     RETLW 0x1
335:                       return _OT_TO_RESP;            
336:                   }      
337:                   case 19:   //Water flow rate
338:                   case 20:   //Day of Week & Time of Day        
339:                   case 21:   //Date
340:                   case 22:   //Year            
341:           
342:                   case 29:   //Solar storage temperature        
343:                   case 30:   //Solar collector temperature        
344:                   case 31:   //Flow temperature CH2
345:                   case 32:   //DHW2 temperature        
346:                   case 33:   //Exhaust temperature (temp. spalin)        
347:                   case 34:   //Boiler heat exchanger temperature     
348:                   case 36:   //Flame current        
349:                   case 37:   //TrCH2        
350:                   case 38:   //Relative Humidity
351:                   case 77:   //Relative ventilation        
352:                   case 78:   //Relative humidity        
353:                   case 79:   //CO2 level 
354:                   case 80:   //Supply inlet temperature
355:                   case 81:   //Supply outlet temperature        
356:                   case 82:   //Exhaust inlet temperature        
357:                   case 83:   //Exhaust outlet temperature  
358:                   case 84:   //Actual exhaust fan speed        
359:                   case 85:   //Actual inlet fan speed           
360:                   case 109:  //Electricity producer starts  
361:                   case 110:  //Electricity producer hours        
362:                   case 111:  //Electricity production      
363:                   case 112:  //Cumulative Electricity production        
364:                   case 113:  //Number of un-successful burner starts  
365:                   case 114:  //Number of times flame signal was too low        
366:                   case 116:  //Successful Burner starts        
367:                   case 117:  //CH pump starts        
368:                   case 118:  //DHW pump/valve starts  
369:                   case 119:  //DHW burner starts        
370:                   case 120:  //Burner operation hours            
371:                   case 121:  //CH pump operation hours        
372:                   case 122:  //DHW pump/valve operation hours  
373:                   case 123:  //DHW burner operation hours                     
374:                   {
375:                       SetUkownAckRespData();
376:                       return _OT_TO_RESP;
377:                   }  
378:                   //-----------------------------------------
379:                   //Class 5 : Pre-Defined Remote Boiler Parameters
380:                   case 6:     //Remote-parameter transfer-enable flags
381:                   {
382:                       SetReadAckRespData();
3E0A  EC83     CALL 0xC106, 0
3E0C  F060     NOP
383:                       
384:                       OT.TFrame.byte1.war=0;  //Remote-parameter transfer-enable flags
3E0E  6B3B     CLRF _PFNf_LINres, BANKED
385:                       OT.TFrame.byte1.b0=1;   //0: DHW Setpoint [ transfer disabled, transfer enabled ]
3E10  813B     BSF _PFNf_LINres, 0, BANKED
386:                       OT.TFrame.byte1.b1=1;   //max CHsetpoint [ transfer disabled, transfer enabled ]   
3E12  833B     BSF _PFNf_LINres, 1, BANKED
387:                       OT.TFrame.byte0.war=0;  //Remote-parameter transfer-enable flags
3E14  6B3A     CLRF _PFNf_LIN_STR, BANKED
388:                       OT.TFrame.byte0.b0=1;   //DHW Setpoint [ read-only, read/write ]
3E16  813A     BSF _PFNf_LIN_STR, 0, BANKED
389:                       OT.TFrame.byte0.b1=1;   //max CHsetpoint [ read-only, read/write ]            
3E18  833A     BSF _PFNf_LIN_STR, 1, BANKED
3E1A  0C01     RETLW 0x1
390:                       return _OT_TO_RESP;            
391:                   }
392:                   case 48:     //DHWsetp upp-bound, low-bound
393:                   {
394:                       SetReadAckRespData();
3E1C  EC83     CALL 0xC106, 0
3E1E  F060     NOP
395:                       
396:                       OT.TFrame.data1=PFN.maxPCW;   //DHW Setpoint upper & lower bounds for adjustment (°C)
3E20  C1E8     MOVFF 0x1E8, 0x13B
3E22  F13B     NOP
397:                       OT.TFrame.data0=PFN.minPCW;   //DHW Setpoint upper & lower bounds for adjustment (°C)              
3E24  C1EA     MOVFF 0x1EA, 0x13A
3E26  F13A     NOP
3E28  0C01     RETLW 0x1
398:                       return _OT_TO_RESP;            
399:                   }   
400:                   case 49:     //max CHsetp upp-bound, low-bound
401:                   {
402:                       SetReadAckRespData();
3E2A  EC83     CALL 0xC106, 0
3E2C  F060     NOP
403:                       if(!PFNf_pgd)
3E2E  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
3E30  D005     BRA 0x3E3C
404:                       {
405:                           OT.TFrame.data1=PFN.maxPCO;   //Max CH water Setpoint upper & lower bounds for adjustment (°C)
3E32  C1E4     MOVFF 0x1E4, 0x13B
3E34  F13B     NOP
406:                           OT.TFrame.data0=PFN.minPCO;   //Max CH water Setpoint upper & lower bounds for adjustment (°C)
3E36  C1E6     MOVFF 0x1E6, 0x13A
3E38  F13A     NOP
407:                       }
3E3A  0C01     RETLW 0x1
408:                       else
409:                       {
410:                           OT.TFrame.data1=PFN.SETPmax;
3E3C  C1FB     MOVFF 0x1FB, 0x13B
3E3E  F13B     NOP
411:                           OT.TFrame.data0=PFN.SETPmin;
3E40  C1FA     MOVFF 0x1FA, 0x13A
3E42  F13A     NOP
3E44  0C01     RETLW 0x1
412:                       }
413:                       return _OT_TO_RESP;            
414:                   } 
415:                   case 56:     //DHW Setpoint
416:                   {
417:                       SetReadAckRespData();
3E46  EC83     CALL 0xC106, 0
3E48  F060     NOP
418:                       
419:                       OT.TFrame.word0.war=DataToF88(PFN.PCW);      // Domestic hot water temperature Setpoint (°C)
3E4A  C1F0     MOVFF 0x1F0, _PFNf_setKey
3E4C  F07C     NOP
3E4E  C1F1     MOVFF 0x1F1, _PFNf_set_aleg
3E50  F07D     NOP
3E52  EC35     CALL 0xBC6A, 0
3E54  F05E     NOP
3E56  D924     RCALL PL480
3E58  ECCD     CALL 0xB59A, 0
3E5A  F05A     NOP
3E5C  D014     BRA 0x3E86
420:                       return _OT_TO_RESP;            
421:                   }        
422:                   case 57:     //max CH water Setpoint
423:                   {
424:                       SetReadAckRespData();
3E5E  EC83     CALL 0xC106, 0
3E60  F060     NOP
425:                       if(!PFNf_pgd)
3E62  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
3E64  D00A     BRA 0x3E7A
426:                       {            
427:                           OT.TFrame.word0.war=DataToF88(PFN.PCO);          //Maximum allowable CH water Setpoint (°C)
3E66  C1EE     MOVFF 0x1EE, _PFNf_setKey
3E68  F07C     NOP
3E6A  C1EF     MOVFF 0x1EF, _PFNf_set_aleg
3E6C  F07D     NOP
3E6E  EC35     CALL 0xBC6A, 0
3E70  F05E     NOP
3E72  D916     RCALL PL480
3E74  ECCD     CALL 0xB59A, 0
3E76  F05A     NOP
3E78  D006     BRA 0x3E86
428:                       }
429:                       else
430:                       {
431:                           OT.TFrame.word0.war=DataToF88(PFN.SETPmax);      //Maximum allowable CH water Setpoint (°C)                
3E7A  51FB     MOVF 0xFB, W, BANKED
3E7C  EC35     CALL 0xB86A, 0
3E7E  F05C     NOP
3E80  D900     RCALL PL126
3E82  ECCD     CALL 0xB59A, 0
3E84  F05A     NOP
3E86  C0A9     MOVFF dt, 0x13A
3E88  F13A     NOP
3E8A  C0AA     MOVFF f, 0x13B
3E8C  F13B     NOP
3E8E  0C01     RETLW 0x1
3E90  5138     MOVF _PFNf_LIN_PBCW, W, BANKED
3E92  E101     BNZ 0x3E96
3E94  D6CA     BRA 0x3C2A
3E96  0A03     XORLW 0x3
3E98  E101     BNZ 0x3E9C
3E9A  D734     BRA 0x3D04
3E9C  0A06     XORLW 0x6
3E9E  E101     BNZ 0x3EA2
3EA0  D6E5     BRA 0x3C6C
3EA2  0A03     XORLW 0x3
3EA4  E0B2     BZ 0x3E0A
3EA6  0A01     XORLW 0x1
3EA8  E101     BNZ 0x3EAC
3EAA  D729     BRA 0x3CFE
3EAC  0A0E     XORLW 0xE
3EAE  E101     BNZ 0x3EB2
3EB0  D726     BRA 0x3CFE
3EB2  0A03     XORLW 0x3
3EB4  E101     BNZ 0x3EB8
3EB6  D723     BRA 0x3CFE
3EB8  0A01     XORLW 0x1
3EBA  E101     BNZ 0x3EBE
3EBC  D720     BRA 0x3CFE
3EBE  0A07     XORLW 0x7
3EC0  E101     BNZ 0x3EC4
3EC2  D71D     BRA 0x3CFE
3EC4  0A01     XORLW 0x1
3EC6  E101     BNZ 0x3ECA
3EC8  D71A     BRA 0x3CFE
3ECA  0A03     XORLW 0x3
3ECC  E101     BNZ 0x3ED0
3ECE  D717     BRA 0x3CFE
3ED0  0A01     XORLW 0x1
3ED2  E101     BNZ 0x3ED6
3ED4  D714     BRA 0x3CFE
3ED6  0A1E     XORLW 0x1E
3ED8  E101     BNZ 0x3EDC
3EDA  D734     BRA 0x3D44
3EDC  0A03     XORLW 0x3
3EDE  E101     BNZ 0x3EE2
3EE0  D73A     BRA 0x3D56
3EE2  0A01     XORLW 0x1
3EE4  E101     BNZ 0x3EE8
3EE6  D70B     BRA 0x3CFE
3EE8  0A07     XORLW 0x7
3EEA  E101     BNZ 0x3EEE
3EEC  D708     BRA 0x3CFE
3EEE  0A01     XORLW 0x1
3EF0  E101     BNZ 0x3EF4
3EF2  D705     BRA 0x3CFE
3EF4  0A03     XORLW 0x3
3EF6  E101     BNZ 0x3EFA
3EF8  D702     BRA 0x3CFE
3EFA  0A0F     XORLW 0xF
3EFC  E101     BNZ 0x3F00
3EFE  D746     BRA 0x3D8C
3F00  0A03     XORLW 0x3
3F02  E101     BNZ 0x3F06
3F04  D74C     BRA 0x3D9E
3F06  0A01     XORLW 0x1
3F08  E101     BNZ 0x3F0C
3F0A  D752     BRA 0x3DB0
3F0C  0A07     XORLW 0x7
3F0E  E101     BNZ 0x3F12
3F10  D766     BRA 0x3DDE
3F12  0A01     XORLW 0x1
3F14  E101     BNZ 0x3F18
3F16  D6F3     BRA 0x3CFE
3F18  0A03     XORLW 0x3
3F1A  E101     BNZ 0x3F1E
3F1C  D6F0     BRA 0x3CFE
3F1E  0A01     XORLW 0x1
3F20  E101     BNZ 0x3F24
3F22  D6ED     BRA 0x3CFE
3F24  0A3F     XORLW 0x3F
3F26  E101     BNZ 0x3F2A
3F28  D6EA     BRA 0x3CFE
3F2A  0A01     XORLW 0x1
3F2C  E101     BNZ 0x3F30
3F2E  D6E7     BRA 0x3CFE
3F30  0A03     XORLW 0x3
3F32  E101     BNZ 0x3F36
3F34  D6E4     BRA 0x3CFE
3F36  0A01     XORLW 0x1
3F38  E101     BNZ 0x3F3C
3F3A  D75A     BRA 0x3DF0
3F3C  0A07     XORLW 0x7
3F3E  E101     BNZ 0x3F42
3F40  D6DE     BRA 0x3CFE
3F42  0A01     XORLW 0x1
3F44  E101     BNZ 0x3F48
3F46  D6DB     BRA 0x3CFE
3F48  0A03     XORLW 0x3
3F4A  E101     BNZ 0x3F4E
3F4C  D6D8     BRA 0x3CFE
3F4E  0A16     XORLW 0x16
3F50  E101     BNZ 0x3F54
3F52  D764     BRA 0x3E1C
3F54  0A01     XORLW 0x1
3F56  E101     BNZ 0x3F5A
3F58  D768     BRA 0x3E2A
3F5A  0A09     XORLW 0x9
3F5C  E101     BNZ 0x3F60
3F5E  D773     BRA 0x3E46
3F60  0A01     XORLW 0x1
3F62  E101     BNZ 0x3F66
3F64  D77C     BRA 0x3E5E
3F66  0A7F     XORLW 0x7F
3F68  E101     BNZ 0x3F6C
3F6A  D6C9     BRA 0x3CFE
3F6C  0A0E     XORLW 0xE
3F6E  E101     BNZ 0x3F72
3F70  D6C6     BRA 0x3CFE
3F72  0A01     XORLW 0x1
3F74  E101     BNZ 0x3F78
3F76  D6C3     BRA 0x3CFE
3F78  0A03     XORLW 0x3
3F7A  E101     BNZ 0x3F7E
3F7C  D6C0     BRA 0x3CFE
3F7E  0A01     XORLW 0x1
3F80  E101     BNZ 0x3F84
3F82  D6BD     BRA 0x3CFE
3F84  0A07     XORLW 0x7
3F86  E101     BNZ 0x3F8A
3F88  D6BA     BRA 0x3CFE
3F8A  0A01     XORLW 0x1
3F8C  E101     BNZ 0x3F90
3F8E  D6B7     BRA 0x3CFE
3F90  0A03     XORLW 0x3
3F92  E101     BNZ 0x3F96
3F94  D6B4     BRA 0x3CFE
3F96  0A01     XORLW 0x1
3F98  E101     BNZ 0x3F9C
3F9A  D6B1     BRA 0x3CFE
3F9C  0A1F     XORLW 0x1F
3F9E  E101     BNZ 0x3FA2
3FA0  D6AE     BRA 0x3CFE
3FA2  0A01     XORLW 0x1
3FA4  E101     BNZ 0x3FA8
3FA6  D6AB     BRA 0x3CFE
3FA8  0A03     XORLW 0x3
3FAA  E101     BNZ 0x3FAE
3FAC  D6A8     BRA 0x3CFE
3FAE  0A01     XORLW 0x1
3FB0  E101     BNZ 0x3FB4
3FB2  D6A5     BRA 0x3CFE
3FB4  0A07     XORLW 0x7
3FB6  E101     BNZ 0x3FBA
3FB8  D6A2     BRA 0x3CFE
3FBA  0A01     XORLW 0x1
3FBC  E101     BNZ 0x3FC0
3FBE  D69F     BRA 0x3CFE
3FC0  0A03     XORLW 0x3
3FC2  E101     BNZ 0x3FC6
3FC4  D69C     BRA 0x3CFE
3FC6  0A01     XORLW 0x1
3FC8  E101     BNZ 0x3FCC
3FCA  D699     BRA 0x3CFE
3FCC  0A0F     XORLW 0xF
3FCE  E101     BNZ 0x3FD2
3FD0  D696     BRA 0x3CFE
3FD2  0A01     XORLW 0x1
3FD4  E101     BNZ 0x3FD8
3FD6  D693     BRA 0x3CFE
3FD8  0A03     XORLW 0x3
3FDA  E101     BNZ 0x3FDE
3FDC  D690     BRA 0x3CFE
3FDE  0A01     XORLW 0x1
3FE0  E101     BNZ 0x3FE4
3FE2  D68D     BRA 0x3CFE
3FE4  0A38     XORLW 0x38
3FE6  E101     BNZ 0x3FEA
3FE8  D68A     BRA 0x3CFE
3FEA  0A07     XORLW 0x7
3FEC  E101     BNZ 0x3FF0
3FEE  D687     BRA 0x3CFE
3FF0  0A01     XORLW 0x1
3FF2  E101     BNZ 0x3FF6
3FF4  D684     BRA 0x3CFE
3FF6  0A02     XORLW 0x2
3FF8  E101     BNZ 0x3FFC
3FFA  D681     BRA 0x3CFE
3FFC  0A0F     XORLW 0xF
3FFE  E101     BNZ 0x4002
4000  D67E     BRA 0x3CFE
4002  0A01     XORLW 0x1
4004  E101     BNZ 0x4008
4006  D67B     BRA 0x3CFE
4008  0A03     XORLW 0x3
400A  E101     BNZ 0x400E
400C  D678     BRA 0x3CFE
400E  0A01     XORLW 0x1
4010  E101     BNZ 0x4014
4012  D675     BRA 0x3CFE
4014  0A07     XORLW 0x7
4016  E101     BNZ 0x401A
4018  D672     BRA 0x3CFE
401A  0A01     XORLW 0x1
401C  E101     BNZ 0x4020
401E  D66F     BRA 0x3CFE
4020  0A03     XORLW 0x3
4022  E101     BNZ 0x4026
4024  D66C     BRA 0x3CFE
4026  0A01     XORLW 0x1
4028  E101     BNZ 0x402C
402A  D669     BRA 0x3CFE
402C  0A1F     XORLW 0x1F
402E  E101     BNZ 0x4032
4030  D666     BRA 0x3CFE
4032  0A01     XORLW 0x1
4034  E101     BNZ 0x4038
4036  D663     BRA 0x3CFE
4038  0A03     XORLW 0x3
403A  E101     BNZ 0x403E
403C  D660     BRA 0x3CFE
403E  0A01     XORLW 0x1
4040  E101     BNZ 0x4044
4042  D65D     BRA 0x3CFE
4044  0A07     XORLW 0x7
4046  E101     BNZ 0x404A
4048  D65A     BRA 0x3CFE
404A  0A01     XORLW 0x1
404C  E101     BNZ 0x4050
404E  D657     BRA 0x3CFE
4050  0A03     XORLW 0x3
4052  E101     BNZ 0x4056
4054  D654     BRA 0x3CFE
4056  0A01     XORLW 0x1
4058  E101     BNZ 0x405C
405A  D651     BRA 0x3CFE
405C  0A0F     XORLW 0xF
405E  E101     BNZ 0x4062
4060  D64E     BRA 0x3CFE
4062  0A01     XORLW 0x1
4064  E101     BNZ 0x4068
4066  D64B     BRA 0x3CFE
4068  0A03     XORLW 0x3
406A  E101     BNZ 0x406E
406C  D648     BRA 0x3CFE
406E  0A01     XORLW 0x1
4070  E101     BNZ 0x4074
4072  D645     BRA 0x3CFE
4074  0A06     XORLW 0x6
4076  E101     BNZ 0x407A
4078  D656     BRA 0x3D26
407A  0A02     XORLW 0x2
407C  E101     BNZ 0x4080
407E  D65E     BRA 0x3D3C
4080  D63E     BRA 0x3CFE
432:                       }
433:                       return _OT_TO_RESP;            
434:                   }               
435:                   case 86:  //Remote-parameter transfer-enable flags ventilation / heat-recovery 
436:                   case 87:  //Nominal ventilation value            
437:                   {
438:                       SetUkownAckRespData();
439:                       return _OT_TO_RESP;
440:                   } 
441:                   //-----------------------------------------
442:                   //Class 6 : Transparent Slave Parameters
443:                   /*case 10:  //Number of TSP's 
444:                   {
445:                       SetReadAckRespData();
446:                       
447:                       OT.TFrame.word0.war=0;      // Number of transparent-slave-parameter supported by the slave device.
448:                       return _OT_TO_RESP;            
449:                   }*/
450:                   case 10:  //Number of TSP's        
451:                   case 11:  //TSP index no, value 
452:                   case 88:  //Number of TSP?s ventilation / heat-recovery 
453:                   case 89:  //TSP index no. ventilation / heat-recovery     
454:                   case 105:  //Number of TSP?s Solar Storage 
455:                   case 106:  //TSP index no. SolarStorage            
456:                   {
457:                       SetUkownAckRespData();            
458:                       return _OT_TO_RESP;
459:                   }  
460:                   //-----------------------------------------
461:                   //Class 7 : Fault History Data      
462:                   /*case 12:  //Size of Fault Buffer 
463:                   {
464:                       SetReadAckRespData();
465:                       
466:                       OT.TFrame.word0.war=0;      // The size of the fault history buffer..
467:                       return _OT_TO_RESP;            
468:                   }*/  
469:                   case 12:  //Size of Fault Buffer        
470:                   case 13:  //FHB-entry index no 
471:                   case 90:  //Size of Fault Buffer ventilation / heat-recovery 
472:                   case 91:  //FHB-entry index no. ventilation / heat-recovery     
473:                   case 107:  //Size of Fault Buffer Solar Storage 
474:                   case 108:  //FHB-entry index no.Solar Storage            
475:                   {
476:                       SetUkownAckRespData();            
477:                       return _OT_TO_RESP;
478:                   }  
479:                   //-----------------------------------------
480:                   //Class 8 : Control of Special Applications
481:                   /*case 9:  //Remote Override Room Setpoint    
482:                   {
483:                       SetReadAckRespData();
484:                       
485:                       OT.TFrame.word0.war=0;      // 0= No override 1..30= Remote override room Setpoint
486:                       return _OT_TO_RESP;            
487:                   }     
488:                   case 99:  //Remote Override Operating Mode Heating
489:                   {
490:                       SetReadAckRespData();
491:                       
492:                       OT.TFrame.byte1.war=0;      //Remote Override Operating Mode DHW            
493:                       OT.TFrame.byte0.war=0;      //Remote Override Operating Mode Heating
494:                       return _OT_TO_RESP;            
495:                   }            
496:                   case 100:  //Remote Override Room Setpoint function         
497:                   {
498:                       SetReadAckRespData();
499:                       
500:                       OT.TFrame.byte1.war=0;   //reserved
501:                       OT.TFrame.byte0.war=0;   //Remote Override Room Setpoint function
502:                       OT.TFrame.byte0.b0=0;//Manual change priority [disable overruling remote Setpoint by manual Setpoint change, enable overruling remote Setpoint by manual Setpoint change ]
503:                       OT.TFrame.byte0.b1=0;//Program change priority [disable overruling remote Setpoint by program Setpoint change, enable overruling remote Setpoint by program Setpoint change ]            
504:                       return _OT_TO_RESP;            
505:                   }*/
506:                   case 9:  //Remote Override Room Setpoint
507:                   case 99:  //Remote Override Operating Mode Heating 
508:                   case 100:  //Remote Override Room Setpoint function   
509:                   case 7:  //Cooling control signal    
510:                   case 14:  //Maximum relative modulation level setting 
511:                   case 15:  //Maximum boiler capacity & Minimum modulation level  
512:                   {
513:                       SetUkownAckRespData();            
514:                       return _OT_TO_RESP;
515:                   } 
516:                   default:
517:                   {
518:                       SetUkownAckRespData();            
519:                       return _OT_TO_RESP;            
520:                   }
521:               }
522:           }
523:           /*---------------------------------------------------------------------------------*/
524:           //Interpretacja odebranej ramki z poleceniem zapisu
525:           unsigned char OTMSGWriteData(void)
526:           {
527:               /*static unsigned char ind=0,a=0;
528:               if(ind<49)ind++;
529:               else ind=0;
530:               a++;
531:               did[ind]=OT.RFrame.data_id;
532:               db=a; 
533:               */
534:               switch(OT.RFrame.data_id)
4C0C  D107     BRA 0x4E1C
4E1C  0101     MOVLB 0x1
535:               {
536:                   //-----------------------------------------
537:                   //Class 1 : Control and Status Information
538:                   case 1:     //Control Setpoint f8.8
539:                   {
540:                       SetWriteAckRespData();           
4C0E  EC5B     CALL 0xBEB6, 0
4C10  F05F     NOP
541:                       OTMaster.Ref._Control_Setpoint=1;
4C12  8D5E     BSF 0x5E, 6, BANKED
542:                       OTMaster.Control_Setpoint=F88ToData((signed int) OT.RFrame.word0.war);
4C14  D994     RCALL PL344
4C16  EC1B     CALL 0xB636, 0
4C18  F05B     NOP
4C1A  C080     MOVFF _PFNf_set_nco, 0x167
4C1C  F167     NOP
4C1E  C081     MOVFF _PFNf_set_ncw, 0x168
4C20  F168     NOP
4C22  C082     MOVFF _PFNf_str_nco, 0x169
4C24  F169     NOP
543:                       if((OTMaster.Control_Setpoint>=PFN.SETPmin)&&(OTMaster.Control_Setpoint<=PFN.SETPmax))   //dolna granica =minPCO, gorna granica =PCO
4C26  D990     RCALL PL356
4C28  EC35     CALL 0xB86A, 0
4C2A  F05C     NOP
4C2C  D981     RCALL PL300
4C2E  ECAE     CALL 0xA95C, 0
4C30  F054     NOP
4C32  E310     BNC 0x4C54
4C34  0101     MOVLB 0x1
4C36  51FB     MOVF 0xFB, W, BANKED
4C38  EC35     CALL 0xB86A, 0
4C3A  F05C     NOP
4C3C  D96C     RCALL PL244
4C3E  ECAE     CALL 0xA95C, 0
4C40  F054     NOP
4C42  E308     BNC 0x4C54
544:                       {
545:                           PFN.CONTSETP=(unsigned char) OTMaster.Control_Setpoint;
4C44  EC03     CALL 0x3206, 0
4C46  F019     NOP
4C48  EC6D     CALL 0x86DA, 0
4C4A  F043     NOP
4C4C  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
4C4E  0101     MOVLB 0x1
4C50  6FF9     MOVWF 0xF9, BANKED
546:                       }
4C52  0C01     RETLW 0x1
547:                       else
548:                       if(OTMaster.Control_Setpoint<PFN.SETPmin)    
4C54  D979     RCALL PL356
4C56  EC35     CALL 0xB86A, 0
4C58  F05C     NOP
4C5A  D96A     RCALL PL300
4C5C  ECAE     CALL 0xA95C, 0
4C5E  F054     NOP
4C60  E203     BC 0x4C68
549:                       {
550:                           //PFN.PCO=PFN.minPCO;
551:                           PFN.CONTSETP=PFN.SETPmin;
4C62  C1FA     MOVFF 0x1FA, 0x1F9
4C64  F1F9     NOP
552:                       }
4C66  0C01     RETLW 0x1
553:                       else
554:                       if(OTMaster.Control_Setpoint>PFN.SETPmax)
4C68  0101     MOVLB 0x1
4C6A  51FB     MOVF 0xFB, W, BANKED
4C6C  EC35     CALL 0xB86A, 0
4C6E  F05C     NOP
4C70  D952     RCALL PL244
4C72  ECAE     CALL 0xA95C, 0
4C74  F054     NOP
4C76  A0D8     BTFSS STATUS, 0, ACCESS
555:                       {
556:                           //PFN.PCO=PFN.maxPCO;
557:                           PFN.CONTSETP=PFN.SETPmax;      
4C78  C1FB     MOVFF 0x1FB, 0x1F9
4C7A  F1F9     NOP
558:                       }    
559:                       return _OT_TO_RESP;
4C7C  0C01     RETLW 0x1
560:                   }
561:                   case 8:     //Control Setpoint2 f8.8        
562:                   case 71:    //Control Setpoint ventilation / heat-recovery          
563:                   {
564:                       SetUkownAckRespData();
4C7E  ECE5     CALL 0xBFCA, 0
4C80  F05F     NOP
4C82  0C01     RETLW 0x1
565:                       return _OT_TO_RESP;
566:                   }
567:                   //--------------------------------------------
568:                   //Class 2 : Configuration Information
569:                   case 2:       //Master configuration 
570:                   {
571:                       SetWriteAckRespData();            
4C84  EC5B     CALL 0xBEB6, 0
4C86  F05F     NOP
572:                       OTMaster.Ref._MemberID=1;   
4C88  815E     BSF 0x5E, 0, BANKED
573:                       OTMaster.MemberID=OT.RFrame.data0;   
4C8A  C136     MOVFF 0x136, 0x162
4C8C  F162     NOP
574:                       OTMaster.Ref._Config=1;            
4C8E  855E     BSF 0x5E, 2, BANKED
575:                       OTMaster.Config.war=OT.RFrame.data1;            
4C90  C137     MOVFF 0x137, 0x166
4C92  F166     NOP
4C94  0C01     RETLW 0x1
576:                       return _OT_TO_RESP;  
577:                   }        
578:                   case 124:     //OpenTherm version Master
579:                   {
580:                       SetWriteAckRespData();
4C96  EC5B     CALL 0xBEB6, 0
4C98  F05F     NOP
581:                       OTMaster.Ref._OTVer=1;      
4C9A  875E     BSF 0x5E, 3, BANKED
582:                       OTMaster.OTVer=OT.RFrame.word0.war;
4C9C  C136     MOVFF 0x136, 0x160
4C9E  F160     NOP
4CA0  C137     MOVFF 0x137, 0x161
4CA2  F161     NOP
4CA4  0C01     RETLW 0x1
583:                       return _OT_TO_RESP;            
584:                   } 
585:                   case 126:     //Master product version number and type
586:                   {
587:                       SetWriteAckRespData();
4CA6  EC5B     CALL 0xBEB6, 0
4CA8  F05F     NOP
588:                       OTMaster.Ref._ProductVer=1;            
4CAA  8B5E     BSF 0x5E, 5, BANKED
589:                       OTMaster.ProductVer=OT.RFrame.data0;    
4CAC  C136     MOVFF 0x136, 0x164
4CAE  F164     NOP
590:                       OTMaster.Ref._ProductType=1;            
4CB0  895E     BSF 0x5E, 4, BANKED
591:                       OTMaster.ProductType=OT.RFrame.data1;            
4CB2  C137     MOVFF 0x137, 0x163
4CB4  F163     NOP
4CB6  0C01     RETLW 0x1
592:                       return _OT_TO_RESP;            
593:                   }                
594:                   //-----------------------------------------
595:                   //Class 3 : Remote Request
596:                   case 4:     //Request-Code
597:                   {
598:                       switch(OT.RFrame.data1)
4CC4  5137     MOVF _PFNf_LIN_PBCO, W, BANKED
4CC6  E0F8     BZ 0x4CB8
4CC8  0A01     XORLW 0x1
4CCA  E0F6     BZ 0x4CB8
4CCC  0A03     XORLW 0x3
4CCE  E0F4     BZ 0x4CB8
4CD0  0A01     XORLW 0x1
4CD2  E0F2     BZ 0x4CB8
4CD4  0A07     XORLW 0x7
4CD6  E0F0     BZ 0x4CB8
4CD8  0A01     XORLW 0x1
4CDA  E0EE     BZ 0x4CB8
4CDC  0A03     XORLW 0x3
4CDE  E0EC     BZ 0x4CB8
4CE0  0A01     XORLW 0x1
4CE2  E0EA     BZ 0x4CB8
4CE4  0A0F     XORLW 0xF
4CE6  E0E8     BZ 0x4CB8
4CE8  0A01     XORLW 0x1
4CEA  E0E6     BZ 0x4CB8
4CEC  0A03     XORLW 0x3
4CEE  E0E4     BZ 0x4CB8
4CF0  0A01     XORLW 0x1
4CF2  A4D8     BTFSS STATUS, 2, ACCESS
4CF4  0A07     XORLW 0x7
4CF6  D7E0     BRA 0x4CB8
599:                       {
600:                           case 0: //Back to Normal oparation mode
601:                           case 1: //?BLOR?= Boiler Lock-out Reset request
602:                           case 2: //?CHWF?=CH water filling request
603:                           case 3: //Service mode maximum power request(for instance for CO2 measurement during Chimney Sweep Function )
604:                           case 4: //Service mode minimum power request(CO2 measurement)
605:                           case 5: //Service mode spark test request (no gas)
606:                           case 6: //Service mode fan maximum speed request(no flame)
607:                           case 7: //Service mode fan to minimum speed request (no flame)
608:                           case 8: //Service mode 3-way valve to CH request(no pump, no flame)
609:                           case 9: //Service mode 3-way valve to DHW request(no pump, no flame)
610:                           case 10://Request to reset service request flag
611:                           case 11://Service test 1. This is a OEM specific test.
612:                           case 12://Automatic hydronic air purge
613:                           default:    //odrzucenie polecenia
614:                               OT.TFrame.msg_type=_UNKOWN_ACK_OT_DATA;
4CB8  0E70     MOVLW 0x70
4CBA  133D     IORWF _PFNf_LINresSR, F, BANKED
615:                               OT.TFrame.data1=OT.RFrame.data1;
4CBC  C137     MOVFF 0x137, 0x13B
4CBE  F13B     NOP
616:                               OT.TFrame.data0=0;  //0..127 refused; 128..255 accepted
4CC0  6B3A     CLRF _PFNf_LIN_STR, BANKED
4CC2  0C01     RETLW 0x1
617:                               return _OT_TO_RESP;                       
618:                               
619:                       }
620:                   }            
621:                   //-----------------------------------------
622:                   //Class 4 : Sensor and Informational Data          
623:                   case 16:   //Room Setpoint        
624:                   {
625:                       SetWriteAckRespData();
4CF8  EC5B     CALL 0xBEB6, 0
4CFA  F05F     NOP
626:                       OTMaster.Ref._Room_Setpoint=1;            
4CFC  8F5E     BSF 0x5E, 7, BANKED
4CFE  D91F     RCALL PL344
627:                       OTMaster.Room_Setpoint=F88ToData((signed int) OT.RFrame.word0.war);            
4D00  EC1B     CALL 0xB636, 0
4D02  F05B     NOP
4D04  C080     MOVFF _PFNf_set_nco, 0x16A
4D06  F16A     NOP
4D08  C081     MOVFF _PFNf_set_ncw, 0x16B
4D0A  F16B     NOP
4D0C  C082     MOVFF _PFNf_str_nco, 0x16C
4D0E  F16C     NOP
4D10  0C01     RETLW 0x1
628:                       return _OT_TO_RESP;            
629:                   }
630:                   case 24:   //Room temperature 
631:                   {
632:                       SetWriteAckRespData();
4D12  EC5B     CALL 0xBEB6, 0
4D14  F05F     NOP
633:                       OTMaster.Ref._Room_Temperature=1;            
4D16  815F     BSF 0x5F, 0, BANKED
4D18  D912     RCALL PL344
634:                       OTMaster.Room_Temperature=F88ToData((signed int) OT.RFrame.word0.war);            
4D1A  EC1B     CALL 0xB636, 0
4D1C  F05B     NOP
4D1E  C080     MOVFF _PFNf_set_nco, 0x16D
4D20  F16D     NOP
4D22  C081     MOVFF _PFNf_set_ncw, 0x16E
4D24  F16E     NOP
4D26  C082     MOVFF _PFNf_str_nco, 0x16F
4D28  F16F     NOP
4D2A  0C01     RETLW 0x1
635:                       return _OT_TO_RESP;            
636:                   }            
637:                   case 20:   //Day of Week & Time of Day        
638:                   case 21:   //Date
639:                   case 22:   //Year        
640:                   case 23:   //Room Setpoint CH2
641:                   case 27:    //Outside temperature
642:                   case 37:   //TrCH2        
643:                   case 38:   //Relative Humidity      
644:                   case 78:   //Relative humidity        
645:                   case 79:   //CO2 level 
646:                   case 98:   //Type of sensor and battery        
647:                   case 109:  //Electricity producer starts  
648:                   case 110:  //Electricity producer hours            
649:                   case 112:  //Cumulative Electricity production        
650:                   case 113:  //Number of un-successful burner starts  
651:                   case 114:  //Number of times flame signal was too low        
652:                   case 116:  //Successful Burner starts        
653:                   case 117:  //CH pump starts        
654:                   case 118:  //DHW pump/valve starts  
655:                   case 119:  //DHW burner starts        
656:                   case 120:  //Burner operation hours            
657:                   case 121:  //CH pump operation hours        
658:                   case 122:  //DHW pump/valve operation hours       
659:                   case 123:  //DHW burner operation hours            
660:                   {
661:                       SetUkownAckRespData();
662:                       return _OT_TO_RESP;
663:                   }  
664:                   //-----------------------------------------
665:                   //Class 5 : Pre-Defined Remote Boiler Parameters 
666:                   case 56:     //DHW Setpoint
667:                   {
668:                       SetWriteAckRespData();
4D2C  EC5B     CALL 0xBEB6, 0
4D2E  F05F     NOP
669:                       OTMaster.Ref._DHW_Setpoint=1;            
4D30  835F     BSF 0x5F, 1, BANKED
4D32  D905     RCALL PL344
670:                       OTMaster.DHW_Setpoint=F88ToData((signed int) OT.RFrame.word0.war);
4D34  EC1B     CALL 0xB636, 0
4D36  F05B     NOP
4D38  C080     MOVFF _PFNf_set_nco, 0x170
4D3A  F170     NOP
4D3C  C081     MOVFF _PFNf_set_ncw, 0x171
4D3E  F171     NOP
4D40  C082     MOVFF _PFNf_str_nco, 0x172
4D42  F172     NOP
671:                       if((OTMaster.DHW_Setpoint>=PFN.minPCW)&&(OTMaster.DHW_Setpoint<=PFN.maxPCW))
4D44  C170     MOVFF 0x170, _PFNf_set_nco
4D46  F080     NOP
4D48  C171     MOVFF 0x171, _PFNf_set_ncw
4D4A  F081     NOP
4D4C  C172     MOVFF 0x172, _PFNf_str_nco
4D4E  F082     NOP
4D50  C1EA     MOVFF 0x1EA, _PFNf_setKey
4D52  F07C     NOP
4D54  C1EB     MOVFF 0x1EB, _PFNf_set_aleg
4D56  F07D     NOP
4D58  EC35     CALL 0xBC6A, 0
4D5A  F05E     NOP
4D5C  D8FE     RCALL PL470
4D5E  ECAE     CALL 0xA95C, 0
4D60  F054     NOP
4D62  A0D8     BTFSS STATUS, 0, ACCESS
4D64  0C01     RETLW 0x1
4D66  C1E8     MOVFF 0x1E8, _PFNf_setKey
4D68  F07C     NOP
4D6A  C1E9     MOVFF 0x1E9, _PFNf_set_aleg
4D6C  F07D     NOP
4D6E  EC35     CALL 0xBC6A, 0
4D70  F05E     NOP
4D72  D8FA     RCALL PL478
4D74  C170     MOVFF 0x170, _PFNf_str_ncw
4D76  F083     NOP
4D78  C171     MOVFF 0x171, _PFNf_tdzCO
4D7A  F084     NOP
4D7C  C172     MOVFF 0x172, _PFNf_tdzCW
4D7E  F085     NOP
4D80  ECAE     CALL 0xA95C, 0
4D82  F054     NOP
4D84  A0D8     BTFSS STATUS, 0, ACCESS
4D86  0C01     RETLW 0x1
672:                       {
673:                           PFN.PCW=(unsigned int)OTMaster.DHW_Setpoint;
4D88  C170     MOVFF 0x170, _RSDT1f_NewLIDN
4D8A  F08E     NOP
4D8C  C171     MOVFF 0x171, _RSDT1f_NoRespToLIN
4D8E  F08F     NOP
4D90  C172     MOVFF 0x172, _RSDT1f_OdpLIDN
4D92  F090     NOP
4D94  EC6D     CALL 0x86DA, 0
4D96  F043     NOP
4D98  C08E     MOVFF _RSDT1f_NewLIDN, 0x1F0
4D9A  F1F0     NOP
4D9C  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x1F1
4D9E  F1F1     NOP
4DA0  0C01     RETLW 0x1
674:                       }      
675:                       return _OT_TO_RESP; 
676:                   }        
677:                   case 57:     //max CH water Setpoint
678:                   {            
679:                       OTMaster.Ref._maxCH_Setpoint=1;            
4DA2  855F     BSF 0x5F, 2, BANKED
4DA4  D8CC     RCALL PL344
680:                       OTMaster.maxCH_Setpoint=F88ToData((signed int) OT.RFrame.word0.war);
4DA6  EC1B     CALL 0xB636, 0
4DA8  F05B     NOP
4DAA  C080     MOVFF _PFNf_set_nco, 0x173
4DAC  F173     NOP
4DAE  C081     MOVFF _PFNf_set_ncw, 0x174
4DB0  F174     NOP
4DB2  C082     MOVFF _PFNf_str_nco, 0x175
4DB4  F175     NOP
681:                       if(!PFNf_pgd)       //przy nieaktywnym regulatorze zezwol na modyfikacje maxCH
4DB6  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
4DB8  D762     BRA 0x4C7E
682:                       {
683:                           SetWriteAckRespData();
4DBA  EC5B     CALL 0xBEB6, 0
4DBC  F05F     NOP
684:                           if((OTMaster.maxCH_Setpoint>=PFN.minPCO)&&(OTMaster.maxCH_Setpoint<=PFN.maxPCO))
4DBE  C173     MOVFF 0x173, _PFNf_set_nco
4DC0  F080     NOP
4DC2  C174     MOVFF 0x174, _PFNf_set_ncw
4DC4  F081     NOP
4DC6  C175     MOVFF 0x175, _PFNf_str_nco
4DC8  F082     NOP
4DCA  C1E6     MOVFF 0x1E6, _PFNf_setKey
4DCC  F07C     NOP
4DCE  C1E7     MOVFF 0x1E7, _PFNf_set_aleg
4DD0  F07D     NOP
4DD2  EC35     CALL 0xBC6A, 0
4DD4  F05E     NOP
4DD6  D8C1     RCALL PL470
4DD8  ECAE     CALL 0xA95C, 0
4DDA  F054     NOP
4DDC  A0D8     BTFSS STATUS, 0, ACCESS
4DDE  0C01     RETLW 0x1
4DE0  C1E4     MOVFF 0x1E4, _PFNf_setKey
4DE2  F07C     NOP
4DE4  C1E5     MOVFF 0x1E5, _PFNf_set_aleg
4DE6  F07D     NOP
4DE8  EC35     CALL 0xBC6A, 0
4DEA  F05E     NOP
4DEC  D8BD     RCALL PL478
4DEE  C173     MOVFF 0x173, _PFNf_str_ncw
4DF0  F083     NOP
4DF2  C174     MOVFF 0x174, _PFNf_tdzCO
4DF4  F084     NOP
4DF6  C175     MOVFF 0x175, _PFNf_tdzCW
4DF8  F085     NOP
4DFA  ECAE     CALL 0xA95C, 0
4DFC  F054     NOP
4DFE  A0D8     BTFSS STATUS, 0, ACCESS
4E00  0C01     RETLW 0x1
685:                           {
686:                               PFN.PCO=(unsigned int)OTMaster.maxCH_Setpoint;
4E02  C173     MOVFF 0x173, _RSDT1f_NewLIDN
4E04  F08E     NOP
4E06  C174     MOVFF 0x174, _RSDT1f_NoRespToLIN
4E08  F08F     NOP
4E0A  C175     MOVFF 0x175, _RSDT1f_OdpLIDN
4E0C  F090     NOP
4E0E  EC6D     CALL 0x86DA, 0
4E10  F043     NOP
4E12  C08E     MOVFF _RSDT1f_NewLIDN, 0x1EE
4E14  F1EE     NOP
4E16  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x1EF
4E18  F1EF     NOP
4E1A  0C01     RETLW 0x1
4E1C  0101     MOVLB 0x1
4E1E  5138     MOVF _PFNf_LIN_PBCW, W, BANKED
4E20  0A01     XORLW 0x1
4E22  E101     BNZ 0x4E26
4E24  D6F4     BRA 0x4C0E
4E26  0A03     XORLW 0x3
4E28  E101     BNZ 0x4E2C
4E2A  D72C     BRA 0x4C84
4E2C  0A06     XORLW 0x6
4E2E  E101     BNZ 0x4E32
4E30  D749     BRA 0x4CC4
4E32  0A03     XORLW 0x3
4E34  E101     BNZ 0x4E38
4E36  D723     BRA 0x4C7E
4E38  0A0F     XORLW 0xF
4E3A  E101     BNZ 0x4E3E
4E3C  D720     BRA 0x4C7E
4E3E  0A03     XORLW 0x3
4E40  E101     BNZ 0x4E44
4E42  D71D     BRA 0x4C7E
4E44  0A05     XORLW 0x5
4E46  E101     BNZ 0x4E4A
4E48  D71A     BRA 0x4C7E
4E4A  0A1E     XORLW 0x1E
4E4C  E101     BNZ 0x4E50
4E4E  D754     BRA 0x4CF8
4E50  0A04     XORLW 0x4
4E52  E101     BNZ 0x4E56
4E54  D714     BRA 0x4C7E
4E56  0A01     XORLW 0x1
4E58  E101     BNZ 0x4E5C
4E5A  D711     BRA 0x4C7E
4E5C  0A03     XORLW 0x3
4E5E  E101     BNZ 0x4E62
4E60  D70E     BRA 0x4C7E
4E62  0A01     XORLW 0x1
4E64  E101     BNZ 0x4E68
4E66  D70B     BRA 0x4C7E
4E68  0A0F     XORLW 0xF
4E6A  E101     BNZ 0x4E6E
4E6C  D752     BRA 0x4D12
4E6E  0A03     XORLW 0x3
4E70  E101     BNZ 0x4E74
4E72  D705     BRA 0x4C7E
4E74  0A3E     XORLW 0x3E
4E76  E101     BNZ 0x4E7A
4E78  D702     BRA 0x4C7E
4E7A  0A03     XORLW 0x3
4E7C  E101     BNZ 0x4E80
4E7E  D6FF     BRA 0x4C7E
4E80  0A1E     XORLW 0x1E
4E82  E101     BNZ 0x4E86
4E84  D753     BRA 0x4D2C
4E86  0A01     XORLW 0x1
4E88  E08C     BZ 0x4DA2
4E8A  0A7E     XORLW 0x7E
4E8C  E101     BNZ 0x4E90
4E8E  D6F7     BRA 0x4C7E
4E90  0A09     XORLW 0x9
4E92  E101     BNZ 0x4E96
4E94  D6F4     BRA 0x4C7E
4E96  0A01     XORLW 0x1
4E98  E101     BNZ 0x4E9C
4E9A  D6F1     BRA 0x4C7E
4E9C  0A18     XORLW 0x18
4E9E  E101     BNZ 0x4EA2
4EA0  D6EE     BRA 0x4C7E
4EA2  0A0E     XORLW 0xE
4EA4  E101     BNZ 0x4EA8
4EA6  D6EB     BRA 0x4C7E
4EA8  0A3B     XORLW 0x3B
4EAA  E101     BNZ 0x4EAE
4EAC  D6E8     BRA 0x4C7E
4EAE  0A01     XORLW 0x1
4EB0  E101     BNZ 0x4EB4
4EB2  D6E5     BRA 0x4C7E
4EB4  0A09     XORLW 0x9
4EB6  E101     BNZ 0x4EBA
4EB8  D6E2     BRA 0x4C7E
4EBA  0A07     XORLW 0x7
4EBC  E101     BNZ 0x4EC0
4EBE  D6DF     BRA 0x4C7E
4EC0  0A03     XORLW 0x3
4EC2  E101     BNZ 0x4EC6
4EC4  D6DC     BRA 0x4C7E
4EC6  0A1E     XORLW 0x1E
4EC8  E101     BNZ 0x4ECC
4ECA  D6D9     BRA 0x4C7E
4ECC  0A01     XORLW 0x1
4ECE  E101     BNZ 0x4ED2
4ED0  D6D6     BRA 0x4C7E
4ED2  0A03     XORLW 0x3
4ED4  E101     BNZ 0x4ED8
4ED6  D6D3     BRA 0x4C7E
4ED8  0A06     XORLW 0x6
4EDA  E101     BNZ 0x4EDE
4EDC  D6D0     BRA 0x4C7E
4EDE  0A01     XORLW 0x1
4EE0  E101     BNZ 0x4EE4
4EE2  D6CD     BRA 0x4C7E
4EE4  0A03     XORLW 0x3
4EE6  E101     BNZ 0x4EEA
4EE8  D6CA     BRA 0x4C7E
4EEA  0A01     XORLW 0x1
4EEC  E101     BNZ 0x4EF0
4EEE  D6C7     BRA 0x4C7E
4EF0  0A0F     XORLW 0xF
4EF2  E101     BNZ 0x4EF6
4EF4  D6C4     BRA 0x4C7E
4EF6  0A01     XORLW 0x1
4EF8  E101     BNZ 0x4EFC
4EFA  D6C1     BRA 0x4C7E
4EFC  0A03     XORLW 0x3
4EFE  E101     BNZ 0x4F02
4F00  D6BE     BRA 0x4C7E
4F02  0A01     XORLW 0x1
4F04  E101     BNZ 0x4F08
4F06  D6BB     BRA 0x4C7E
4F08  0A07     XORLW 0x7
4F0A  E101     BNZ 0x4F0E
4F0C  D6C4     BRA 0x4C96
4F0E  0A02     XORLW 0x2
4F10  E101     BNZ 0x4F14
4F12  D6C9     BRA 0x4CA6
4F14  D6B4     BRA 0x4C7E
687:                           }
688:                       }
689:                       else                //przy aktywnym reg. pogodowym to regulator definiuje maxCH
690:                       {
691:                           SetUkownAckRespData();  
692:                       }           
693:                       return _OT_TO_RESP;            
694:                   }               
695:                   case 87:  //Nominal ventilation value            
696:                   {
697:                       SetUkownAckRespData();
698:                       return _OT_TO_RESP;
699:                   } 
700:                   //-----------------------------------------
701:                   //Class 6 : Transparent Slave Parameters
702:                   case 11:  //TSP index no, value  
703:                   case 89:  //TSP index no. ventilation / heat-recovery     
704:                   case 106:  //TSP index no. SolarStorage            
705:                   {
706:                       SetUkownAckRespData();            
707:                       return _OT_TO_RESP;
708:                   }  
709:                   //-----------------------------------------
710:                   //Class 7 : Fault History Data      
711:                   //-----------------------------------------
712:                   //Class 8 : Control of Special Applications
713:                   case 7:  //Cooling control signal    
714:                   case 14:  //Maximum relative modulation level setting   
715:                   case 99:  //Remote Override Operating Mode Heating            
716:                   {
717:                       SetUkownAckRespData();            
718:                       return _OT_TO_RESP;
719:                   }   
720:                   default:
721:                   {
722:                       SetUkownAckRespData();            
723:                       return _OT_TO_RESP;            
724:                   }        
725:               }    
726:           }
727:           /*---------------------------------------------------------------------------------*/
728:           signed int DataToF88(float dt)
729:           {
730:               return (signed int)(dt*256);
B59A  6B82     CLRF _PFNf_str_nco, BANKED
B59C  0E80     MOVLW 0x80
B59E  6F83     MOVWF _PFNf_str_ncw, BANKED
B5A0  0E43     MOVLW 0x43
B5A2  6F84     MOVWF _PFNf_tdzCO, BANKED
B5A4  C0A9     MOVFF dt, _PFNf_set_fnserw
B5A6  F07F     NOP
B5A8  C0AA     MOVFF f, _PFNf_set_nco
B5AA  F080     NOP
B5AC  C0AB     MOVFF 0xAB, _PFNf_set_ncw
B5AE  F081     NOP
B5B0  ECE7     CALL 0x83CE, 0
B5B2  F041     NOP
B5B4  C07F     MOVFF _PFNf_set_fnserw, _RSDT1f_NewLIDN
B5B6  F08E     NOP
B5B8  C080     MOVFF _PFNf_set_nco, _RSDT1f_NoRespToLIN
B5BA  F08F     NOP
B5BC  C081     MOVFF _PFNf_set_ncw, _RSDT1f_OdpLIDN
B5BE  F090     NOP
B5C0  EC6D     CALL 0x86DA, 0
B5C2  F043     NOP
B5C4  C08E     MOVFF _RSDT1f_NewLIDN, dt
B5C6  F0A9     NOP
B5C8  C08F     MOVFF _RSDT1f_NoRespToLIN, f
B5CA  F0AA     NOP
731:           }
B5CC  0012     RETURN 0
732:           float F88ToData(signed int dt)
733:           {
734:               return (float)(dt/256);
B636  0E01     MOVLW 0x1
B638  0100     MOVLB 0x0
B63A  6F77     MOVWF _PFNf_prn_pg, BANKED
B63C  6B76     CLRF _PFNf_prn_in, BANKED
B63E  C080     MOVFF _PFNf_set_nco, _PFNf_prODP
B640  F074     NOP
B642  C081     MOVFF _PFNf_set_ncw, _PFNf_prn_cs
B644  F075     NOP
B646  ECC3     CALL 0x9D86, 0
B648  F04E     NOP
B64A  D809     RCALL PL726
B64C  EC11     CALL 0xB422, 0
B64E  F05A     NOP
B650  C07C     MOVFF _PFNf_setKey, _PFNf_set_nco
B652  F080     NOP
B654  C07D     MOVFF _PFNf_set_aleg, _PFNf_set_ncw
B656  F081     NOP
B658  C07E     MOVFF _PFNf_set_eco, _PFNf_str_nco
B65A  F082     NOP
735:           }
B65C  0012     RETURN 0
736:           /*---------------------------------------------------------------------------------*/
737:           /*---------------------------------------------------------------------------------*/
738:           #endif //(_EXT_BOARD>=3)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/ot.c  -----------------------
1:             /*ot.c*/
2:             //Funkcje obslugi komunikacji OT
3:             /*---------------------------------------------------------------------------------*/
4:             //#include <pic18.h>
5:             //#include <htc.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "ot.h"				//parametry lokalne
9:             
10:            volatile tpOTDta OT;
11:            extern volatile tpOTMaster OTMaster;
12:            
13:            volatile unsigned int db=0;
14:            //volatile bit PFNf_Rsync;		 
15:            volatile bit PFNf_firstEdge;		 
16:            volatile bit PFNf_OTTimeout;
17:            
18:            volatile unsigned char xxy,zzz,vvv;
19:            #if (_EXT_BOARD>=3)
20:            /*---------------------------------------------------------------------------------*/
21:            /*---------------------------------------------------------------------------------*/
22:            void InitOT(void)
23:            {
24:                OT.RFrame.war=0;
93D2  D83B     RCALL __end_of_InitOT
25:                OT.T2=0;
93D4  6B11     CLRF PFNf_zima, BANKED
93D6  6B12     CLRF RSDT1f_RD_STD, BANKED
26:                OT.otPeriod=0;
93D8  6B13     CLRF UAD1tf_RFData, BANKED
93DA  6B14     CLRF UADtf_RErrREC, BANKED
93DC  6B15     CLRF _LIN1f_Busy, BANKED
93DE  6B16     CLRF _LIN1f_CHK, BANKED
27:                OT.preload=0;
93E0  6B19     CLRF _LIN1f_FIN, BANKED
93E2  6B1A     CLRF _LIN1f_FResp, BANKED
28:                OT.preload4=0;
93E4  6B1D     CLRF _LIN1f_SCS, BANKED
93E6  6B1E     CLRF _MGSDf_ERRt, BANKED
29:                OT.cnt=0;
93E8  6B1F     CLRF _MGSDf_NO_ODB, BANKED
30:                OT.cnt1=0;
93EA  6B0D     CLRF PFNf_plmCO, BANKED
31:                OT.cnt2=0;
93EC  6B0E     CLRF PFNf_popFN, BANKED
32:                OT.data1=0;
93EE  6B28     CLRF _PFNf_10V_RT, BANKED
93F0  6B29     CLRF _PFNf_10V_nPCO, BANKED
93F2  6B2A     CLRF _PFNf_EnAleg, BANKED
93F4  6B2B     CLRF _PFNf_EnF10V, BANKED
33:                OT.errorMsg=0;
93F6  6B32     CLRF _PFNf_LIN_DPGD, BANKED
34:                OT.millis=0;
93F8  6B04     CLRF MGSDf_TransData, BANKED
93FA  6B05     CLRF PFNf_KnfDisErr, BANKED
93FC  6B06     CLRF PFNf_LIN_CW, BANKED
93FE  6B07     CLRF PFNf_OTTimeout, BANKED
35:                OT.parityOdd=0;
9400  6B20     CLRF _MGSDf_RERR_REC, BANKED
36:                OT.previousTransitionCount=0;
9402  6B23     CLRF _MGSDf_TransACK, BANKED
37:                OT.sum=0;
9404  6B0F     CLRF PFNf_set_fnserw, BANKED
9406  6B10     CLRF PFNf_str_nco, BANKED
38:                OT.tdr=0;
9408  6B08     CLRF PFNf_b_set_nco, BANKED
940A  6B09     CLRF PFNf_b_str_nco, BANKED
940C  D823     RCALL PL710
39:                OT.tempFrame=0;
40:                OT.tempFrame=0;
940E  6B24     CLRF _MGSDf_TransData, BANKED
9410  6B25     CLRF _MGSDf_TransDataRC, BANKED
9412  6B26     CLRF _MGSDf_TransDataTR, BANKED
9414  6B27     CLRF _MGSDf_TransOK, BANKED
41:                OT.timeLow=0;
9416  6B00     CLRF 0x0, BANKED
9418  6B01     CLRF DtCOf_err_CO, BANKED
941A  6B02     CLRF LIN1f_Busy, BANKED
941C  6B03     CLRF LIN1f_NDTA, BANKED
42:                OT.transitionCount=0;
941E  6B21     CLRF _MGSDf_RERR_TIM, BANKED
9420  6B22     CLRF _MGSDf_TERR_TIM, BANKED
43:                OTMaster.Ref.war=0;
9422  6B5E     CLRF 0x5E, BANKED
9424  6B5F     CLRF 0x5F, BANKED
44:                
45:                PFNf_firstEdge=1;
9426  840A     BSF PFNf_firstEdge, 2, ACCESS
9428  D810     RCALL __end_of_InitOT
46:                
47:            
48:                OT.RFrame.war=0;
49:            	INT0IF=0;			
942A  92F2     BCF INTCON, 1, ACCESS
50:            	INT0IE=0;
942C  98F2     BCF INTCON, 4, ACCESS
51:            #if _NEG_IN==0    
52:            	INTEDG0=0;          //zbocze opadajace
53:            #else
54:            	INTEDG0=1;          //zbocze narastajace
942E  8CF1     BSF INTCON2, 6, ACCESS
55:            #endif    
56:            	INT1IF=0;			
9430  90F0     BCF INTCON3, 0, ACCESS
57:            	INT1IE=0;			
9432  96F0     BCF INTCON3, 3, ACCESS
58:            	INT1IP=1;  
9434  8CF0     BSF INTCON3, 6, ACCESS
59:            #if _NEG_IN==0    
60:            	INTEDG1=1;          //zbocze narastajace 
61:            #else
62:            	INTEDG1=0;          //zbocze opadajace
9436  9AF1     BCF INTCON2, 5, ACCESS
63:            #endif
64:                //OT.RFrame.war=0b11100000100010001111000010101010;
65:                //db=OT.RFrame.word0.war;    
66:                //db=OT.RFrame.byte2.war;    
67:                //db=OT.RFrame.parity;
68:                //db=OT.RFrame.msg_type;
69:                //db=OT.RFrame.data_id;
70:                //db=OT.RFrame.data1;
71:                //db=OT.RFrame.data0;    
72:                DetachINT();
9438  ECA2     CALL 0xC144, 0
943A  F060     NOP
73:                InitTimer0();    
943C  ECB0     CALL 0xBD60, 0
943E  F05E     NOP
74:                SetOTDeamon(0);   
9440  0E00     MOVLW 0x0
9442  ECB6     CALL 0xC16C, 0
9444  F060     NOP
75:                _OUT_OT=0;
9446  948A     BCF LATB, 2, ACCESS
76:            }
9448  0012     RETURN 0
77:            
78:            void WrtTMR0(volatile unsigned int tm)
79:            {  
80:                OT.prelTMR0=tm;
C1AE  C074     MOVFF _PFNf_prODP, 0x117
C1B0  F117     NOP
C1B2  C075     MOVFF _PFNf_prn_cs, 0x118
C1B4  F118     NOP
C1D6  C028     MOVFF _PFNf_10V_RT, 0x117
C1F4  C015     MOVFF _LIN1f_Busy, 0x117
81:            }
C1B6  0012     RETURN 0
C1DE  0012     RETURN 0
C1FC  0012     RETURN 0
82:            /*---------------------------------------------------------------------------------*/
83:            /*---------------------------------------------------------------------------------*/
84:            //Zlicza milisekundy poczawszy od aktywacji timera2  - przepelnienie po 50 dniach
85:            //umiescic w przerwaniu od timera2
86:            void IntMillis(void)
87:            {
88:                volatile static unsigned char m4=0;
89:                m4++;
BE38  0101     MOVLB 0x1
BE3A  2BA8     INCF sign, F, BANKED
90:                if(m4==4)   //przeladowanie co 250us, 4*250us=1ms
BE3C  0E04     MOVLW 0x4
BE3E  19A8     XORWF sign, W, BANKED
BE40  A4D8     BTFSS STATUS, 2, ACCESS
BE42  0012     RETURN 0
91:                {
92:                    m4=0;
BE44  6BA8     CLRF sign, BANKED
93:                    OT.millis++;         
BE46  2B04     INCF MGSDf_TransData, F, BANKED
BE48  0E00     MOVLW 0x0
BE4A  2305     ADDWFC PFNf_KnfDisErr, F, BANKED
BE4C  2306     ADDWFC PFNf_LIN_CW, F, BANKED
BE4E  2307     ADDWFC PFNf_OTTimeout, F, BANKED
94:                }
95:            }
BE50  0C00     RETLW 0x0
96:            /*---------------------------------------------------------------------------------*/
97:            //zwraca wartosc milisekund ktore uplynely od aktywacji timera2
98:            unsigned long int Millis(void)
99:            {
100:               return OT.millis;
C040  C104     MOVFF 0x104, _PFNf_prODP
C042  F074     NOP
C044  C105     MOVFF 0x105, _PFNf_prn_cs
C046  F075     NOP
C048  C106     MOVFF 0x106, _PFNf_prn_in
C04A  F076     NOP
C04C  C107     MOVFF 0x107, _PFNf_prn_pg
C04E  F077     NOP
C088  C104     MOVFF 0x104, _PFNf_10V_RT
C0D0  C104     MOVFF 0x104, _LIN1f_Busy
101:           }
C050  0012     RETURN 0
C098  0012     RETURN 0
C0E0  0012     RETURN 0
102:           /*---------------------------------------------------------------------------------*/
103:           /*---------------------------------------------------------------------------------*/
104:           void StartOTTimeout(const unsigned int tmout, const unsigned char typ)
105:           {
106:               OT.tdr=0;
BF72  0101     MOVLB 0x1
BF74  6B08     CLRF PFNf_b_set_nco, BANKED
BF76  6B09     CLRF PFNf_b_str_nco, BANKED
BF88  0101     MOVLB 0x1
BFB4  0101     MOVLB 0x1
107:               OT.tmo=tmout;    
BF78  C074     MOVFF _PFNf_prODP, 0x10A
BF7A  F10A     NOP
BF7C  C075     MOVFF _PFNf_prn_cs, 0x10B
BF7E  F10B     NOP
BF8E  C028     MOVFF _PFNf_10V_RT, 0x10A
BF90  F10A     NOP
BF92  C029     MOVFF _PFNf_10V_nPCO, 0x10B
BF94  F10B     NOP
BFBA  C015     MOVFF _LIN1f_Busy, 0x10A
BFBC  F10A     NOP
BFBE  C016     MOVFF _LIN1f_CHK, 0x10B
BFC0  F10B     NOP
108:               OT.tptm=typ;
BF80  C076     MOVFF _PFNf_prn_in, 0x10C
BF82  F10C     NOP
BF96  C02A     MOVFF _PFNf_EnAleg, 0x10C
BF98  F10C     NOP
BFC2  C017     MOVFF _LIN1f_ERRR, 0x10C
BFC4  F10C     NOP
109:               PFNf_OTTimeout=1;
BF84  8C07     BSF PFNf_OTTimeout, 6, ACCESS
BF9A  8C07     BSF PFNf_OTTimeout, 6, ACCESS
BFC6  8C07     BSF PFNf_OTTimeout, 6, ACCESS
110:           }
BF86  0012     RETURN 0
BF9C  0012     RETURN 0
BFC8  0012     RETURN 0
111:           void StopOTTimeout(void)
C0E2  D000     BRA PL194
C28E  EF72     GOTO 0xC0E4
C290  F060     NOP
112:           {
113:               OT.tdr=0; 
C296  EF72     GOTO 0xC0E4
C298  F060     NOP
114:               OT.tmo=0xffff;    
115:               OT.tptm=0;    
116:               PFNf_OTTimeout=0;
117:           }
118:           void IntOTTimeout(void)
119:           {
120:               volatile static unsigned char m4=0;
121:               m4++;
AB56  2BA9     INCF dt, F, BANKED
122:               if(m4==4)   //przeladowanie co 250us, 4*250us=1ms
AB58  0E04     MOVLW 0x4
AB5A  19A9     XORWF dt, W, BANKED
AB5C  A4D8     BTFSS STATUS, 2, ACCESS
AB5E  0012     RETURN 0
123:               {
124:                   m4=0;
AB60  6BA9     CLRF dt, BANKED
125:                   if(OT.tdr<OT.tmo) OT.tdr++;  //przeladowanie po 268ms
AB62  510A     MOVF PFNf_firstEdge, W, BANKED
AB64  5D08     SUBWF PFNf_b_set_nco, W, BANKED
AB66  510B     MOVF PFNf_lato, W, BANKED
AB68  5909     SUBWFB PFNf_b_str_nco, W, BANKED
AB6A  E203     BC 0xAB72
AB6C  4B08     INFSNZ PFNf_b_set_nco, F, BANKED
AB6E  2B09     INCF PFNf_b_str_nco, F, BANKED
AB70  0012     RETURN 0
126:                   else
127:                   {
128:                       if(PFNf_OTTimeout)
AB72  AC07     BTFSS PFNf_OTTimeout, 6, ACCESS
AB74  0012     RETURN 0
129:                       {
130:                           OT.tdr=0;                
AB76  6B08     CLRF PFNf_b_set_nco, BANKED
AB78  6B09     CLRF PFNf_b_str_nco, BANKED
131:                           PFNf_OTTimeout=0;
AB7A  9C07     BCF PFNf_OTTimeout, 6, ACCESS
132:                           switch(OT.tptm)
AB7C  D008     BRA 0xAB8E
AB8E  510C     MOVF PFNf_off, W, BANKED
AB90  B4D8     BTFSC STATUS, 2, ACCESS
AB92  0012     RETURN 0
AB94  0A01     XORLW 0x1
AB96  E0F3     BZ 0xAB7E
AB98  0A03     XORLW 0x3
AB9A  E0F1     BZ 0xAB7E
AB9C  0A01     XORLW 0x1
AB9E  E0F4     BZ 0xAB88
ABA0  0A07     XORLW 0x7
ABA2  E0F0     BZ 0xAB84
133:                           {
134:                               case 0:
135:                               {
136:                                   return;
137:                               }
138:                               case 1:     //timeout dla procedury synchronizacji (MeasureOTPeriod)
139:                                   //db=1;
140:                               case 2:     //timeout dla procedury oczekiwania (WaitOTFrame)
141:                               {
142:                                   //db=2;
143:                                   SetOTDeamon(0);      //start MeasureOTPeriod
AB7E  0E00     MOVLW 0x0
AB80  EFE6     GOTO 0xC1CC
AB82  F060     NOP
144:                                   return;
145:                               }
146:                               case 3:     //timeout dla zbocza inicjujacego odczyt ramki                       
147:                               {
148:                                   //db=3;
149:                                   SetOTDeamon(2);      //start WaitOTFrame
150:                                   return;
151:                               } 
152:                               case 4:     //timeout dla decyzji na odpowiedz                        
153:                               {
154:                                   OT.ToACK=0;    
AB84  6B34     CLRF _PFNf_LIN_EPBCO, BANKED
155:                                   OT.ACKType=0;
AB86  6B35     CLRF _PFNf_LIN_EPBCW, BANKED
156:                                   SetOTDeamon(2);      //start WaitOTFrame
AB88  0E02     MOVLW 0x2
AB8A  EFE6     GOTO 0xC1CC
AB8C  F060     NOP
157:                                   return;
158:                               }                    
159:                           }
160:           
161:                       }
162:                   }
163:               }
164:           }
ABA4  0012     RETURN 0
165:           /*---------------------------------------------------------------------------------*/
166:           /*---------------------------------------------------------------------------------*/
167:           //Korekta dla zmiennych szerokosci bitów informacji
168:           SetOffset(void)
169:           {
170:               volatile unsigned int offset,rtim;
171:               
172:               rtim=ReadTMR0();     //read timer0    
AE8E  EC14     CALL 0xBC28, 0
AE90  F05E     NOP
AE92  C015     MOVFF _LIN1f_Busy, _LIN1f_FIN
AE94  F019     NOP
AE96  C016     MOVFF _LIN1f_CHK, _LIN1f_FResp
AE98  F01A     NOP
173:               offset=0xFFFF-rtim;
AE9A  1C19     COMF _LIN1f_FIN, W, ACCESS
AE9C  6E1B     MOVWF _LIN1f_FTrans, ACCESS
AE9E  1C1A     COMF _LIN1f_FResp, W, ACCESS
AEA0  6E1C     MOVWF _LIN1f_NDTA, ACCESS
174:               OT.pop=0;
AEA2  0101     MOVLB 0x1
AEA4  6B2C     CLRF _PFNf_EnLIN, BANKED
AEA6  6B2D     CLRF _PFNf_FLIN, BANKED
175:               if(offset<OT.offsetL)                   //za szybki pkt pomiaru
AEA8  512E     MOVF _PFNf_FOT, W, BANKED
AEAA  5C1B     SUBWF _LIN1f_FTrans, W, ACCESS
AEAC  512F     MOVF _PFNf_KnfDisErr, W, BANKED
AEAE  581C     SUBWFB _LIN1f_NDTA, W, ACCESS
AEB0  E20B     BC 0xAEC8
176:               {
177:                   db++;
AEB2  0102     MOVLB 0x2
AEB4  4B20     INFSNZ _MGSDf_RERR_REC, F, BANKED
AEB6  2B21     INCF _MGSDf_RERR_TIM, F, BANKED
178:                   OT.pop=offset-OT.offsetL;
AEB8  0101     MOVLB 0x1
AEBA  512E     MOVF _PFNf_FOT, W, BANKED
AEBC  5C1B     SUBWF _LIN1f_FTrans, W, ACCESS
AEBE  6F2C     MOVWF _PFNf_EnLIN, BANKED
AEC0  512F     MOVF _PFNf_KnfDisErr, W, BANKED
AEC2  581C     SUBWFB _LIN1f_NDTA, W, ACCESS
AEC4  6F2D     MOVWF _PFNf_FLIN, BANKED
179:                   //ReloadTMR0(rtim+pop);    
180:               } 
AEC6  0012     RETURN 0
181:               else
182:               if(offset<OT.offset2)                   //za wolny pkt pomiaru
AEC8  5130     MOVF _PFNf_LIN_CK, W, BANKED
AECA  5C1B     SUBWF _LIN1f_FTrans, W, ACCESS
AECC  5131     MOVF _PFNf_LIN_CW, W, BANKED
AECE  581C     SUBWFB _LIN1f_NDTA, W, ACCESS
AED0  E3F3     BNC 0xAEB8
AED2  0012     RETURN 0
183:               {
184:                   OT.pop=offset-OT.offsetL;    
185:               }
186:           }
187:           /*---------------------------------------------------------------------------------*/
188:           /*---------------------------------------------------------------------------------*/
189:           //Przerwanie INT1
190:           volatile static unsigned char INT0krok=0;
191:           void SetINT0Krk(const unsigned char kr)
C1C2  0100     MOVLB 0x0
C1C4  6F74     MOVWF _PFNf_prODP, BANKED
C226  6E28     MOVWF _PFNf_10V_RT, ACCESS
C23E  6E15     MOVWF _LIN1f_Busy, ACCESS
192:           {
193:               INT0krok=kr;
C1C6  C074     MOVFF _PFNf_prODP, INT0krok
C1C8  F1C3     NOP
C228  C028     MOVFF _PFNf_10V_RT, INT0krok
C22A  F1C3     NOP
C240  C015     MOVFF _LIN1f_Busy, INT0krok
C242  F1C3     NOP
194:           }
C1CA  0012     RETURN 0
C22C  0012     RETURN 0
C244  0012     RETURN 0
195:           void IntINT0(void)
196:           {
197:               volatile unsigned int offset,rtim;
198:               //volatile signed int pop;
199:               
200:               switch(INT0krok)
981C  D026     BRA 0x986A
986A  0101     MOVLB 0x1
986C  51C3     MOVF 0xC3, W, BANKED
986E  B4D8     BTFSC STATUS, 2, ACCESS
9870  0012     RETURN 0
9872  0A01     XORLW 0x1
9874  E0D4     BZ 0x981E
9876  0A03     XORLW 0x3
9878  E0EB     BZ 0x9850
987A  0A01     XORLW 0x1
987C  E0EC     BZ 0x9856
987E  0A07     XORLW 0x7
9880  E0F0     BZ 0x9862
201:               {
202:                   case 0:
203:                   {
204:                       return;
205:                   }
206:                   case 1:     //IntMeasureOTPeriod
207:                   {           
208:                       if(PFNf_firstEdge)  //zbocze inicjujace pomiar?
981E  A40A     BTFSS PFNf_firstEdge, 2, ACCESS
9820  D00A     BRA 0x9836
209:                       {                
210:                           ReloadTMR0(0);      //reset timer0  
9822  6A16     CLRF _LIN1f_CHK, ACCESS
9824  6A15     CLRF _LIN1f_Busy, ACCESS
9826  EC91     CALL 0xB122, 0
9828  F058     NOP
211:                           WrtTMR0(0);         //reset timer0                
982A  EC7F     CALL 0x82FE, 0
982C  F041     NOP
982E  ECFA     CALL 0xC1F4, 0
9830  F060     NOP
212:                           PFNf_firstEdge=0;
9832  940A     BCF PFNf_firstEdge, 2, ACCESS
9834  D030     BRA PL216
213:                           OT.data1=0;
214:                       }
215:                       else                //zbocze zamykajace pomiar
216:                       {      
217:                           OT.data1=ReadTMR0();     //read timer0
9836  EC14     CALL 0xBC28, 0
9838  F05E     NOP
983A  C015     MOVFF _LIN1f_Busy, 0x128
983C  F128     NOP
983E  C016     MOVFF _LIN1f_CHK, 0x129
9840  F129     NOP
9842  0101     MOVLB 0x1
9844  6B2A     CLRF _PFNf_EnAleg, BANKED
9846  6B2B     CLRF _PFNf_EnF10V, BANKED
218:                           IntMeasureOTPeriod();   //Synchronizacja
9848  EC7D     CALL 0x72FA, 0
984A  F039     NOP
219:                           PFNf_firstEdge=1;                
984C  840A     BSF PFNf_firstEdge, 2, ACCESS
984E  0012     RETURN 0
220:                       } 
221:                       return;
222:                   }
223:                   case 2:     //WaitOTFrame
224:                   {
225:                       OT.timeLow=Millis();   //nowy punkt startowy pomiaru czasu
9850  EC68     CALL 0xC0D0, 0
9852  F060     NOP
9854  D017     BRA PL134
226:                       return;
227:                   }         
228:                   case 3:     //ReadOTFrame (pierwsze zbocze)
229:                   {
230:                       DetachINT();    
9856  EC7A     CALL 0xC0F4, 0
9858  F060     NOP
231:                       StopOTTimeout();
985A  EC71     CALL 0xC0E2, 0
985C  F060     NOP
232:                       StartReadOTFrame();
985E  EFF5     GOTO 0xB3EA
9860  F059     NOP
233:                       return;
234:                   }        
235:                   case 4:     //ReadOTFrame (kolejne bity)
236:                   {
237:                       OT.transitionCount++;
9862  4B21     INFSNZ _MGSDf_RERR_TIM, F, BANKED
9864  2B22     INCF _MGSDf_TERR_TIM, F, BANKED
238:                       SetOffset();                //poprawka dla pkt. pomiaru
9866  EF47     GOTO 0xAE8E
9868  F057     NOP
239:                       return;
240:                   }
241:               }
242:           }
9882  0012     RETURN 0
243:           /*---------------------------------------------------------------------------------*/
244:           /*---------------------------------------------------------------------------------*/
245:           //Przerwanie INT1
246:           volatile static unsigned char INT1krok=0;
247:           void SetINT1Krk(const unsigned char kr)
C1B8  0100     MOVLB 0x0
C1BA  6F74     MOVWF _PFNf_prODP, BANKED
C21E  6E28     MOVWF _PFNf_10V_RT, ACCESS
C236  6E15     MOVWF _LIN1f_Busy, ACCESS
248:           {
249:               INT1krok=kr;
C1BC  C074     MOVFF _PFNf_prODP, INT1krok
C1BE  F1C4     NOP
C220  C028     MOVFF _PFNf_10V_RT, INT1krok
C222  F1C4     NOP
C238  C015     MOVFF _LIN1f_Busy, INT1krok
C23A  F1C4     NOP
250:           }
C1C0  0012     RETURN 0
C224  0012     RETURN 0
C23C  0012     RETURN 0
251:           void IntINT1(void)
252:           {
253:               //volatile unsigned int offset,rtim;    
254:               //volatile signed int pop;
255:               
256:               switch(INT1krok)
BB5A  D008     BRA 0xBB6C
BB6C  0101     MOVLB 0x1
BB6E  51C4     MOVF 0xC4, W, BANKED
BB70  B4D8     BTFSC STATUS, 2, ACCESS
BB72  0012     RETURN 0
BB74  0A01     XORLW 0x1
BB76  E0F2     BZ 0xBB5C
BB78  0A03     XORLW 0x3
BB7A  E0F4     BZ 0xBB64
257:               {
258:                   case 0:
259:                   {    
260:                       return;
261:                   }
262:                   case 1:     //WaitOTFrame
263:                   {
264:                       OT.timeLow=Millis();       //nowy punkt startowy pomiaru czasu 
BB5C  EC68     CALL 0xC0D0, 0
BB5E  F060     NOP
BB60  EF42     GOTO 0x9884
BB62  F04C     NOP
265:                       return;
266:                   }        
267:                   case 2:     //ReadOTFrame (kolejne bity)
268:                   {
269:                       OT.transitionCount++;   
BB64  4B21     INFSNZ _MGSDf_RERR_TIM, F, BANKED
BB66  2B22     INCF _MGSDf_TERR_TIM, F, BANKED
270:                       SetOffset();                //poprawka dla pkt. pomiaru
BB68  EF47     GOTO 0xAE8E
BB6A  F057     NOP
271:                       return;
272:                   }
273:                   
274:               }
275:           }
BB7C  0012     RETURN 0
276:           /*---------------------------------------------------------------------------------*/
277:           /*---------------------------------------------------------------------------------*/
278:           //Deaktywacja przerwania INT0, INT1 na wejsciu OT
279:           void DetachINT(void)
C0F4  D805     RCALL PL760
C144  EC80     CALL 0xC100, 0
C146  F060     NOP
280:           {
281:           	INT0IE=0;			   		
C152  EC80     CALL 0xC100, 0
282:           	INT1IE=0;    
283:               SetINT0Krk(0);    
C0F6  EC1F     CALL 0xC23E, 0
C0F8  F061     NOP
C148  ECE1     CALL 0xC1C2, 0
C14A  F060     NOP
C156  EC13     CALL 0xC226, 0
C158  F061     NOP
284:               SetINT1Krk(0);				  
C0FA  0E00     MOVLW 0x0
C14C  0E00     MOVLW 0x0
C14E  EFDC     GOTO 0xC1B8
C150  F060     NOP
C15A  0E00     MOVLW 0x0
C15C  EF0F     GOTO 0xC21E
C15E  F061     NOP
285:           }
286:           /*---------------------------------------------------------------------------------*/
287:           /*---------------------------------------------------------------------------------*/
288:           //Aktywacja przerwania INT0 na wejsciu OT dla funkcji INTRsync (zbocze OT opadajace)
289:           void AtachINTRsync(void)
BE6C  D809     RCALL PL754
C076  EC40     CALL 0xBE80, 0
C078  F05F     NOP
290:           {					   		
291:           	INT0IE=0;			   		
C0BE  EC40     CALL 0xBE80, 0
292:           	INT1IE=0;
293:               SetINT0Krk(1);    
BE6E  EC1F     CALL 0xC23E, 0
BE70  F061     NOP
C07A  ECE1     CALL 0xC1C2, 0
C07C  F060     NOP
C0C2  EC13     CALL 0xC226, 0
C0C4  F061     NOP
294:               SetINT1Krk(0);
BE72  0E00     MOVLW 0x0
C07E  0E00     MOVLW 0x0
C080  ECDC     CALL 0xC1B8, 0
C082  F060     NOP
C084  EF3D     GOTO 0xBE7A
C086  F05F     NOP
C0C6  0E00     MOVLW 0x0
C0C8  EC0F     CALL 0xC21E, 0
C0CA  F061     NOP
295:           #if _NEG_IN==0    
296:           	INTEDG0=0;          //zbocze opadajace
297:           #else
298:           	INTEDG0=1;          //zbocze narastajace
C0CC  EF3D     GOTO 0xBE7A
C0CE  F05F     NOP
299:           #endif
300:           	INT0IE=1;    
301:           }
302:           /*---------------------------------------------------------------------------------*/
303:           /*---------------------------------------------------------------------------------*/
304:           //Aktywacja przerwania INT0,INT1 na wejsciu OT dla funkcji WaitOTFrame (zbocze OT opadajace)
305:           void AtachINTWaitOTFrame(void)
BF9E  D807     RCALL PL750
C064  ECD7     CALL 0xBFAE, 0
C066  F05F     NOP
306:           {		
307:           	INT0IE=0;			   		
C0AC  ECD7     CALL 0xBFAE, 0
308:           	INT1IE=0;    
309:               SetINT0Krk(2);    
BFA0  EC1F     CALL 0xC23E, 0
BFA2  F061     NOP
C068  ECE1     CALL 0xC1C2, 0
C06A  F060     NOP
C0B0  EC13     CALL 0xC226, 0
C0B2  F061     NOP
310:               SetINT1Krk(1);
BFA4  0E01     MOVLW 0x1
C06C  0E01     MOVLW 0x1
C06E  ECDC     CALL 0xC1B8, 0
C070  F060     NOP
C072  EF9E     GOTO 0xBF3C
C074  F05F     NOP
C0B4  0E01     MOVLW 0x1
C0B6  EC0F     CALL 0xC21E, 0
C0B8  F061     NOP
311:           #if _NEG_IN==0    
312:           	INTEDG0=0;          //zbocze opadajace
313:           	INTEDG1=1;          //zbocze narastajace    
314:           #else
315:           	INTEDG0=1;          //zbocze narastajace
C0BA  EF9E     GOTO 0xBF3C
C0BC  F05F     NOP
316:           	INTEDG1=0;          //zbocze opadajace    
317:           #endif   
318:           	INT0IE=1; 
319:           	INT1IE=1;    
320:           }
321:           /*---------------------------------------------------------------------------------*/
322:           /*---------------------------------------------------------------------------------*/
323:           //Aktywacja przerwania INT0 na wejsciu OT dla funkcji WaitOTFrame (zbocze OT opadajace)
324:           void AtachINTStartRec(void)
BE52  D806     RCALL PL752
C052  EC30     CALL 0xBE60, 0
C054  F05F     NOP
325:           {					   		
326:           	INT0IE=0;			   		
C09A  EC30     CALL 0xBE60, 0
327:           	INT1IE=0;
328:               SetINT0Krk(3);    
BE54  EC1F     CALL 0xC23E, 0
BE56  F061     NOP
C056  ECE1     CALL 0xC1C2, 0
C058  F060     NOP
C09E  EC13     CALL 0xC226, 0
C0A0  F061     NOP
329:               SetINT1Krk(0);
BE58  0E00     MOVLW 0x0
C05A  0E00     MOVLW 0x0
C05C  ECDC     CALL 0xC1B8, 0
C05E  F060     NOP
C060  EF33     GOTO 0xBE66
C062  F05F     NOP
C0A2  0E00     MOVLW 0x0
C0A4  EC0F     CALL 0xC21E, 0
C0A6  F061     NOP
330:           #if _NEG_IN==0    
331:           	INTEDG0=1;          //zbocze narastajace
332:           #else
333:           	INTEDG0=0;          //zbocze opadajace
C0A8  EF33     GOTO 0xBE66
C0AA  F05F     NOP
334:           #endif
335:           	INT0IE=1;    
336:           }
337:           /*---------------------------------------------------------------------------------*/
338:           /*---------------------------------------------------------------------------------*/
339:           //Aktywacja przerwania INT0,INT1 na wejsciu OT dla funkcji INTTransition (oba zbocza)
340:           void AtachINTTransition(void)
341:           {					   		
342:               SetINT0Krk(4);    
BF2E  0E04     MOVLW 0x4
BF30  EC1F     CALL 0xC23E, 0
BF32  F061     NOP
343:               SetINT1Krk(2);
BF34  0E02     MOVLW 0x2
BF36  EC1B     CALL 0xC236, 0
BF38  F061     NOP
BF3A  D000     BRA PL272
344:           #if _NEG_IN==0    
345:           	INTEDG0=0;          //zbocze opadajace
346:           	INTEDG1=1;          //zbocze narastajace    
347:           #else
348:           	INTEDG0=1;          //zbocze narastajace
349:           	INTEDG1=0;          //zbocze opadajace    
350:           #endif   
351:           	INT0IE=1; 
352:           	INT1IE=1;    
353:           }
354:           /*---------------------------------------------------------------------------------*/
355:           /*---------------------------------------------------------------------------------*/
356:           //Pomiar wartosci sredniej parametrow czasowych ramki (przerwanie INT0)
357:           volatile static unsigned char MOTkrk=0;
358:           //volatile static unsigned char cnt1=0;
359:           //volatile static unsigned char cnt2=0;
360:           //volatile static int sum=0;
361:           //volatile static unsigned int T2;
362:           #define _RELOAD0    0
363:           void StartMeasureOTPeriod(void)
B0E2  D812     RCALL PL202
B48E  EC84     CALL 0xB108, 0
B490  F058     NOP
364:           {
365:               TMR0IE=0;
B602  EC84     CALL 0xB108, 0
366:               MOTkrk=0;
367:               OT.cnt1=0;
368:               OT.cnt2=0;      
369:               OT.sum=0;
370:               OT.nRERR=0;
371:               PFNf_firstEdge=1;
372:               AtachINTRsync();                    //aktywacja przerwania INT0
B0E4  EC36     CALL 0xBE6C, 0
B0E6  F05F     NOP
B492  EC3B     CALL 0xC076, 0
B494  F060     NOP
B606  EC5F     CALL 0xC0BE, 0
B608  F060     NOP
373:               StartOTTimeout(_MEASURE_TIMO,1);    //restart procedury po _MEASURE_TIMO [usek] oczekiwania
B0E8  0E61     MOVLW 0x61
B0EA  6E16     MOVWF _LIN1f_CHK, ACCESS
B0EC  0EA8     MOVLW 0xA8
B0EE  D815     RCALL PL784
B0F0  ECDA     CALL 0xBFB4, 0
B0F2  F05F     NOP
B496  0E61     MOVLW 0x61
B498  0100     MOVLB 0x0
B49A  6F75     MOVWF _PFNf_prn_cs, BANKED
B49C  0EA8     MOVLW 0xA8
B49E  D80E     RCALL PL828
B4A0  ECB9     CALL 0xBF72, 0
B4A2  F05F     NOP
B60A  0E61     MOVLW 0x61
B60C  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
B60E  0EA8     MOVLW 0xA8
B610  D80B     RCALL PL774
B612  ECC4     CALL 0xBF88, 0
B614  F05F     NOP
374:               ReloadTMR0(_RELOAD0);               //przerwanie po pelnym przepelnieniu TIMER0    
B0F4  6A16     CLRF _LIN1f_CHK, ACCESS
B0F6  6A15     CLRF _LIN1f_Busy, ACCESS
B0F8  EC91     CALL 0xB122, 0
B0FA  F058     NOP
B0FC  EC7F     CALL 0x82FE, 0
B0FE  F041     NOP
B4A4  0100     MOVLB 0x0
B4A6  6B75     CLRF _PFNf_prn_cs, BANKED
B4A8  6B74     CLRF _PFNf_prODP, BANKED
B4AA  EC11     CALL 0xB022, 0
B4AC  F058     NOP
B616  6A29     CLRF _PFNf_10V_nPCO, ACCESS
B618  6A28     CLRF _PFNf_10V_RT, ACCESS
B61A  EC51     CALL 0xB0A2, 0
B61C  F058     NOP
B61E  D808     RCALL PL816
375:               WrtTMR0(_RELOAD0);                  //wartosc przeladowania dla kolejnego przerwania TIMER0  
B100  ECFA     CALL 0xC1F4, 0
B102  F060     NOP
B4AE  0E00     MOVLW 0x0
B4B0  6B75     CLRF _PFNf_prn_cs, BANKED
B4B2  6B74     CLRF _PFNf_prODP, BANKED
B4B4  ECD7     CALL 0xC1AE, 0
B4B6  F060     NOP
B620  ECEB     CALL 0xC1D6, 0
B622  F060     NOP
376:               TMR0IE=1;
B104  8AF2     BSF INTCON, 5, ACCESS
B4B8  8AF2     BSF INTCON, 5, ACCESS
B624  8AF2     BSF INTCON, 5, ACCESS
377:           }
B106  0012     RETURN 0
B4BA  0012     RETURN 0
B626  0012     RETURN 0
378:           void IntMeasureOTPeriod(void)
379:           {
380:               //wartosc srednia odcinkow czasowych T2
381:               switch(MOTkrk)
72FA  D08D     BRA 0x7416
7416  51C8     MOVF 0xC8, W, BANKED
382:               {
383:                   case 0:
384:                   {
385:                       if(OT.cnt1<_SAMPLE_SIZE) 
72FC  0E0A     MOVLW 0xA
72FE  610D     CPFSLT PFNf_plmCO, BANKED
7300  D006     BRA 0x730E
386:                       {
387:                           OT.cnt2=0;
7302  6B0E     CLRF PFNf_popFN, BANKED
388:                           OT.T2=0xffff;                
7304  6911     SETF PFNf_zima, BANKED
7306  6912     SETF RSDT1f_RD_STD, BANKED
389:                           MOTkrk=1;             
7308  0E01     MOVLW 0x1
730A  6FC8     MOVWF 0xC8, BANKED
390:                       }
730C  D05D     BRA 0x73C8
391:                       else    //wynik
392:                       {
393:                           TMR0IE=0;
730E  9AF2     BCF INTCON, 5, ACCESS
394:                           StopOTTimeout();                 
7310  EC71     CALL 0xC0E2, 0
7312  F060     NOP
395:                           DetachINT();  
7314  EC7A     CALL 0xC0F4, 0
7316  F060     NOP
396:                           OT.otPeriod=(OT.sum*_TICK_TO_USEC)/_SAMPLE_SIZE;            //wartosc srednia [u sek]
7318  EE21     LFSR 2, 0x10F
731A  F00F     NOP
731C  CFDE     MOVFF POSTINC2, _MGSDf_TERR_TIM
731E  F022     NOP
7320  CFDD     MOVFF POSTDEC2, _MGSDf_TransACK
7322  F023     NOP
7324  90D8     BCF STATUS, 0, ACCESS
7326  3622     RLCF _MGSDf_TERR_TIM, F, ACCESS
7328  3623     RLCF _MGSDf_TransACK, F, ACCESS
732A  90D8     BCF STATUS, 0, ACCESS
732C  3622     RLCF _MGSDf_TERR_TIM, F, ACCESS
732E  3623     RLCF _MGSDf_TransACK, F, ACCESS
7330  C022     MOVFF _MGSDf_TERR_TIM, _LIN1f_Busy
7332  F015     NOP
7334  C023     MOVFF _MGSDf_TransACK, _LIN1f_CHK
7336  F016     NOP
7338  6A18     CLRF _LIN1f_FAdta, ACCESS
733A  0E0A     MOVLW 0xA
733C  6E17     MOVWF _LIN1f_ERRR, ACCESS
733E  ECB7     CALL 0xAD6E, 0
7340  F056     NOP
7342  C015     MOVFF _LIN1f_Busy, 0x113
7344  F113     NOP
7346  C016     MOVFF _LIN1f_CHK, 0x114
7348  F114     NOP
734A  0101     MOVLB 0x1
734C  6B15     CLRF _LIN1f_Busy, BANKED
734E  6B16     CLRF _LIN1f_CHK, BANKED
397:                           OT.preload=0xffff-(OT.otPeriod/_TICK_TO_USEC);              //wartosc przeladowania timera0;
7350  D869     RCALL PL196
7352  0E03     MOVLW 0x3
7354  D001     BRA 0x7358
7356  D86F     RCALL PL394
7358  2EE8     DECFSZ WREG, F, ACCESS
735A  D7FD     BRA 0x7356
735C  1C22     COMF _MGSDf_TERR_TIM, W, ACCESS
735E  6F19     MOVWF _LIN1f_FIN, BANKED
7360  1C23     COMF _MGSDf_TransACK, W, ACCESS
7362  6F1A     MOVWF _LIN1f_FResp, BANKED
7364  D85F     RCALL PL196
398:                           OT.preload2=0xffff-((OT.otPeriod/_TICK_TO_USEC)/2);         //wartosc przeladowania timera0;                
7366  0E04     MOVLW 0x4
7368  D001     BRA 0x736C
736A  D865     RCALL PL394
736C  2EE8     DECFSZ WREG, F, ACCESS
736E  D7FD     BRA 0x736A
7370  1C22     COMF _MGSDf_TERR_TIM, W, ACCESS
7372  6F1B     MOVWF _LIN1f_FTrans, BANKED
7374  1C23     COMF _MGSDf_TransACK, W, ACCESS
7376  6F1C     MOVWF _LIN1f_NDTA, BANKED
7378  D855     RCALL PL196
399:                           OT.preload4=0xffff-((OT.otPeriod/_TICK_TO_USEC)/5);         //wartosc przeladowania wstepnego TIMER0 dla odczytu ramki                
737A  0E03     MOVLW 0x3
737C  D001     BRA 0x7380
737E  D85B     RCALL PL394
7380  2EE8     DECFSZ WREG, F, ACCESS
7382  D7FD     BRA 0x737E
7384  C022     MOVFF _MGSDf_TERR_TIM, _LIN1f_Busy
7386  F015     NOP
7388  C023     MOVFF _MGSDf_TransACK, _LIN1f_CHK
738A  F016     NOP
738C  C024     MOVFF _MGSDf_TransData, _LIN1f_ERRR
738E  F017     NOP
7390  C025     MOVFF _MGSDf_TransDataRC, _LIN1f_FAdta
7392  F018     NOP
7394  0E05     MOVLW 0x5
7396  6E19     MOVWF _LIN1f_FIN, ACCESS
7398  6A1A     CLRF _LIN1f_FResp, ACCESS
739A  6A1B     CLRF _LIN1f_FTrans, ACCESS
739C  6A1C     CLRF _LIN1f_NDTA, ACCESS
739E  ECB1     CALL 0x9F62, 0
73A0  F04F     NOP
73A2  1C15     COMF _LIN1f_Busy, W, ACCESS
73A4  6F1D     MOVWF _LIN1f_SCS, BANKED
73A6  1C16     COMF _LIN1f_CHK, W, ACCESS
73A8  6F1E     MOVWF _MGSDf_ERRt, BANKED
400:                           OT.offset2=0xffff-OT.preload2;                
73AA  1D1B     COMF _LIN1f_FTrans, W, BANKED
73AC  6F30     MOVWF _PFNf_LIN_CK, BANKED
73AE  1D1C     COMF _LIN1f_NDTA, W, BANKED
73B0  6F31     MOVWF _PFNf_LIN_CW, BANKED
401:                           OT.offsetL=0xffff-OT.preload4;
73B2  1D1D     COMF _LIN1f_SCS, W, BANKED
73B4  6F2E     MOVWF _PFNf_FOT, BANKED
73B6  1D1E     COMF _MGSDf_ERRt, W, BANKED
73B8  6F2F     MOVWF _PFNf_KnfDisErr, BANKED
402:                           //db=1;                                
403:                           SetOTDeamon(2);                              //inicjalizacja timer0 dla WaitOTFrame   
73BA  0E02     MOVLW 0x2
73BC  ECF5     CALL 0xC1EA, 0
73BE  F060     NOP
404:                           MOTkrk=2;                 
73C0  0E02     MOVLW 0x2
73C2  0101     MOVLB 0x1
73C4  6FC8     MOVWF 0xC8, BANKED
73C6  0C02     RETLW 0x2
405:                           return;
406:                       }
407:                   }
408:                   case 1:
409:                   {            
410:                       if(OT.cnt2<_SAMPLE_SIZE)    
73C8  0E0A     MOVLW 0xA
73CA  610E     CPFSLT PFNf_popFN, BANKED
73CC  D01B     BRA 0x7404
411:                       {             
412:                           if(OT.data1!=0)    //nie nastapilo przepelnienie timera0?
73CE  5128     MOVF _PFNf_10V_RT, W, BANKED
73D0  1129     IORWF _PFNf_10V_nPCO, W, BANKED
73D2  112A     IORWF _PFNf_EnAleg, W, BANKED
73D4  112B     IORWF _PFNf_EnF10V, W, BANKED
73D6  B4D8     BTFSC STATUS, 2, ACCESS
73D8  0012     RETURN 0
413:                           {
414:                               if(OT.data1<OT.T2)    //znajdz najkrotszy odcinek czasu miedzy kolejnymi narastajacymi zboczami
73DA  5111     MOVF PFNf_zima, W, BANKED
73DC  6E22     MOVWF _MGSDf_TERR_TIM, ACCESS
73DE  5112     MOVF RSDT1f_RD_STD, W, BANKED
73E0  6E23     MOVWF _MGSDf_TransACK, ACCESS
73E2  6A24     CLRF _MGSDf_TransData, ACCESS
73E4  6A25     CLRF _MGSDf_TransDataRC, ACCESS
73E6  5022     MOVF _MGSDf_TERR_TIM, W, ACCESS
73E8  5D28     SUBWF _PFNf_10V_RT, W, BANKED
73EA  5023     MOVF _MGSDf_TransACK, W, ACCESS
73EC  5929     SUBWFB _PFNf_10V_nPCO, W, BANKED
73EE  5024     MOVF _MGSDf_TransData, W, ACCESS
73F0  592A     SUBWFB _PFNf_EnAleg, W, BANKED
73F2  5025     MOVF _MGSDf_TransDataRC, W, ACCESS
73F4  592B     SUBWFB _PFNf_EnF10V, W, BANKED
73F6  E204     BC 0x7400
415:                               {
416:                                   OT.T2=OT.data1;
73F8  C128     MOVFF 0x128, 0x111
73FA  F111     NOP
73FC  C129     MOVFF 0x129, 0x112
73FE  F112     NOP
417:                               }
418:                               OT.cnt2++;                      
7400  2B0E     INCF PFNf_popFN, F, BANKED
7402  0012     RETURN 0
419:                           }       
420:                       }
421:                       else
422:                       {
423:                           OT.sum+=OT.T2;
7404  EE21     LFSR 2, 0x111
7406  F011     NOP
7408  50DE     MOVF POSTINC2, W, ACCESS
740A  270F     ADDWF PFNf_set_fnserw, F, BANKED
740C  50DD     MOVF POSTDEC2, W, ACCESS
740E  2310     ADDWFC PFNf_str_nco, F, BANKED
424:                           OT.cnt1++;     
7410  2B0D     INCF PFNf_plmCO, F, BANKED
425:                           MOTkrk=0;
7412  6BC8     CLRF 0xC8, BANKED
7414  0012     RETURN 0
7416  51C8     MOVF 0xC8, W, BANKED
7418  E101     BNZ 0x741C
741A  D770     BRA 0x72FC
741C  0A01     XORLW 0x1
741E  E0D4     BZ 0x73C8
7420  0A03     XORLW 0x3
7422  0012     RETURN 0
426:                       }
427:                       return;            
428:                   }
429:                   case 2:
430:                   {
431:                       return;
432:                   }
433:               }
434:               return;
435:           }
436:           /*---------------------------------------------------------------------------------*/
437:           /*---------------------------------------------------------------------------------*/
438:           //Oczekiwanie na poczatek kolejnej ramki
439:           volatile static unsigned char MOTFkrk=0;
440:           
441:           #define _RELOAD1    0xffff-(2000/_TICK_TO_USEC)  //przerwanie co 2000us TIMER0
442:           void StartWaitOTFrame(void)
443:           {
444:               MOTFkrk=0; 
B1DE  0100     MOVLB 0x0
B1E0  6BDD     CLRF MOTFkrk, BANKED
B306  0100     MOVLB 0x0
B340  0100     MOVLB 0x0
445:               StartOTTimeout(_WAITOT_TIMO,1);                 //restart do MeasureOTPeriod po _WAITOT_TIMO [usek] oczekiwania
B1E2  0E27     MOVLW 0x27
B1E4  6F75     MOVWF _PFNf_prn_cs, BANKED
B1E6  0E10     MOVLW 0x10
B1E8  EC5E     CALL 0xB4BC, 0
B1EA  F05A     NOP
B1EC  ECB9     CALL 0xBF72, 0
B1EE  F05F     NOP
B30A  0E27     MOVLW 0x27
B30C  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
B30E  0E10     MOVLW 0x10
B310  EC14     CALL 0xB628, 0
B312  F05B     NOP
B314  ECC4     CALL 0xBF88, 0
B316  F05F     NOP
B344  0E27     MOVLW 0x27
B346  6E16     MOVWF _LIN1f_CHK, ACCESS
B348  0E10     MOVLW 0x10
B34A  EC8D     CALL 0xB11A, 0
B34C  F058     NOP
B34E  ECDA     CALL 0xBFB4, 0
B350  F05F     NOP
446:               AtachINTWaitOTFrame();    
B1F0  EC32     CALL 0xC064, 0
B1F2  F060     NOP
B1F4  D807     RCALL PL590
B318  EC56     CALL 0xC0AC, 0
B31A  F060     NOP
B31C  D80C     RCALL PL718
B352  ECCF     CALL 0xBF9E, 0
B354  F05F     NOP
B356  D80C     RCALL PL658
447:               ReloadTMR0(_RELOAD1);                           //przerwanie TIMER0 po 2000us    
B1F6  EC11     CALL 0xB022, 0
B1F8  F058     NOP
B1FA  D80A     RCALL PL648
B31E  EC51     CALL 0xB0A2, 0
B320  F058     NOP
B322  D804     RCALL PL680
B358  EC91     CALL 0xB122, 0
B35A  F058     NOP
B35C  D804     RCALL PL634
448:               WrtTMR0(_RELOAD1);                              //wartosc przeladowania dla kolejnego przerwania TIMER0                       
B1FC  ECD7     CALL 0xC1AE, 0
B1FE  F060     NOP
B324  ECEB     CALL 0xC1D6, 0
B326  F060     NOP
B35E  ECFA     CALL 0xC1F4, 0
B360  F060     NOP
449:               TMR0IE=1;                 
B200  8AF2     BSF INTCON, 5, ACCESS
B328  8AF2     BSF INTCON, 5, ACCESS
B362  8AF2     BSF INTCON, 5, ACCESS
450:           }
B202  0012     RETURN 0
B32A  0012     RETURN 0
B364  0012     RETURN 0
451:           bit WaitOTFrame(void)
452:           {   
453:           //    volatile static unsigned long int timeLow;
454:               volatile unsigned long int waitTime;
455:               
456:               //WrtTMR0(_RELOAD1);                              //przerwanie co 2000us
457:               //wartosc srednia odcinkow czasowych T2
458:               switch(MOTFkrk)
8A76  D033     BRA 0x8ADE
8ADE  0100     MOVLB 0x0
9100  D037     BRA 0x9170
9170  0100     MOVLB 0x0
95FE  D038     BRA 0x9670
9670  0100     MOVLB 0x0
459:               {
460:                   case 0:
461:                   {
462:                       if(_IN_OT==_HIGH_OT) return 0;          //stan wysoki linii - oczekuj
8A78  B081     BTFSC PORTB, 0, ACCESS
8A7A  D002     BRA 0x8A80
8A7C  90D8     BCF STATUS, 0, ACCESS
8A7E  0012     RETURN 0
9102  B081     BTFSC PORTB, 0, ACCESS
9104  D002     BRA 0x910A
9106  90D8     BCF STATUS, 0, ACCESS
9108  0012     RETURN 0
9600  B081     BTFSC PORTB, 0, ACCESS
9602  D002     BRA 0x9608
9604  90D8     BCF STATUS, 0, ACCESS
9606  0012     RETURN 0
463:                       else 
464:                       {             
465:                           OT.timeLow=Millis();
8A80  EC20     CALL 0xC040, 0
8A82  F060     NOP
8A84  D834     RCALL PL314
910A  EC44     CALL 0xC088, 0
910C  F060     NOP
910E  D838     RCALL PL322
9608  EC68     CALL 0xC0D0, 0
960A  F060     NOP
960C  EC42     CALL 0x9884, 0
960E  F04C     NOP
466:                           MOTFkrk=1;
8A86  0100     MOVLB 0x0
8A88  6FDD     MOVWF MOTFkrk, BANKED
9110  0100     MOVLB 0x0
9112  6FDD     MOVWF MOTFkrk, BANKED
9610  0E01     MOVLW 0x1
9612  0100     MOVLB 0x0
9614  6FDD     MOVWF MOTFkrk, BANKED
467:                       } 
468:                   }
469:                   case 1:
470:                   {
471:                       if(_IN_OT==_LOW_OT)                     //stan niski linii - trwa transmisja ramki lub przerwa miedzy ramkami MASTER
8A8A  A081     BTFSS PORTB, 0, ACCESS
8A8C  D026     BRA 0x8ADA
9114  A081     BTFSS PORTB, 0, ACCESS
9116  D02A     BRA 0x916C
9616  A081     BTFSS PORTB, 0, ACCESS
9618  D029     BRA 0x966C
472:                       {
473:                           waitTime=Millis()-OT.timeLow;
8A8E  EC20     CALL 0xC040, 0
8A90  F060     NOP
8A92  D836     RCALL PL668
8A94  6F78     MOVWF _PFNf_prn_pp, BANKED
8A96  D843     RCALL PL694
8A98  6F79     MOVWF _PFNf_prn_res, BANKED
8A9A  D83C     RCALL PL692
8A9C  6F7A     MOVWF _PFNf_res, BANKED
8A9E  D835     RCALL PL686
8AA0  6F7B     MOVWF _PFNf_rozruch, BANKED
9118  EC44     CALL 0xC088, 0
911A  F060     NOP
911C  0101     MOVLB 0x1
911E  5100     MOVF 0x0, W, BANKED
9120  5C28     SUBWF _PFNf_10V_RT, W, ACCESS
9122  6E2C     MOVWF _PFNf_EnLIN, ACCESS
9124  5101     MOVF DtCOf_err_CO, W, BANKED
9126  5829     SUBWFB _PFNf_10V_nPCO, W, ACCESS
9128  6E2D     MOVWF _PFNf_FLIN, ACCESS
912A  5102     MOVF LIN1f_Busy, W, BANKED
912C  582A     SUBWFB _PFNf_EnAleg, W, ACCESS
912E  6E2E     MOVWF _PFNf_FOT, ACCESS
9130  5103     MOVF LIN1f_NDTA, W, BANKED
9132  582B     SUBWFB _PFNf_EnF10V, W, ACCESS
9134  6E2F     MOVWF _PFNf_KnfDisErr, ACCESS
961A  EC68     CALL 0xC0D0, 0
961C  F060     NOP
961E  0101     MOVLB 0x1
9620  5100     MOVF 0x0, W, BANKED
9622  5C15     SUBWF _LIN1f_Busy, W, ACCESS
9624  6E19     MOVWF _LIN1f_FIN, ACCESS
9626  5101     MOVF DtCOf_err_CO, W, BANKED
9628  5816     SUBWFB _LIN1f_CHK, W, ACCESS
962A  6E1A     MOVWF _LIN1f_FResp, ACCESS
962C  5102     MOVF LIN1f_Busy, W, BANKED
962E  5817     SUBWFB _LIN1f_ERRR, W, ACCESS
9630  6E1B     MOVWF _LIN1f_FTrans, ACCESS
9632  5103     MOVF LIN1f_NDTA, W, BANKED
9634  5818     SUBWFB _LIN1f_FAdta, W, ACCESS
9636  6E1C     MOVWF _LIN1f_NDTA, ACCESS
474:                           if(waitTime>= _MIN_WAIT_FOR_MASTER) //stan niski utrzymywany bez przerwy przez 100ms MASTER?
8AA2  517B     MOVF _PFNf_rozruch, W, BANKED
8AA4  117A     IORWF _PFNf_res, W, BANKED
8AA6  1179     IORWF _PFNf_prn_res, W, BANKED
8AA8  E103     BNZ 0x8AB0
8AAA  0E55     MOVLW 0x55
8AAC  5D78     SUBWF _PFNf_prn_pp, W, BANKED
8AAE  E3E6     BNC 0x8A7C
9136  502F     MOVF _PFNf_KnfDisErr, W, ACCESS
9138  102E     IORWF _PFNf_FOT, W, ACCESS
913A  102D     IORWF _PFNf_FLIN, W, ACCESS
913C  E103     BNZ 0x9144
913E  0E55     MOVLW 0x55
9140  5C2C     SUBWF _PFNf_EnLIN, W, ACCESS
9142  E3E1     BNC 0x9106
9638  501C     MOVF _LIN1f_NDTA, W, ACCESS
963A  101B     IORWF _LIN1f_FTrans, W, ACCESS
963C  101A     IORWF _LIN1f_FResp, W, ACCESS
963E  E103     BNZ 0x9646
9640  0E55     MOVLW 0x55
9642  5C19     SUBWF _LIN1f_FIN, W, ACCESS
9644  E3DF     BNC 0x9604
475:                           {
476:                               StopOTTimeout();
8AB0  EC47     CALL 0xC28E, 0
8AB2  F061     NOP
9144  EC4B     CALL 0xC296, 0
9146  F061     NOP
9646  EC71     CALL 0xC0E2, 0
9648  F060     NOP
477:                               //deaktywacja timer0
478:                               TMR0IE=0;                       //zatrzymanie przerwania od TIMER0
8AB4  9AF2     BCF INTCON, 5, ACCESS
9148  9AF2     BCF INTCON, 5, ACCESS
964A  9AF2     BCF INTCON, 5, ACCESS
479:                               TMR0ON=0;                       //zatrzymanie TIMER0   
8AB6  9ED5     BCF T0CON, 7, ACCESS
914A  9ED5     BCF T0CON, 7, ACCESS
964C  9ED5     BCF T0CON, 7, ACCESS
480:                               //WrtTMR0(OT.preload4);           //wartosc przeladowania wstepnego dla odczytu ramki                    
481:                               //ReloadTMR0(OT.preload4);        //wartosc przeladowania wstepnego dla odczytu ramki
482:                               //aktywacja przerwania INT
483:                               DetachINT();
8AB8  ECA2     CALL 0xC144, 0
8ABA  F060     NOP
914C  ECA9     CALL 0xC152, 0
914E  F060     NOP
964E  EC7A     CALL 0xC0F4, 0
9650  F060     NOP
484:                               AtachINTStartRec();             //aktywacja przerwania INT0 dla pierwszego zbocza ramki 
8ABC  EC29     CALL 0xC052, 0
8ABE  F060     NOP
9150  EC4D     CALL 0xC09A, 0
9152  F060     NOP
9652  EC29     CALL 0xBE52, 0
9654  F05F     NOP
485:                               //aktywacja timeout dla oczekiwania na zbocze inicjujace odczyt 
486:                               StartOTTimeout(_FEDG_TIMO,3);   //ponow WaitOTFrame po _FEDG_TIMO [usek] oczekiwania na zbocze inicjujace
8AC0  0E13     MOVLW 0x13
8AC2  0100     MOVLB 0x0
8AC4  6F75     MOVWF _PFNf_prn_cs, BANKED
8AC6  0E88     MOVLW 0x88
8AC8  6F74     MOVWF _PFNf_prODP, BANKED
8ACA  0E03     MOVLW 0x3
8ACC  6F76     MOVWF _PFNf_prn_in, BANKED
8ACE  ECB9     CALL 0xBF72, 0
8AD0  F05F     NOP
8AD2  EC40     CALL 0x9680, 0
8AD4  F04B     NOP
9154  0E13     MOVLW 0x13
9156  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
9158  0E88     MOVLW 0x88
915A  6E28     MOVWF _PFNf_10V_RT, ACCESS
915C  0E03     MOVLW 0x3
915E  6E2A     MOVWF _PFNf_EnAleg, ACCESS
9160  ECC4     CALL 0xBF88, 0
9162  F05F     NOP
9656  0E13     MOVLW 0x13
9658  6E16     MOVWF _LIN1f_CHK, ACCESS
965A  0E88     MOVLW 0x88
965C  6E15     MOVWF _LIN1f_Busy, ACCESS
965E  0E03     MOVLW 0x3
9660  6E17     MOVWF _LIN1f_ERRR, ACCESS
9662  ECDA     CALL 0xBFB4, 0
9664  F05F     NOP
9666  D80C     RCALL PL762
487:                               MOTFkrk=2;
9164  EC40     CALL 0x9680, 0
9166  F04B     NOP
488:                               return 1;                       //KONIEC - przygotuj sie do odczytu kolejnej ramki MASTER
8AD6  80D8     BSF STATUS, 0, ACCESS
8AD8  0012     RETURN 0
9168  80D8     BSF STATUS, 0, ACCESS
916A  0012     RETURN 0
9668  80D8     BSF STATUS, 0, ACCESS
966A  0012     RETURN 0
489:                           }                
490:                       }
491:                       else
492:                       {
493:                           MOTFkrk=0;                          //jestes w trakcie nadawania ramki przez MASTER, kontynuuj oczekiwanie
8ADA  6BDD     CLRF MOTFkrk, BANKED
8ADC  D7CF     BRA 0x8A7C
916C  6BDD     CLRF MOTFkrk, BANKED
916E  D7CB     BRA 0x9106
966C  6BDD     CLRF MOTFkrk, BANKED
966E  D7CA     BRA 0x9604
9670  0100     MOVLB 0x0
9672  51DD     MOVF MOTFkrk, W, BANKED
9674  E0C5     BZ 0x9600
9676  0A01     XORLW 0x1
9678  E0CE     BZ 0x9616
967A  0A03     XORLW 0x3
967C  E0F5     BZ 0x9668
967E  D7C2     BRA 0x9604
494:                       }
495:                       return 0;
496:                   }
497:                   case 2:
498:                   {
499:                       return 1;
500:                   }
501:               }
502:               return 0;
503:           }
504:           /*---------------------------------------------------------------------------------*/
505:           /*---------------------------------------------------------------------------------*/
506:           //Oczekiwanie na poczatek kolejnej ramki
507:           volatile static unsigned char ROTFkrk=0;
508:           //volatile unsigned char cnt=0;
509:           //volatile unsigned char parityOdd=0;
510:           //volatile unsigned char previousTransitionCount=0;
511:           //volatile long unsigned int tempFrame=0;
512:           void StartReadOTFrame(void)
513:           { 
514:               //_WOUTX=1;       
515:               OT.cnt=0;
B3EA  6B1F     CLRF _MGSDf_NO_ODB, BANKED
516:               OT.parityOdd=0; 
B3EC  6B20     CLRF _MGSDf_RERR_REC, BANKED
517:               OT.tempFrame=0;             
B3EE  EC2A     CALL 0x9454, 0
B3F0  F04A     NOP
518:               OT.transitionCount=0; 
B3F2  6B21     CLRF _MGSDf_RERR_TIM, BANKED
B3F4  6B22     CLRF _MGSDf_TERR_TIM, BANKED
519:               OT.previousTransitionCount=0;    
B3F6  6B23     CLRF _MGSDf_TransACK, BANKED
520:               //INT0,INT1
521:               AtachINTTransition();
B3F8  EC97     CALL 0xBF2E, 0
B3FA  F05F     NOP
522:               //aktywacja timer0
523:               ReloadTMR0(OT.preload4);        //wartosc przeladowania wstepnego TIMER0 dla odczytu ramki
B3FC  C11D     MOVFF 0x11D, _LIN1f_Busy
B3FE  F015     NOP
B400  C11E     MOVFF 0x11E, _LIN1f_CHK
B402  F016     NOP
B404  EC91     CALL 0xB122, 0
B406  F058     NOP
524:               WrtTMR0(OT.preload);            //wartosc przeladowania dla kolejnego przerwania TIMER0
B408  C119     MOVFF 0x119, _LIN1f_Busy
B40A  F015     NOP
B40C  C11A     MOVFF 0x11A, _LIN1f_CHK
B40E  F016     NOP
B410  ECFA     CALL 0xC1F4, 0
B412  F060     NOP
525:               StopOTTimeout();
B414  EC71     CALL 0xC0E2, 0
B416  F060     NOP
526:               TMR0IE=1;                       //aktywacja przerwania od TIMER0
B418  8AF2     BSF INTCON, 5, ACCESS
527:               TMR0ON=1;                       //uruchomienie TIMER0 
B41A  8ED5     BSF T0CON, 7, ACCESS
528:               ROTFkrk=0;     
B41C  0100     MOVLB 0x0
B41E  6BDE     CLRF ROTFkrk, BANKED
529:           }
B420  0012     RETURN 0
530:           /*unsigned char ReadOTFrame(void)
531:           {   
532:               switch(ROTFkrk)
533:               {
534:                   case 0:                                       //przerwanie timer0 po _otPeriod/4 (zapobiega odczytowi stanu podczas zmiany sygnalu)
535:                   {  
536:                       if(OT.cnt>_FRAME_LENGTH)
537:                       {
538:                           _WOUTX=0;
539:                           return 1;
540:                       }            
541:                       _WOUTX=0;
542:                       WrtTMR0(OT.preload);            
543:                       ROTFkrk=1;
544:                       OT.cnt++;            
545:                       return 0;
546:                   }
547:                   case 1:
548:                   {     
549:                       if(OT.cnt>_FRAME_LENGTH)
550:                       {
551:                           _WOUTX=0;
552:                           return 1;
553:                       }            
554:                       _WOUTX=1;            
555:                       WrtTMR0(OT.preload);            
556:                       ROTFkrk=0;
557:                       OT.cnt++;            
558:                       return 0;
559:                   }        
560:               }
561:               return 1;
562:           }*/
563:           unsigned char ReadOTFrame(void)
564:           {
565:               volatile unsigned char sample;
566:             
567:               switch(ROTFkrk)
8852  D03B     BRA 0x88CA
88CA  0100     MOVLB 0x0
8C88  D04D     BRA 0x8D24
8D24  0100     MOVLB 0x0
9060  D042     BRA 0x90E6
90E6  0100     MOVLB 0x0
568:               {   
569:                   case 0:                                       //przerwanie timer0 co _otPeriod
570:                   {
571:           #if _TEST_OT==1            
572:                       if(_ROUTX) _WOUTX=0;
573:                       else _WOUTX=1;          
574:           #endif
575:                       if(OT.cnt<_FRAME_LENGTH)
8854  0E22     MOVLW 0x22
8856  0101     MOVLB 0x1
8858  611F     CPFSLT _MGSDf_NO_ODB, BANKED
885A  D028     BRA 0x88AC
8C8A  0E22     MOVLW 0x22
8C8C  0101     MOVLB 0x1
8C8E  611F     CPFSLT _MGSDf_NO_ODB, BANKED
8C90  D035     BRA 0x8CFC
9062  0E22     MOVLW 0x22
9064  0101     MOVLB 0x1
9066  611F     CPFSLT _MGSDf_NO_ODB, BANKED
9068  D02A     BRA 0x90BE
576:                       {
577:                           if((OT.cnt>0)&&(OT.transitionCount==OT.previousTransitionCount))
885C  511F     MOVF _MGSDf_NO_ODB, W, BANKED
885E  E009     BZ 0x8872
8860  5123     MOVF _MGSDf_TransACK, W, BANKED
8862  1921     XORWF _MGSDf_RERR_TIM, W, BANKED
8864  1122     IORWF _MGSDf_TERR_TIM, W, BANKED
8866  E105     BNZ 0x8872
8C92  511F     MOVF _MGSDf_NO_ODB, W, BANKED
8C94  E00A     BZ 0x8CAA
8C96  5123     MOVF _MGSDf_TransACK, W, BANKED
8C98  1921     XORWF _MGSDf_RERR_TIM, W, BANKED
8C9A  1122     IORWF _MGSDf_TERR_TIM, W, BANKED
8C9C  E106     BNZ 0x8CAA
906A  511F     MOVF _MGSDf_NO_ODB, W, BANKED
906C  E00A     BZ 0x9082
906E  5123     MOVF _MGSDf_TransACK, W, BANKED
9070  1921     XORWF _MGSDf_RERR_TIM, W, BANKED
9072  1122     IORWF _MGSDf_TERR_TIM, W, BANKED
9074  E106     BNZ 0x9082
578:                           {
579:                               //db=1;
580:                               if(OT.nRERR<0xff) OT.nRERR++;   //zwieksz licznik bledow odczytu
8868  2933     INCF _PFNf_LIN_ENDO, W, BANKED
886A  E001     BZ 0x886E
886C  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
8C9E  2933     INCF _PFNf_LIN_ENDO, W, BANKED
8CA0  E001     BZ 0x8CA4
8CA2  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
9076  2933     INCF _PFNf_LIN_ENDO, W, BANKED
9078  E001     BZ 0x907C
907A  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
581:                               OT.errorMsg=1;     //bad data
886E  0E01     MOVLW 0x1
8870  D03C     BRA PL306
8CA4  0E01     MOVLW 0x1
8CA6  EF75     GOTO 0x88EA
8CA8  F044     NOP
907C  0E01     MOVLW 0x1
907E  EF75     GOTO 0x88EA
9080  F044     NOP
582:                               OT.RFrame.war=0;
583:                               return 2;
584:                           }
585:                           else
586:                           {
587:                               OT.previousTransitionCount=OT.transitionCount;
8872  C121     MOVFF 0x121, 0x123
8874  F123     NOP
8CAA  C121     MOVFF 0x121, 0x123
8CAC  F123     NOP
9082  C121     MOVFF 0x121, 0x123
9084  F123     NOP
588:                           }
589:           #if _NEG_IN==0
590:                           sample=_IN_OT;
591:           #else
592:                           if(_IN_OT) sample=0;
8876  A081     BTFSS PORTB, 0, ACCESS
8878  D002     BRA 0x887E
887A  6A16     CLRF _LIN1f_CHK, ACCESS
887C  D002     BRA 0x8882
8CAE  A081     BTFSS PORTB, 0, ACCESS
8CB0  D003     BRA 0x8CB8
8CB2  0100     MOVLB 0x0
8CB4  6B75     CLRF _PFNf_prn_cs, BANKED
8CB6  D003     BRA 0x8CBE
9086  A081     BTFSS PORTB, 0, ACCESS
9088  D002     BRA 0x908E
908A  6A29     CLRF _PFNf_10V_nPCO, ACCESS
908C  D002     BRA 0x9092
593:                           else sample=1;
887E  0E01     MOVLW 0x1
8880  6E16     MOVWF _LIN1f_CHK, ACCESS
8CB8  0E01     MOVLW 0x1
8CBA  0100     MOVLB 0x0
8CBC  6F75     MOVWF _PFNf_prn_cs, BANKED
908E  0E01     MOVLW 0x1
9090  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
594:           #endif         
595:                           if(sample==1)
8882  0416     DECF _LIN1f_CHK, W, ACCESS
8884  E101     BNZ 0x8888
8886  D837     RCALL PL392
8CBE  0575     DECF _PFNf_prn_cs, W, BANKED
8CC0  E103     BNZ 0x8CC8
9092  0429     DECF _PFNf_10V_nPCO, W, ACCESS
9094  E102     BNZ 0x909A
596:                           {
597:                               OT.parityOdd=!OT.parityOdd; //cala ramka (razem z parity bit) musi miec parzysta liczbe jedynek
8CC2  0101     MOVLB 0x1
8CC4  EC7B     CALL 0x88F6, 0
8CC6  F044     NOP
9096  EC7B     CALL 0x88F6, 0
9098  F044     NOP
598:                           }
599:                           //First sample is start bit, last is stop bit
600:                           if((OT.cnt==0)||(OT.cnt==(_FRAME_LENGTH-1)))
8888  511F     MOVF _MGSDf_NO_ODB, W, BANKED
888A  E003     BZ 0x8892
888C  0E21     MOVLW 0x21
888E  191F     XORWF _MGSDf_NO_ODB, W, BANKED
8890  E107     BNZ 0x88A0
8CC8  0101     MOVLB 0x1
8CCA  511F     MOVF _MGSDf_NO_ODB, W, BANKED
8CCC  E003     BZ 0x8CD4
8CCE  0E21     MOVLW 0x21
8CD0  191F     XORWF _MGSDf_NO_ODB, W, BANKED
8CD2  E10C     BNZ 0x8CEC
909A  511F     MOVF _MGSDf_NO_ODB, W, BANKED
909C  E003     BZ 0x90A4
909E  0E21     MOVLW 0x21
90A0  191F     XORWF _MGSDf_NO_ODB, W, BANKED
90A2  E108     BNZ 0x90B4
601:                           {
602:                               if(sample!=1)
8892  0416     DECF _LIN1f_CHK, W, ACCESS
8894  E009     BZ 0x88A8
8CD4  0100     MOVLB 0x0
8CD6  0575     DECF _PFNf_prn_cs, W, BANKED
8CD8  E102     BNZ 0x8CDE
8CDA  EFAE     GOTO 0x9F5C
8CDC  F04F     NOP
90A4  0429     DECF _PFNf_10V_nPCO, W, ACCESS
90A6  E009     BZ 0x90BA
603:                               {
604:                                   //db=2;
605:                                   if(OT.nRERR<0xff) OT.nRERR++;   //zwieksz licznik bledow odczytu                        
8896  2933     INCF _PFNf_LIN_ENDO, W, BANKED
8898  E001     BZ 0x889C
889A  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
8CDE  0101     MOVLB 0x1
8CE0  2933     INCF _PFNf_LIN_ENDO, W, BANKED
8CE2  E001     BZ 0x8CE6
8CE4  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
90A8  2933     INCF _PFNf_LIN_ENDO, W, BANKED
90AA  E001     BZ 0x90AE
90AC  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
606:                                   OT.errorMsg=2;     //bad start/stop
889C  0E02     MOVLW 0x2
889E  D025     BRA PL306
8CE6  0E02     MOVLW 0x2
8CE8  EF75     GOTO 0x88EA
8CEA  F044     NOP
90AE  0E02     MOVLW 0x2
90B0  EF75     GOTO 0x88EA
90B2  F044     NOP
607:                                   OT.RFrame.war=0;
608:                                   return 2;
609:                               }
610:                           }
611:                           else
612:                           {
613:                               OT.tempFrame<<=1;
88A0  EC7A     CALL 0x90F4, 0
88A2  F048     NOP
8CEC  EC7A     CALL 0x90F4, 0
8CEE  F048     NOP
90B4  D81F     RCALL PL180
614:                               OT.tempFrame|=sample;
88A4  5016     MOVF _LIN1f_CHK, W, ACCESS
88A6  1324     IORWF _MGSDf_TransData, F, BANKED
8CF0  0100     MOVLB 0x0
8CF2  5175     MOVF _PFNf_prn_cs, W, BANKED
8CF4  0101     MOVLB 0x1
8CF6  1324     IORWF _MGSDf_TransData, F, BANKED
90B6  5029     MOVF _PFNf_10V_nPCO, W, ACCESS
90B8  1324     IORWF _MGSDf_TransData, F, BANKED
615:                           }
616:                           OT.cnt++;
88A8  2B1F     INCF _MGSDf_NO_ODB, F, BANKED
8CF8  EFAE     GOTO 0x9F5C
8CFA  F04F     NOP
90BA  2B1F     INCF _MGSDf_NO_ODB, F, BANKED
617:                           return 0;
88AA  0C00     RETLW 0x0
90BC  0C00     RETLW 0x0
618:                       }
619:                       else
620:                       {
621:                           ROTFkrk=1;
88AC  D82A     RCALL PL768
8CFC  EC81     CALL 0x8902, 0
8CFE  F044     NOP
90BE  EC81     CALL 0x8902, 0
90C0  F044     NOP
622:                       }
623:                   }
624:                   case 1:
625:                   {
626:                       DetachINT();
88AE  EC7A     CALL 0xC0F4, 0
88B0  F060     NOP
8D00  ECA2     CALL 0xC144, 0
8D02  F060     NOP
90C2  ECA9     CALL 0xC152, 0
90C4  F060     NOP
627:           #if _TEST_OT==1            
628:                       _WOUTX=0;
629:           #endif            
630:                       if(OT.parityOdd==1)     //mimo dopelnienia w parity bit stwierdzono nieparzysta liczbe jedynek?
88B2  0101     MOVLB 0x1
88B4  0520     DECF _MGSDf_RERR_REC, W, BANKED
88B6  E105     BNZ 0x88C2
8D04  0101     MOVLB 0x1
8D06  0520     DECF _MGSDf_RERR_REC, W, BANKED
8D08  E106     BNZ 0x8D16
90C6  0101     MOVLB 0x1
90C8  0520     DECF _MGSDf_RERR_REC, W, BANKED
90CA  E106     BNZ 0x90D8
631:                       {
632:                           //db=3;
633:                           if(OT.nRERR<0xff) OT.nRERR++;   //zwieksz licznik bledow odczytu                
88B8  2933     INCF _PFNf_LIN_ENDO, W, BANKED
88BA  E001     BZ 0x88BE
88BC  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
8D0A  2933     INCF _PFNf_LIN_ENDO, W, BANKED
8D0C  E001     BZ 0x8D10
8D0E  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
90CC  2933     INCF _PFNf_LIN_ENDO, W, BANKED
90CE  E001     BZ 0x90D2
90D0  2B33     INCF _PFNf_LIN_ENDO, F, BANKED
634:                           OT.errorMsg=3;
88BE  0E03     MOVLW 0x3
88C0  D014     BRA PL306
8D10  0E03     MOVLW 0x3
8D12  EF75     GOTO 0x88EA
8D14  F044     NOP
90D2  0E03     MOVLW 0x3
90D4  EF75     GOTO 0x88EA
90D6  F044     NOP
635:                           OT.RFrame.war=0;
636:                           return 2;                
637:                       }
638:                       else
639:                       {
640:                           //db=4;
641:                           if(OT.nRERR>0) OT.nRERR--;  //zmniejsz licznik bledow odczytu
88C2  5133     MOVF _PFNf_LIN_ENDO, W, BANKED
88C4  E009     BZ PL174
88C6  0733     DECF _PFNf_LIN_ENDO, F, BANKED
8D16  5133     MOVF _PFNf_LIN_ENDO, W, BANKED
8D18  E102     BNZ 0x8D1E
8D1A  EF6C     GOTO 0x88D8
8D1C  F044     NOP
8D1E  0733     DECF _PFNf_LIN_ENDO, F, BANKED
90D8  5133     MOVF _PFNf_LIN_ENDO, W, BANKED
90DA  E102     BNZ 0x90E0
90DC  EF6C     GOTO 0x88D8
90DE  F044     NOP
90E0  0733     DECF _PFNf_LIN_ENDO, F, BANKED
642:                           OT.RFrame.war=OT.tempFrame;
88C8  D007     BRA PL174
8D20  EF6C     GOTO 0x88D8
8D22  F044     NOP
90E2  EF6C     GOTO 0x88D8
90E4  F044     NOP
90E6  0100     MOVLB 0x0
90E8  51DE     MOVF ROTFkrk, W, BANKED
90EA  E0BB     BZ 0x9062
90EC  0A01     XORLW 0x1
90EE  A4D8     BTFSS STATUS, 2, ACCESS
90F0  0C01     RETLW 0x1
90F2  D7E7     BRA 0x90C2
643:                       }
644:                       return 1;
645:                   }
646:               }
647:               return 1;
648:           }
649:           /*---------------------------------------------------------------------------------*/
650:           /*---------------------------------------------------------------------------------*/
651:           long unsigned int GetOTFrame(void)
652:           {
653:               return OT.RFrame.war;
654:           }
655:           /*---------------------------------------------------------------------------------*/
656:           unsigned char GetOTErrMsg(void)
657:           {
658:               return OT.errorMsg;
659:           }
660:           /*---------------------------------------------------------------------------------*/
661:           unsigned char GetOTPeriod(void)
662:           {
663:               return OT.otPeriod;
664:           }
665:           /*---------------------------------------------------------------------------------*/
666:           unsigned char GetOTMsgType(void)
667:           {
668:               return OT.RFrame.msg_type;
669:           }
670:           /*unsigned char GetOTMsgType(void)
671:           {
672:               volatile long unsigned int tempFrame;
673:               volatile unsigned char msgType;
674:               tempFrame=OT.RFrame.war;
675:               tempFrame>>=28;
676:               msgType=tempFrame&0b00000111;
677:               return msgType;
678:           }*/
679:           /*---------------------------------------------------------------------------------*/
680:           unsigned char GetOTDataId(void)
681:           {
682:               return OT.RFrame.data_id;
683:           }
684:           /*unsigned char GetOTDataId(void)
685:           {
686:               volatile long unsigned int tempFrame;
687:               tempFrame=OT.RFrame.war;
688:               tempFrame>>=16;
689:               return (unsigned char) tempFrame;
690:           }*/
691:           /*---------------------------------------------------------------------------------*/
692:           unsigned int GetOTRDataWord(void)
693:           {
694:               return OT.RFrame.word0.war;
695:           }
696:           /*---------------------------------------------------------------------------------*/
697:           unsigned int GetOTRDataByte0(void)
698:           {
699:               return OT.RFrame.byte0.war;
700:           }
701:           /*---------------------------------------------------------------------------------*/
702:           unsigned int GetOTRDataByte1(void)
703:           {
704:               return OT.RFrame.byte1.war;
705:           }
706:           /*---------------------------------------------------------------------------------*/
707:           unsigned char GetOTRParity(void)
708:           {
709:           
710:               return (OT.RFrame.parity)?1:0;
711:           }
712:           /*unsigned char GetOTParity(void)
713:           {
714:               volatile long unsigned int tempFrame;
715:               tempFrame=OT.RFrame.war;
716:               tempFrame>>=31;
717:               return (unsigned char)tempFrame;
718:           }*/
719:           
720:           /*---------------------------------------------------------------------------------*/
721:           unsigned int GetOTIsMaster(void)
722:           {
723:               if(GetOTMsgType()<=3) return 1;
724:               else return 0;
725:           }
726:           volatile unsigned char T0krok=0;
727:           /*---------------------------------------------------------------------------------*/
728:           /*---------------------------------------------------------------------------------*/
729:           //Oczekiwanie na warunki konieczne przed wysylka ramki odpowiedzi
730:           volatile static unsigned char MOTRkrk=0;
731:           
732:           #define _RELOAD1    0xffff-(2000/_TICK_TO_USEC)  //przerwanie co 2000us TIMER0
733:           void StartWaitOTResp(void)
B69A  D813     RCALL PL390
B812  EC61     CALL 0xB6C2, 0
B814  F05B     NOP
734:           {
735:               MOTRkrk=0; 
B8E8  EC61     CALL 0xB6C2, 0
736:               OT.ToACK=1;                                     //znacznik ze odebrano paczke danych   
737:               OT.ACKType=0;                                   //wynik analizy paczki danych (decyzja o odpowiedzi lu rezygnacji)
738:               StartOTTimeout(_WAITTT_TIMO,4);                 //rezygnacja z odpowiedzi po _WAITTT_TIMO [msek] oczekiwania
B69C  6E16     MOVWF _LIN1f_CHK, ACCESS
B69E  0E90     MOVLW 0x90
B6A0  6E15     MOVWF _LIN1f_Busy, ACCESS
B6A2  0E04     MOVLW 0x4
B6A4  6E17     MOVWF _LIN1f_ERRR, ACCESS
B6A6  ECDA     CALL 0xBFB4, 0
B6A8  F05F     NOP
B816  0100     MOVLB 0x0
B818  6F75     MOVWF _PFNf_prn_cs, BANKED
B81A  0E90     MOVLW 0x90
B81C  6F74     MOVWF _PFNf_prODP, BANKED
B81E  0E04     MOVLW 0x4
B820  6F76     MOVWF _PFNf_prn_in, BANKED
B822  ECB9     CALL 0xBF72, 0
B824  F05F     NOP
B8EC  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
B8EE  0E90     MOVLW 0x90
B8F0  6E28     MOVWF _PFNf_10V_RT, ACCESS
B8F2  0E04     MOVLW 0x4
B8F4  6E2A     MOVWF _PFNf_EnAleg, ACCESS
B8F6  ECC4     CALL 0xBF88, 0
B8F8  F05F     NOP
739:               DetachINT();        
B6AA  EC7A     CALL 0xC0F4, 0
B6AC  F060     NOP
B826  ECA2     CALL 0xC144, 0
B828  F060     NOP
B8FA  ECA9     CALL 0xC152, 0
B8FC  F060     NOP
740:               ReloadTMR0(_RELOAD1);                           //przerwanie TIMER0 po 2000us    
B6AE  ECB8     CALL 0xB370, 0
B6B0  F059     NOP
B6B2  EC91     CALL 0xB122, 0
B6B4  F058     NOP
B82A  EC02     CALL 0xB204, 0
B82C  F059     NOP
B82E  EC11     CALL 0xB022, 0
B830  F058     NOP
B8FE  EC9B     CALL 0xB336, 0
B900  F059     NOP
B902  EC51     CALL 0xB0A2, 0
B904  F058     NOP
741:               WrtTMR0(_RELOAD1);                              //wartosc przeladowania dla kolejnego przerwania TIMER0     
B6B6  ECB3     CALL 0xB366, 0
B6B8  F059     NOP
B6BA  ECFA     CALL 0xC1F4, 0
B6BC  F060     NOP
B832  EC08     CALL 0xB210, 0
B834  F059     NOP
B836  ECD7     CALL 0xC1AE, 0
B838  F060     NOP
B906  EC96     CALL 0xB32C, 0
B908  F059     NOP
B90A  ECEB     CALL 0xC1D6, 0
B90C  F060     NOP
742:               TMR0IE=1;                 
B6BE  8AF2     BSF INTCON, 5, ACCESS
B83A  8AF2     BSF INTCON, 5, ACCESS
B90E  8AF2     BSF INTCON, 5, ACCESS
743:           }
B6C0  0012     RETURN 0
B83C  0012     RETURN 0
B910  0012     RETURN 0
744:           unsigned char WaitOTResp(void)
745:           {   
746:           //    volatile static unsigned long int timeLow;
747:               volatile unsigned long int waitTime;
748:                
749:               //wartosc srednia odcinkow czasowych T2
750:               switch(MOTRkrk)
A8AE  D022     BRA 0xA8F4
A8F4  0101     MOVLB 0x1
A9B2  D021     BRA 0xA9F6
A9F6  0101     MOVLB 0x1
A9F8  51C7     MOVF 0xC7, W, BANKED
A9FA  E0DC     BZ 0xA9B4
A9FC  0A01     XORLW 0x1
A9FE  E0E0     BZ 0xA9C0
AA00  0A03     XORLW 0x3
AA02  A4D8     BTFSS STATUS, 2, ACCESS
AA04  0C00     RETLW 0x0
AA06  D7F5     BRA 0xA9F2
AA08  D021     BRA 0xAA4C
AA4C  0101     MOVLB 0x1
751:               {
752:                   case 0:
753:                   {            
754:                       OT.timeLow=Millis();
A8B0  EC68     CALL 0xC0D0, 0
A8B2  F060     NOP
A8B4  EC42     CALL 0x9884, 0
A8B6  F04C     NOP
A9B4  EC20     CALL 0xC040, 0
A9B6  F060     NOP
A9B8  EC77     CALL 0x8AEE, 0
A9BA  F045     NOP
AA0A  EC44     CALL 0xC088, 0
AA0C  F060     NOP
AA0E  ECC0     CALL 0x9180, 0
AA10  F048     NOP
755:                       MOTRkrk=1;
A8B8  0E01     MOVLW 0x1
A8BA  0101     MOVLB 0x1
A8BC  6FC7     MOVWF 0xC7, BANKED
A9BC  0101     MOVLB 0x1
A9BE  6FC7     MOVWF 0xC7, BANKED
AA12  0101     MOVLB 0x1
AA14  6FC7     MOVWF 0xC7, BANKED
756:                   }
757:                   case 1:
758:                   {
759:                       //if(_ROUTX) _WOUTX=0;
760:                       //else _WOUTX=1;            
761:                       waitTime=Millis()-OT.timeLow;
A8BE  EC68     CALL 0xC0D0, 0
A8C0  F060     NOP
A8C2  0101     MOVLB 0x1
A8C4  5100     MOVF 0x0, W, BANKED
A8C6  5C15     SUBWF _LIN1f_Busy, W, ACCESS
A8C8  6E19     MOVWF _LIN1f_FIN, ACCESS
A8CA  5101     MOVF DtCOf_err_CO, W, BANKED
A8CC  5816     SUBWFB _LIN1f_CHK, W, ACCESS
A8CE  6E1A     MOVWF _LIN1f_FResp, ACCESS
A8D0  5102     MOVF LIN1f_Busy, W, BANKED
A8D2  5817     SUBWFB _LIN1f_ERRR, W, ACCESS
A8D4  6E1B     MOVWF _LIN1f_FTrans, ACCESS
A8D6  5103     MOVF LIN1f_NDTA, W, BANKED
A8D8  5818     SUBWFB _LIN1f_FAdta, W, ACCESS
A8DA  6E1C     MOVWF _LIN1f_NDTA, ACCESS
A9C0  EC20     CALL 0xC040, 0
A9C2  F060     NOP
A9C4  EC80     CALL 0x8B00, 0
A9C6  F045     NOP
A9C8  6F78     MOVWF _PFNf_prn_pp, BANKED
A9CA  EC8F     CALL 0x8B1E, 0
A9CC  F045     NOP
A9CE  6F79     MOVWF _PFNf_prn_res, BANKED
A9D0  EC8A     CALL 0x8B14, 0
A9D2  F045     NOP
A9D4  6F7A     MOVWF _PFNf_res, BANKED
A9D6  EC85     CALL 0x8B0A, 0
A9D8  F045     NOP
A9DA  6F7B     MOVWF _PFNf_rozruch, BANKED
AA16  EC44     CALL 0xC088, 0
AA18  F060     NOP
AA1A  0101     MOVLB 0x1
AA1C  5100     MOVF 0x0, W, BANKED
AA1E  5C28     SUBWF _PFNf_10V_RT, W, ACCESS
AA20  6E2C     MOVWF _PFNf_EnLIN, ACCESS
AA22  5101     MOVF DtCOf_err_CO, W, BANKED
AA24  5829     SUBWFB _PFNf_10V_nPCO, W, ACCESS
AA26  6E2D     MOVWF _PFNf_FLIN, ACCESS
AA28  5102     MOVF LIN1f_Busy, W, BANKED
AA2A  582A     SUBWFB _PFNf_EnAleg, W, ACCESS
AA2C  6E2E     MOVWF _PFNf_FOT, ACCESS
AA2E  5103     MOVF LIN1f_NDTA, W, BANKED
AA30  582B     SUBWFB _PFNf_EnF10V, W, ACCESS
AA32  6E2F     MOVWF _PFNf_KnfDisErr, ACCESS
762:                       if(waitTime<_MIN_WAIT_FOR_SLAVE) return 0;  //uplynal minimalny dozwolony czas do transmisji? 
A8DC  501C     MOVF _LIN1f_NDTA, W, ACCESS
A8DE  101B     IORWF _LIN1f_FTrans, W, ACCESS
A8E0  101A     IORWF _LIN1f_FResp, W, ACCESS
A8E2  E104     BNZ 0xA8EC
A8E4  0E19     MOVLW 0x19
A8E6  5C19     SUBWF _LIN1f_FIN, W, ACCESS
A8E8  E201     BC 0xA8EC
A8EA  0C00     RETLW 0x0
A9DC  517B     MOVF _PFNf_rozruch, W, BANKED
A9DE  117A     IORWF _PFNf_res, W, BANKED
A9E0  1179     IORWF _PFNf_prn_res, W, BANKED
A9E2  E104     BNZ 0xA9EC
A9E4  0E19     MOVLW 0x19
A9E6  5D78     SUBWF _PFNf_prn_pp, W, BANKED
A9E8  E201     BC 0xA9EC
A9EA  0C00     RETLW 0x0
AA34  502F     MOVF _PFNf_KnfDisErr, W, ACCESS
AA36  102E     IORWF _PFNf_FOT, W, ACCESS
AA38  102D     IORWF _PFNf_FLIN, W, ACCESS
AA3A  E104     BNZ 0xAA44
AA3C  0E19     MOVLW 0x19
AA3E  5C2C     SUBWF _PFNf_EnLIN, W, ACCESS
AA40  E201     BC 0xAA44
AA42  0C00     RETLW 0x0
763:                       MOTRkrk=2;
A8EC  0E02     MOVLW 0x2
A8EE  6FC7     MOVWF 0xC7, BANKED
A9EC  0E02     MOVLW 0x2
A9EE  0101     MOVLB 0x1
A9F0  6FC7     MOVWF 0xC7, BANKED
AA44  0E02     MOVLW 0x2
AA46  6FC7     MOVWF 0xC7, BANKED
764:                   }
765:                   case 2:
766:                   {
767:                       //_WOUTX=1;            
768:                       return OT.ACKType;                          //wartosc zwracana po przygotowaniu odpowiedzi
A8F0  5135     MOVF _PFNf_LIN_EPBCW, W, BANKED
A8F2  0012     RETURN 0
A9F2  5135     MOVF _PFNf_LIN_EPBCW, W, BANKED
A9F4  0012     RETURN 0
AA48  5135     MOVF _PFNf_LIN_EPBCW, W, BANKED
AA4A  0012     RETURN 0
AA4C  0101     MOVLB 0x1
AA4E  51C7     MOVF 0xC7, W, BANKED
AA50  E0DC     BZ 0xAA0A
AA52  0A01     XORLW 0x1
AA54  E0E0     BZ 0xAA16
AA56  0A03     XORLW 0x3
AA58  A4D8     BTFSS STATUS, 2, ACCESS
AA5A  0C00     RETLW 0x0
AA5C  D7F5     BRA 0xAA48
769:                   }     
770:               }
771:               return 0;
772:           }
773:           /*---------------------------------------------------------------------------------*/
774:           /*---------------------------------------------------------------------------------*/
775:           //Ustawienie bitu parzystosci w ramce odpowiedzi
776:           void SetTFrameParityOdd(void)
777:           {
778:               unsigned char i;
779:               long unsigned int mask;
780:               mask=0x40000000;
99A8  0100     MOVLB 0x0
99AA  6B78     CLRF _PFNf_prn_pp, BANKED
99AC  6B79     CLRF _PFNf_prn_res, BANKED
99AE  6B7A     CLRF _PFNf_res, BANKED
99B0  0E40     MOVLW 0x40
99B2  6F7B     MOVWF _PFNf_rozruch, BANKED
A688  6A2C     CLRF _PFNf_EnLIN, ACCESS
A6E8  6A19     CLRF _LIN1f_FIN, ACCESS
781:               
782:               OT.TFrame.parity=0;
99B4  0101     MOVLB 0x1
99B6  9F3D     BCF _PFNf_LINresSR, 7, BANKED
A692  9F3D     BCF _PFNf_LINresSR, 7, BANKED
A6F2  9F3D     BCF _PFNf_LINresSR, 7, BANKED
783:               for(i=0;i<31;i++)
99B8  0100     MOVLB 0x0
99BA  6B7C     CLRF _PFNf_setKey, BANKED
9A20  2B7C     INCF _PFNf_setKey, F, BANKED
A694  6A30     CLRF _PFNf_LIN_CK, ACCESS
A6DE  2A30     INCF _PFNf_LIN_CK, F, ACCESS
A6E0  0E1E     MOVLW 0x1E
A6E2  6430     CPFSGT _PFNf_LIN_CK, ACCESS
A6E4  D7D8     BRA 0xA696
A6E6  0C1E     RETLW 0x1E
A6F4  6A1D     CLRF _LIN1f_SCS, ACCESS
A73E  2A1D     INCF _LIN1f_SCS, F, ACCESS
784:               {
785:                   if(OT.TFrame.war&mask) OT.TFrame.parity=!OT.TFrame.parity;
99BC  5178     MOVF _PFNf_prn_pp, W, BANKED
99BE  0101     MOVLB 0x1
99C0  153A     ANDWF _PFNf_LIN_STR, W, BANKED
99C2  0100     MOVLB 0x0
99C4  6F74     MOVWF _PFNf_prODP, BANKED
99C6  5179     MOVF _PFNf_prn_res, W, BANKED
99C8  0101     MOVLB 0x1
99CA  153B     ANDWF _PFNf_LINres, W, BANKED
99CC  0100     MOVLB 0x0
99CE  6F75     MOVWF _PFNf_prn_cs, BANKED
99D0  517A     MOVF _PFNf_res, W, BANKED
99D2  0101     MOVLB 0x1
99D4  153C     ANDWF MGSD, W, BANKED
99D6  0100     MOVLB 0x0
99D8  6F76     MOVWF _PFNf_prn_in, BANKED
99DA  517B     MOVF _PFNf_rozruch, W, BANKED
99DC  0101     MOVLB 0x1
99DE  153D     ANDWF _PFNf_LINresSR, W, BANKED
99E0  0100     MOVLB 0x0
99E2  6F77     MOVWF _PFNf_prn_pg, BANKED
99E4  5174     MOVF _PFNf_prODP, W, BANKED
99E6  1175     IORWF _PFNf_prn_cs, W, BANKED
99E8  1176     IORWF _PFNf_prn_in, W, BANKED
99EA  1177     IORWF _PFNf_prn_pg, W, BANKED
99EC  E013     BZ 0x9A14
99EE  0101     MOVLB 0x1
99F0  BF3D     BTFSC _PFNf_LINresSR, 7, BANKED
99F2  D004     BRA 0x99FC
99F4  0100     MOVLB 0x0
99F6  6B74     CLRF _PFNf_prODP, BANKED
99F8  2B74     INCF _PFNf_prODP, F, BANKED
99FA  D002     BRA 0x9A00
99FC  0100     MOVLB 0x0
99FE  6B74     CLRF _PFNf_prODP, BANKED
9A00  3374     RRCF _PFNf_prODP, F, BANKED
9A02  3374     RRCF _PFNf_prODP, F, BANKED
9A04  0101     MOVLB 0x1
9A06  513D     MOVF _PFNf_LINresSR, W, BANKED
9A08  0100     MOVLB 0x0
9A0A  1974     XORWF _PFNf_prODP, W, BANKED
9A0C  0B7F     ANDLW 0x7F
9A0E  1974     XORWF _PFNf_prODP, W, BANKED
9A10  0101     MOVLB 0x1
9A12  6F3D     MOVWF _PFNf_LINresSR, BANKED
A696  502C     MOVF _PFNf_EnLIN, W, ACCESS
A698  153A     ANDWF _PFNf_LIN_STR, W, BANKED
A69A  6E28     MOVWF _PFNf_10V_RT, ACCESS
A69C  502D     MOVF _PFNf_FLIN, W, ACCESS
A69E  153B     ANDWF _PFNf_LINres, W, BANKED
A6A0  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
A6A2  502E     MOVF _PFNf_FOT, W, ACCESS
A6A4  153C     ANDWF MGSD, W, BANKED
A6A6  6E2A     MOVWF _PFNf_EnAleg, ACCESS
A6A8  502F     MOVF _PFNf_KnfDisErr, W, ACCESS
A6AA  153D     ANDWF _PFNf_LINresSR, W, BANKED
A6AC  6E2B     MOVWF _PFNf_EnF10V, ACCESS
A6AE  5028     MOVF _PFNf_10V_RT, W, ACCESS
A6B0  1029     IORWF _PFNf_10V_nPCO, W, ACCESS
A6B2  102A     IORWF _PFNf_EnAleg, W, ACCESS
A6B4  102B     IORWF _PFNf_EnF10V, W, ACCESS
A6B6  E00E     BZ 0xA6D4
A6B8  BF3D     BTFSC _PFNf_LINresSR, 7, BANKED
A6BA  D003     BRA 0xA6C2
A6BC  6A28     CLRF _PFNf_10V_RT, ACCESS
A6BE  2A28     INCF _PFNf_10V_RT, F, ACCESS
A6C0  D001     BRA 0xA6C4
A6C2  6A28     CLRF _PFNf_10V_RT, ACCESS
A6C4  3228     RRCF _PFNf_10V_RT, F, ACCESS
A6C6  3228     RRCF _PFNf_10V_RT, F, ACCESS
A6C8  0101     MOVLB 0x1
A6CA  513D     MOVF _PFNf_LINresSR, W, BANKED
A6CC  1828     XORWF _PFNf_10V_RT, W, ACCESS
A6CE  0B7F     ANDLW 0x7F
A6D0  1828     XORWF _PFNf_10V_RT, W, ACCESS
A6D2  6F3D     MOVWF _PFNf_LINresSR, BANKED
A6F6  5019     MOVF _LIN1f_FIN, W, ACCESS
A6F8  153A     ANDWF _PFNf_LIN_STR, W, BANKED
A6FA  6E15     MOVWF _LIN1f_Busy, ACCESS
A6FC  501A     MOVF _LIN1f_FResp, W, ACCESS
A6FE  153B     ANDWF _PFNf_LINres, W, BANKED
A700  6E16     MOVWF _LIN1f_CHK, ACCESS
A702  501B     MOVF _LIN1f_FTrans, W, ACCESS
A704  153C     ANDWF MGSD, W, BANKED
A706  6E17     MOVWF _LIN1f_ERRR, ACCESS
A708  501C     MOVF _LIN1f_NDTA, W, ACCESS
A70A  153D     ANDWF _PFNf_LINresSR, W, BANKED
A70C  6E18     MOVWF _LIN1f_FAdta, ACCESS
A70E  5015     MOVF _LIN1f_Busy, W, ACCESS
A710  1016     IORWF _LIN1f_CHK, W, ACCESS
A712  1017     IORWF _LIN1f_ERRR, W, ACCESS
A714  1018     IORWF _LIN1f_FAdta, W, ACCESS
A716  E00E     BZ 0xA734
A718  BF3D     BTFSC _PFNf_LINresSR, 7, BANKED
A71A  D003     BRA 0xA722
A71C  6A15     CLRF _LIN1f_Busy, ACCESS
A71E  2A15     INCF _LIN1f_Busy, F, ACCESS
A720  D001     BRA 0xA724
A722  6A15     CLRF _LIN1f_Busy, ACCESS
A724  3215     RRCF _LIN1f_Busy, F, ACCESS
A726  3215     RRCF _LIN1f_Busy, F, ACCESS
A728  0101     MOVLB 0x1
A72A  513D     MOVF _PFNf_LINresSR, W, BANKED
A72C  1815     XORWF _LIN1f_Busy, W, ACCESS
A72E  0B7F     ANDLW 0x7F
A730  1815     XORWF _LIN1f_Busy, W, ACCESS
A732  6F3D     MOVWF _PFNf_LINresSR, BANKED
786:                   mask>>=1;        
9A14  0100     MOVLB 0x0
9A16  90D8     BCF STATUS, 0, ACCESS
9A18  337B     RRCF _PFNf_rozruch, F, BANKED
9A1A  337A     RRCF _PFNf_res, F, BANKED
9A1C  3379     RRCF _PFNf_prn_res, F, BANKED
9A1E  3378     RRCF _PFNf_prn_pp, F, BANKED
A6D4  90D8     BCF STATUS, 0, ACCESS
A6D6  322F     RRCF _PFNf_KnfDisErr, F, ACCESS
A6D8  322E     RRCF _PFNf_FOT, F, ACCESS
A6DA  322D     RRCF _PFNf_FLIN, F, ACCESS
A6DC  322C     RRCF _PFNf_EnLIN, F, ACCESS
A734  90D8     BCF STATUS, 0, ACCESS
A736  321C     RRCF _LIN1f_NDTA, F, ACCESS
A738  321B     RRCF _LIN1f_FTrans, F, ACCESS
A73A  321A     RRCF _LIN1f_FResp, F, ACCESS
A73C  3219     RRCF _LIN1f_FIN, F, ACCESS
A73E  2A1D     INCF _LIN1f_SCS, F, ACCESS
A740  0E1E     MOVLW 0x1E
A742  641D     CPFSGT _LIN1f_SCS, ACCESS
A744  D7D8     BRA 0xA6F6
A746  0C1E     RETLW 0x1E
787:               }
788:           }
789:           /*---------------------------------------------------------------------------------*/
790:           /*---------------------------------------------------------------------------------*/
791:           //Wysylanie ramki odpowiedzi
792:           volatile static unsigned char TOTFkrk=0;
793:           
794:           void StartTransmitOTFrame(void)
B1A0  D80F     RCALL PL146
795:           {       
796:               OT.cnt=0;
B9DC  0101     MOVLB 0x1
B9DE  ECE0     CALL 0xB1C0, 0
B9E0  F058     NOP
BB36  ECE0     CALL 0xB1C0, 0
797:               OT.cnt2=0;   
798:               OT.tempFrame=OT.TFrame.war;    
799:               DetachINT();
B1A2  EC7A     CALL 0xC0F4, 0
B1A4  F060     NOP
B9E2  ECA2     CALL 0xC144, 0
B9E4  F060     NOP
BB3A  ECA9     CALL 0xC152, 0
BB3C  F060     NOP
800:               //aktywacja timer0
801:               ReloadTMR0(_TR_PRELOAD);        //przerwanie TIMER0 co 0.5msek   (0xFF84)  
B1A6  6816     SETF _LIN1f_CHK, ACCESS
B1A8  0E84     MOVLW 0x84
B1AA  6E15     MOVWF _LIN1f_Busy, ACCESS
B1AC  EC91     CALL 0xB122, 0
B1AE  F058     NOP
B9E6  0100     MOVLB 0x0
B9E8  6975     SETF _PFNf_prn_cs, BANKED
B9EA  0E84     MOVLW 0x84
B9EC  6F74     MOVWF _PFNf_prODP, BANKED
B9EE  EC11     CALL 0xB022, 0
B9F0  F058     NOP
BB3E  6829     SETF _PFNf_10V_nPCO, ACCESS
BB40  0E84     MOVLW 0x84
BB42  6E28     MOVWF _PFNf_10V_RT, ACCESS
BB44  EC51     CALL 0xB0A2, 0
BB46  F058     NOP
802:               WrtTMR0(_TR_PRELOAD);           //wartosc przeladowania dla kolejnego przerwania TIMER0
B1B0  6816     SETF _LIN1f_CHK, ACCESS
B1B2  0E84     MOVLW 0x84
B1B4  6E15     MOVWF _LIN1f_Busy, ACCESS
B1B6  ECFA     CALL 0xC1F4, 0
B1B8  F060     NOP
B9F2  6975     SETF _PFNf_prn_cs, BANKED
B9F4  0E84     MOVLW 0x84
B9F6  6F74     MOVWF _PFNf_prODP, BANKED
B9F8  ECD7     CALL 0xC1AE, 0
B9FA  F060     NOP
BB48  6829     SETF _PFNf_10V_nPCO, ACCESS
BB4A  0E84     MOVLW 0x84
BB4C  6E28     MOVWF _PFNf_10V_RT, ACCESS
BB4E  ECEB     CALL 0xC1D6, 0
BB50  F060     NOP
803:               StopOTTimeout();
B1BA  EC71     CALL 0xC0E2, 0
B9FC  EC47     CALL 0xC28E, 0
BB52  EC4B     CALL 0xC296, 0
BB54  F061     NOP
804:               TMR0IE=1;                       //aktywacja przerwania od TIMER0
BB56  EFEB     GOTO 0xB1D6
BB58  F058     NOP
805:               TMR0ON=1;                       //uruchomienie TIMER0 
806:               TOTFkrk=0;     
807:           }
808:           unsigned char TransmitOTFrame(void)
809:           {
810:               volatile static unsigned char sample=0;
811:               //_WOUTX=0;
812:               switch(TOTFkrk)
9EEC  D02D     BRA 0x9F48
9F48  0101     MOVLB 0x1
A134  D032     BRA 0xA19A
A19A  0101     MOVLB 0x1
A282  D030     BRA 0xA2E4
A2E4  0101     MOVLB 0x1
813:               {   
814:                   case 0:                                       //przerwanie timer0 co _otPeriod
815:                   {           
816:                       if(OT.cnt2)
9EEE  510E     MOVF PFNf_popFN, W, BANKED
9EF0  E00F     BZ 0x9F10
A136  510E     MOVF PFNf_popFN, W, BANKED
A138  E011     BZ 0xA15C
A284  510E     MOVF PFNf_popFN, W, BANKED
A286  E00F     BZ 0xA2A6
817:                       {
818:                           OT.cnt2=0;
9EF2  6B0E     CLRF PFNf_popFN, BANKED
A13A  6B0E     CLRF PFNf_popFN, BANKED
A288  6B0E     CLRF PFNf_popFN, BANKED
819:                           _OUT_OT=!sample;
9EF4  5048     MOVF sample, W, ACCESS
9EF6  E103     BNZ 0x9EFE
9EF8  6A15     CLRF _LIN1f_Busy, ACCESS
9EFA  2A15     INCF _LIN1f_Busy, F, ACCESS
9EFC  D001     BRA 0x9F00
9EFE  6A15     CLRF _LIN1f_Busy, ACCESS
9F00  4615     RLNCF _LIN1f_Busy, F, ACCESS
9F02  4615     RLNCF _LIN1f_Busy, F, ACCESS
9F04  508A     MOVF LATB, W, ACCESS
9F06  1815     XORWF _LIN1f_Busy, W, ACCESS
9F08  0BFB     ANDLW 0xFB
9F0A  1815     XORWF _LIN1f_Busy, W, ACCESS
9F0C  6E8A     MOVWF LATB, ACCESS
A13C  5048     MOVF sample, W, ACCESS
A13E  E104     BNZ 0xA148
A140  0100     MOVLB 0x0
A142  6B74     CLRF _PFNf_prODP, BANKED
A144  2B74     INCF _PFNf_prODP, F, BANKED
A146  D002     BRA 0xA14C
A148  0100     MOVLB 0x0
A14A  6B74     CLRF _PFNf_prODP, BANKED
A14C  4774     RLNCF _PFNf_prODP, F, BANKED
A14E  4774     RLNCF _PFNf_prODP, F, BANKED
A150  508A     MOVF LATB, W, ACCESS
A152  1974     XORWF _PFNf_prODP, W, BANKED
A154  0BFB     ANDLW 0xFB
A156  1974     XORWF _PFNf_prODP, W, BANKED
A158  6E8A     MOVWF LATB, ACCESS
A28A  5048     MOVF sample, W, ACCESS
A28C  E103     BNZ 0xA294
A28E  6A28     CLRF _PFNf_10V_RT, ACCESS
A290  2A28     INCF _PFNf_10V_RT, F, ACCESS
A292  D001     BRA 0xA296
A294  6A28     CLRF _PFNf_10V_RT, ACCESS
A296  4628     RLNCF _PFNf_10V_RT, F, ACCESS
A298  4628     RLNCF _PFNf_10V_RT, F, ACCESS
A29A  508A     MOVF LATB, W, ACCESS
A29C  1828     XORWF _PFNf_10V_RT, W, ACCESS
A29E  0BFB     ANDLW 0xFB
A2A0  1828     XORWF _PFNf_10V_RT, W, ACCESS
A2A2  6E8A     MOVWF LATB, ACCESS
820:                           //_WOUTX=!sample;
821:                           return 0;
9F0E  0C00     RETLW 0x0
A15A  0C00     RETLW 0x0
A2A4  0C00     RETLW 0x0
822:                       }
823:                       else
824:                       if(OT.cnt<_FRAME_LENGTH)
9F10  0E22     MOVLW 0x22
9F12  611F     CPFSLT _MGSDf_NO_ODB, BANKED
9F14  D01E     BRA PL384
A15C  0E22     MOVLW 0x22
A15E  611F     CPFSLT _MGSDf_NO_ODB, BANKED
A160  EFA9     GOTO 0x9F52
A162  F04F     NOP
A2A6  0E22     MOVLW 0x22
A2A8  611F     CPFSLT _MGSDf_NO_ODB, BANKED
A2AA  EFA9     GOTO 0x9F52
A2AC  F04F     NOP
825:                       {
826:                           OT.cnt2=1;       
9F16  0E01     MOVLW 0x1
9F18  6F0E     MOVWF PFNf_popFN, BANKED
A164  0E01     MOVLW 0x1
A166  6F0E     MOVWF PFNf_popFN, BANKED
A2AE  0E01     MOVLW 0x1
A2B0  6F0E     MOVWF PFNf_popFN, BANKED
827:                           //First sample is start bit, last is stop bit
828:                           if((OT.cnt==0)||(OT.cnt==(_FRAME_LENGTH-1)))
9F1A  511F     MOVF _MGSDf_NO_ODB, W, BANKED
9F1C  E003     BZ 0x9F24
9F1E  0E21     MOVLW 0x21
9F20  191F     XORWF _MGSDf_NO_ODB, W, BANKED
9F22  E103     BNZ 0x9F2A
A168  511F     MOVF _MGSDf_NO_ODB, W, BANKED
A16A  E003     BZ 0xA172
A16C  0E21     MOVLW 0x21
A16E  191F     XORWF _MGSDf_NO_ODB, W, BANKED
A170  E103     BNZ 0xA178
A2B2  511F     MOVF _MGSDf_NO_ODB, W, BANKED
A2B4  E003     BZ 0xA2BC
A2B6  0E21     MOVLW 0x21
A2B8  191F     XORWF _MGSDf_NO_ODB, W, BANKED
A2BA  E103     BNZ 0xA2C2
829:                           {
830:                               sample=1;   //bit stop/start
9F24  0E01     MOVLW 0x1
9F26  6E48     MOVWF sample, ACCESS
A172  0E01     MOVLW 0x1
A174  6E48     MOVWF sample, ACCESS
A2BC  0E01     MOVLW 0x1
A2BE  6E48     MOVWF sample, ACCESS
831:                           }
9F28  D008     BRA 0x9F3A
A176  D008     BRA 0xA188
A2C0  D008     BRA 0xA2D2
832:                           else
833:                           {
834:                               if(OT.tempFrame&0x80000000) sample=1;
9F2A  AF27     BTFSS _MGSDf_TransOK, 7, BANKED
9F2C  D003     BRA 0x9F34
9F2E  0E01     MOVLW 0x1
9F30  6E48     MOVWF sample, ACCESS
9F32  D001     BRA 0x9F36
A178  AF27     BTFSS _MGSDf_TransOK, 7, BANKED
A17A  D003     BRA 0xA182
A17C  0E01     MOVLW 0x1
A17E  6E48     MOVWF sample, ACCESS
A180  D001     BRA 0xA184
A2C2  AF27     BTFSS _MGSDf_TransOK, 7, BANKED
A2C4  D003     BRA 0xA2CC
A2C6  0E01     MOVLW 0x1
A2C8  6E48     MOVWF sample, ACCESS
A2CA  D001     BRA 0xA2CE
835:                               else sample=0;
9F34  6A48     CLRF sample, ACCESS
A182  6A48     CLRF sample, ACCESS
A2CC  6A48     CLRF sample, ACCESS
836:                               OT.tempFrame<<=1;
9F36  EC7A     CALL 0x90F4, 0
9F38  F048     NOP
A184  EC7A     CALL 0x90F4, 0
A186  F048     NOP
A2CE  EC7A     CALL 0x90F4, 0
A2D0  F048     NOP
837:                           }
838:                           _OUT_OT=sample;                
9F3A  B048     BTFSC sample, 0, ACCESS
9F3C  D002     BRA 0x9F42
9F3E  948A     BCF LATB, 2, ACCESS
9F40  D001     BRA 0x9F44
9F42  848A     BSF LATB, 2, ACCESS
9F44  D00B     BRA PL714
A188  B048     BTFSC sample, 0, ACCESS
A18A  D002     BRA 0xA190
A18C  948A     BCF LATB, 2, ACCESS
A18E  D001     BRA 0xA192
A190  848A     BSF LATB, 2, ACCESS
A192  EFAE     GOTO 0x9F5C
A194  F04F     NOP
A2D2  B048     BTFSC sample, 0, ACCESS
A2D4  D002     BRA 0xA2DA
A2D6  948A     BCF LATB, 2, ACCESS
A2D8  D001     BRA 0xA2DC
A2DA  848A     BSF LATB, 2, ACCESS
839:                           //_WOUTX=sample;                
840:                           OT.cnt++;
A2DC  EFAE     GOTO 0x9F5C
A2DE  F04F     NOP
841:                           return 0;
842:                       }
843:                       else
9F46  D005     BRA PL384
A196  EFA9     GOTO 0x9F52
A198  F04F     NOP
A19A  0101     MOVLB 0x1
A19C  51CA     MOVF 0xCA, W, BANKED
A19E  E0CB     BZ 0xA136
A1A0  0A01     XORLW 0x1
A1A2  0C01     RETLW 0x1
844:                       {
845:                           _OUT_OT=0;
A2E0  EFA9     GOTO 0x9F52
A2E2  F04F     NOP
A2E4  0101     MOVLB 0x1
A2E6  51CA     MOVF 0xCA, W, BANKED
A2E8  E0CD     BZ 0xA284
A2EA  0A01     XORLW 0x1
A2EC  0C01     RETLW 0x1
846:                           //_WOUTX=1;
847:                           OT.cnt2=0;
848:                           TOTFkrk=1;
849:                       }
850:                   }
851:                   case 1:
852:                   {
853:                       return 1;
854:                   }
855:               }
856:               return 1;
857:           }
858:           /*---------------------------------------------------------------------------------*/
859:           /*---------------------------------------------------------------------------------*/
860:           /*---------------------------------------------------------------------------------*/
861:           /*---------------------------------------------------------------------------------*/
862:           /*---------------------------------------------------------------------------------*/
863:           //Procedura odbioru i wysylki ramki OT
864:           void SetOTDeamon(const unsigned char tk)
C16C  0100     MOVLB 0x0
C16E  6F7E     MOVWF _PFNf_set_eco, BANKED
C1CC  6E32     MOVWF _PFNf_LIN_DPGD, ACCESS
C1EA  6E1F     MOVWF _MGSDf_NO_ODB, ACCESS
865:           {
866:               T0krok=tk;   
C170  C07E     MOVFF _PFNf_set_eco, T0krok
C172  F1C9     NOP
C1CE  C032     MOVFF _PFNf_LIN_DPGD, T0krok
C1D0  F1C9     NOP
C1EC  C01F     MOVFF _MGSDf_NO_ODB, T0krok
C1EE  F1C9     NOP
867:               IntOTDeamon();    //wykonaj wskazany krok;
C174  EFCB     GOTO 0x8796
C1D2  EF94     GOTO 0x8B28
C1D4  F045     NOP
C1F0  EF1B     GOTO 0x8236
C1F2  F041     NOP
868:           }
869:           void IntOTDeamon(void)
870:           {
871:               volatile unsigned char stn=0; 
8236  6A1E     CLRF _MGSDf_ERRt, ACCESS
8796  0100     MOVLB 0x0
8798  6B7D     CLRF _PFNf_set_aleg, BANKED
8B28  6A31     CLRF _PFNf_LIN_CW, ACCESS
872:               
873:               //if(T0krok!=4) OT.data2=0;
874:               
875:               switch(T0krok)
8238  D03F     BRA 0x82B8
82B8  0101     MOVLB 0x1
82BA  51C9     MOVF 0xC9, W, BANKED
82BC  E0BE     BZ 0x823A
82BE  0A01     XORLW 0x1
82C0  E0C1     BZ 0x8244
82C2  0A03     XORLW 0x3
82C4  E0C5     BZ 0x8250
82C6  0A01     XORLW 0x1
82C8  E0C8     BZ 0x825A
82CA  0A07     XORLW 0x7
82CC  E0CB     BZ 0x8264
82CE  0A01     XORLW 0x1
82D0  E0DD     BZ 0x828C
82D2  0A03     XORLW 0x3
82D4  E0EC     BZ 0x82AE
879A  D04B     BRA 0x8832
8832  0101     MOVLB 0x1
8834  51C9     MOVF 0xC9, W, BANKED
8836  E0B2     BZ 0x879C
8838  0A01     XORLW 0x1
883A  E0B6     BZ 0x87A8
883C  0A03     XORLW 0x3
883E  E0BD     BZ 0x87BA
8840  0A01     XORLW 0x1
8842  E0C1     BZ 0x87C6
8844  0A07     XORLW 0x7
8846  E0C7     BZ 0x87D6
8848  0A01     XORLW 0x1
884A  E0DB     BZ 0x8802
884C  0A03     XORLW 0x3
884E  E0EC     BZ 0x8828
8B2A  D047     BRA 0x8BBA
8BBA  0101     MOVLB 0x1
8BBC  51C9     MOVF 0xC9, W, BANKED
8BBE  E0B6     BZ 0x8B2C
8BC0  0A01     XORLW 0x1
8BC2  E0BA     BZ 0x8B38
8BC4  0A03     XORLW 0x3
8BC6  E0BF     BZ 0x8B46
8BC8  0A01     XORLW 0x1
8BCA  E0C3     BZ 0x8B52
8BCC  0A07     XORLW 0x7
8BCE  E0C9     BZ 0x8B62
8BD0  0A01     XORLW 0x1
8BD2  E0DC     BZ 0x8B8C
8BD4  0A03     XORLW 0x3
8BD6  E0EC     BZ 0x8BB0
876:               {
877:                   //Pomiar parametrow przebiegu OT
878:                   case 0:                             //(MeasureOTPeriod)
879:                   {
880:                       StopOTTimeout();            
823A  EC71     CALL 0xC0E2, 0
823C  F060     NOP
879C  EC47     CALL 0xC28E, 0
879E  F061     NOP
8B2C  EC4B     CALL 0xC296, 0
8B2E  F061     NOP
881:                       StartMeasureOTPeriod();         //aktywne przerwanie TIMER0, uruchomienie przerwania INT0
823E  EC71     CALL 0xB0E2, 0
8240  F058     NOP
8242  D056     BRA PL530
87A0  EC47     CALL 0xB48E, 0
87A2  F05A     NOP
87A4  EF78     GOTO 0x82F0
87A6  F041     NOP
8B30  EC01     CALL 0xB602, 0
8B32  F05B     NOP
882:                       T0krok=1;
8B34  EF78     GOTO 0x82F0
8B36  F041     NOP
883:                       return;
884:                   }
885:                   case 1:                             //na potrzeby (MeasureOTPeriod) przerwanie po 268ms
886:                   {
887:                       WrtTMR0(_RELOAD0);              //przerwanie co 268ms TIMER0 
8244  D85C     RCALL PL764
8246  ECFA     CALL 0xC1F4, 0
8248  F060     NOP
87A8  0E00     MOVLW 0x0
87AA  0100     MOVLB 0x0
87AC  6B75     CLRF _PFNf_prn_cs, BANKED
87AE  6B74     CLRF _PFNf_prODP, BANKED
87B0  ECD7     CALL 0xC1AE, 0
87B2  F060     NOP
8B38  EC18     CALL 0xB630, 0
8B3A  F05B     NOP
8B3C  ECEB     CALL 0xC1D6, 0
8B3E  F060     NOP
888:                       PFNf_firstEdge=1;               //restart oczekiwania na zbocze inicjujace
824A  840A     BSF PFNf_firstEdge, 2, ACCESS
824C  EF4B     GOTO 0x9896
824E  F04C     NOP
87B4  840A     BSF PFNf_firstEdge, 2, ACCESS
87B6  EF4B     GOTO 0x9896
87B8  F04C     NOP
8B40  840A     BSF PFNf_firstEdge, 2, ACCESS
889:                       OT.data1=0;            
8B42  EF4B     GOTO 0x9896
8B44  F04C     NOP
890:                       return;
891:                   }
892:                   //Oczekiwanie na ramke OT
893:                   case 2:                             //(WaitOTFrame)
894:                   {
895:                       StopOTTimeout();            
8250  EC71     CALL 0xC0E2, 0
8252  F060     NOP
87BA  EC47     CALL 0xC28E, 0
87BC  F061     NOP
8B46  EC4B     CALL 0xC296, 0
8B48  F061     NOP
896:                       StartWaitOTFrame();             //aktywne przerwanie TIMER0           
8254  ECA0     CALL 0xB340, 0
8256  F059     NOP
8258  D043     BRA PL522
87BE  ECEF     CALL 0xB1DE, 0
87C0  F058     NOP
87C2  EF70     GOTO 0x82E0
87C4  F041     NOP
8B4A  EC83     CALL 0xB306, 0
8B4C  F059     NOP
897:                       T0krok=3;
8B4E  EF70     GOTO 0x82E0
8B50  F041     NOP
898:                       return;
899:                   }
900:                   case 3:                             //(WaitOTFrame)aktywne przerwanie TIMER0 (co 2ms), potem (WaitToFirstEdge) aktywne przerwanie INT0
901:                   {
902:                       if(!WaitOTFrame())return;    //oczekuj na poziom aktywnosci, przy aktywnym odczekaj jeszcze 100ms, a nastepnie przejdz dalej po pierwszym zboczu
825A  ECFF     CALL 0x95FE, 0
825C  F04A     NOP
825E  E244     BC PL526
8260  0012     RETURN 0
87C6  EC3B     CALL 0x8A76, 0
87C8  F045     NOP
87CA  E302     BNC 0x87D0
87CC  EF74     GOTO 0x82E8
87CE  F041     NOP
87D0  0012     RETURN 0
8B52  EC80     CALL 0x9100, 0
8B54  F048     NOP
8B56  E302     BNC 0x8B5C
8B58  EF74     GOTO 0x82E8
8B5A  F041     NOP
8B5C  0012     RETURN 0
903:                       T0krok=4; 
8262  D042     BRA PL526
87D2  EF74     GOTO 0x82E8
87D4  F041     NOP
8B5E  EF74     GOTO 0x82E8
8B60  F041     NOP
904:                       return;
905:                   } 
906:                   //Odczyt ramki OT
907:                   case 4:                             //(ReadOTFrame)aktywne przerwanie TIMER0,aktywne przerwanie INT0,INT1
908:                   {
909:                       stn=ReadOTFrame();
8264  EC29     CALL 0x8852, 0
8266  F044     NOP
8268  6E1E     MOVWF _MGSDf_ERRt, ACCESS
87D6  EC44     CALL 0x8C88, 0
87D8  F046     NOP
87DA  0100     MOVLB 0x0
87DC  6F7D     MOVWF _PFNf_set_aleg, BANKED
8B62  EC30     CALL 0x9060, 0
8B64  F048     NOP
8B66  6E31     MOVWF _PFNf_LIN_CW, ACCESS
910:                       switch(stn)
826A  D00A     BRA 0x8280
8280  501E     MOVF _MGSDf_ERRt, W, ACCESS
8282  B4D8     BTFSC STATUS, 2, ACCESS
8284  0012     RETURN 0
8286  0A01     XORLW 0x1
8288  E0F1     BZ 0x826C
828A  D7F5     BRA 0x8276
87DE  D00B     BRA 0x87F6
87F6  517D     MOVF _PFNf_set_aleg, W, BANKED
87F8  B4D8     BTFSC STATUS, 2, ACCESS
87FA  0012     RETURN 0
87FC  0A01     XORLW 0x1
87FE  E0F0     BZ 0x87E0
8800  D7F5     BRA 0x87EC
8B68  D00B     BRA 0x8B80
8B80  5031     MOVF _PFNf_LIN_CW, W, ACCESS
8B82  B4D8     BTFSC STATUS, 2, ACCESS
8B84  0012     RETURN 0
8B86  0A01     XORLW 0x1
8B88  E0F0     BZ 0x8B6A
8B8A  D7F5     BRA 0x8B76
911:                       {
912:                           case 0:     //oczekiwanie na zakonczenie procedury
913:                           {
914:                               return;
915:                           }
916:                           case 1:     //sukces, przetwarzanie danych
917:                           {
918:                               //_WOUTX=1; 
919:                               StopOTTimeout();
826C  EC71     CALL 0xC0E2, 0
826E  F060     NOP
87E0  EC47     CALL 0xC28E, 0
87E2  F061     NOP
8B6A  EC4B     CALL 0xC296, 0
8B6C  F061     NOP
920:                               StartWaitOTResp();                 //aktywne przerwanie TIMER0
8270  EC4D     CALL 0xB69A, 0
8272  F05B     NOP
8274  D031     BRA PL514
87E4  EC09     CALL 0xB812, 0
87E6  F05C     NOP
87E8  EF6C     GOTO 0x82D8
87EA  F041     NOP
8B6E  EC74     CALL 0xB8E8, 0
8B70  F05C     NOP
921:                               T0krok=5;
8B72  EF6C     GOTO 0x82D8
8B74  F041     NOP
922:                               //db=1;
923:                               return;
924:                           }
925:                           default:    //blad odbioru
926:                           {
927:                               if(OT.nRERR<5)                      //liczba bledow odczytu w normie?
8276  0E05     MOVLW 0x5
8278  0101     MOVLB 0x1
827A  6133     CPFSLT _PFNf_LIN_ENDO, BANKED
827C  D7DE     BRA 0x823A
827E  D7E8     BRA 0x8250
87EC  0E05     MOVLW 0x5
87EE  0101     MOVLB 0x1
87F0  6133     CPFSLT _PFNf_LIN_ENDO, BANKED
87F2  D7D4     BRA 0x879C
87F4  D7E2     BRA 0x87BA
8B76  0E05     MOVLW 0x5
8B78  0101     MOVLB 0x1
8B7A  6133     CPFSLT _PFNf_LIN_ENDO, BANKED
8B7C  D7D7     BRA 0x8B2C
8B7E  D7E3     BRA 0x8B46
928:                               {
929:                                   StopOTTimeout();
930:                                   StartWaitOTFrame();             //aktywne przerwanie TIMER0
931:                                   T0krok=3;  
932:                               }
933:                               else                                //ponow synchronizacje
934:                               {
935:                                   StopOTTimeout();                        
936:                                   StartMeasureOTPeriod();         //aktywne przerwanie TIMER0, uruchomienie przerwania INT0
937:                                   T0krok=1;                        
938:                               }
939:                               return;
940:                           }
941:                       }
942:                   }
943:                   //Oczekiwanie na analize ramki OT i odpowiedni moment wysylki (przerwanie TIMER0 co 2[ms])
944:                   case 5:                             
945:                   {               
946:                       stn=WaitOTResp();
828C  EC57     CALL 0xA8AE, 0
828E  F054     NOP
8290  6E1E     MOVWF _MGSDf_ERRt, ACCESS
8802  ECD9     CALL 0xA9B2, 0
8804  F054     NOP
8806  0100     MOVLB 0x0
8808  6F7D     MOVWF _PFNf_set_aleg, BANKED
8B8C  EC04     CALL 0xAA08, 0
8B8E  F055     NOP
8B90  6E31     MOVWF _PFNf_LIN_CW, ACCESS
947:                       switch(stn)
8292  D007     BRA 0x82A2
82A2  501E     MOVF _MGSDf_ERRt, W, ACCESS
82A4  B4D8     BTFSC STATUS, 2, ACCESS
82A6  0012     RETURN 0
82A8  0A01     XORLW 0x1
82AA  E0F4     BZ 0x8294
82AC  D7D1     BRA 0x8250
880A  D008     BRA 0x881C
881C  517D     MOVF _PFNf_set_aleg, W, BANKED
881E  B4D8     BTFSC STATUS, 2, ACCESS
8820  0012     RETURN 0
8822  0A01     XORLW 0x1
8824  E0F3     BZ 0x880C
8826  D7C9     BRA 0x87BA
8B92  D008     BRA 0x8BA4
8BA4  5031     MOVF _PFNf_LIN_CW, W, ACCESS
8BA6  B4D8     BTFSC STATUS, 2, ACCESS
8BA8  0012     RETURN 0
8BAA  0A01     XORLW 0x1
8BAC  E0F3     BZ 0x8B94
8BAE  D7CB     BRA 0x8B46
948:                       {
949:                           case 0:                             //czekaj na decyzje lub odpowiedz
950:                           {
951:                               return;
952:                           }
953:                           case _OT_TO_RESP:                   //odpowiedz gotowa przejdz do transmisji
954:                           {
955:                               StopOTTimeout();                    
8294  EC71     CALL 0xC0E2, 0
8296  F060     NOP
880C  EC47     CALL 0xC28E, 0
880E  F061     NOP
8B94  EC4B     CALL 0xC296, 0
8B96  F061     NOP
956:                               SetTFrameParityOdd();           //ustaw bit dopelnienia do parzystosci
8298  EC74     CALL 0xA6E8, 0
829A  F053     NOP
8810  ECD4     CALL 0x99A8, 0
8812  F04C     NOP
8B98  EC44     CALL 0xA688, 0
8B9A  F053     NOP
957:                               StartTransmitOTFrame();
829C  ECD0     CALL 0xB1A0, 0
829E  F058     NOP
82A0  D02B     BRA PL756
8814  ECEE     CALL 0xB9DC, 0
8816  F05C     NOP
8818  EF7C     GOTO 0x82F8
881A  F041     NOP
8B9C  EC9B     CALL 0xBB36, 0
8B9E  F05D     NOP
958:                               T0krok=6;
8BA0  EF7C     GOTO 0x82F8
8BA2  F041     NOP
959:                               return;
960:                           }
961:                           default:                            //rezygnacja z odpowiedzi, czekaj na kolejna ramke
962:                           {
963:                               StopOTTimeout();
964:                               StartWaitOTFrame();             
965:                               T0krok=3;      
966:                               return;
967:                           }
968:                       }
969:                   }  
970:                   case 6:
971:                   {
972:                       if(!TransmitOTFrame())return;    //oczekuj na poziom aktywnosci, przy aktywnym odczekaj jeszcze 100ms, a nastepnie przejdz dalej po pierwszym zboczu
82AE  EC76     CALL 0x9EEC, 0
82B0  F04F     NOP
82B2  0900     IORLW 0x0
82B4  E1CF     BNZ 0x8254
82B6  0012     RETURN 0
8828  EC9A     CALL 0xA134, 0
882A  F050     NOP
882C  0900     IORLW 0x0
882E  E1C7     BNZ 0x87BE
8830  0012     RETURN 0
8BB0  EC41     CALL 0xA282, 0
8BB2  F051     NOP
8BB4  0900     IORLW 0x0
8BB6  E1C9     BNZ 0x8B4A
8BB8  0012     RETURN 0
973:                       StartWaitOTFrame();             
974:                       T0krok=3;            
975:                       return;            
976:                   }
977:               }
978:           }
82D6  0012     RETURN 0
8850  0012     RETURN 0
8BD8  0012     RETURN 0
979:           /*---------------------------------------------------------------------------------*/
980:           /*---------------------------------------------------------------------------------*/
981:           /*---------------------------------------------------------------------------------*/
982:           #endif //(_EXT_BOARD>=3)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/osc.c  ----------------------
1:             /*osc.c*/
2:             /*Konfiguracja wewnetrznego oscylatora*/
3:             //#include <pic18.h>
4:             #include <xc.h>
5:             #include "global.h"			//parametry globalne
6:             
7:             void InitOsc(void)
8:             {
9:             	IRCF2=1;
C136  8CD3     BSF OSCCON, 6, ACCESS
10:            	IRCF1=1;
C138  8AD3     BSF OSCCON, 5, ACCESS
11:            	IRCF0=1;	//wewnetrzny oscylator ustawiony na 8MHz
C13A  88D3     BSF OSCCON, 4, ACCESS
12:            
13:            #if _PLL!=0		//dla PIC18F63j90 aktywny tylko przy zew. osc.
14:            	SCS1=0;		//default internal oscylator (zdefiniowany w CONFIG)
C13C  92D3     BCF OSCCON, 1, ACCESS
15:            	SCS0=0;    
C13E  90D3     BCF OSCCON, 0, ACCESS
16:            	PLLEN=1;	//zalacz petle x4
C140  8C9B     BSF OSCTUNE, 6, ACCESS
17:            #else
18:            	SCS1=1;     //select internal oscylator
19:            	SCS0=1;    
20:            	PLLEN=0;	//wylacz petle x4
21:            #endif
22:            }
C142  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/main.c  ---------------------
1:             /*main.c*/  
2:             /*Oprogramowanie rodziny sterownikow UNI-02 dla kondensatow*/
3:             /*(wprowadzona prezentacja numeru oprogramowania i rodzaju konfiguracji, wprowadzona mozliwosc blokady grzania WU dla kotlow jednofunkcyjnych)*/
4:             /*(wprowadzony staly wskaz temperatury zasobnika*/
5:             /*Wprowadzony parametr P18*/
6:             /*Wprowadzony parametr P19*/
7:             //#include <pic18.h>
8:             //#include <htc.h>
9:             #include <xc.h>
10:            #include <stdio.h>
11:            #include <string.h>
12:            #include "global.h"			//parametry globalne
13:            #include "main.h"			//parametry lokalne
14:            #if (_EXT_BOARD>=2)
15:                #include "amgs_rs9b.tp.h"
16:                #include "LIN1SInterpreter.h"
17:            #else
18:                #include "mgs_rs9b.tp.h"
19:            #endif
20:            #include "port.h"
21:            #include "print.h"			//parametry globalne
22:            #include "keypad.tp.h"
23:            #include "ot.tp.h"			//parametry lokalne
24:            
25:            extern volatile StPin ky[];
26:            tpMAIN M;
27:            volatile tpRSDTA1 RSDT1;
28:            volatile DataPFN PFN; //****
29:            
30:            extern MGSRSData MGSD;
31:            extern volatile tpOTMaster OTMaster;
32:            extern volatile unsigned char x;
33:            unsigned char zps,zmn;
34:            extern volatile unsigned char xxy,zzz,vvv;
35:            volatile unsigned char aa=0,bb=0,cc=0,dd=0,ee=0,ff=0;
36:            //#if _EXT_BOARD>=2
37:            //    unsigned char tbuf[]={0};
38:            //#endif
39:            extern unsigned char dCVBC[];
40:            
41:            unsigned int LiczCRC(unsigned char *tb, unsigned char n);
42:            unsigned char TWO_ASCIItoHEX(unsigned char a1, unsigned char a0);
43:            unsigned char CheckCHK(unsigned char a3, unsigned char a2, unsigned char a1, unsigned char a0, unsigned int h);
44:            unsigned int FOUR_ASCIItoHEX(unsigned char b3, unsigned char b2, unsigned char b1, unsigned char b0);
45:            void HEXtoTWO_ASCII(unsigned char h,unsigned char *a1, unsigned char *a0);
46:            void HEXtoFOUR_ASCII(unsigned int h,unsigned char *a3, unsigned char *a2,unsigned char *a1, unsigned char *a0);
47:            void StartRWtoCVBS(unsigned char MSS,unsigned int DID,unsigned int DTA);
48:            
49:            
50:            void DecWsw(void);
51:            void main(void)
52:            {
53:            
54:            //------------------
55:            //------------------
56:            	InitOsc();
7C2E  EC9B     CALL 0xC136, 0
7C30  F060     NOP
57:            	InitGlobal();
7C32  EC0B     CALL 0xC216, 0
7C34  F061     NOP
58:            #if _EXT_BOARD!=0    
59:                InitAC();
7C36  ECF2     CALL 0xBBE4, 0
7C38  F05D     NOP
60:                InitDataPmr();              //inicjalizacja danych dla pomiaru interfejsu 10V
7C3A  EC49     CALL 0xC292, 0
7C3C  F061     NOP
61:            #else
62:            	ADCON1=0x0f;				//(!) wszystkie wejscia AC jako cyfrowe    
63:            #endif
64:            	InitTimer1();
7C3E  ECA1     CALL 0xBD42, 0
7C40  F05E     NOP
65:            	InitPWM2();
7C42  EC4A     CALL 0xB894, 0
7C44  F05C     NOP
66:            	InitLLED();
7C46  EC03     CALL 0xC206, 0
7C48  F061     NOP
67:            	InitPort();
7C4A  EC2C     CALL 0xB458, 0
7C4C  F05A     NOP
68:            	InitTransProc();
7C4E  EC83     CALL 0xBD06, 0
7C50  F05E     NOP
69:                InitTimer3();
7C52  EC92     CALL 0xBD24, 0
7C54  F05E     NOP
70:            #if _EXT_BOARD!=0
71:            	InitAUart2();
7C56  EC0D     CALL 0xB21A, 0
7C58  F059     NOP
72:            #if (_EXT_BOARD>=2)                    //aktywowany modul LIN1SLAVE?    
73:                InitUart1();
7C5A  EC16     CALL 0xA42C, 0
7C5C  F052     NOP
74:            #endif
75:            #else
76:                InitUart();
77:            #endif
78:            #if (_EXT_BOARD>=3)    
79:                InitOT();
7C5E  ECE9     CALL 0x93D2, 0
7C60  F049     NOP
80:            #endif    
81:            	InitI2C();
7C62  EC5F     CALL 0xB8BE, 0
7C64  F05C     NOP
82:            	InitWsw();
7C66  ECAE     CALL 0xAF5C, 0
7C68  F057     NOP
83:            	LED=1;
7C6A  828B     BSF LATC, 1, ACCESS
84:            //------------------
85:            //------------------
86:            	if (!POR||!BOR)							//zalaczono zasilanie?
7C6C  B2D0     BTFSC RCON, 1, ACCESS
7C6E  A0D0     BTFSS RCON, 0, ACCESS
87:            	{
88:            		TestScr();
7C70  EC49     CALL 0xB292, 0
7C72  F059     NOP
89:            		PwrOnDelay();						//zwloka na wypadek stanow nieustalonych	
7C74  ECDB     CALL 0xBDB6, 0
7C76  F05E     NOP
90:            	}
91:            	else
92:            	{
93:            		PwrOnDelay();						//zwloka na wypadek stanow nieustalonych	
94:            	}
95:            	EndTestScr();
7C78  EC66     CALL 0xB2CC, 0
7C7A  F059     NOP
96:            	
97:            	//stan po zalaczeniu zasilania
98:            	if (!POR||!BOR)		//zalaczono zasilanie? 
7C7C  A2D0     BTFSS RCON, 1, ACCESS
7C7E  D002     BRA 0x7C84
7C80  B0D0     BTFSC RCON, 0, ACCESS
7C82  D002     BRA 0x7C88
99:            	{	
100:           		POR=1;
7C84  82D0     BSF RCON, 1, ACCESS
101:           		BOR=1;
7C86  80D0     BSF RCON, 0, ACCESS
102:           	}
103:           	
104:           //------------------
105:           //------------------
106:           //------------------
107:           	InitKonf();
7C88  EC07     CALL 0xC20E, 0
7C8A  F061     NOP
108:           
109:           #if _TDEMO==1
110:           //Tryb DEMO ***************************************
111:           	#if _TDEMOFL==1
112:           			TestScr();
113:           			while(1)			//****************************			
114:           			{					//****************************
115:           				CLRWDT();		//****************************
116:           			}
117:           	}	
118:           	#else
119:           			PFNf_fmsg=0;		//****************************
120:           			PFN.KAWR=8;			//****************************
121:           			PFNf_ferr=0;		//****************************
122:           			PFN.KERR=2;			//****************************
123:           			PFNf_off=0;			//****************************
124:           			PFNf_lato=0;		//****************************
125:           			PFNf_zima=1;		//****************************
126:           			PFNf_errCS=0;		//****************************
127:           			PFNf_errCO=0;		//****************************
128:           			PFNf_errCW=0;		//****************************
129:           			PFNf_tdzCO=0;		//****************************
130:           			PFNf_tdzCW=0;		//****************************
131:           			PFNf_prn_res=0;		//****************************
132:           			PFN.CO=25;			//****************************
133:           			PFN.CW=35;			//****************************
134:           			PFN.CS=15;			//****************************
135:           			PFN.minPCW=35;		//****************************
136:           			PFN.minPCO=45;		//****************************
137:           			PFN.maxPCW=65;		//****************************
138:           			PFN.maxPCO=85;		//****************************
139:           			PFN.PCW=35;			//****************************
140:           			PFN.PCO=45;			//****************************
141:           			PFN.ECO=5;			//****************************
142:           			PFNf_plmCW=0;
143:           			PFNf_plmCO=0;
144:           			PFNf_pgd=0;
145:           			PFNf_aktywne_KNF=0;	//****************************
146:           			PFNf_KnfDisErr=0;
147:           			PFNf_aleg=0;
148:           			PFNf_fnserw=0;
149:           			PFNf_opgres=0;
150:           			PFNf_opgprg=1;
151:           			while(1)			//****************************			
152:           			{					//****************************
153:           				CLRWDT();		//****************************
154:           				PFNf_ofzima=PFNf_zima;	//****************************
155:           				PFNf_oflato=PFNf_lato;	//****************************
156:           				PFNf_ofoff=PFNf_off;	//****************************
157:           				PFNf_ofnserw=PFNf_fnserw;
158:           				PFNf_oaleg=PFNf_aleg;
159:           				MKonfiguracja();//****************************
160:           				TrybPracy();	//****************************
161:           				DecWsw();		//****************************
162:           			}					//****************************
163:           	}							//****************************
164:           	#endif
165:           //**************************************************
166:           #else
167:           	PFN.KRS=0;
7C8C  0101     MOVLB 0x1
7C8E  6BF6     CLRF 0xF6, BANKED
168:           	PFNf_toInit=1;							//odczekaj na polaczenie z UNI02
7C90  8011     BSF PFNf_zima, 0, ACCESS
169:               StartRTS(_RTEST);//******************
7C92  0E02     MOVLW 0x2
7C94  EC45     CALL 0xBC8A, 0
7C96  F05E     NOP
170:           
171:           	while(1)								//petla glowna programu				
172:           	{
173:           		CLRWDT();         
7C98  0004     CLRWDT
174:           #if _EXT_BOARD==1
175:                   Pomiar10V();        //interfejs 10V
176:           #endif
177:           #if _EXT_BOARD==2
178:                   if(!PFNf_LIN_KSK&&!PFNf_LIN_STR)
179:                   {    
180:                       Pomiar10V();        //interfejs 10V
181:                   }
182:                   else
183:                   {
184:                       PFNf_bEnF10V=0;             //znacznik do aktywacji wejscia 10V              
185:                       PFNf_EnF10V=0;              //znacznik aktywnosci wejscia 10V  
186:                       PFNf_b10V_RT=0;             //znacznik do aktywacji pobudzenia z wejscia 10V                
187:                       PFNf_10V_RT=0;              //znacznik pobudzenia z wejscia 10V   
188:                       PFNf_10V_nPCO=0;            //znacznik nowej wartosci PCO z wejscia 10V            
189:                   }
190:           #endif        
191:           #if _EXT_BOARD>=3
192:                   if(!PFNf_LIN_KSK&&!PFNf_LIN_STR&&!PFNf_FOT)
7C9A  AC06     BTFSS PFNf_LIN_CW, 6, ACCESS
7C9C  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
7C9E  D005     BRA 0x7CAA
7CA0  BC05     BTFSC PFNf_KnfDisErr, 6, ACCESS
7CA2  D003     BRA 0x7CAA
193:                   {    
194:                       Pomiar10V();        //interfejs 10V
7CA4  EC39     CALL 0x6472, 0
7CA6  F032     NOP
195:                   }
7CA8  D005     BRA 0x7CB4
196:                   else
197:                   {
198:                       PFNf_bEnF10V=0;             //znacznik do aktywacji wejscia 10V              
7CAA  9608     BCF PFNf_b_set_nco, 3, ACCESS
199:                       PFNf_EnF10V=0;              //znacznik aktywnosci wejscia 10V  
7CAC  9605     BCF PFNf_KnfDisErr, 3, ACCESS
200:                       PFNf_b10V_RT=0;             //znacznik do aktywacji pobudzenia z wejscia 10V                
7CAE  9408     BCF PFNf_b_set_nco, 2, ACCESS
201:                       PFNf_10V_RT=0;              //znacznik pobudzenia z wejscia 10V   
7CB0  9005     BCF PFNf_KnfDisErr, 0, ACCESS
202:                       PFNf_10V_nPCO=0;            //znacznik nowej wartosci PCO z wejscia 10V            
7CB2  9205     BCF PFNf_KnfDisErr, 1, ACCESS
203:                   }
204:           #endif         
205:                   //TRANSMISJA LIN
206:           #if (_EXT_BOARD>=2)
207:                   LIN1SDeamon();                                      //LIN1 SLAVE
7CB4  EC05     CALL 0x7A0A, 0
7CB6  F03D     NOP
208:                   if(RTdS(_RTFLIN)>_TFLIN) 
7CB8  0E08     MOVLW 0x8
7CBA  EC8B     CALL 0xBF16, 0
7CBC  F05F     NOP
7CBE  6FAD     MOVWF 0xAD, BANKED
7CC0  0E64     MOVLW 0x64
7CC2  65AD     CPFSGT 0xAD, BANKED
7CC4  D009     BRA 0x7CD8
209:                   {
210:                       BitSet3(&RSDT1.inLNSTAT,_FLIN,0);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
7CC6  ECD6     CALL 0x1FAC, 0
7CC8  F00F     NOP
7CCA  0E00     MOVLW 0x0
7CCC  6F78     MOVWF _PFNf_prn_pp, BANKED
7CCE  6F79     MOVWF _PFNf_prn_res, BANKED
7CD0  EC48     CALL 0xAC90, 0
7CD2  F056     NOP
211:                       PFNf_FLIN=0;
7CD4  EC4A     CALL 0x4894, 0
7CD6  F024     NOP
212:                       PFNf_LIN_RT=0;
213:                       PFNf_LIN_CW=0;            
214:                   }
215:           #else
216:                   BitSet3(&RSDT1.inLNSTAT,_FLIN,0);
217:                   PFNf_FLIN=0;
218:           #endif
219:                   //TRANSMISJA OT
220:           #if (_EXT_BOARD>=3)        
221:                   OTInterpreter();
7CD8  EC93     CALL 0x9926, 0
7CDA  F04C     NOP
222:                   if(RTdS(_RTFOT)>_TFOT) 
7CDC  0E0B     MOVLW 0xB
7CDE  EC8B     CALL 0xBF16, 0
7CE0  F05F     NOP
7CE2  6FAD     MOVWF 0xAD, BANKED
7CE4  0E64     MOVLW 0x64
7CE6  65AD     CPFSGT 0xAD, BANKED
7CE8  D00A     BRA 0x7CFE
223:                   {
224:                       BitSet3(&RSDT1.inINSTAT,_FOT,0);        //odswiez znacznik komunikacji OT dla ukladu UNI-02
7CEA  ECFA     CALL 0x1FF4, 0
7CEC  F00F     NOP
7CEE  0E02     MOVLW 0x2
7CF0  6F78     MOVWF _PFNf_prn_pp, BANKED
7CF2  0E00     MOVLW 0x0
7CF4  6F79     MOVWF _PFNf_prn_res, BANKED
7CF6  EC48     CALL 0xAC90, 0
7CF8  F056     NOP
225:                       OTMaster.Ref.war=0;                     //brak aktywnosci - wyzeruj flagi aktualizacji danych            
7CFA  EC3F     CALL 0x487E, 0
7CFC  F024     NOP
226:                       PFNf_FOT=0;
227:                       PFNf_OT_DPGD=0;
228:                   }        
229:           #else        
230:                   BitSet3(&RSDT1.inINSTAT,_FOT,0);
231:                   PFNf_FOT=0;
232:                   PFNf_OT_DPGD=0;        
233:           #endif        
234:                   //if(!PFNf_toInit&&PFNf_kalVNT) PFNf_toInit=1;
235:           		if(MGSDf_NO_ODB||PFNf_toInit) InitUNIData();		//odczekaj na polaczenie z UNI02
7CFE  AE03     BTFSS LIN1f_NDTA, 7, ACCESS
7D00  B011     BTFSC PFNf_zima, 0, ACCESS
7D02  EC6C     CALL 0x44D8, 0
7D04  F022     NOP
236:           		MKonfiguracja();					//decyzja o wejsciu do proc. konfiguracji
7D06  EC28     CALL 0xA50, 0
7D08  F005     NOP
237:           		TrybPracy();
7D0A  EC19     CALL 0x2032, 0
7D0C  F010     NOP
238:           		RingProc();							//transmisja do/z plytki UNI-02
7D0E  EC70     CALL 0x7EE0, 0
7D10  F03F     NOP
239:           		RefData();							//aktualizacja danych WE/WY
7D12  ECAA     CALL 0x1954, 0
7D14  F00C     NOP
240:           		DecWsw();							//decyzja o wyswietlaniu parametrow
7D16  EC79     CALL 0xF2, 0
7D18  F000     NOP
241:           		DecRes();							//decyzja o wejsciu oczekiwania na transmisje po resecie
7D1A  EC16     CALL 0xBA2C, 0
7D1C  F05D     NOP
7D1E  D7BC     BRA 0x7C98
242:           	}
243:           }
244:           #endif
245:           
246:           //--------------------------------------------------------------
247:           void InitUNIData(void)
248:           {
249:           	volatile static unsigned char n=0,k=3,j=3;
250:           
251:           //-----------OCZEKIWANIE
252:           	EndErr();
44D8  ECC2     CALL 0xC184, 0
44DA  F060     NOP
253:           	EndPR();
44DC  ECE1     CALL 0xBBC2, 0
44DE  F05D     NOP
254:           	EndNst();
44E0  EC36     CALL 0xC26C, 0
44E2  F061     NOP
255:           	ClrAllMarks();
44E4  ECC5     CALL 0xB78A, 0
44E6  F05B     NOP
256:           	ClrDig(1,1,0);
44E8  0E01     MOVLW 0x1
44EA  6F7E     MOVWF _PFNf_set_eco, BANKED
44EC  EC36     CALL 0x5E6C, 0
44EE  F02F     NOP
44F0  EC54     CALL 0x9AA8, 0
44F2  F04D     NOP
257:           	Mark(_GZ_OFF,2);
44F4  EC3E     CALL 0x5E7C, 0
44F6  F02F     NOP
44F8  EC1F     CALL 0xB83E, 0
44FA  F05C     NOP
44FC  ECE0     CALL 0x1FC0, 0
44FE  F00F     NOP
258:           	BitSet3(&RSDT1.inSTAT0,_INITDTA,1);	//aktywacja trybu INICJALIZACJI
4500  0E07     MOVLW 0x7
4502  6F78     MOVWF _PFNf_prn_pp, BANKED
4504  0E01     MOVLW 0x1
4506  6F79     MOVWF _PFNf_prn_res, BANKED
4508  EC48     CALL 0xAC90, 0
450A  F056     NOP
259:           	PFNf_kalVNT=0;
450C  960B     BCF PFNf_lato, 3, ACCESS
260:           	PFNf_opgres=0;
450E  980D     BCF PFNf_plmCO, 4, ACCESS
261:           	PFNf_opgprg=0;
4510  960D     BCF PFNf_plmCO, 3, ACCESS
262:           	PFNf_ferr=0;
4512  920A     BCF PFNf_firstEdge, 1, ACCESS
263:               RSDT1f_RD_STD=0;    
4514  9612     BCF RSDT1f_RD_STD, 3, ACCESS
264:               RSDT1f_RRD_STD=0;    
4516  9A12     BCF RSDT1f_RD_STD, 5, ACCESS
265:               RSDT1f_RD_KNF=0;    
4518  9212     BCF RSDT1f_RD_STD, 1, ACCESS
266:               RSDT1f_RRD_KNF=0;    
451A  9812     BCF RSDT1f_RD_STD, 4, ACCESS
267:               RSDT1.vSTD=0;
451C  0102     MOVLB 0x2
451E  6B2F     CLRF _PFNf_KnfDisErr, BANKED
268:               RSDT1.vKNF=0;   
4520  6B50     CLRF 0x50, BANKED
269:               PFN.vUNI02=0;
4522  0101     MOVLB 0x1
4524  6BEC     CLRF 0xEC, BANKED
270:               PFN.ALIN=0; //ustaw wstepnie adres niedozwolony LIN - blokada odbioru do czasu nawiazania komunikacji z UNI-02
4526  6BED     CLRF 0xED, BANKED
271:               PFN.STRB=0; //ustaw wstepnie specjalny tryb pracy na 0
4528  6BFC     CLRF 0xFC, BANKED
272:               RSDT1.inSTAT2=0;
452A  0102     MOVLB 0x2
452C  6B7E     CLRF _PFNf_set_eco, BANKED
273:           	n=0;
452E  0101     MOVLB 0x1
4530  6BA7     CLRF x, BANKED
274:               j=3;
4532  0E03     MOVLW 0x3
4534  0100     MOVLB 0x0
4536  6FEA     MOVWF __pdataBANK0, BANKED
275:               k=3;
4538  6FEB     MOVWF k, BANKED
276:           	PrintVerBoards(1);	//reset procedury wizualizacji wersji
453A  0E01     MOVLW 0x1
453C  EC35     CALL 0x5C6A, 0
453E  F02E     NOP
277:               //Oczekiwanie na ustalony stan plyty sterujacej, okreslona wersje oprogramowania plyty sterujacej i zaktualizowane dane STD
278:               //gdzie n - wymusza okeslona liczbe wykonan i pozwala na podtrzymanie petli na czas aktywnosci procedury kalibracji
279:               //gdzie k,j - wymusza odbior ustalonej, minimalnej liczby ramek STD i KNF
280:           	while(!PFN.vUNI02||(!PFNf_opgres&&!PFNf_opgprg)||(PFNf_opgres&&!PFNf_ferr)||(n++<10)||k||j)  
4540  D0D7     BRA 0x46F0
46F0  0101     MOVLB 0x1
46F2  51EC     MOVF 0xEC, W, BANKED
46F4  E101     BNZ 0x46F8
46F6  D725     BRA 0x4542
46F8  B80D     BTFSC PFNf_plmCO, 4, ACCESS
46FA  D002     BRA 0x4700
46FC  A60D     BTFSS PFNf_plmCO, 3, ACCESS
46FE  D721     BRA 0x4542
4700  A80D     BTFSS PFNf_plmCO, 4, ACCESS
4702  D002     BRA 0x4708
4704  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
4706  D71D     BRA 0x4542
4708  2BA7     INCF x, F, BANKED
470A  05A7     DECF x, W, BANKED
470C  0100     MOVLB 0x0
470E  6FAC     MOVWF 0xAC, BANKED
4710  0E09     MOVLW 0x9
4712  65AC     CPFSGT 0xAC, BANKED
4714  D716     BRA 0x4542
4716  51EB     MOVF k, W, BANKED
4718  E001     BZ 0x471C
471A  D713     BRA 0x4542
471C  51EA     MOVF __pdataBANK0, W, BANKED
471E  E001     BZ 0x4722
4720  D710     BRA 0x4542
281:           	{
282:           		SetLightLLed(1);
4542  0E01     MOVLW 0x1
4544  ECE4     CALL 0xA5C8, 0
4546  F052     NOP
283:           		while(!MGSDf_TransACK)
4548  D024     BRA 0x4592
4592  A604     BTFSS MGSDf_TransData, 3, ACCESS
4594  D7DA     BRA 0x454A
284:           		{
285:           			CLRWDT();
454A  0004     CLRWDT
286:                       //TRANSMISJA UNI-02
287:           			RingProc();                                               //transmisja do/z plytki UNI-02
454C  EC70     CALL 0x7EE0, 0
454E  F03F     NOP
288:                       //TRANSMISJA LIN
289:           #if (_EXT_BOARD>=2)
290:                       LIN1SDeamon();                                                   //LIN1 SLAVE
4550  EC05     CALL 0x7A0A, 0
4552  F03D     NOP
291:                       if(RTdS(_RTFLIN)>_TFLIN)
4554  0E08     MOVLW 0x8
4556  EC8B     CALL 0xBF16, 0
4558  F05F     NOP
455A  6FAC     MOVWF 0xAC, BANKED
455C  0E64     MOVLW 0x64
455E  65AC     CPFSGT 0xAC, BANKED
4560  D008     BRA 0x4572
4562  ECD6     CALL 0x1FAC, 0
4564  F00F     NOP
292:                       {
293:                           BitSet3(&RSDT1.inLNSTAT,_FLIN,0);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
4566  0E00     MOVLW 0x0
4568  6F78     MOVWF _PFNf_prn_pp, BANKED
456A  6F79     MOVWF _PFNf_prn_res, BANKED
456C  EC48     CALL 0xAC90, 0
456E  F056     NOP
4570  D991     RCALL PL820
294:                           PFNf_FLIN=0;
295:                           PFNf_LIN_RT=0;
296:                           PFNf_LIN_CW=0;                            
297:                       }
298:           #else
299:                       BitSet3(&RSDT1.inLNSTAT,_FLIN,0);
300:                       PFNf_FLIN=0;
301:           #endif
302:                       //TRANSMISJA OT
303:           #if (_EXT_BOARD>=3)        
304:                       OTInterpreter();
4572  EC93     CALL 0x9926, 0
4574  F04C     NOP
305:                       if(RTdS(_RTFOT)>_TFOT) 
4576  0E0B     MOVLW 0xB
4578  EC8B     CALL 0xBF16, 0
457A  F05F     NOP
457C  6FAC     MOVWF 0xAC, BANKED
457E  0E64     MOVLW 0x64
4580  65AC     CPFSGT 0xAC, BANKED
4582  D007     BRA 0x4592
4584  ECFA     CALL 0x1FF4, 0
4586  F00F     NOP
306:                       {
307:                           BitSet3(&RSDT1.inINSTAT,_FOT,0);        //odswiez znacznik komunikacji OT dla ukladu UNI-02
4588  0E02     MOVLW 0x2
458A  D96A     RCALL PL482
458C  EC48     CALL 0xAC90, 0
458E  F056     NOP
4590  D976     RCALL PL584
308:                           OTMaster.Ref.war=0;                     //brak aktywnosci - wyzeruj flagi aktualizacji danych
309:                           PFNf_FOT=0;   
310:                           PFNf_OT_DPGD=0;
311:                       }        
312:           #else        
313:                       BitSet3(&RSDT1.inINSTAT,_FOT,0);
314:                       PFNf_FOT=0;   
315:                       PFNf_OT_DPGD=0;
316:           #endif
317:           		}
318:           		MGSDf_TransACK=0;
4596  9604     BCF MGSDf_TransData, 3, ACCESS
319:                   //----------------------------------------------------------
320:                   //WYMUSZENIE ODBIORU MINIMUM TRZECH RAMEK STD, KNF
321:                   //odrzuc pierwsze trzy ramki STD
322:                   if(k&&RSDT1f_RD_STD)   
4598  0100     MOVLB 0x0
459A  51EB     MOVF k, W, BANKED
459C  E007     BZ 0x45AC
459E  A612     BTFSS RSDT1f_RD_STD, 3, ACCESS
45A0  D005     BRA 0x45AC
323:                   {
324:                       k--;    
45A2  07EB     DECF k, F, BANKED
325:                       if(k)
45A4  51EB     MOVF k, W, BANKED
45A6  E002     BZ 0x45AC
326:                       {
327:                           RSDT1f_RD_STD=0;    //uniewaznij ramke
45A8  9612     BCF RSDT1f_RD_STD, 3, ACCESS
328:                           RSDT1f_RRD_STD=0;
45AA  9A12     BCF RSDT1f_RD_STD, 5, ACCESS
329:                       }
330:                   }
331:                   //odrzuc pierwsze trzy ramki KNF
332:                   if(j&&RSDT1f_RD_KNF)   
45AC  51EA     MOVF __pdataBANK0, W, BANKED
45AE  E007     BZ 0x45BE
45B0  A212     BTFSS RSDT1f_RD_STD, 1, ACCESS
45B2  D005     BRA 0x45BE
333:                   {
334:                       j--;
45B4  07EA     DECF __pdataBANK0, F, BANKED
335:                       if(j)  
45B6  51EA     MOVF __pdataBANK0, W, BANKED
45B8  E002     BZ 0x45BE
336:                       {
337:                           RSDT1f_RD_KNF=0;    //uniewaznij ramke
45BA  9212     BCF RSDT1f_RD_STD, 1, ACCESS
338:                           RSDT1f_RRD_KNF=0;
45BC  9812     BCF RSDT1f_RD_STD, 4, ACCESS
339:                       }
340:                   } 
341:                   //----------------------------------------------------------
342:                   //aktualizacja danych 
343:                   if(!k&&RSDT1f_RD_STD)
45BE  51EB     MOVF k, W, BANKED
45C0  E12E     BNZ 0x461E
45C2  A612     BTFSS RSDT1f_RD_STD, 3, ACCESS
45C4  D02C     BRA 0x461E
344:                   {
345:                       RSDT1f_RRD_STD=1;		//aktywna blokada na czas interpretacji danych        
45C6  8A12     BSF RSDT1f_RD_STD, 5, ACCESS
346:                       PFNf_opgres=GetBit2(RSDT1.outSTAT0,_PGRES);
45C8  EC09     CALL 0x2012, 0
45CA  F010     NOP
45CC  ECC6     CALL 0xB98C, 0
45CE  F05C     NOP
45D0  E302     BNC 0x45D6
45D2  880D     BSF PFNf_plmCO, 4, ACCESS
45D4  D001     BRA 0x45D8
45D6  980D     BCF PFNf_plmCO, 4, ACCESS
347:                       PFNf_opgprg=GetBit2(RSDT1.outSTAT0,_PGPRG);
45D8  0E01     MOVLW 0x1
45DA  ECD1     CALL 0x1FA2, 0
45DC  F00F     NOP
45DE  ECC6     CALL 0xB98C, 0
45E0  F05C     NOP
45E2  E302     BNC 0x45E8
45E4  860D     BSF PFNf_plmCO, 3, ACCESS
45E6  D001     BRA 0x45EA
45E8  960D     BCF PFNf_plmCO, 3, ACCESS
348:                       PFNf_ferr=GetBit2(RSDT1.outSTAT1,_ERR);
45EA  0E03     MOVLW 0x3
45EC  ECE5     CALL 0x1FCA, 0
45EE  F00F     NOP
45F0  ECC6     CALL 0xB98C, 0
45F2  F05C     NOP
45F4  E302     BNC 0x45FA
45F6  820A     BSF PFNf_firstEdge, 1, ACCESS
45F8  D001     BRA 0x45FC
45FA  920A     BCF PFNf_firstEdge, 1, ACCESS
349:                       PFNf_kalVNT=GetBit2(RSDT1.outSTAT2,_KALIB);
45FC  0E07     MOVLW 0x7
45FE  ECCC     CALL 0x1F98, 0
4600  F00F     NOP
4602  ECC6     CALL 0xB98C, 0
4604  F05C     NOP
4606  E302     BNC 0x460C
4608  860B     BSF PFNf_lato, 3, ACCESS
460A  D001     BRA 0x460E
460C  960B     BCF PFNf_lato, 3, ACCESS
350:           
351:                       PFN.RDZ0=RSDT1.outRDZ0;							//nr wesji oprogramowania plytki UNI-02
460E  D921     RCALL PL296
352:                       PFN.RDZ1=RSDT1.outRDZ1;
353:                       PFN.RDZ2=RSDT1.outRDZ2;
354:           
355:                       PFNf_EnAleg=((PFN.RDZ1&0x0F)==_UNICO);					//znacznik kotla zasobnikowego (1F)
4610  D930     RCALL PL550
4612  E102     BNZ 0x4618
4614  8405     BSF PFNf_KnfDisErr, 2, ACCESS
4616  D001     BRA 0x461A
4618  9405     BCF PFNf_KnfDisErr, 2, ACCESS
356:                       PFN.vUNI02=((PFN.RDZ1&0xF0)>>4)+(PFN.RDZ2&0b00011111);    //wersja opr.UNI-02
461A  D905     RCALL PL100
357:                       if(PFN.vUNI02>2) PFN.ALIN=(PFN.RDZ0&0b11100000)>>5;
358:                       else PFN.ALIN=5;
359:                       RSDT1f_RRD_STD=0;		//aktywna blokada na czas interpretacji danych
461C  9A12     BCF RSDT1f_RD_STD, 5, ACCESS
360:                   }
361:                   //informacja o stanie przyciskow dla plytki sterujacej
362:                   if(!k&&!j&&!PFNf_opgres)
461E  0100     MOVLB 0x0
4620  51EB     MOVF k, W, BANKED
4622  E162     BNZ 0x46E8
4624  51EA     MOVF __pdataBANK0, W, BANKED
4626  E160     BNZ 0x46E8
4628  B80D     BTFSC PFNf_plmCO, 4, ACCESS
462A  D05E     BRA 0x46E8
363:                   {
364:           #if _KEY_BBOARD==0           
365:                       if(!k&&!j)
366:                       {
367:                           BitSet3(&RSDT1.inSTAT1,_KSET,RdPrt(S_SET));				//detekcja przyciskow wejscia do konfiguracji
368:                           BitSet3(&RSDT1.inSTAT1,_KOFF,RdPrt(S_OFF));
369:                           BitSet3(&RSDT1.inSTAT1,_KMINUS,RdPrt(S_KDW));           //detekcja przycisku na potrzeby wyjscia z proc.kalibracji
370:                           BitSet3(&RSDT1.inSTAT1,_KPLUS,RdPrt(S_KUP));    
371:                       }
372:                       else
373:                       {
374:                           BitSet3(&RSDT1.inSTAT1,_KSET,0);				
375:                           BitSet3(&RSDT1.inSTAT1,_KOFF,0);
376:                           BitSet3(&RSDT1.inSTAT1,_KMINUS,0);           
377:                           BitSet3(&RSDT1.inSTAT1,_KPLUS,0);                
378:                       }
379:                       BitSet3(&RSDT1.inSTAT1,_7KEY,0);                        //znacznik interfejsu 7Key             
380:           #endif
381:           #if _KEY_BBOARD==1  
382:                       if(!k&&!j)
462C  51EB     MOVF k, W, BANKED
462E  E127     BNZ 0x467E
4630  51EA     MOVF __pdataBANK0, W, BANKED
4632  E125     BNZ 0x467E
383:                       {            
384:                           BitSet3(&RSDT1.inSTAT1,_KSET,RdPrt(S_KOM));				//detekcja przyciskow wejscia do konfiguracji
4634  D8F3     RCALL PL90
4636  EC16     CALL 0x202C, 0
4638  F010     NOP
463A  EC02     CALL 0xBA04, 0
463C  F05D     NOP
463E  ECDB     CALL 0x1FB6, 0
4640  F00F     NOP
4642  EC48     CALL 0xAC90, 0
4644  F056     NOP
4646  D8EA     RCALL PL90
385:                           BitSet3(&RSDT1.inSTAT1,_KOFF,RdPrt(S_OFF));            
4648  EC13     CALL 0x2026, 0
464A  F010     NOP
464C  EC02     CALL 0xBA04, 0
464E  F05D     NOP
4650  ECDB     CALL 0x1FB6, 0
4652  F00F     NOP
4654  EC48     CALL 0xAC90, 0
4656  F056     NOP
4658  D8E1     RCALL PL90
386:                           BitSet3(&RSDT1.inSTAT1,_KMINUS,RdPrt(S_KDW_CO));        //detekcja przycisku na potrzeby wyjscia z proc.kalibracji
465A  EC10     CALL 0x2020, 0
465C  F010     NOP
465E  EC02     CALL 0xBA04, 0
4660  F05D     NOP
4662  ECDB     CALL 0x1FB6, 0
4664  F00F     NOP
4666  EC48     CALL 0xAC90, 0
4668  F056     NOP
466A  D8D8     RCALL PL90
387:                           BitSet3(&RSDT1.inSTAT1,_KPLUS,RdPrt(S_KUP_CO));  
466C  EC0D     CALL 0x201A, 0
466E  F010     NOP
4670  EC02     CALL 0xBA04, 0
4672  F05D     NOP
4674  ECDB     CALL 0x1FB6, 0
4676  F00F     NOP
4678  EC48     CALL 0xAC90, 0
467A  F056     NOP
388:                       }
467C  D014     BRA 0x46A6
389:                       else
390:                       {
391:                           BitSet3(&RSDT1.inSTAT1,_KSET,0);				
467E  D8CE     RCALL PL90
4680  0E03     MOVLW 0x3
4682  D8EE     RCALL PL482
4684  EC48     CALL 0xAC90, 0
4686  F056     NOP
4688  D8C9     RCALL PL90
392:                           BitSet3(&RSDT1.inSTAT1,_KOFF,0);            
468A  0E04     MOVLW 0x4
468C  D8E9     RCALL PL482
468E  EC48     CALL 0xAC90, 0
4690  F056     NOP
4692  D8C4     RCALL PL90
393:                           BitSet3(&RSDT1.inSTAT1,_KMINUS,0);        
4694  0E02     MOVLW 0x2
4696  D8E4     RCALL PL482
4698  EC48     CALL 0xAC90, 0
469A  F056     NOP
469C  D8BF     RCALL PL90
394:                           BitSet3(&RSDT1.inSTAT1,_KPLUS,0);                  
469E  0E01     MOVLW 0x1
46A0  D8DF     RCALL PL482
46A2  EC48     CALL 0xAC90, 0
46A4  F056     NOP
395:                       }
46A6  D8BA     RCALL PL90
396:                       BitSet3(&RSDT1.inSTAT1,_7KEY,1);                        //znacznik interfejsu 7Key             
46A8  EC04     CALL 0x2008, 0
46AA  F010     NOP
46AC  EC48     CALL 0xAC90, 0
46AE  F056     NOP
397:           #endif            
398:           #if _EXT_BOARD!=0
399:                       if(!k&&!j&&PFNf_FLIN)
46B0  51EB     MOVF k, W, BANKED
46B2  E107     BNZ 0x46C2
46B4  51EA     MOVF __pdataBANK0, W, BANKED
46B6  E105     BNZ 0x46C2
46B8  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
46BA  D003     BRA 0x46C2
400:                       {
401:                           RSDT1.inSTAT2=PFN.STRB;                             //specjalny tryb produkcyjny
46BC  C1FC     MOVFF 0x1FC, 0x27E
46BE  F27E     NOP
402:                       }
46C0  D002     BRA 0x46C6
403:                       else
404:                       {
405:                           RSDT1.inSTAT2=0;                
46C2  0102     MOVLB 0x2
46C4  6B7E     CLRF _PFNf_set_eco, BANKED
406:                       }
407:           #else
408:                       RSDT1.inSTAT2=0;
409:           #endif            
410:                       if(PFN.vUNI02&&PFNf_kalVNT)                             //podtrzymanie petli na czas aktywnosci procedury kalibracji
46C6  0101     MOVLB 0x1
46C8  51EC     MOVF 0xEC, W, BANKED
46CA  E008     BZ 0x46DC
46CC  A60B     BTFSS PFNf_lato, 3, ACCESS
46CE  D006     BRA 0x46DC
411:                       {
412:                           n=8;												//(!)odczekaj az zakonczy sie tryb kalibracji
46D0  0E08     MOVLW 0x8
46D2  6FA7     MOVWF x, BANKED
413:                           PrintVerBoards(0);									//procedra wizualizacji wersji oprogramowania plytek
46D4  0E00     MOVLW 0x0
46D6  EC35     CALL 0x5C6A, 0
46D8  F02E     NOP
414:                       }										
46DA  D00A     BRA 0x46F0
415:                       else 
416:                       {
417:                           Mark(_GZ_MXCW,0);                                   //znacznik oczekiwania na polaczenie
46DC  0100     MOVLB 0x0
46DE  6B7A     CLRF _PFNf_res, BANKED
46E0  0E0B     MOVLW 0xB
46E2  EC1F     CALL 0xB83E, 0
46E4  F05C     NOP
46E6  D004     BRA 0x46F0
418:                       }
419:                   }
420:                   else
421:                   {
422:                       Mark(_GZ_MXCW,0);                                       //znacznik oczekiwania na polaczenie
46E8  6B7A     CLRF _PFNf_res, BANKED
46EA  0E0B     MOVLW 0xB
46EC  EC1F     CALL 0xB83E, 0
46EE  F05C     NOP
423:                   }
424:           	}
425:           	MGSDf_TransACK=0;
4722  9604     BCF MGSDf_TransData, 3, ACCESS
426:               
427:           //--------------------------------------------------------------    
428:           //-----------INICJALIZACJA NASTAW WYSWIETLACZA DANYMI Z PLYTKI STERUJACEJ    
429:               PFNf_fnserw=GetBit2(RSDT1.outSTAT0,_FKSRV);
4724  0E04     MOVLW 0x4
4726  6F74     MOVWF _PFNf_prODP, BANKED
4728  0102     MOVLB 0x2
472A  5145     MOVF CommRT, W, BANKED
472C  ECC6     CALL 0xB98C, 0
472E  F05C     NOP
4730  E302     BNC 0x4736
4732  8C0A     BSF PFNf_firstEdge, 6, ACCESS
4734  D001     BRA 0x4738
4736  9C0A     BCF PFNf_firstEdge, 6, ACCESS
430:               PFNf_aleg=GetBit2(RSDT1.outSTAT0,_ANTYL);
4738  0E05     MOVLW 0x5
473A  ECD1     CALL 0x1FA2, 0
473C  F00F     NOP
473E  ECC6     CALL 0xB98C, 0
4740  F05C     NOP
4742  E302     BNC 0x4748
4744  8208     BSF PFNf_b_set_nco, 1, ACCESS
4746  D001     BRA 0x474A
4748  9208     BCF PFNf_b_set_nco, 1, ACCESS
431:               PFNf_off=GetBit2(RSDT1.outSTAT2,_F_OFF);
474A  0E06     MOVLW 0x6
474C  ECCC     CALL 0x1F98, 0
474E  F00F     NOP
4750  ECC6     CALL 0xB98C, 0
4752  F05C     NOP
4754  E302     BNC 0x475A
4756  8A0C     BSF PFNf_off, 5, ACCESS
4758  D001     BRA 0x475C
475A  9A0C     BCF PFNf_off, 5, ACCESS
432:               PFNf_lato=GetBit2(RSDT1.outSTAT2,_F_LATO);
475C  0E05     MOVLW 0x5
475E  ECCC     CALL 0x1F98, 0
4760  F00F     NOP
4762  ECC6     CALL 0xB98C, 0
4764  F05C     NOP
4766  E302     BNC 0x476C
4768  880B     BSF PFNf_lato, 4, ACCESS
476A  D001     BRA 0x476E
476C  980B     BCF PFNf_lato, 4, ACCESS
433:               PFNf_zima=GetBit2(RSDT1.outSTAT2,_F_ZIMA);
476E  0E04     MOVLW 0x4
4770  ECCC     CALL 0x1F98, 0
4772  F00F     NOP
4774  ECC6     CALL 0xB98C, 0
4776  F05C     NOP
4778  E302     BNC 0x477E
477A  8811     BSF PFNf_zima, 4, ACCESS
477C  D001     BRA 0x4780
477E  9811     BCF PFNf_zima, 4, ACCESS
434:               PFNf_kalVNT=GetBit2(RSDT1.outSTAT2,_KALIB);
4780  0E07     MOVLW 0x7
4782  ECCC     CALL 0x1F98, 0
4784  F00F     NOP
4786  ECC6     CALL 0xB98C, 0
4788  F05C     NOP
478A  E302     BNC 0x4790
478C  860B     BSF PFNf_lato, 3, ACCESS
478E  D001     BRA 0x4792
4790  960B     BCF PFNf_lato, 3, ACCESS
435:           
436:               PFN.RDZ0=RSDT1.outRDZ0;
4792  D85F     RCALL PL296
437:               PFN.RDZ1=RSDT1.outRDZ1;
438:               PFN.RDZ2=RSDT1.outRDZ2;    
439:               PFN.PCW=(unsigned int)RSDT1.outPCW;
4794  C239     MOVFF 0x239, 0x1F0
4796  F1F0     NOP
4798  0101     MOVLB 0x1
479A  6BF1     CLRF 0xF1, BANKED
440:               PFN.PCO=(unsigned int)RSDT1.outPCO;
479C  C238     MOVFF 0x238, 0x1EE
479E  F1EE     NOP
47A0  6BEF     CLRF 0xEF, BANKED
441:               PFN.ECO=(unsigned int)RSDT1.outECO;
47A2  C242     MOVFF 0x242, 0x1F2
47A4  F1F2     NOP
47A6  6BF3     CLRF 0xF3, BANKED
442:           
443:               PFN.ALIN=(PFN.RDZ0&0b11100000)>>5;
47A8  39D5     SWAPF CMSGPar, W, BANKED
47AA  42E8     RRNCF WREG, F, ACCESS
47AC  0B07     ANDLW 0x7
47AE  6FED     MOVWF 0xED, BANKED
47B0  D860     RCALL PL550
444:               PFNf_EnAleg=((PFN.RDZ1&0x0F)==_UNICO);              //znacznik kotla zasobnikowego (1F)
47B2  E102     BNZ 0x47B8
47B4  8405     BSF PFNf_KnfDisErr, 2, ACCESS
47B6  D001     BRA 0x47BA
47B8  9405     BCF PFNf_KnfDisErr, 2, ACCESS
445:               PFN.vUNI02=((PFN.RDZ1&0xF0)>>4)+(PFN.RDZ2&0b00011111);                      //wersja opr.UNI-02
47BA  D835     RCALL PL100
446:               if(PFN.vUNI02>2) PFN.ALIN=(PFN.RDZ0&0b11100000)>>5; //adres LIN
447:               else PFN.ALIN=5;
448:                  
449:               PFNf_newPCO=0;
47BC  900C     BCF PFNf_off, 0, ACCESS
450:               PFNf_newPCW=0;
47BE  920C     BCF PFNf_off, 1, ACCESS
451:               PFNf_newECO=0;
47C0  9E0B     BCF PFNf_lato, 7, ACCESS
452:               PFNf_EnLIN=1;
47C2  8805     BSF PFNf_KnfDisErr, 4, ACCESS
453:               PFNf_prn_res=0;
47C4  920F     BCF PFNf_set_fnserw, 1, ACCESS
454:               PFNf_res=0;	
47C6  940F     BCF PFNf_set_fnserw, 2, ACCESS
455:           //--------------------------------------------------------------    
456:           //-----------PIERWSZA AKTUALIZACJA DANYCH DLA PLYTKI STERUJACEJ
457:               RefData();                  //aktualizacja danych
47C8  ECAA     CALL 0x1954, 0
47CA  F00C     NOP
458:           //--------------------------------------------------------------    
459:           //-----------ZAKONCZENIE PROCEDURY INICJALIZACJI 
460:               BitSet3(&RSDT1.inSTAT0,_INITDTA,0);	//deaktywacja trybu INICJALIZACJI    
47CC  ECE0     CALL 0x1FC0, 0
47CE  F00F     NOP
47D0  0E07     MOVLW 0x7
47D2  D846     RCALL PL482
47D4  EC48     CALL 0xAC90, 0
47D6  F056     NOP
461:               Mark(_GZ_OFF,0);
47D8  6B7A     CLRF _PFNf_res, BANKED
47DA  0E0A     MOVLW 0xA
47DC  EC1F     CALL 0xB83E, 0
47DE  F05C     NOP
462:               PFNf_toInit=0;
47E0  9011     BCF PFNf_zima, 0, ACCESS
463:               PFNf_LINres=0;
47E2  9607     BCF PFNf_OTTimeout, 3, ACCESS
47E4  D852     RCALL PL666
464:           //--------------------------------------------------------------    
465:           //-----------PRZYGOROWANIE KLAWIATURY DO PRACY    
466:           #if _KEY_BBOARD==0    
467:               ResBufKeyEx(&ky[SS_SET]);
468:               ResBufKeyEx(&ky[SS_OFF]);
469:               ResBufKeyEx(&ky[SS_KUP]);
470:               ResBufKeyEx(&ky[SS_KDW]);
471:           #endif
472:           #if _KEY_BBOARD==1    
473:               ResBufKeyEx(&ky[SS_SET]);
47E6  EC77     CALL 0xBAEE, 0
47E8  F05D     NOP
47EA  EC60     CALL 0x26C0, 0
47EC  F013     NOP
474:               ResBufKeyEx(&ky[SS_KOM]);    
47EE  EC77     CALL 0xBAEE, 0
47F0  F05D     NOP
475:               ResBufKeyEx(&ky[SS_OFF]);
47F2  0EB0     MOVLW 0xB0
47F4  6F74     MOVWF _PFNf_prODP, BANKED
47F6  0E03     MOVLW 0x3
47F8  6F75     MOVWF _PFNf_prn_cs, BANKED
47FA  EC77     CALL 0xBAEE, 0
47FC  F05D     NOP
476:               ResBufKeyEx(&ky[SS_KUP_CW]);
47FE  EC75     CALL 0x26EA, 0
4800  F013     NOP
4802  EC77     CALL 0xBAEE, 0
4804  F05D     NOP
4806  D830     RCALL PL516
477:               ResBufKeyEx(&ky[SS_KDW_CW]);
4808  EC77     CALL 0xBAEE, 0
480A  F05D     NOP
480C  EC44     CALL 0x2688, 0
480E  F013     NOP
478:               ResBufKeyEx(&ky[SS_KUP_CO]);
4810  EC77     CALL 0xBAEE, 0
4812  F05D     NOP
4814  EC3F     CALL 0x267E, 0
4816  F013     NOP
479:               ResBufKeyEx(&ky[SS_KDW_CO]);    
4818  EF77     GOTO 0xBAEE
481A  F05D     NOP
480:           #endif 
481:           }
482:           //--------------------------------------------------------------
483:           
484:           void RefData(void)
485:           {
486:           //read
487:           //STANDARD
488:           	if(RSDT1f_RD_STD)
1954  A612     BTFSS RSDT1f_RD_STD, 3, ACCESS
1956  D193     BRA 0x1C7E
489:           	{
490:           		RSDT1f_RRD_STD=1;		//aktywna blokada na czas interpretacji danych
1958  8A12     BSF RSDT1f_RD_STD, 5, ACCESS
491:           		RSDT1f_RD_STD=0;
195A  9612     BCF RSDT1f_RD_STD, 3, ACCESS
195C  EC29     CALL 0x4852, 0
195E  F024     NOP
492:                   
493:           		PFN.RDZ0=RSDT1.outRDZ0;
494:           		PFN.RDZ1=RSDT1.outRDZ1;
495:           		PFN.RDZ2=RSDT1.outRDZ2;    
496:           		PFN.CO=RSDT1.outCO;
1960  C233     MOVFF 0x233, 0x1D8
1962  F1D8     NOP
497:           		PFN.CW=RSDT1.outCW;
1964  C234     MOVFF 0x234, 0x1D9
1966  F1D9     NOP
498:           		PFN.CS=RSDT1.outCS;	
1968  C235     MOVFF 0x235, 0x1DA
196A  F1DA     NOP
499:           		PFN.IN=RSDT1.outIN;
196C  C236     MOVFF 0x236, 0x1DB
196E  F1DB     NOP
500:           		PFN.VNT=RSDT1.outVNT;
1970  C237     MOVFF 0x237, 0x1DF
1972  F1DF     NOP
501:           		PFN.minPCO=RSDT1.outPCOmn;
1974  C23A     MOVFF 0x23A, 0x1E6
1976  F1E6     NOP
1978  0101     MOVLB 0x1
197A  6BE7     CLRF 0xE7, BANKED
502:           		PFN.maxPCO=RSDT1.outPCOmx;
197C  C23B     MOVFF 0x23B, 0x1E4
197E  F1E4     NOP
1980  6BE5     CLRF 0xE5, BANKED
503:           		PFN.minPCW=RSDT1.outPCWmn;
1982  C23C     MOVFF 0x23C, 0x1EA
1984  F1EA     NOP
1986  6BEB     CLRF k, BANKED
504:           		PFN.maxPCW=RSDT1.outPCWmx;
1988  C23D     MOVFF 0x23D, 0x1E8
198A  F1E8     NOP
198C  6BE9     CLRF zmn, BANKED
505:           		PFN.PPCO=RSDT1.outPPCO;
198E  C23E     MOVFF 0x23E, 0x1E0
1990  F1E0     NOP
506:           		PFN.PPCW=RSDT1.outPPCW;
1992  C23F     MOVFF 0x23F, 0x1E1
1994  F1E1     NOP
507:           		PFN.KAWR=RSDT1.outAWR;
1996  C241     MOVFF 0x241, 0x1E2
1998  F1E2     NOP
508:           		PFN.KERR=RSDT1.outERR;
199A  C240     MOVFF 0x240, 0x1E3
199C  F1E3     NOP
509:           		PFN.PP=RSDT1.outPP;
199E  C243     MOVFF 0x243, 0x1DC
19A0  F1DC     NOP
510:           		PFN.PG=RSDT1.outPG;
19A2  C244     MOVFF 0x244, 0x1DD
19A4  F1DD     NOP
511:           		PFN.rCO=RSDT1.outrCO;
19A6  C24B     MOVFF 0x24B, 0x1F4
19A8  F1F4     NOP
512:           		PFN.rCW=RSDT1.outrCW;
19AA  C24C     MOVFF 0x24C, 0x1F5
19AC  F1F5     NOP
513:                   PFN.ZW=RSDT1.outZW;
19AE  C24D     MOVFF 0x24D, 0x1DE
19B0  F1DE     NOP
514:                   PFN.SETPmin=RSDT1.outSETPmin;
19B2  C24E     MOVFF 0x24E, 0x1FA
19B4  F1FA     NOP
515:                   PFN.SETPmax=RSDT1.outSETPmax;       
19B6  C24F     MOVFF 0x24F, 0x1FB
19B8  F1FB     NOP
516:                   
517:           		PFNf_EnAleg=((PFN.RDZ1&0x0F)==_UNICO); 
19BA  C1D6     MOVFF 0x1D6, _PFNf_set_aleg
19BC  F07D     NOP
19BE  0E0F     MOVLW 0xF
19C0  0100     MOVLB 0x0
19C2  177D     ANDWF _PFNf_set_aleg, F, BANKED
19C4  E102     BNZ 0x19CA
19C6  8405     BSF PFNf_KnfDisErr, 2, ACCESS
19C8  D001     BRA 0x19CC
19CA  9405     BCF PFNf_KnfDisErr, 2, ACCESS
518:           	
519:           		PFNf_opgres=GetBit2(RSDT1.outSTAT0,_PGRES);
19CC  0100     MOVLB 0x0
19CE  DB21     RCALL PL788
19D0  ECC6     CALL 0xB98C, 0
19D2  F05C     NOP
19D4  E302     BNC 0x19DA
19D6  880D     BSF PFNf_plmCO, 4, ACCESS
19D8  D001     BRA 0x19DC
19DA  980D     BCF PFNf_plmCO, 4, ACCESS
520:           		PFNf_opgprg=GetBit2(RSDT1.outSTAT0,_PGPRG);
19DC  0E01     MOVLW 0x1
19DE  DAE1     RCALL PL182
19E0  ECC6     CALL 0xB98C, 0
19E2  F05C     NOP
19E4  E302     BNC 0x19EA
19E6  860D     BSF PFNf_plmCO, 3, ACCESS
19E8  D001     BRA 0x19EC
19EA  960D     BCF PFNf_plmCO, 3, ACCESS
521:                   if(!PFNf_opgres&&!PFNf_opgprg) PFNf_toInit=1;
19EC  A80D     BTFSS PFNf_plmCO, 4, ACCESS
19EE  B60D     BTFSC PFNf_plmCO, 3, ACCESS
19F0  D001     BRA 0x19F4
19F2  8011     BSF PFNf_zima, 0, ACCESS
522:           		PFNf_plmCO=GetBit2(RSDT1.outSTAT0,_PLMCO);
19F4  0E02     MOVLW 0x2
19F6  DAD5     RCALL PL182
19F8  ECC6     CALL 0xB98C, 0
19FA  F05C     NOP
19FC  E302     BNC 0x1A02
19FE  8E0D     BSF PFNf_plmCO, 7, ACCESS
1A00  D001     BRA 0x1A04
1A02  9E0D     BCF PFNf_plmCO, 7, ACCESS
523:           		PFNf_plmCW=GetBit2(RSDT1.outSTAT0,_PLMCW);
1A04  0E03     MOVLW 0x3
1A06  DACD     RCALL PL182
1A08  ECC6     CALL 0xB98C, 0
1A0A  F05C     NOP
1A0C  E302     BNC 0x1A12
1A0E  800E     BSF PFNf_popFN, 0, ACCESS
1A10  D001     BRA 0x1A14
1A12  900E     BCF PFNf_popFN, 0, ACCESS
524:           		PFNf_ofnserw=GetBit2(RSDT1.outSTAT0,_FKSRV);
1A14  0E04     MOVLW 0x4
1A16  DAC5     RCALL PL182
1A18  ECC6     CALL 0xB98C, 0
1A1A  F05C     NOP
1A1C  E302     BNC 0x1A22
1A1E  8E0C     BSF PFNf_off, 7, ACCESS
1A20  D001     BRA 0x1A24
1A22  9E0C     BCF PFNf_off, 7, ACCESS
525:           		PFNf_oaleg=GetBit2(RSDT1.outSTAT0,_ANTYL);
1A24  0E05     MOVLW 0x5
1A26  DABD     RCALL PL182
1A28  ECC6     CALL 0xB98C, 0
1A2A  F05C     NOP
1A2C  E302     BNC 0x1A32
1A2E  840C     BSF PFNf_off, 2, ACCESS
1A30  D001     BRA 0x1A34
1A32  940C     BCF PFNf_off, 2, ACCESS
526:           		PFNf_opKNF=GetBit2(RSDT1.outSTAT0,_KNFPRC);
1A34  0E06     MOVLW 0x6
1A36  DAB5     RCALL PL182
1A38  ECC6     CALL 0xB98C, 0
1A3A  F05C     NOP
1A3C  E302     BNC 0x1A42
1A3E  840D     BSF PFNf_plmCO, 2, ACCESS
1A40  D001     BRA 0x1A44
1A42  940D     BCF PFNf_plmCO, 2, ACCESS
527:           		PFNf_enKNF=GetBit2(RSDT1.outSTAT0,_ENKNF);
1A44  0E07     MOVLW 0x7
1A46  DAAD     RCALL PL182
1A48  ECC6     CALL 0xB98C, 0
1A4A  F05C     NOP
1A4C  E302     BNC 0x1A52
1A4E  8609     BSF PFNf_b_str_nco, 3, ACCESS
1A50  D001     BRA 0x1A54
1A52  9609     BCF PFNf_b_str_nco, 3, ACCESS
528:           
529:           		PFNf_tdzCO=PFNf_plmCO&&GetBit2(RSDT1.outSTAT1,_TdzCO);
1A54  AE0D     BTFSS PFNf_plmCO, 7, ACCESS
1A56  D007     BRA 0x1A66
1A58  0E01     MOVLW 0x1
1A5A  DAB7     RCALL PL238
1A5C  ECC6     CALL 0xB98C, 0
1A5E  F05C     NOP
1A60  E302     BNC 0x1A66
1A62  8810     BSF PFNf_str_nco, 4, ACCESS
1A64  D001     BRA 0x1A68
1A66  9810     BCF PFNf_str_nco, 4, ACCESS
530:           		PFNf_tdzCW=PFNf_plmCW&&GetBit2(RSDT1.outSTAT1,_TdzCW);
1A68  A00E     BTFSS PFNf_popFN, 0, ACCESS
1A6A  D009     BRA 0x1A7E
1A6C  0100     MOVLB 0x0
1A6E  6B74     CLRF _PFNf_prODP, BANKED
1A70  0102     MOVLB 0x2
1A72  5146     MOVF 0x46, W, BANKED
1A74  ECC6     CALL 0xB98C, 0
1A76  F05C     NOP
1A78  E302     BNC 0x1A7E
1A7A  8A10     BSF PFNf_str_nco, 5, ACCESS
1A7C  D001     BRA 0x1A80
1A7E  9A10     BCF PFNf_str_nco, 5, ACCESS
531:           		PFNf_fmsg=GetBit2(RSDT1.outSTAT1,_MSG);
1A80  0E02     MOVLW 0x2
1A82  DAA3     RCALL PL238
1A84  ECC6     CALL 0xB98C, 0
1A86  F05C     NOP
1A88  E302     BNC 0x1A8E
1A8A  860A     BSF PFNf_firstEdge, 3, ACCESS
1A8C  D001     BRA 0x1A90
1A8E  960A     BCF PFNf_firstEdge, 3, ACCESS
532:           		PFNf_ferr=GetBit2(RSDT1.outSTAT1,_ERR);
1A90  0E03     MOVLW 0x3
1A92  DA9B     RCALL PL238
1A94  ECC6     CALL 0xB98C, 0
1A96  F05C     NOP
1A98  E302     BNC 0x1A9E
1A9A  820A     BSF PFNf_firstEdge, 1, ACCESS
1A9C  D001     BRA 0x1AA0
1A9E  920A     BCF PFNf_firstEdge, 1, ACCESS
533:           		PFNf_fL3=GetBit2(RSDT1.outSTAT1,_L3);
1AA0  0E04     MOVLW 0x4
1AA2  DA93     RCALL PL238
1AA4  ECC6     CALL 0xB98C, 0
1AA6  F05C     NOP
1AA8  E302     BNC 0x1AAE
1AAA  800A     BSF PFNf_firstEdge, 0, ACCESS
1AAC  D001     BRA 0x1AB0
1AAE  900A     BCF PFNf_firstEdge, 0, ACCESS
534:           		PFNf_pgd=GetBit2(RSDT1.outSTAT1,_PGD);
1AB0  0E05     MOVLW 0x5
1AB2  DA8B     RCALL PL238
1AB4  ECC6     CALL 0xB98C, 0
1AB6  F05C     NOP
1AB8  E302     BNC 0x1ABE
1ABA  8A0D     BSF PFNf_plmCO, 5, ACCESS
1ABC  D001     BRA 0x1AC0
1ABE  9A0D     BCF PFNf_plmCO, 5, ACCESS
535:           		PFNf_obgCO=GetBit2(RSDT1.outSTAT1,_OBGCO);
1AC0  0E06     MOVLW 0x6
1AC2  DA83     RCALL PL238
1AC4  ECC6     CALL 0xB98C, 0
1AC6  F05C     NOP
1AC8  E302     BNC 0x1ACE
1ACA  860C     BSF PFNf_off, 3, ACCESS
1ACC  D001     BRA 0x1AD0
1ACE  960C     BCF PFNf_off, 3, ACCESS
536:           		PFNf_obgCW=GetBit2(RSDT1.outSTAT1,_OBGCW);
1AD0  0E07     MOVLW 0x7
1AD2  DA7B     RCALL PL238
1AD4  ECC6     CALL 0xB98C, 0
1AD6  F05C     NOP
1AD8  E302     BNC 0x1ADE
1ADA  880C     BSF PFNf_off, 4, ACCESS
1ADC  D001     BRA 0x1AE0
1ADE  980C     BCF PFNf_off, 4, ACCESS
537:           
538:           		PFNf_errCS=GetBit2(RSDT1.outSTAT2,_ErrCS);
1AE0  0E02     MOVLW 0x2
1AE2  DA5A     RCALL PL132
1AE4  ECC6     CALL 0xB98C, 0
1AE6  F05C     NOP
1AE8  E302     BNC 0x1AEE
1AEA  8A09     BSF PFNf_b_str_nco, 5, ACCESS
1AEC  D001     BRA 0x1AF0
1AEE  9A09     BCF PFNf_b_str_nco, 5, ACCESS
539:           		PFNf_errCO=GetBit2(RSDT1.outSTAT2,_ErrCO);
1AF0  0E01     MOVLW 0x1
1AF2  DA52     RCALL PL132
1AF4  ECC6     CALL 0xB98C, 0
1AF6  F05C     NOP
1AF8  E302     BNC 0x1AFE
1AFA  8809     BSF PFNf_b_str_nco, 4, ACCESS
1AFC  D001     BRA 0x1B00
1AFE  9809     BCF PFNf_b_str_nco, 4, ACCESS
540:           		PFNf_errCW=GetBit2(RSDT1.outSTAT2,_ErrCW);
1B00  0100     MOVLB 0x0
1B02  6B74     CLRF _PFNf_prODP, BANKED
1B04  0102     MOVLB 0x2
1B06  5147     MOVF 0x47, W, BANKED
1B08  ECC6     CALL 0xB98C, 0
1B0A  F05C     NOP
1B0C  E302     BNC 0x1B12
1B0E  8C09     BSF PFNf_b_str_nco, 6, ACCESS
1B10  D001     BRA 0x1B14
1B12  9C09     BCF PFNf_b_str_nco, 6, ACCESS
541:           		PFNf_fnoCS=GetBit2(RSDT1.outSTAT2,_CSnmt);
1B14  0E03     MOVLW 0x3
1B16  DA40     RCALL PL132
1B18  ECC6     CALL 0xB98C, 0
1B1A  F05C     NOP
1B1C  E302     BNC 0x1B22
1B1E  880A     BSF PFNf_firstEdge, 4, ACCESS
1B20  D001     BRA 0x1B24
1B22  980A     BCF PFNf_firstEdge, 4, ACCESS
542:           		PFNf_ofzima=GetBit2(RSDT1.outSTAT2,_F_ZIMA);
1B24  0E04     MOVLW 0x4
1B26  DA38     RCALL PL132
1B28  ECC6     CALL 0xB98C, 0
1B2A  F05C     NOP
1B2C  E302     BNC 0x1B32
1B2E  820D     BSF PFNf_plmCO, 1, ACCESS
1B30  D001     BRA 0x1B34
1B32  920D     BCF PFNf_plmCO, 1, ACCESS
543:           		PFNf_oflato=GetBit2(RSDT1.outSTAT2,_F_LATO);
1B34  0E05     MOVLW 0x5
1B36  DA30     RCALL PL132
1B38  ECC6     CALL 0xB98C, 0
1B3A  F05C     NOP
1B3C  E302     BNC 0x1B42
1B3E  8C0C     BSF PFNf_off, 6, ACCESS
1B40  D001     BRA 0x1B44
1B42  9C0C     BCF PFNf_off, 6, ACCESS
544:           		PFNf_ofoff=GetBit2(RSDT1.outSTAT2,_F_OFF);   
1B44  0E06     MOVLW 0x6
1B46  DA28     RCALL PL132
1B48  ECC6     CALL 0xB98C, 0
1B4A  F05C     NOP
1B4C  E302     BNC 0x1B52
1B4E  800D     BSF PFNf_plmCO, 0, ACCESS
1B50  D001     BRA 0x1B54
1B52  900D     BCF PFNf_plmCO, 0, ACCESS
545:           		PFNf_kalVNT=GetBit2(RSDT1.outSTAT2,_KALIB);
1B54  0E07     MOVLW 0x7
1B56  DA20     RCALL PL132
1B58  ECC6     CALL 0xB98C, 0
1B5A  F05C     NOP
1B5C  E302     BNC 0x1B62
1B5E  860B     BSF PFNf_lato, 3, ACCESS
1B60  D001     BRA 0x1B64
1B62  960B     BCF PFNf_lato, 3, ACCESS
546:            
547:           		PFNf_zcfm=GetBit2(RSDT1.outSTAT3,_ZCFM);
1B64  0100     MOVLB 0x0
1B66  6B74     CLRF _PFNf_prODP, BANKED
1B68  0102     MOVLB 0x2
1B6A  5148     MOVF sample, W, BANKED
1B6C  ECC6     CALL 0xB98C, 0
1B6E  F05C     NOP
1B70  E302     BNC 0x1B76
1B72  8611     BSF PFNf_zima, 3, ACCESS
1B74  D001     BRA 0x1B78
1B76  9611     BCF PFNf_zima, 3, ACCESS
548:           		PFNf_vnt=GetBit2(RSDT1.outSTAT3,_VNT_ON);
1B78  0E01     MOVLW 0x1
1B7A  DA32     RCALL PL252
1B7C  ECC6     CALL 0xB98C, 0
1B7E  F05C     NOP
1B80  E302     BNC 0x1B86
1B82  8411     BSF PFNf_zima, 2, ACCESS
1B84  D001     BRA 0x1B88
1B86  9411     BCF PFNf_zima, 2, ACCESS
549:           		PFNf_rozruch=GetBit2(RSDT1.outSTAT3,_ROZ);
1B88  0E02     MOVLW 0x2
1B8A  DA2A     RCALL PL252
1B8C  ECC6     CALL 0xB98C, 0
1B8E  F05C     NOP
1B90  E302     BNC 0x1B96
1B92  860F     BSF PFNf_set_fnserw, 3, ACCESS
1B94  D001     BRA 0x1B98
1B96  960F     BCF PFNf_set_fnserw, 3, ACCESS
550:           		PFNf_errIN=GetBit2(RSDT1.outSTAT3,_ErrIN);
1B98  0E03     MOVLW 0x3
1B9A  DA22     RCALL PL252
1B9C  ECC6     CALL 0xB98C, 0
1B9E  F05C     NOP
1BA0  E302     BNC 0x1BA6
1BA2  8E09     BSF PFNf_b_str_nco, 7, ACCESS
1BA4  D001     BRA 0x1BA8
1BA6  9E09     BCF PFNf_b_str_nco, 7, ACCESS
551:           		PFNf_pmpPWM=GetBit2(RSDT1.outSTAT3,_PMP_PWM);
1BA8  0E04     MOVLW 0x4
1BAA  DA1A     RCALL PL252
1BAC  ECC6     CALL 0xB98C, 0
1BAE  F05C     NOP
1BB0  E302     BNC 0x1BB6
1BB2  820E     BSF PFNf_popFN, 1, ACCESS
1BB4  D001     BRA 0x1BB8
1BB6  920E     BCF PFNf_popFN, 1, ACCESS
552:           		PFNf_trbECO=GetBit2(RSDT1.outSTAT3,_TRB_ECO);
1BB8  0E05     MOVLW 0x5
1BBA  DA12     RCALL PL252
1BBC  ECC6     CALL 0xB98C, 0
1BBE  F05C     NOP
1BC0  E302     BNC 0x1BC6
1BC2  8211     BSF PFNf_zima, 1, ACCESS
1BC4  D001     BRA 0x1BC8
1BC6  9211     BCF PFNf_zima, 1, ACCESS
553:           		PFNf_timZAS=GetBit2(RSDT1.outSTAT3,_TIM_ZAS);   //znacznik pobudzenia CW/stan na wejsciu timera zasobnika
1BC8  0E06     MOVLW 0x6
1BCA  DA0A     RCALL PL252
1BCC  ECC6     CALL 0xB98C, 0
1BCE  F05C     NOP
1BD0  E302     BNC 0x1BD6
1BD2  8C10     BSF PFNf_str_nco, 6, ACCESS
1BD4  D001     BRA 0x1BD8
1BD6  9C10     BCF PFNf_str_nco, 6, ACCESS
554:                   PFNf_pobRT=GetBit2(RSDT1.outSTAT3,_POB_RT);     //znacznik pobudzenia RT
1BD8  0E07     MOVLW 0x7
1BDA  DA02     RCALL PL252
1BDC  ECC6     CALL 0xB98C, 0
1BDE  F05C     NOP
1BE0  E302     BNC 0x1BE6
1BE2  840E     BSF PFNf_popFN, 2, ACCESS
1BE4  D001     BRA 0x1BE8
1BE6  940E     BCF PFNf_popFN, 2, ACCESS
555:                   
556:                   PFNf_prODP=GetBit2(RSDT1.outSTAT4,_PR_ODP);     //znacznik aktywnosci procedury odpowietrzajacej
1BE8  0100     MOVLB 0x0
1BEA  6B74     CLRF _PFNf_prODP, BANKED
1BEC  0102     MOVLB 0x2
1BEE  5149     MOVF RSerial, W, BANKED
1BF0  ECC6     CALL 0xB98C, 0
1BF2  F05C     NOP
1BF4  E302     BNC 0x1BFA
1BF6  880E     BSF PFNf_popFN, 4, ACCESS
1BF8  D001     BRA 0x1BFC
1BFA  980E     BCF PFNf_popFN, 4, ACCESS
1BFC  D9F6     RCALL PL260
557:                   PFNf_popFN=GetBit2(RSDT1.outSTAT4,_POP_FN);     //poprzedni stan przelacznika funkcji (1-lato, 0-pozostale)
1BFE  5149     MOVF RSerial, W, BANKED
1C00  ECC6     CALL 0xB98C, 0
1C02  F05C     NOP
1C04  E302     BNC 0x1C0A
1C06  860E     BSF PFNf_popFN, 3, ACCESS
1C08  D001     BRA 0x1C0C
1C0A  960E     BCF PFNf_popFN, 3, ACCESS
558:                   PFNf_tmpZW=GetBit2(RSDT1.outSTAT4,_TMP_ZW);     //aktywnosc czujnika temperatury zewnetrznej
1C0C  0E02     MOVLW 0x2
1C0E  D9F7     RCALL PL502
1C10  ECC6     CALL 0xB98C, 0
1C12  F05C     NOP
1C14  E302     BNC 0x1C1A
1C16  8E10     BSF PFNf_str_nco, 7, ACCESS
1C18  D001     BRA 0x1C1C
1C1A  9E10     BCF PFNf_str_nco, 7, ACCESS
559:                   PFNf_pgdTP=GetBit2(RSDT1.outSTAT4,_PGD_TP);     //rodzaj wewnetrznego regulatora pogodowego        
1C1C  0E03     MOVLW 0x3
1C1E  D9EF     RCALL PL502
1C20  ECC6     CALL 0xB98C, 0
1C22  F05C     NOP
1C24  E302     BNC 0x1C2A
1C26  8C0D     BSF PFNf_plmCO, 6, ACCESS
1C28  D001     BRA 0x1C2C
1C2A  9C0D     BCF PFNf_plmCO, 6, ACCESS
560:                   
561:           		//poprawka na wersje oprogramowania UNI-02 (kompatybilnosc wsteczna)
562:           		if(PFN.vUNI02<2) PFNf_timZAS=1;
1C2C  0E02     MOVLW 0x2
1C2E  0101     MOVLB 0x1
1C30  61EC     CPFSLT 0xEC, BANKED
1C32  D001     BRA 0x1C36
1C34  8C10     BSF PFNf_str_nco, 6, ACCESS
563:                   if(PFN.vUNI02>2) PFN.ALIN=(PFN.RDZ0&0b11100000)>>5; //adres LIN
1C36  0E02     MOVLW 0x2
1C38  65EC     CPFSGT 0xEC, BANKED
1C3A  D004     BRA 0x1C44
1C3C  39D5     SWAPF CMSGPar, W, BANKED
1C3E  42E8     RRNCF WREG, F, ACCESS
1C40  0B07     ANDLW 0x7
1C42  D001     BRA 0x1C46
564:                   else PFN.ALIN=5;
1C44  0E05     MOVLW 0x5
1C46  6FED     MOVWF 0xED, BANKED
565:                   if(!PFNf_ofnserw) PFNf_LINresSR=0;
1C48  AE0C     BTFSS PFNf_off, 7, ACCESS
1C4A  9A07     BCF PFNf_OTTimeout, 5, ACCESS
566:           		if(PFNf_ofnserw) PFNf_b_ofnserw=1;
1C4C  BE0C     BTFSC PFNf_off, 7, ACCESS
1C4E  8A08     BSF PFNf_b_set_nco, 5, ACCESS
567:           		if(PFNf_ofnserw&&!PFNf_fnserw&&!PFNf_LINresSR) PFNf_fnserw=1;
1C50  BE0C     BTFSC PFNf_off, 7, ACCESS
1C52  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
1C54  D002     BRA 0x1C5A
1C56  AA07     BTFSS PFNf_OTTimeout, 5, ACCESS
1C58  8C0A     BSF PFNf_firstEdge, 6, ACCESS
568:           		if(PFNf_b_ofnserw&&!PFNf_ofnserw) PFNf_fnserw=0;
1C5A  BA08     BTFSC PFNf_b_set_nco, 5, ACCESS
1C5C  BE0C     BTFSC PFNf_off, 7, ACCESS
1C5E  D001     BRA 0x1C62
1C60  9C0A     BCF PFNf_firstEdge, 6, ACCESS
569:                   if(!PFNf_oaleg) PFNf_LINresAL=0;
1C62  A40C     BTFSS PFNf_off, 2, ACCESS
1C64  9807     BCF PFNf_OTTimeout, 4, ACCESS
570:           		if(PFNf_oaleg) PFNf_b_oaleg=1;
1C66  B40C     BTFSC PFNf_off, 2, ACCESS
1C68  8808     BSF PFNf_b_set_nco, 4, ACCESS
571:           		if(PFNf_oaleg&&!PFNf_aleg&&!PFNf_LINresAL) PFNf_aleg=1;
1C6A  B40C     BTFSC PFNf_off, 2, ACCESS
1C6C  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
1C6E  D002     BRA 0x1C74
1C70  A807     BTFSS PFNf_OTTimeout, 4, ACCESS
1C72  8208     BSF PFNf_b_set_nco, 1, ACCESS
572:           		if(PFNf_b_oaleg&&!PFNf_oaleg) PFNf_aleg=0;
1C74  B808     BTFSC PFNf_b_set_nco, 4, ACCESS
1C76  B40C     BTFSC PFNf_off, 2, ACCESS
1C78  D001     BRA 0x1C7C
1C7A  9208     BCF PFNf_b_set_nco, 1, ACCESS
573:           		RSDT1f_RRD_STD=0;
1C7C  9A12     BCF RSDT1f_RD_STD, 5, ACCESS
574:           	}
575:           //write
576:           //STANDARD
577:           	RSDT1.inPCO=(unsigned char)PFN.PCO;
1C7E  C1EE     MOVFF 0x1EE, 0x276
1C80  F276     NOP
578:           	RSDT1.inPCW=(unsigned char)PFN.PCW;
1C82  C1F0     MOVFF 0x1F0, 0x277
1C84  F277     NOP
579:           	RSDT1.inECO=(unsigned char)PFN.ECO;
1C86  C1F2     MOVFF 0x1F2, 0x278
1C88  F278     NOP
580:           
581:           	BitSet3(&RSDT1.inSTAT0,_INITKNF,PFNf_aktywne_KNF);
1C8A  0E79     MOVLW 0x79
1C8C  0100     MOVLB 0x0
1C8E  6F76     MOVWF _PFNf_prn_in, BANKED
1C90  0E02     MOVLW 0x2
1C92  6F77     MOVWF _PFNf_prn_pg, BANKED
1C94  0E00     MOVLW 0x0
1C96  6F78     MOVWF _PFNf_prn_pp, BANKED
1C98  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
1C9A  0E01     MOVLW 0x1
1C9C  6F79     MOVWF _PFNf_prn_res, BANKED
1C9E  EC48     CALL 0xAC90, 0
1CA0  F056     NOP
582:           
583:           	BitSet3(&RSDT1.inSTAT0,_INITSRV,PFNf_fnserw&&!PFNf_ofnserw);
1CA2  6B7E     CLRF _PFNf_set_eco, BANKED
1CA4  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
1CA6  BE0C     BTFSC PFNf_off, 7, ACCESS
1CA8  D002     BRA 0x1CAE
1CAA  0E01     MOVLW 0x1
1CAC  6F7E     MOVWF _PFNf_set_eco, BANKED
1CAE  D988     RCALL PL234
1CB0  0E01     MOVLW 0x1
1CB2  6F78     MOVWF _PFNf_prn_pp, BANKED
1CB4  C07E     MOVFF _PFNf_set_eco, _PFNf_prn_res
1CB6  F079     NOP
1CB8  EC48     CALL 0xAC90, 0
1CBA  F056     NOP
584:           	BitSet3(&RSDT1.inSTAT0,_INITANL,PFNf_aleg&&!PFNf_oaleg);
1CBC  6B7F     CLRF _PFNf_set_fnserw, BANKED
1CBE  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
1CC0  B40C     BTFSC PFNf_off, 2, ACCESS
1CC2  D002     BRA 0x1CC8
1CC4  0E01     MOVLW 0x1
1CC6  6F7F     MOVWF _PFNf_set_fnserw, BANKED
1CC8  D97B     RCALL PL234
1CCA  0E02     MOVLW 0x2
1CCC  6F78     MOVWF _PFNf_prn_pp, BANKED
1CCE  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_res
1CD0  F079     NOP
1CD2  EC48     CALL 0xAC90, 0
1CD4  F056     NOP
585:           	BitSet3(&RSDT1.inSTAT0,_PFN_ZIMA,PFNf_zima&&!PFNf_off);
1CD6  6B80     CLRF _PFNf_set_nco, BANKED
1CD8  B811     BTFSC PFNf_zima, 4, ACCESS
1CDA  BA0C     BTFSC PFNf_off, 5, ACCESS
1CDC  D002     BRA 0x1CE2
1CDE  0E01     MOVLW 0x1
1CE0  6F80     MOVWF _PFNf_set_nco, BANKED
1CE2  D96E     RCALL PL234
1CE4  0E03     MOVLW 0x3
1CE6  6F78     MOVWF _PFNf_prn_pp, BANKED
1CE8  C080     MOVFF _PFNf_set_nco, _PFNf_prn_res
1CEA  F079     NOP
1CEC  EC48     CALL 0xAC90, 0
1CEE  F056     NOP
586:           	BitSet3(&RSDT1.inSTAT0,_PFN_LATO,PFNf_lato&&!PFNf_off);
1CF0  6B81     CLRF _PFNf_set_ncw, BANKED
1CF2  B80B     BTFSC PFNf_lato, 4, ACCESS
1CF4  BA0C     BTFSC PFNf_off, 5, ACCESS
1CF6  D002     BRA 0x1CFC
1CF8  0E01     MOVLW 0x1
1CFA  6F81     MOVWF _PFNf_set_ncw, BANKED
1CFC  D961     RCALL PL234
1CFE  0E04     MOVLW 0x4
1D00  6F78     MOVWF _PFNf_prn_pp, BANKED
1D02  C081     MOVFF _PFNf_set_ncw, _PFNf_prn_res
1D04  F079     NOP
1D06  EC48     CALL 0xAC90, 0
1D08  F056     NOP
1D0A  D95A     RCALL PL234
587:           	BitSet3(&RSDT1.inSTAT0,_PFN_OFF,PFNf_off);
1D0C  0E05     MOVLW 0x5
1D0E  6F78     MOVWF _PFNf_prn_pp, BANKED
1D10  0E00     MOVLW 0x0
1D12  BA0C     BTFSC PFNf_off, 5, ACCESS
1D14  0E01     MOVLW 0x1
1D16  6F79     MOVWF _PFNf_prn_res, BANKED
1D18  EC48     CALL 0xAC90, 0
1D1A  F056     NOP
588:           	BitSet3(&RSDT1.inSTAT0,_PFN_RES,(PFNf_res||PFNf_LINresSR||PFNf_LINresAL));
1D1C  0E01     MOVLW 0x1
1D1E  6F82     MOVWF _PFNf_str_nco, BANKED
1D20  A40F     BTFSS PFNf_set_fnserw, 2, ACCESS
1D22  BA07     BTFSC PFNf_OTTimeout, 5, ACCESS
1D24  D002     BRA 0x1D2A
1D26  A807     BTFSS PFNf_OTTimeout, 4, ACCESS
1D28  6B82     CLRF _PFNf_str_nco, BANKED
1D2A  D94A     RCALL PL234
1D2C  0E06     MOVLW 0x6
1D2E  6F78     MOVWF _PFNf_prn_pp, BANKED
1D30  C082     MOVFF _PFNf_str_nco, _PFNf_prn_res
1D32  F079     NOP
1D34  EC48     CALL 0xAC90, 0
1D36  F056     NOP
1D38  EC0E     CALL 0x481C, 0
1D3A  F024     NOP
589:           
590:           	BitSet3(&RSDT1.inSTAT1,_SRVMAX,PFNf_fns_max);
1D3C  0E00     MOVLW 0x0
1D3E  6F78     MOVWF _PFNf_prn_pp, BANKED
1D40  BA0A     BTFSC PFNf_firstEdge, 5, ACCESS
1D42  0E01     MOVLW 0x1
1D44  6F79     MOVWF _PFNf_prn_res, BANKED
1D46  EC48     CALL 0xAC90, 0
1D48  F056     NOP
1D4A  EC0E     CALL 0x481C, 0
1D4C  F024     NOP
1D4E  D965     RCALL PL792
591:               
592:           #if _KEY_BBOARD==0    
593:           	BitSet3(&RSDT1.inSTAT1,_KPLUS,RdPrt(S_KUP));
594:           	BitSet3(&RSDT1.inSTAT1,_KMINUS,RdPrt(S_KDW));
595:           	BitSet3(&RSDT1.inSTAT1,_KSET,RdPrt(S_SET));
596:           	BitSet3(&RSDT1.inSTAT1,_KOFF,RdPrt(S_OFF));
597:               BitSet3(&RSDT1.inSTAT1,_7KEY,0);                        //znacznik interfejsu 7Key    
598:           #endif
599:           #if _KEY_BBOARD==1    
600:           	BitSet3(&RSDT1.inSTAT1,_KPLUS,RdPrt(S_KUP_CO));
1D50  EC02     CALL 0xBA04, 0
1D52  F05D     NOP
1D54  D930     RCALL PL212
1D56  EC48     CALL 0xAC90, 0
1D58  F056     NOP
1D5A  EC0E     CALL 0x481C, 0
1D5C  F024     NOP
1D5E  D960     RCALL PL798
601:           	BitSet3(&RSDT1.inSTAT1,_KMINUS,RdPrt(S_KDW_CO));
1D60  EC02     CALL 0xBA04, 0
1D62  F05D     NOP
1D64  D928     RCALL PL212
1D66  EC48     CALL 0xAC90, 0
1D68  F056     NOP
1D6A  EC0E     CALL 0x481C, 0
1D6C  F024     NOP
1D6E  D95E     RCALL PL834
602:           	BitSet3(&RSDT1.inSTAT1,_KSET,RdPrt(S_KOM));
1D70  EC02     CALL 0xBA04, 0
1D72  F05D     NOP
1D74  D920     RCALL PL212
1D76  EC48     CALL 0xAC90, 0
1D78  F056     NOP
1D7A  EC0E     CALL 0x481C, 0
1D7C  F024     NOP
1D7E  D953     RCALL PL804
603:           	BitSet3(&RSDT1.inSTAT1,_KOFF,RdPrt(S_OFF));
1D80  EC02     CALL 0xBA04, 0
1D82  F05D     NOP
1D84  D918     RCALL PL212
1D86  EC48     CALL 0xAC90, 0
1D88  F056     NOP
1D8A  EC0E     CALL 0x481C, 0
1D8C  F024     NOP
1D8E  D93C     RCALL PL738
604:               BitSet3(&RSDT1.inSTAT1,_7KEY,1);                        //znacznik interfejsu 7Key    
1D90  EC48     CALL 0xAC90, 0
1D92  F056     NOP
1D94  D92F     RCALL PL350
605:           #endif  
606:               
607:           #if _EXT_BOARD!=0
608:               BitSet3(&RSDT1.inINSTAT,_F10V,PFNf_EnF10V);      //bit aktywnosci interfejsu 10V  
1D96  0E00     MOVLW 0x0
1D98  6F78     MOVWF _PFNf_prn_pp, BANKED
1D9A  B605     BTFSC PFNf_KnfDisErr, 3, ACCESS
1D9C  0E01     MOVLW 0x1
1D9E  6F79     MOVWF _PFNf_prn_res, BANKED
1DA0  EC48     CALL 0xAC90, 0
1DA2  F056     NOP
609:               BitSet3(&RSDT1.inINSTAT,_10V_RT,(PFNf_10V_RT&&PFNf_EnF10V));    //zdalne pobudzenie RT z interfejsu 10V
1DA4  6B83     CLRF _PFNf_str_ncw, BANKED
1DA6  B005     BTFSC PFNf_KnfDisErr, 0, ACCESS
1DA8  A605     BTFSS PFNf_KnfDisErr, 3, ACCESS
1DAA  D002     BRA 0x1DB0
1DAC  0E01     MOVLW 0x1
1DAE  6F83     MOVWF _PFNf_str_ncw, BANKED
1DB0  D921     RCALL PL350
1DB2  0E01     MOVLW 0x1
1DB4  6F78     MOVWF _PFNf_prn_pp, BANKED
1DB6  C083     MOVFF _PFNf_str_ncw, _PFNf_prn_res
1DB8  F079     NOP
1DBA  EC48     CALL 0xAC90, 0
1DBC  F056     NOP
610:               if(!PFNf_EnF10V&&!PFNf_LIN_KSK&&!PFNf_LIN_STR&&!(OTMaster.Ref._Control_Setpoint&&PFNf_FOT))
1DBE  A605     BTFSS PFNf_KnfDisErr, 3, ACCESS
1DC0  BC06     BTFSC PFNf_LIN_CW, 6, ACCESS
1DC2  D007     BRA 0x1DD2
1DC4  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
1DC6  D005     BRA 0x1DD2
1DC8  0101     MOVLB 0x1
1DCA  BD5E     BTFSC 0x5E, 6, BANKED
1DCC  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
611:               {
612:                   PFN.CONTSETP=PFN.SETPmax;
1DCE  C1FB     MOVFF 0x1FB, 0x1F9
1DD0  F1F9     NOP
613:                   RSDT1.inCONTSETP=PFN.CONTSETP;
614:               }
615:               else RSDT1.inCONTSETP=PFN.CONTSETP;  
1DD2  C1F9     MOVFF 0x1F9, 0x27D
1DD4  F27D     NOP
616:               
617:               RSDT1.inSTAT2=PFN.STRB;
1DD6  C1FC     MOVFF 0x1FC, 0x27E
1DD8  F27E     NOP
618:           #else
619:               BitSet3(&RSDT1.inINSTAT,_F10V,0);                //bit aktywnosci interfejsu 10V  
620:               BitSet3(&RSDT1.inINSTAT,_10V_RT,0);              //zdalne pobudzenie RT
621:               RSDT1.inCONTSETP=(unsigned char)PFN.PCO;  
622:               RSDT1.inSTAT2=0;
623:           #endif
624:                   
625:           #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?    
626:               if(PFNf_LIN_CK)         //nadszedl sygnal cykliczny?
1DDA  A006     BTFSS PFNf_LIN_CW, 0, ACCESS
1DDC  D004     BRA 0x1DE6
627:               {
628:                   PFNf_LIN_CK=0;
1DDE  9006     BCF PFNf_LIN_CW, 0, ACCESS
629:                   StartRTS(_RTLCK);
1DE0  0E03     MOVLW 0x3
1DE2  EC45     CALL 0xBC8A, 0
1DE4  F05E     NOP
630:               }
631:               if(RTS(_RTLCK)>=15)     //brak sygnalu cyklicznego? 
1DE6  0E03     MOVLW 0x3
1DE8  EC73     CALL 0xBEE6, 0
1DEA  F05F     NOP
1DEC  6F7D     MOVWF _PFNf_set_aleg, BANKED
1DEE  0E0E     MOVLW 0xE
1DF0  657D     CPFSGT _PFNf_set_aleg, BANKED
1DF2  D007     BRA 0x1E02
632:               {
633:                   PFNf_LIN_EPBCO=0;
1DF4  9806     BCF PFNf_LIN_CW, 4, ACCESS
634:                   PFNf_LIN_PBCO=0;   
1DF6  9E06     BCF PFNf_LIN_CW, 7, ACCESS
635:                   PFNf_LIN_EPBCW=0;
1DF8  9A06     BCF PFNf_LIN_CW, 5, ACCESS
636:                   PFNf_LIN_PBCW=0;
1DFA  9007     BCF PFNf_OTTimeout, 0, ACCESS
637:                   PFNf_LIN_KSK=0;  
1DFC  9C06     BCF PFNf_LIN_CW, 6, ACCESS
638:                   PFNf_LIN_STR=0;
1DFE  9407     BCF PFNf_OTTimeout, 2, ACCESS
639:                   PFNf_LIN_DPGD=0; 
1E00  9406     BCF PFNf_LIN_CW, 2, ACCESS
640:               }
641:               BitSet3(&RSDT1.inSTAT1,_END_ODP,(PFNf_prODP&&PFNf_LIN_ENDO&&PFNf_FLIN));     //deaktywacja procedury odpowietrzajacej
1E02  6B84     CLRF _PFNf_tdzCO, BANKED
1E04  B80E     BTFSC PFNf_popFN, 4, ACCESS
1E06  A606     BTFSS PFNf_LIN_CW, 3, ACCESS
1E08  D004     BRA 0x1E12
1E0A  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1E0C  D002     BRA 0x1E12
1E0E  0E01     MOVLW 0x1
1E10  6F84     MOVWF _PFNf_tdzCO, BANKED
1E12  EC0E     CALL 0x481C, 0
1E14  F024     NOP
1E16  0E05     MOVLW 0x5
1E18  6F78     MOVWF _PFNf_prn_pp, BANKED
1E1A  C084     MOVFF _PFNf_tdzCO, _PFNf_prn_res
1E1C  F079     NOP
1E1E  EC48     CALL 0xAC90, 0
1E20  F056     NOP
642:               if(!PFNf_prODP) PFNf_LIN_ENDO=0;
1E22  A80E     BTFSS PFNf_popFN, 4, ACCESS
1E24  9606     BCF PFNf_LIN_CW, 3, ACCESS
643:               if(!PFNf_LIN_EPBCO)     //nieaktywne pobudzenie cykliczne?
1E26  B806     BTFSC PFNf_LIN_CW, 4, ACCESS
1E28  D00E     BRA 0x1E46
644:               {
645:                   BitSet3(&RSDT1.inLNSTAT,_LN_RT,(PFNf_LIN_RT&&PFNf_FLIN));                //zdalne pobudzenie RT
1E2A  6B85     CLRF _PFNf_tdzCW, BANKED
1E2C  B207     BTFSC PFNf_OTTimeout, 1, ACCESS
1E2E  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1E30  D002     BRA 0x1E36
1E32  0E01     MOVLW 0x1
1E34  6F85     MOVWF _PFNf_tdzCW, BANKED
1E36  D8BA     RCALL PL184
1E38  0E01     MOVLW 0x1
1E3A  6F78     MOVWF _PFNf_prn_pp, BANKED
1E3C  C085     MOVFF _PFNf_tdzCW, _PFNf_prn_res
1E3E  F079     NOP
1E40  EC48     CALL 0xAC90, 0
1E42  F056     NOP
646:               }
1E44  D00E     BRA 0x1E62
647:               else
648:               {
649:                   PFNf_LIN_RT=0;
1E46  9207     BCF PFNf_OTTimeout, 1, ACCESS
650:                   BitSet3(&RSDT1.inLNSTAT,_LN_RT,(PFNf_LIN_PBCO&&PFNf_FLIN));                //zdalne pobudzenie RT        
1E48  6B86     CLRF _PFNf_timZAS, BANKED
1E4A  BE06     BTFSC PFNf_LIN_CW, 7, ACCESS
1E4C  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1E4E  D002     BRA 0x1E54
1E50  0E01     MOVLW 0x1
1E52  6F86     MOVWF _PFNf_timZAS, BANKED
1E54  D8AB     RCALL PL184
1E56  0E01     MOVLW 0x1
1E58  6F78     MOVWF _PFNf_prn_pp, BANKED
1E5A  C086     MOVFF _PFNf_timZAS, _PFNf_prn_res
1E5C  F079     NOP
1E5E  EC48     CALL 0xAC90, 0
1E60  F056     NOP
651:               }
652:               if(!PFNf_LIN_EPBCW)     //nieaktywne pobudzenie cykliczne?
1E62  BA06     BTFSC PFNf_LIN_CW, 5, ACCESS
1E64  D010     BRA 0x1E86
653:               {   
654:                   BitSet3(&RSDT1.inLNSTAT,_LN_CW,(PFNf_EnAleg&&PFNf_LIN_CW&&PFNf_FLIN));   //zdalne pobudzenie timera zasobnika  (dla kotlow jednofunkcyjnych))
1E66  6B87     CLRF _PFNf_tmpZW, BANKED
1E68  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
1E6A  A206     BTFSS PFNf_LIN_CW, 1, ACCESS
1E6C  D004     BRA 0x1E76
1E6E  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1E70  D002     BRA 0x1E76
1E72  0E01     MOVLW 0x1
1E74  6F87     MOVWF _PFNf_tmpZW, BANKED
1E76  D89A     RCALL PL184
1E78  0E02     MOVLW 0x2
1E7A  6F78     MOVWF _PFNf_prn_pp, BANKED
1E7C  C087     MOVFF _PFNf_tmpZW, _PFNf_prn_res
1E7E  F079     NOP
1E80  EC48     CALL 0xAC90, 0
1E82  F056     NOP
655:               }
1E84  D010     BRA 0x1EA6
656:               else
657:               {
658:                   PFNf_LIN_CW=0;
1E86  9206     BCF PFNf_LIN_CW, 1, ACCESS
659:                   BitSet3(&RSDT1.inLNSTAT,_LN_CW,(PFNf_EnAleg&&PFNf_LIN_PBCW&&PFNf_FLIN)); //zdalne pobudzenie timera zasobnika  (dla kotlow jednofunkcyjnych))        
1E88  6B88     CLRF _PFNf_toInit, BANKED
1E8A  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
1E8C  A007     BTFSS PFNf_OTTimeout, 0, ACCESS
1E8E  D004     BRA 0x1E98
1E90  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1E92  D002     BRA 0x1E98
1E94  0E01     MOVLW 0x1
1E96  6F88     MOVWF _PFNf_toInit, BANKED
1E98  D889     RCALL PL184
1E9A  0E02     MOVLW 0x2
1E9C  6F78     MOVWF _PFNf_prn_pp, BANKED
1E9E  C088     MOVFF _PFNf_toInit, _PFNf_prn_res
1EA0  F079     NOP
1EA2  EC48     CALL 0xAC90, 0
1EA4  F056     NOP
660:               }
661:               BitSet3(&RSDT1.inLNSTAT,_LN_KSK,(PFNf_LIN_KSK&&PFNf_FLIN));                  //znacznik pracy w trybie kaskady
1EA6  6B89     CLRF _PFNf_trbECO, BANKED
1EA8  BC06     BTFSC PFNf_LIN_CW, 6, ACCESS
1EAA  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1EAC  D002     BRA 0x1EB2
1EAE  0E01     MOVLW 0x1
1EB0  6F89     MOVWF _PFNf_trbECO, BANKED
1EB2  D87C     RCALL PL184
1EB4  0E03     MOVLW 0x3
1EB6  6F78     MOVWF _PFNf_prn_pp, BANKED
1EB8  C089     MOVFF _PFNf_trbECO, _PFNf_prn_res
1EBA  F079     NOP
1EBC  EC48     CALL 0xAC90, 0
1EBE  F056     NOP
662:               BitSet3(&RSDT1.inLNSTAT,_LN_STR,(PFNf_LIN_STR&&PFNf_FLIN));                  //znacznik pracy w trybie sterowania z managera strefy lub z regulatora RT 
1EC0  6B8A     CLRF _PFNf_vnt, BANKED
1EC2  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
1EC4  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1EC6  D002     BRA 0x1ECC
1EC8  0E01     MOVLW 0x1
1ECA  6F8A     MOVWF _PFNf_vnt, BANKED
1ECC  D86F     RCALL PL184
1ECE  0E04     MOVLW 0x4
1ED0  6F78     MOVWF _PFNf_prn_pp, BANKED
1ED2  C08A     MOVFF _PFNf_vnt, _PFNf_prn_res
1ED4  F079     NOP
1ED6  EC48     CALL 0xAC90, 0
1ED8  F056     NOP
663:               BitSet3(&RSDT1.inLNSTAT,_LN_DPGD,(PFNf_LIN_DPGD&&PFNf_FLIN));                //znacznik dezaktywacji wewnetrznego regulatora pogodowego
1EDA  6B8B     CLRF _PFNf_zcfm, BANKED
1EDC  B406     BTFSC PFNf_LIN_CW, 2, ACCESS
1EDE  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
1EE0  D002     BRA 0x1EE6
1EE2  0E01     MOVLW 0x1
1EE4  6F8B     MOVWF _PFNf_zcfm, BANKED
1EE6  D862     RCALL PL184
1EE8  0E05     MOVLW 0x5
1EEA  6F78     MOVWF _PFNf_prn_pp, BANKED
1EEC  C08B     MOVFF _PFNf_zcfm, _PFNf_prn_res
1EEE  F079     NOP
1EF0  EC48     CALL 0xAC90, 0
1EF2  F056     NOP
664:           
665:           #else
666:               BitSet3(&RSDT1.inLNSTAT,_LN_RT,0);                //zdalne pobudzenie RT  
667:               BitSet3(&RSDT1.inLNSTAT,_LN_CW,0);                //zdalne pobudzenie timera zasobnika
668:               BitSet3(&RSDT1.inLNSTAT,_LN_KSK,0);               //znacznik pracy w trybie kaskady  
669:               BitSet3(&RSDT1.inLNSTAT,_LN_STR,0);               //znacznik pracy w trybie sterowania z managera strefy zlub regulatora RT
670:               BitSet3(&RSDT1.inLNSTAT,_LN_DPGD,0);              //znacznik dezaktywacji wewnetrznego regulatora pogodowego  
671:               BitSet3(&RSDT1.inSTAT1,_END_ODP,0);               //deaktywacja procedury odpowietrzajacej
672:           #endif    
673:           
674:           #if (_EXT_BOARD>=3)                     //aktywowany modul OT?    
675:               if(OTMaster.Ref._Status)
1EF4  0101     MOVLB 0x1
1EF6  A35E     BTFSS 0x5E, 1, BANKED
1EF8  D011     BRA 0x1F1C
676:               {
677:                   BitSet3(&RSDT1.inINSTAT,_OT_RT,(OTMaster.Status._CH_enable&&PFNf_FOT));                //zdalne pobudzenie RT   
1EFA  0100     MOVLB 0x0
1EFC  6B8C     CLRF _PFNf_zima, BANKED
1EFE  0101     MOVLB 0x1
1F00  B165     BTFSC 0x65, 0, BANKED
1F02  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
1F04  D003     BRA 0x1F0C
1F06  0E01     MOVLW 0x1
1F08  0100     MOVLB 0x0
1F0A  6F8C     MOVWF _PFNf_zima, BANKED
1F0C  D863     RCALL PL240
1F0E  0E03     MOVLW 0x3
1F10  6F78     MOVWF _PFNf_prn_pp, BANKED
1F12  C08C     MOVFF _PFNf_zima, _PFNf_prn_res
1F14  F079     NOP
1F16  EC48     CALL 0xAC90, 0
1F18  F056     NOP
678:               }
1F1A  D006     BRA 0x1F28
679:               else
680:               {
681:                   BitSet3(&RSDT1.inINSTAT,_OT_RT,0);                //zdalne pobudzenie RT          
1F1C  D85B     RCALL PL240
1F1E  0E03     MOVLW 0x3
1F20  EC30     CALL 0x4860, 0
1F22  F024     NOP
1F24  EC48     CALL 0xAC90, 0
1F26  F056     NOP
682:               }
683:               if(OTMaster.Ref._Status)
1F28  0101     MOVLB 0x1
1F2A  A35E     BTFSS 0x5E, 1, BANKED
1F2C  D013     BRA 0x1F54
684:               {
685:                   BitSet3(&RSDT1.inINSTAT,_OT_CW,(PFNf_EnAleg&&OTMaster.Status._DHW_enable&&PFNf_FOT));   //zdalne pobudzenie timera zasobnika  (dla kotlow jednofunkcyjnych))
1F2E  0100     MOVLB 0x0
1F30  6B8D     CLRF _PWMf_ENPWM2, BANKED
1F32  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
1F34  D007     BRA 0x1F44
1F36  0101     MOVLB 0x1
1F38  B365     BTFSC 0x65, 1, BANKED
1F3A  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
1F3C  D003     BRA 0x1F44
1F3E  0E01     MOVLW 0x1
1F40  0100     MOVLB 0x0
1F42  6F8D     MOVWF _PWMf_ENPWM2, BANKED
1F44  D847     RCALL PL240
1F46  0E04     MOVLW 0x4
1F48  6F78     MOVWF _PFNf_prn_pp, BANKED
1F4A  C08D     MOVFF _PWMf_ENPWM2, _PFNf_prn_res
1F4C  F079     NOP
1F4E  EC48     CALL 0xAC90, 0
1F50  F056     NOP
686:               }
1F52  D006     BRA 0x1F60
687:               else
688:               {
689:                   BitSet3(&RSDT1.inINSTAT,_OT_CW,0);                  //zdalne pobudzenie timera zasobnika  (dla kotlow jednofunkcyjnych))        
1F54  D83F     RCALL PL240
1F56  0E04     MOVLW 0x4
1F58  EC30     CALL 0x4860, 0
1F5A  F024     NOP
1F5C  EC48     CALL 0xAC90, 0
1F5E  F056     NOP
690:               }
691:               BitSet3(&RSDT1.inINSTAT,_OT_STR,(OTMaster.Ref._Control_Setpoint&&PFNf_FOT));                  //znacznik pracy z zewnetrnie regulowanym SETP 
1F60  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
1F62  0101     MOVLB 0x1
1F64  BD5E     BTFSC 0x5E, 6, BANKED
1F66  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
1F68  D003     BRA 0x1F70
1F6A  0E01     MOVLW 0x1
1F6C  0100     MOVLB 0x0
1F6E  6F8E     MOVWF _RSDT1f_NewLIDN, BANKED
1F70  D831     RCALL PL240
1F72  0E05     MOVLW 0x5
1F74  6F78     MOVWF _PFNf_prn_pp, BANKED
1F76  C08E     MOVFF _RSDT1f_NewLIDN, _PFNf_prn_res
1F78  F079     NOP
1F7A  EC48     CALL 0xAC90, 0
1F7C  F056     NOP
692:               BitSet3(&RSDT1.inINSTAT,_OT_DPGD,(PFNf_OT_DPGD&&PFNf_FOT));                                   //dezaktywacja wewnetrznego regulatora pogodowego  
1F7E  6B8F     CLRF _RSDT1f_NoRespToLIN, BANKED
1F80  BE07     BTFSC PFNf_OTTimeout, 7, ACCESS
1F82  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
1F84  D002     BRA 0x1F8A
1F86  0E01     MOVLW 0x1
1F88  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
1F8A  D834     RCALL PL350
1F8C  0E06     MOVLW 0x6
1F8E  6F78     MOVWF _PFNf_prn_pp, BANKED
1F90  C08F     MOVFF _RSDT1f_NoRespToLIN, _PFNf_prn_res
1F92  F079     NOP
1F94  EF48     GOTO 0xAC90
1F96  F056     NOP
693:               //BitSet3(&RSDT1.inINSTAT,_OT_DPGD,1);                                   //dezaktywacja wewnetrznego regulatora pogodowego
694:           #else
695:               BitSet3(&RSDT1.inINSTAT,_OT_RT,0);                //zdalne pobudzenie RT  
696:               BitSet3(&RSDT1.inINSTAT,_OT_CW,0);                //zdalne pobudzenie timera zasobnika  
697:               BitSet3(&RSDT1.inINSTAT,_OT_STR,0);               //znacznik pracy w trybie sterowania z managera strefy lub z regulatora RT 
698:               BitSet3(&RSDT1.inINSTAT,_OT_DPGD,0);              //dezaktywacja wewnetrznego regulatora pogodowego    
699:           #endif     
700:           }
701:           //--------------------------------------------------------------
702:           void MarkMinMax(unsigned char shCW,unsigned char shCO)
945E  6F81     MOVWF _PFNf_set_ncw, BANKED
703:           {
704:           	Mark(_GZ_MNCW,shCW&&(PFN.PCW<=PFN.minPCW));
9460  0100     MOVLB 0x0
9462  6B7D     CLRF _PFNf_set_aleg, BANKED
9464  5181     MOVF _PFNf_set_ncw, W, BANKED
9466  E009     BZ 0x947A
9468  0101     MOVLB 0x1
946A  51F0     MOVF 0xF0, W, BANKED
946C  5DEA     SUBWF __pdataBANK0, W, BANKED
946E  51F1     MOVF 0xF1, W, BANKED
9470  59EB     SUBWFB k, W, BANKED
9472  E303     BNC 0x947A
9474  0E01     MOVLW 0x1
9476  0100     MOVLB 0x0
9478  6F7D     MOVWF _PFNf_set_aleg, BANKED
947A  C07D     MOVFF _PFNf_set_aleg, _PFNf_res
947C  F07A     NOP
947E  0E0C     MOVLW 0xC
9480  EC1F     CALL 0xB83E, 0
9482  F05C     NOP
705:           	Mark(_GZ_MXCW,shCW&&(PFN.PCW>=PFN.maxPCW));
9484  6B7E     CLRF _PFNf_set_eco, BANKED
9486  5181     MOVF _PFNf_set_ncw, W, BANKED
9488  E009     BZ 0x949C
948A  0101     MOVLB 0x1
948C  51E8     MOVF 0xE8, W, BANKED
948E  5DF0     SUBWF 0xF0, W, BANKED
9490  51E9     MOVF zmn, W, BANKED
9492  59F1     SUBWFB 0xF1, W, BANKED
9494  E303     BNC 0x949C
9496  0E01     MOVLW 0x1
9498  0100     MOVLB 0x0
949A  6F7E     MOVWF _PFNf_set_eco, BANKED
949C  C07E     MOVFF _PFNf_set_eco, _PFNf_res
949E  F07A     NOP
94A0  0E0B     MOVLW 0xB
94A2  EC1F     CALL 0xB83E, 0
94A4  F05C     NOP
706:           	Mark(_GZ_MNCO,shCO&&(PFN.PCO<=PFN.minPCO));
94A6  6B7F     CLRF _PFNf_set_fnserw, BANKED
94A8  517C     MOVF _PFNf_setKey, W, BANKED
94AA  E009     BZ 0x94BE
94AC  0101     MOVLB 0x1
94AE  51EE     MOVF 0xEE, W, BANKED
94B0  5DE6     SUBWF 0xE6, W, BANKED
94B2  51EF     MOVF 0xEF, W, BANKED
94B4  59E7     SUBWFB 0xE7, W, BANKED
94B6  E303     BNC 0x94BE
94B8  0E01     MOVLW 0x1
94BA  0100     MOVLB 0x0
94BC  6F7F     MOVWF _PFNf_set_fnserw, BANKED
94BE  C07F     MOVFF _PFNf_set_fnserw, _PFNf_res
94C0  F07A     NOP
94C2  0E0E     MOVLW 0xE
94C4  EC1F     CALL 0xB83E, 0
94C6  F05C     NOP
707:           	Mark(_GZ_MXCO,shCO&&(PFN.PCO>=PFN.maxPCO));
94C8  6B80     CLRF _PFNf_set_nco, BANKED
94CA  517C     MOVF _PFNf_setKey, W, BANKED
94CC  E009     BZ 0x94E0
94CE  0101     MOVLB 0x1
94D0  51E4     MOVF 0xE4, W, BANKED
94D2  5DEE     SUBWF 0xEE, W, BANKED
94D4  51E5     MOVF 0xE5, W, BANKED
94D6  59EF     SUBWFB 0xEF, W, BANKED
94D8  E303     BNC 0x94E0
94DA  0E01     MOVLW 0x1
94DC  0100     MOVLB 0x0
94DE  6F80     MOVWF _PFNf_set_nco, BANKED
94E0  C080     MOVFF _PFNf_set_nco, _PFNf_res
94E2  F07A     NOP
94E4  0E0D     MOVLW 0xD
94E6  EF1F     GOTO 0xB83E
94E8  F05C     NOP
708:           }
709:           void MarkMinMaxECO(void)
710:           {
711:           	Mark(_GZ_MNCW,0);
AE00  6B7A     CLRF _PFNf_res, BANKED
AE02  0E0C     MOVLW 0xC
AE04  EC1F     CALL 0xB83E, 0
AE06  F05C     NOP
712:           	Mark(_GZ_MXCW,0);
AE08  6B7A     CLRF _PFNf_res, BANKED
AE0A  0E0B     MOVLW 0xB
AE0C  EC1F     CALL 0xB83E, 0
AE0E  F05C     NOP
713:           	Mark(_GZ_MNCO,PFN.ECO<=1);
AE10  0101     MOVLB 0x1
AE12  51F3     MOVF 0xF3, W, BANKED
AE14  E105     BNZ 0xAE20
AE16  0E02     MOVLW 0x2
AE18  5DF2     SUBWF 0xF2, W, BANKED
AE1A  E202     BC 0xAE20
AE1C  0E01     MOVLW 0x1
AE1E  D001     BRA 0xAE22
AE20  0E00     MOVLW 0x0
AE22  0100     MOVLB 0x0
AE24  6F7A     MOVWF _PFNf_res, BANKED
AE26  0E0E     MOVLW 0xE
AE28  EC1F     CALL 0xB83E, 0
AE2A  F05C     NOP
714:           	Mark(_GZ_MXCO,PFN.ECO>=9);
AE2C  0101     MOVLB 0x1
AE2E  51F3     MOVF 0xF3, W, BANKED
AE30  E103     BNZ 0xAE38
AE32  0E09     MOVLW 0x9
AE34  5DF2     SUBWF 0xF2, W, BANKED
AE36  E302     BNC 0xAE3C
AE38  0E01     MOVLW 0x1
AE3A  D001     BRA 0xAE3E
AE3C  0E00     MOVLW 0x0
AE3E  0100     MOVLB 0x0
AE40  6F7A     MOVWF _PFNf_res, BANKED
AE42  0E0D     MOVLW 0xD
AE44  EF1F     GOTO 0xB83E
AE46  F05C     NOP
715:           }
716:           //--------------------------------------------------------------
717:           #if _TDEMO==0
718:           
719:           void PrintVerBoards(unsigned char ref)
5C6A  0100     MOVLB 0x0
5C6C  6F82     MOVWF _PFNf_str_nco, BANKED
720:           {
721:           	if(ref)
5C6E  5182     MOVF _PFNf_str_nco, W, BANKED
5C70  E101     BNZ 0x5C74
5C72  D0E1     BRA 0x5E36
722:           	{
723:            		M.PVB=0;
5C74  0101     MOVLB 0x1
5C76  6BC6     CLRF 0xC6, BANKED
724:           		StartRTdS(_RTVER);
5C78  0E06     MOVLW 0x6
5C7A  EF55     GOTO 0xBCAA
5C7C  F05E     NOP
725:           		return;
726:           	}
727:           	switch(M.PVB)
5E36  0101     MOVLB 0x1
728:           	{
729:           		case 0:							
730:           			ClrDig(1,1,0);				//wyczysc ekran
5C7E  0E01     MOVLW 0x1
5C80  0100     MOVLB 0x0
5C82  6F7E     MOVWF _PFNf_set_eco, BANKED
5C84  D8F3     RCALL PL612
5C86  EC54     CALL 0x9AA8, 0
5C88  F04D     NOP
731:           			Mark(_GZ_MXCW,0);			//wygas migajacy symbol max
5C8A  6B7A     CLRF _PFNf_res, BANKED
5C8C  0E0B     MOVLW 0xB
5C8E  EC1F     CALL 0xB83E, 0
5C90  F05C     NOP
732:           			Mark(_GZ_OFF,0);			//wygas migajacy symbol OFF
5C92  6B7A     CLRF _PFNf_res, BANKED
5C94  0E0A     MOVLW 0xA
5C96  EC1F     CALL 0xB83E, 0
5C98  F05C     NOP
733:           			StartRTdS(_RTVER);
5C9A  0E06     MOVLW 0x6
5C9C  EC55     CALL 0xBCAA, 0
5C9E  F05E     NOP
734:           			M.PVB=1;
5CA0  0E01     MOVLW 0x1
5CA2  0101     MOVLB 0x1
5CA4  6FC6     MOVWF 0xC6, BANKED
735:           			break;
5CA6  0C01     RETLW 0x1
736:           		case 1:	//b1						
737:           			if(RTdS(_RTVER)<5) return;
5CA8  0E06     MOVLW 0x6
5CAA  EC8B     CALL 0xBF16, 0
5CAC  F05F     NOP
5CAE  6F81     MOVWF _PFNf_set_ncw, BANKED
5CB0  0E05     MOVLW 0x5
5CB2  6181     CPFSLT _PFNf_set_ncw, BANKED
5CB4  D001     BRA 0x5CB8
5CB6  0C05     RETLW 0x5
738:           			StartRTdS(_RTVER);
5CB8  0E06     MOVLW 0x6
5CBA  EC55     CALL 0xBCAA, 0
5CBC  F05E     NOP
739:           			PrintVER(0xb1,PFN.vUNI02,1);			//wyswietl parametr dla b1 
5CBE  C1EC     MOVFF 0x1EC, _PFNf_set_eco
5CC0  F07E     NOP
5CC2  0E01     MOVLW 0x1
5CC4  6F7F     MOVWF _PFNf_set_fnserw, BANKED
5CC6  0EB1     MOVLW 0xB1
5CC8  EC93     CALL 0x9B26, 0
5CCA  F04D     NOP
740:           			M.PVB=2;
5CCC  0E02     MOVLW 0x2
5CCE  0101     MOVLB 0x1
5CD0  6FC6     MOVWF 0xC6, BANKED
741:           		break;
5CD2  0C02     RETLW 0x2
742:           		case 2:							
743:           			if(RTdS(_RTVER)<=15) return;
5CD4  0E06     MOVLW 0x6
5CD6  EC8B     CALL 0xBF16, 0
5CD8  F05F     NOP
5CDA  6F81     MOVWF _PFNf_set_ncw, BANKED
5CDC  0E10     MOVLW 0x10
5CDE  6181     CPFSLT _PFNf_set_ncw, BANKED
5CE0  D001     BRA 0x5CE4
5CE2  0C10     RETLW 0x10
744:           			StartRTdS(_RTVER);
5CE4  0E06     MOVLW 0x6
5CE6  EC55     CALL 0xBCAA, 0
5CE8  F05E     NOP
745:           			ClrDig(1,1,0);				//wyczysc ekran
5CEA  0E01     MOVLW 0x1
5CEC  6F7E     MOVWF _PFNf_set_eco, BANKED
5CEE  D8BE     RCALL PL612
5CF0  EC54     CALL 0x9AA8, 0
5CF2  F04D     NOP
746:           			M.PVB=3;
5CF4  0E03     MOVLW 0x3
5CF6  0101     MOVLB 0x1
5CF8  6FC6     MOVWF 0xC6, BANKED
747:           		break;
5CFA  0C03     RETLW 0x3
748:           		case 3://b2
749:           			if(RTdS(_RTVER)<5) return;
5CFC  0E06     MOVLW 0x6
5CFE  EC8B     CALL 0xBF16, 0
5D00  F05F     NOP
5D02  6F81     MOVWF _PFNf_set_ncw, BANKED
5D04  0E05     MOVLW 0x5
5D06  6181     CPFSLT _PFNf_set_ncw, BANKED
5D08  D001     BRA 0x5D0C
5D0A  0C05     RETLW 0x5
750:           			StartRTdS(_RTVER);
5D0C  0E06     MOVLW 0x6
5D0E  EC55     CALL 0xBCAA, 0
5D10  F05E     NOP
751:           			PrintVER(0xb2,_WERSJA,1);	//wyswietl paranetr dla b2
5D12  0E0B     MOVLW 0xB
5D14  6F7E     MOVWF _PFNf_set_eco, BANKED
5D16  0E01     MOVLW 0x1
5D18  6F7F     MOVWF _PFNf_set_fnserw, BANKED
5D1A  0EB2     MOVLW 0xB2
5D1C  EC93     CALL 0x9B26, 0
5D1E  F04D     NOP
752:           			M.PVB=4;
5D20  0E04     MOVLW 0x4
5D22  0101     MOVLB 0x1
5D24  6FC6     MOVWF 0xC6, BANKED
753:           		break;
5D26  0C04     RETLW 0x4
754:           		case 4:
755:           			if(RTdS(_RTVER)<=15) return;
5D28  0E06     MOVLW 0x6
5D2A  EC8B     CALL 0xBF16, 0
5D2C  F05F     NOP
5D2E  6F81     MOVWF _PFNf_set_ncw, BANKED
5D30  0E10     MOVLW 0x10
5D32  6181     CPFSLT _PFNf_set_ncw, BANKED
5D34  D001     BRA 0x5D38
5D36  0C10     RETLW 0x10
756:           			StartRTdS(_RTVER);
5D38  0E06     MOVLW 0x6
5D3A  EC55     CALL 0xBCAA, 0
5D3C  F05E     NOP
757:           			ClrDig(1,1,0);				//wyczysc ekran
5D3E  0E01     MOVLW 0x1
5D40  6F7E     MOVWF _PFNf_set_eco, BANKED
5D42  D894     RCALL PL612
5D44  EC54     CALL 0x9AA8, 0
5D46  F04D     NOP
758:           			M.PVB=5;
5D48  0E05     MOVLW 0x5
5D4A  0101     MOVLB 0x1
5D4C  6FC6     MOVWF 0xC6, BANKED
759:           		break;
5D4E  0C05     RETLW 0x5
760:           		case 5://1F lub 2F
761:           			if(RTdS(_RTVER)<5) return;
5D50  0E06     MOVLW 0x6
5D52  EC8B     CALL 0xBF16, 0
5D54  F05F     NOP
5D56  6F81     MOVWF _PFNf_set_ncw, BANKED
5D58  0E05     MOVLW 0x5
5D5A  6181     CPFSLT _PFNf_set_ncw, BANKED
5D5C  D001     BRA 0x5D60
5D5E  0C05     RETLW 0x5
762:           			StartRTdS(_RTVER);
5D60  0E06     MOVLW 0x6
5D62  EC55     CALL 0xBCAA, 0
5D64  F05E     NOP
763:           #if (_EXT_BOARD>=2)            
764:                       if(PFN.vUNI02<=2)
5D66  0E03     MOVLW 0x3
5D68  0101     MOVLB 0x1
5D6A  61EC     CPFSLT 0xEC, BANKED
5D6C  D00C     BRA 0x5D86
765:                       {
766:                           if(!PFNf_EnAleg) PrintVER(0x2F,0,1);	//wyswietl 2F dla kotla dwufunkcyjnego
5D6E  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
5D70  D005     BRA 0x5D7C
5D72  D87F     RCALL PL732
5D74  0E2F     MOVLW 0x2F
5D76  EC93     CALL 0x9B26, 0
5D78  F04D     NOP
5D7A  D02C     BRA 0x5DD4
767:                           else PrintVER(0x1F,0,1);				//wyswietl 1F dla kotla jednofunkcyjnego
5D7C  D87A     RCALL PL732
5D7E  0E1F     MOVLW 0x1F
5D80  EC93     CALL 0x9B26, 0
5D82  F04D     NOP
5D84  D027     BRA 0x5DD4
768:                       }
769:                       else
770:                       {
771:                           if(!PFNf_EnAleg) PrintVER(0x2F,(PFN.ALIN<5)?PFN.ALIN:(-1),1);	//wyswietl 2F dla kotla dwufunkcyjnego
5D86  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
5D88  D013     BRA 0x5DB0
5D8A  0E04     MOVLW 0x4
5D8C  65ED     CPFSGT 0xED, BANKED
5D8E  D004     BRA 0x5D98
5D90  0100     MOVLB 0x0
5D92  6983     SETF _PFNf_str_ncw, BANKED
5D94  6984     SETF _PFNf_tdzCO, BANKED
5D96  D004     BRA 0x5DA0
5D98  C1ED     MOVFF 0x1ED, _PFNf_str_ncw
5D9A  F083     NOP
5D9C  0100     MOVLB 0x0
5D9E  6B84     CLRF _PFNf_tdzCO, BANKED
5DA0  C083     MOVFF _PFNf_str_ncw, _PFNf_set_eco
5DA2  F07E     NOP
5DA4  0E01     MOVLW 0x1
5DA6  6F7F     MOVWF _PFNf_set_fnserw, BANKED
5DA8  0E2F     MOVLW 0x2F
5DAA  EC93     CALL 0x9B26, 0
5DAC  F04D     NOP
5DAE  D012     BRA 0x5DD4
772:                           else PrintVER(0x1F,(PFN.ALIN<5)?PFN.ALIN:(-1),1);				//wyswietl 1F dla kotla jednofunkcyjnego
5DB0  0E04     MOVLW 0x4
5DB2  65ED     CPFSGT 0xED, BANKED
5DB4  D004     BRA 0x5DBE
5DB6  0100     MOVLB 0x0
5DB8  6985     SETF _PFNf_tdzCW, BANKED
5DBA  6986     SETF _PFNf_timZAS, BANKED
5DBC  D004     BRA 0x5DC6
5DBE  C1ED     MOVFF 0x1ED, _PFNf_tdzCW
5DC0  F085     NOP
5DC2  0100     MOVLB 0x0
5DC4  6B86     CLRF _PFNf_timZAS, BANKED
5DC6  C085     MOVFF _PFNf_tdzCW, _PFNf_set_eco
5DC8  F07E     NOP
5DCA  0E01     MOVLW 0x1
5DCC  6F7F     MOVWF _PFNf_set_fnserw, BANKED
5DCE  0E1F     MOVLW 0x1F
5DD0  EC93     CALL 0x9B26, 0
5DD2  F04D     NOP
773:                       }
774:           #else
775:                       if(PFN.vUNI02<=2)
776:                       {
777:                           if(!PFNf_EnAleg) PrintVER(0x2F,0,1);	//wyswietl 2F dla kotla dwufunkcyjnego
778:                           else PrintVER(0x1F,0,1);				//wyswietl 1F dla kotla jednofunkcyjnego
779:                       }
780:                       else
781:                       {
782:                           if(!PFNf_EnAleg) PrintVER(0x2F,-1,1);	//wyswietl 2F dla kotla dwufunkcyjnego
783:                           else PrintVER(0x1F,-1,1);				//wyswietl 1F dla kotla jednofunkcyjnego
784:                       }            
785:           #endif
786:           			M.PVB=6;
5DD4  0E06     MOVLW 0x6
5DD6  0101     MOVLB 0x1
5DD8  6FC6     MOVWF 0xC6, BANKED
787:           		break;
5DDA  0C06     RETLW 0x6
788:           		case 6:
789:           			if(RTdS(_RTVER)<=15) return;
5DDC  0E06     MOVLW 0x6
5DDE  EC8B     CALL 0xBF16, 0
5DE0  F05F     NOP
5DE2  6F81     MOVWF _PFNf_set_ncw, BANKED
5DE4  0E10     MOVLW 0x10
5DE6  6181     CPFSLT _PFNf_set_ncw, BANKED
5DE8  D001     BRA 0x5DEC
5DEA  0C10     RETLW 0x10
790:           			StartRTdS(_RTVER);
5DEC  0E06     MOVLW 0x6
5DEE  EC55     CALL 0xBCAA, 0
5DF0  F05E     NOP
791:           			ClrDig(1,1,0);				//wyczysc ekran
5DF2  0E01     MOVLW 0x1
5DF4  6F7E     MOVWF _PFNf_set_eco, BANKED
5DF6  D83A     RCALL PL612
5DF8  EC54     CALL 0x9AA8, 0
5DFA  F04D     NOP
792:           			M.PVB=7;
5DFC  0E07     MOVLW 0x7
5DFE  0101     MOVLB 0x1
5E00  6FC6     MOVWF 0xC6, BANKED
793:           		break;
5E02  0C07     RETLW 0x7
794:           		case 7://zakonczenie procedury
795:           			if(RTdS(_RTVER)<5) return;
5E04  0E06     MOVLW 0x6
5E06  EC8B     CALL 0xBF16, 0
5E08  F05F     NOP
5E0A  6F81     MOVWF _PFNf_set_ncw, BANKED
5E0C  0E05     MOVLW 0x5
5E0E  6181     CPFSLT _PFNf_set_ncw, BANKED
5E10  D001     BRA 0x5E14
5E12  0C05     RETLW 0x5
796:           			M.PVB=8;
5E14  0E08     MOVLW 0x8
5E16  0101     MOVLB 0x1
5E18  6FC6     MOVWF 0xC6, BANKED
797:           		break;
5E1A  0C08     RETLW 0x8
798:           		case 8:
799:           			Mark(_GZ_MXCW,2);			//zpal migajacy symbol max	
5E1C  0E02     MOVLW 0x2
5E1E  0100     MOVLB 0x0
5E20  6F7A     MOVWF _PFNf_res, BANKED
5E22  0E0B     MOVLW 0xB
5E24  EC1F     CALL 0xB83E, 0
5E26  F05C     NOP
5E28  D829     RCALL PL770
800:           			Mark(_GZ_OFF,2);			//zapal migajacy symbol OFF
5E2A  EC1F     CALL 0xB83E, 0
5E2C  F05C     NOP
801:           			M.PVB=9;
5E2E  0E09     MOVLW 0x9
5E30  0101     MOVLB 0x1
5E32  6FC6     MOVWF 0xC6, BANKED
802:           		break;
5E34  0C09     RETLW 0x9
5E36  0101     MOVLB 0x1
5E38  51C6     MOVF 0xC6, W, BANKED
5E3A  E101     BNZ 0x5E3E
5E3C  D720     BRA 0x5C7E
5E3E  0A01     XORLW 0x1
5E40  E101     BNZ 0x5E44
5E42  D732     BRA 0x5CA8
5E44  0A03     XORLW 0x3
5E46  E101     BNZ 0x5E4A
5E48  D745     BRA 0x5CD4
5E4A  0A01     XORLW 0x1
5E4C  E101     BNZ 0x5E50
5E4E  D756     BRA 0x5CFC
5E50  0A07     XORLW 0x7
5E52  E101     BNZ 0x5E56
5E54  D769     BRA 0x5D28
5E56  0A01     XORLW 0x1
5E58  E101     BNZ 0x5E5C
5E5A  D77A     BRA 0x5D50
5E5C  0A03     XORLW 0x3
5E5E  E0BE     BZ 0x5DDC
5E60  0A01     XORLW 0x1
5E62  E0D0     BZ 0x5E04
5E64  0A0F     XORLW 0xF
5E66  E0DA     BZ 0x5E1C
5E68  0A01     XORLW 0x1
5E6A  0012     RETURN 0
803:           		case 9:
804:           		break;
805:           	}
806:           }
807:           #if _KEY_BBOARD==0
808:           void NastawaCOCW(void)//unsigned char one)
809:           {
810:           	volatile static unsigned char obg_cw=0,obg_co=0,zmn2=0,pcw,eco;
811:           
812:           
813:           	if(PFNf_ofnserw||PFNf_set_fnserw||PFNf_oaleg||PFNf_set_aleg) //aktywna funkcja serwisowa lub antylegionella?
814:           	{
815:           		PFNf_set_ncw=0;
816:           		PFNf_set_nco=0;
817:           		PFNf_set_eco=0;
818:           		PFNf_str_nco=0;
819:           	}
820:           //-----------------
821:           	if(!PFNf_set_ncw&&!obg_cw&&PFNf_obgCW)	//uruchomienie w obiegu CW?
822:           	{
823:           		PFNf_str_ncw=1;
824:           		PFNf_b_str_ncw=1;
825:           		StartRTdS(_RTSTR);
826:           		if(!PFNf_fshowLpulse) SetLightLLed(1);	//rozswietlenie maksymalne
827:           	}
828:           	obg_cw=PFNf_obgCW;
829:           	if(PFNf_b_str_ncw)
830:           	{
831:           		PFNf_b_str_ncw=0;
832:           		EndNst();
833:           		PrintNstCW(PFN.PPCW,0);//(!PFNf_ferr&&!PFNf_fmsg));
834:           	}
835:           //-----------------
836:                   
837:           	if(!PFNf_set_nco&&!obg_co&&PFNf_obgCO)	//uruchomienie w obiegu CO?
838:           	{
839:           		PFNf_str_nco=1;
840:           		PFNf_b_str_nco=1;
841:           		StartRTdS(_RTSTR);
842:           	}
843:           	obg_co=PFNf_obgCO;
844:           	if(PFNf_b_str_nco)
845:           	{
846:           		PFNf_b_str_nco=0;
847:           		EndNst();
848:           		if(PFNf_ofnserw||PFNf_set_fnserw)	//aktywna funkcja serwisowa?
849:           		{
850:           			PFNf_set_nco=0;
851:           			PFNf_str_nco=0;
852:           			EndNst();
853:           		}
854:           		else 
855:           		{
856:           			if(!PFNf_EnAleg)
857:           			{
858:           				PrintNstCO(PFN.PPCO,0,0);
859:           			}
860:           			else
861:           			{
862:           				if(PFN.PCW<PFN.minPCW) PrintNstCO(PFN.PPCO,0,1);
863:           				else PrintNstCO(PFN.PPCO,0,0);	
864:           			}
865:           		}
866:           	}
867:                   
868:           //-----------------
869:           	if(PFNf_set_nco||PFNf_set_ncw||RTdS(_RTSTR)>_TSTRNST)				//uplynal czas podtrzymania nastawy po rozruchu?
870:           	{
871:           		PFNf_str_nco=0;
872:           		PFNf_str_ncw=0;
873:           	} 
874:           //-----------------
875:           	if(PFNf_set_ncw)	//wybrano nastawe CW?
876:           	{
877:           		pcw=PFN.PCW;
878:           		//na potrzeby parametru ECO przytrzymanie przycisku +/- wstrzymuje nastawe
879:           		if(!PFNf_mod_ncw&&!RdPrt(S_KUP)&&!RdPrt(S_KDW))
880:           		{
881:           			PFNf_mod_ncw=1;
882:           		}
883:           		if(!PFNf_EnAleg)
884:           		{
885:           			if(PFNf_mod_ncw) ReadParam((unsigned int *)(&PFN.PCW),&zmn,&zps,PFN.minPCW,PFN.maxPCW,0,1);
886:           		}
887:           		else
888:           		{
889:           			if(PFNf_mod_ncw) ReadParam((unsigned int *)(&PFN.PCW),&zmn,&zps,PFN.minPCW-1,PFN.maxPCW,0,1);
890:           		}
891:           		if(!PFNf_b_set_ncw)	//nacisnieto przycisk set?
892:           		{
893:           			PFNf_b_set_ncw=1;
894:           			EndNst();
895:           			zmn2=1;
896:           			pcw=PFN.PCW;				
897:           		}
898:           		if(zmn2||zmn)				//nastawa ulegla zmianie?
899:           		{
900:           			PFNf_newPCW=(pcw!=PFN.PCW);
901:           			zmn2=0;
902:           			StartRTdS(_RTSET);
903:           			if(!PFNf_EnAleg)
904:           			{
905:           				PrintNstCW(PFN.PCW,0);	//PrintNstCW(PFN.PCW,1);
906:           			}
907:           			else
908:           			{
909:           				PrintNstCW2(PFN.PCW,PFN.minPCW-1,0);	//PrintNstCW(PFN.PCW,1);
910:           			}
911:           		}
912:           	}
913:           //-----------------
914:           	if(PFNf_set_nco)	//wybrano nastawe CO?
915:           	{
916:           		pcw=PFN.PCO;
917:           #if (_EXT_BOARD==0)     //stara wersja plytki wyswietlacza   
918:           		ReadParam((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
919:           #else
920:           #if (_EXT_BOARD==1)     //nowa wersja plytki wyswietlacza z interfejsem 10V  
921:                   ReadParam((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
922:           #endif
923:           #if (_EXT_BOARD==2)     //nowa wersja plytki wyswietlacza z interfejsem 10V i LIN   
924:                   if(!PFNf_LIN_KSK)    //nieaktywny interfejs 10V, interfejs LIN w trybie kaskady lub zdalnego sterowania ze strefy czy RT?
925:                   {
926:                       ReadParam((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
927:                   }
928:           #endif 
929:           #if (_EXT_BOARD==3)     //nowa wersja plytki wyswietlacza z interfejsem 10V, LIN i OT        
930:                   if(!PFNf_LIN_KSK)    //nieaktywny interfejs 10V, interfejs LIN w trybie kaskady lub zdalnego sterowania ze strefy czy RT?
931:                   {
932:                       ReadParam((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
933:                   }
934:           #endif        
935:           #endif
936:           		if(!PFNf_b_set_nco)	//stan po nacisnieciu przycisku set?
937:           		{
938:           			PFNf_b_set_nco=1;
939:           			EndNst();
940:           			zmn2=1;
941:           			pcw=PFN.PCO;
942:           			PFNf_newPCO=0;				
943:           		}
944:           		if(zmn2||zmn)				//nastawa ulegla zmianie?
945:           		{
946:           			if(!PFNf_newPCO) PFNf_newPCO=(pcw!=PFN.PCO);
947:           			zmn2=0;
948:           			StartRTdS(_RTSET);
949:           			PrintNstCO(PFN.PCO,PFNf_pgd,0);
950:           		}
951:           	}
952:           //-----------------
953:           	if(PFNf_set_eco)	//wybrano nastawe parametru ECO?
954:           	{
955:           		eco=PFN.ECO;
956:           		if(!PFNf_mod_eco&&!RdPrt(S_KUP)&&!RdPrt(S_KDW))
957:           		{
958:           			PFNf_mod_eco=1;
959:           		}
960:           		if(PFNf_mod_eco) ReadParam((unsigned int *)(&PFN.ECO),&zmn,&zps,1,9,0,1);
961:           		if(!PFNf_b_set_eco)	//nacisnieto przycisk set?
962:           		{
963:           			PFNf_b_set_eco=1;
964:           			EndNst();
965:           			zmn2=1;
966:           			eco=PFN.ECO;				
967:           		}
968:           		if(zmn2||zmn)				//nastawa ulegla zmianie?
969:           		{
970:           			PFNf_newECO=(eco!=PFN.ECO);
971:           			zmn2=0;
972:           			StartRTdS(_RTSET);
973:           			PrintNstECO(PFN.ECO);
974:           		}
975:           	}
976:           //-----------------
977:           	if(!PFNf_set_ncw&&!PFNf_set_nco&&!PFNf_set_eco)	//tryb modyfikacji nastawy jest nieaktywny?
978:           	{
979:           		if(!PFNf_str_ncw&&!PFNf_str_nco) EndNst();
980:           		PFNf_b_set_ncw=0;
981:           		PFNf_b_set_nco=0;
982:           		PFNf_b_set_eco=0;
983:           	}
984:           
985:           }
986:           #endif
987:           #if _KEY_BBOARD==1
988:           void NastawaCOCW(void)//unsigned char one)
989:           {
990:           	volatile static unsigned char obg_cw=0,obg_co=0,zmn2=0,pcw,pco,eco;
991:           
992:           
993:           	if(PFNf_ofnserw||PFNf_set_fnserw||PFNf_oaleg||PFNf_set_aleg) //aktywna funkcja serwisowa lub antylegionella?
4F76  AE0C     BTFSS PFNf_off, 7, ACCESS
4F78  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
4F7A  D004     BRA 0x4F84
4F7C  B40C     BTFSC PFNf_off, 2, ACCESS
4F7E  D002     BRA 0x4F84
4F80  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
4F82  D004     BRA 0x4F8C
994:           	{
995:           		PFNf_set_ncw=0;
4F84  9210     BCF PFNf_str_nco, 1, ACCESS
996:           		PFNf_set_nco=0;
4F86  9010     BCF PFNf_str_nco, 0, ACCESS
997:           		PFNf_set_eco=0;
4F88  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
998:           		PFNf_str_nco=0;
4F8A  9410     BCF PFNf_str_nco, 2, ACCESS
999:           	}
1000:          //-----------------
1001:          	if(!PFNf_set_ncw&&!obg_cw&&PFNf_obgCW)	//uruchomienie w obiegu CW?
4F8C  B210     BTFSC PFNf_str_nco, 1, ACCESS
4F8E  D00F     BRA 0x4FAE
4F90  0101     MOVLB 0x1
4F92  51B8     MOVF 0xB8, W, BANKED
4F94  E10C     BNZ 0x4FAE
4F96  A80C     BTFSS PFNf_off, 4, ACCESS
4F98  D00A     BRA 0x4FAE
1002:          	{
1003:          		PFNf_str_ncw=1;
4F9A  8610     BSF PFNf_str_nco, 3, ACCESS
1004:          		PFNf_b_str_ncw=1;
4F9C  8409     BSF PFNf_b_str_nco, 2, ACCESS
1005:          		StartRTdS(_RTSTR);
4F9E  0E05     MOVLW 0x5
4FA0  EC55     CALL 0xBCAA, 0
4FA2  F05E     NOP
1006:          		if(!PFNf_fshowLpulse) SetLightLLed(1);	//rozswietlenie maksymalne
4FA4  B40B     BTFSC PFNf_lato, 2, ACCESS
4FA6  D003     BRA 0x4FAE
4FA8  0E01     MOVLW 0x1
4FAA  ECE4     CALL 0xA5C8, 0
4FAC  F052     NOP
1007:          	}
1008:          	obg_cw=PFNf_obgCW;
4FAE  0E00     MOVLW 0x0
4FB0  B80C     BTFSC PFNf_off, 4, ACCESS
4FB2  0E01     MOVLW 0x1
4FB4  0101     MOVLB 0x1
4FB6  6FB8     MOVWF 0xB8, BANKED
1009:          	if(PFNf_b_str_ncw)
4FB8  A409     BTFSS PFNf_b_str_nco, 2, ACCESS
4FBA  D00A     BRA 0x4FD0
1010:          	{
1011:          		PFNf_b_str_ncw=0;
4FBC  9409     BCF PFNf_b_str_nco, 2, ACCESS
1012:          		EndNst();
4FBE  EC36     CALL 0xC26C, 0
4FC0  F061     NOP
1013:          		PrintNstCW(PFN.PPCW,0);//(!PFNf_ferr&&!PFNf_fmsg));
4FC2  0E00     MOVLW 0x0
4FC4  0100     MOVLB 0x0
4FC6  6F82     MOVWF _PFNf_str_nco, BANKED
4FC8  0101     MOVLB 0x1
4FCA  51E1     MOVF 0xE1, W, BANKED
4FCC  EC99     CALL 0x8D32, 0
4FCE  F046     NOP
1014:          	}
1015:          //-----------------
1016:                  
1017:          	if(!PFNf_set_nco&&!obg_co&&PFNf_obgCO)	//uruchomienie w obiegu CO?
4FD0  B010     BTFSC PFNf_str_nco, 0, ACCESS
4FD2  D009     BRA 0x4FE6
4FD4  51B7     MOVF 0xB7, W, BANKED
4FD6  E107     BNZ 0x4FE6
4FD8  A60C     BTFSS PFNf_off, 3, ACCESS
4FDA  D005     BRA 0x4FE6
1018:          	{
1019:          		PFNf_str_nco=1;
4FDC  8410     BSF PFNf_str_nco, 2, ACCESS
1020:          		PFNf_b_str_nco=1;
4FDE  8209     BSF PFNf_b_str_nco, 1, ACCESS
1021:          		StartRTdS(_RTSTR);
4FE0  0E05     MOVLW 0x5
4FE2  EC55     CALL 0xBCAA, 0
4FE4  F05E     NOP
1022:          	}
1023:          	obg_co=PFNf_obgCO;
4FE6  0E00     MOVLW 0x0
4FE8  B60C     BTFSC PFNf_off, 3, ACCESS
4FEA  0E01     MOVLW 0x1
4FEC  0101     MOVLB 0x1
4FEE  6FB7     MOVWF 0xB7, BANKED
1024:          	if(PFNf_b_str_nco)
4FF0  A209     BTFSS PFNf_b_str_nco, 1, ACCESS
4FF2  D024     BRA 0x503C
1025:          	{
1026:          		PFNf_b_str_nco=0;
4FF4  9209     BCF PFNf_b_str_nco, 1, ACCESS
1027:          		EndNst();
4FF6  EC36     CALL 0xC26C, 0
4FF8  F061     NOP
1028:          		if(PFNf_ofnserw||PFNf_set_fnserw)	//aktywna funkcja serwisowa?
4FFA  BE0C     BTFSC PFNf_off, 7, ACCESS
4FFC  D002     BRA 0x5002
4FFE  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
5000  D005     BRA 0x500C
1029:          		{
1030:          			PFNf_set_nco=0;
5002  9010     BCF PFNf_str_nco, 0, ACCESS
1031:          			PFNf_str_nco=0;
5004  9410     BCF PFNf_str_nco, 2, ACCESS
1032:          			EndNst();
5006  EC36     CALL 0xC26C, 0
5008  F061     NOP
1033:          		}
500A  D018     BRA 0x503C
1034:          		else 
1035:          		{
1036:          			if(!PFNf_EnAleg)
500C  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
500E  D004     BRA 0x5018
1037:          			{
1038:          				PrintNstCO(PFN.PPCO,0,0);
5010  D923     RCALL PL446
5012  ECE6     CALL 0x77CC, 0
5014  F03B     NOP
1039:          			}
5016  D012     BRA 0x503C
1040:          			else
1041:          			{
1042:          				if(PFN.PCW<PFN.minPCW) PrintNstCO(PFN.PPCO,0,1);
5018  51EA     MOVF __pdataBANK0, W, BANKED
501A  5DF0     SUBWF 0xF0, W, BANKED
501C  51EB     MOVF k, W, BANKED
501E  59F1     SUBWFB 0xF1, W, BANKED
5020  E20A     BC 0x5036
5022  0E00     MOVLW 0x0
5024  0100     MOVLB 0x0
5026  6F82     MOVWF _PFNf_str_nco, BANKED
5028  0E01     MOVLW 0x1
502A  6F83     MOVWF _PFNf_str_ncw, BANKED
502C  0101     MOVLB 0x1
502E  51E0     MOVF LedData, W, BANKED
5030  ECE6     CALL 0x77CC, 0
5032  F03B     NOP
5034  D003     BRA 0x503C
1043:          				else PrintNstCO(PFN.PPCO,0,0);	
5036  D910     RCALL PL446
5038  ECE6     CALL 0x77CC, 0
503A  F03B     NOP
1044:          			}
1045:          		}
1046:          	}
1047:                  
1048:          //-----------------
1049:          	if(PFNf_set_nco||PFNf_set_ncw||RTdS(_RTSTR)>_TSTRNST)				//uplynal czas podtrzymania nastawy po rozruchu?
503C  A010     BTFSS PFNf_str_nco, 0, ACCESS
503E  B210     BTFSC PFNf_str_nco, 1, ACCESS
5040  D007     BRA 0x5050
5042  0E05     MOVLW 0x5
5044  EC8B     CALL 0xBF16, 0
5046  F05F     NOP
5048  6FA4     MOVWF _UADtf_TEnd, BANKED
504A  0E1E     MOVLW 0x1E
504C  65A4     CPFSGT _UADtf_TEnd, BANKED
504E  D002     BRA 0x5054
1050:          	{
1051:          		PFNf_str_nco=0;
5050  9410     BCF PFNf_str_nco, 2, ACCESS
1052:          		PFNf_str_ncw=0;
5052  9610     BCF PFNf_str_nco, 3, ACCESS
1053:          	} 
1054:          //-----------------
1055:          	if(PFNf_set_ncw)	//wybrano nastawe CW?
5054  A210     BTFSS PFNf_str_nco, 1, ACCESS
5056  D04B     BRA 0x50EE
1056:          	{
1057:          		pcw=PFN.PCW;
5058  C1F0     MOVFF 0x1F0, pcw
505A  F1BA     NOP
1058:          
1059:          		if(!PFNf_EnAleg)
505C  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
505E  D009     BRA 0x5072
1060:          		{
1061:          			ReadParamCW((unsigned int *)(&PFN.PCW),&zmn,&zps,PFN.minPCW,PFN.maxPCW,0,1);
5060  D8DE     RCALL PL264
5062  C1EA     MOVFF 0x1EA, _RSDT1f_RRD_KNF
5064  F094     NOP
5066  C1EB     MOVFF 0x1EB, _RSDT1f_RRD_STD
5068  F095     NOP
506A  D8EE     RCALL PL430
506C  EC41     CALL 0x5E82, 0
506E  F02F     NOP
1062:          		}
5070  D00E     BRA 0x508E
1063:          		else
1064:          		{
1065:          			ReadParamCW((unsigned int *)(&PFN.PCW),&zmn,&zps,PFN.minPCW-1,PFN.maxPCW,0,1);
5072  D8D5     RCALL PL264
5074  0EFF     MOVLW 0xFF
5076  0101     MOVLB 0x1
5078  25EA     ADDWF __pdataBANK0, W, BANKED
507A  0100     MOVLB 0x0
507C  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
507E  0EFF     MOVLW 0xFF
5080  0101     MOVLB 0x1
5082  21EB     ADDWFC k, W, BANKED
5084  0100     MOVLB 0x0
5086  6F95     MOVWF _RSDT1f_RRD_STD, BANKED
5088  D8DF     RCALL PL430
508A  EC41     CALL 0x5E82, 0
508C  F02F     NOP
1066:          		}
1067:          		if(!PFNf_b_set_ncw)	//nacisnieto przycisk set?
508E  B009     BTFSC PFNf_b_str_nco, 0, ACCESS
5090  D00C     BRA 0x50AA
1068:          		{
1069:          			PFNf_b_set_ncw=1;
5092  8009     BSF PFNf_b_str_nco, 0, ACCESS
1070:          			EndNst();
5094  EC36     CALL 0xC26C, 0
5096  F061     NOP
1071:          			zmn2=1;
5098  0E01     MOVLW 0x1
509A  0100     MOVLB 0x0
509C  6FDB     MOVWF zmn2, BANKED
1072:          			pcw=PFN.PCW;		
509E  C1F0     MOVFF 0x1F0, pcw
50A0  F1BA     NOP
1073:                      
1074:                      PFNf_set_nco=0;
50A2  9010     BCF PFNf_str_nco, 0, ACCESS
1075:                      PFNf_set_eco=0;        
50A4  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
1076:                      PFNf_b_set_nco=0;
50A6  9E08     BCF PFNf_b_set_nco, 7, ACCESS
1077:                      PFNf_b_set_eco=0;            
50A8  9C08     BCF PFNf_b_set_nco, 6, ACCESS
1078:          		}
1079:          		if(zmn2||zmn)				//nastawa ulegla zmianie?
50AA  51DB     MOVF zmn2, W, BANKED
50AC  E102     BNZ 0x50B2
50AE  51E9     MOVF zmn, W, BANKED
50B0  E01E     BZ 0x50EE
1080:          		{
1081:          			PFNf_newPCW=(pcw!=PFN.PCW);
50B2  0101     MOVLB 0x1
50B4  51BA     MOVF 0xBA, W, BANKED
50B6  19F0     XORWF 0xF0, W, BANKED
50B8  11F1     IORWF 0xF1, W, BANKED
50BA  E002     BZ 0x50C0
50BC  820C     BSF PFNf_off, 1, ACCESS
50BE  D001     BRA 0x50C2
50C0  920C     BCF PFNf_off, 1, ACCESS
1082:          			zmn2=0;
50C2  D8D1     RCALL PL766
1083:          			StartRTdS(_RTSET);
50C4  EC55     CALL 0xBCAA, 0
50C6  F05E     NOP
1084:          			if(!PFNf_EnAleg)
50C8  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
50CA  D007     BRA 0x50DA
1085:          			{
1086:          				PrintNstCW(PFN.PCW,0);	//PrintNstCW(PFN.PCW,1);
50CC  0E00     MOVLW 0x0
50CE  6F82     MOVWF _PFNf_str_nco, BANKED
50D0  0101     MOVLB 0x1
50D2  51F0     MOVF 0xF0, W, BANKED
50D4  EC99     CALL 0x8D32, 0
50D6  F046     NOP
1087:          			}
50D8  D00A     BRA 0x50EE
1088:          			else
1089:          			{
1090:          				PrintNstCW2(PFN.PCW,PFN.minPCW-1,0);	//PrintNstCW(PFN.PCW,1);
50DA  0101     MOVLB 0x1
50DC  05EA     DECF __pdataBANK0, W, BANKED
50DE  0100     MOVLB 0x0
50E0  6F82     MOVWF _PFNf_str_nco, BANKED
50E2  0E00     MOVLW 0x0
50E4  6F83     MOVWF _PFNf_str_ncw, BANKED
50E6  0101     MOVLB 0x1
50E8  51F0     MOVF 0xF0, W, BANKED
50EA  EC92     CALL 0x7B24, 0
50EC  F03D     NOP
1091:          			}
1092:          		}
1093:          	}
1094:          //-----------------
1095:          	if(PFNf_set_nco)	//wybrano nastawe CO?
50EE  A010     BTFSS PFNf_str_nco, 0, ACCESS
50F0  D049     BRA 0x5184
1096:          	{
1097:          		pco=PFN.PCO;
50F2  C1EE     MOVFF 0x1EE, pco
50F4  F1B9     NOP
1098:          		//na potrzeby parametru ECO przytrzymanie przycisku +/- wstrzymuje nastawe
1099:          		if(!PFNf_mod_ncw&&!RdPrt(S_KUP_CO)&&!RdPrt(S_KDW_CO))
50F6  BC0B     BTFSC PFNf_lato, 6, ACCESS
50F8  D009     BRA 0x510C
50FA  0E05     MOVLW 0x5
50FC  EC02     CALL 0xBA04, 0
50FE  F05D     NOP
5100  E205     BC 0x510C
5102  0E06     MOVLW 0x6
5104  EC02     CALL 0xBA04, 0
5106  F05D     NOP
5108  E201     BC 0x510C
1100:          		{
1101:          			PFNf_mod_ncw=1;
510A  8C0B     BSF PFNf_lato, 6, ACCESS
1102:          		}        
1103:          #if (_EXT_BOARD==0)     //stara wersja plytki wyswietlacza   
1104:          		if(PFNf_mod_ncw) ReadParamCO((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
1105:          #else
1106:          #if (_EXT_BOARD==1)     //nowa wersja plytki wyswietlacza z interfejsem 10V  
1107:                  if(PFNf_mod_ncw) ReadParamCO((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
1108:          #endif
1109:          #if (_EXT_BOARD==2)     //nowa wersja plytki wyswietlacza z interfejsem 10V i LIN   
1110:                  if(!PFNf_LIN_KSK)    //nieaktywny interfejs 10V, interfejs LIN w trybie kaskady lub zdalnego sterowania ze strefy czy RT?
1111:                  {
1112:                      if(PFNf_mod_ncw) ReadParamCO((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
1113:                  }
1114:          #endif 
1115:          #if (_EXT_BOARD==3)     //nowa wersja plytki wyswietlacza z interfejsem 10V, LIN i OT        
1116:                  if(!PFNf_LIN_KSK)    //nieaktywny interfejs 10V, interfejs LIN w trybie kaskady lub zdalnego sterowania ze strefy czy RT?
510C  AC06     BTFSS PFNf_LIN_CW, 6, ACCESS
1117:                  {
1118:                      if(PFNf_mod_ncw) ReadParamCO((unsigned int *)(&PFN.PCO),&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
510E  AC0B     BTFSS PFNf_lato, 6, ACCESS
5110  D010     BRA 0x5132
5112  0EEE     MOVLW 0xEE
5114  0100     MOVLB 0x0
5116  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
5118  0E01     MOVLW 0x1
511A  D88D     RCALL PL360
511C  C1E6     MOVFF 0x1E6, _RSDT1f_RRD_STD
511E  F095     NOP
5120  C1E7     MOVFF 0x1E7, _RSDT1f_RespLIDN
5122  F096     NOP
5124  C1E4     MOVFF 0x1E4, _UAD1tf_RFBrSn
5126  F097     NOP
5128  C1E5     MOVFF 0x1E5, _UAD1tf_RFData
512A  F098     NOP
512C  D89F     RCALL PL830
512E  EC42     CALL 0x6084, 0
5130  F030     NOP
1119:                  }
1120:          #endif        
1121:          #endif
1122:          		if(!PFNf_b_set_nco)	//stan po nacisnieciu przycisku set?
5132  BE08     BTFSC PFNf_b_set_nco, 7, ACCESS
5134  D00B     BRA 0x514C
1123:          		{
1124:          			PFNf_b_set_nco=1;
5136  8E08     BSF PFNf_b_set_nco, 7, ACCESS
1125:          			EndNst();
5138  EC36     CALL 0xC26C, 0
513A  F061     NOP
1126:          			zmn2=1;
513C  0E01     MOVLW 0x1
513E  0100     MOVLB 0x0
5140  6FDB     MOVWF zmn2, BANKED
1127:          			pco=PFN.PCO;
5142  C1EE     MOVFF 0x1EE, pco
5144  F1B9     NOP
1128:          			PFNf_newPCO=0;	
5146  900C     BCF PFNf_off, 0, ACCESS
1129:          
1130:                      PFNf_set_ncw=0;        
5148  9210     BCF PFNf_str_nco, 1, ACCESS
1131:                      PFNf_b_set_ncw=0; 			
514A  9009     BCF PFNf_b_str_nco, 0, ACCESS
1132:          		}
1133:          		if(zmn2||zmn)				//nastawa ulegla zmianie?
514C  0100     MOVLB 0x0
514E  51DB     MOVF zmn2, W, BANKED
5150  E102     BNZ 0x5156
5152  51E9     MOVF zmn, W, BANKED
5154  E017     BZ 0x5184
1134:          		{
1135:          			if(!PFNf_newPCO) PFNf_newPCO=(pco!=PFN.PCO);
5156  B00C     BTFSC PFNf_off, 0, ACCESS
5158  D008     BRA 0x516A
515A  0101     MOVLB 0x1
515C  51B9     MOVF 0xB9, W, BANKED
515E  19EE     XORWF 0xEE, W, BANKED
5160  11EF     IORWF 0xEF, W, BANKED
5162  E002     BZ 0x5168
5164  800C     BSF PFNf_off, 0, ACCESS
5166  D001     BRA 0x516A
5168  900C     BCF PFNf_off, 0, ACCESS
1136:          			zmn2=0;
516A  D87D     RCALL PL766
1137:          			StartRTdS(_RTSET);
516C  EC55     CALL 0xBCAA, 0
516E  F05E     NOP
1138:          			PrintNstCO(PFN.PCO,PFNf_pgd,0);
5170  0E00     MOVLW 0x0
5172  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
5174  0E01     MOVLW 0x1
5176  6F82     MOVWF _PFNf_str_nco, BANKED
5178  0E00     MOVLW 0x0
517A  6F83     MOVWF _PFNf_str_ncw, BANKED
517C  0101     MOVLB 0x1
517E  51EE     MOVF 0xEE, W, BANKED
5180  ECE6     CALL 0x77CC, 0
5182  F03B     NOP
1139:          		}
1140:          	}
1141:          //-----------------
1142:          	if(PFNf_set_eco)	//wybrano nastawe parametru ECO?
5184  AC0F     BTFSS PFNf_set_fnserw, 6, ACCESS
5186  D03D     BRA 0x5202
1143:          	{
1144:          		eco=PFN.ECO;
5188  C1F2     MOVFF 0x1F2, eco
518A  F1B6     NOP
1145:          		if(!PFNf_mod_eco&&!RdPrt(S_KUP_CO)&&!RdPrt(S_KDW_CO))
518C  BA0B     BTFSC PFNf_lato, 5, ACCESS
518E  D009     BRA 0x51A2
5190  0E05     MOVLW 0x5
5192  EC02     CALL 0xBA04, 0
5194  F05D     NOP
5196  E205     BC 0x51A2
5198  0E06     MOVLW 0x6
519A  EC02     CALL 0xBA04, 0
519C  F05D     NOP
519E  E201     BC 0x51A2
1146:          		{
1147:          			PFNf_mod_eco=1;
51A0  8A0B     BSF PFNf_lato, 5, ACCESS
1148:          		}
1149:          		if(PFNf_mod_eco) ReadParamCO((unsigned int *)(&PFN.ECO),&zmn,&zps,1,9,0,1);
51A2  AA0B     BTFSS PFNf_lato, 5, ACCESS
51A4  D00E     BRA 0x51C2
51A6  0EF2     MOVLW 0xF2
51A8  0100     MOVLB 0x0
51AA  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
51AC  0E01     MOVLW 0x1
51AE  D843     RCALL PL360
51B0  6B96     CLRF _RSDT1f_RespLIDN, BANKED
51B2  0E01     MOVLW 0x1
51B4  6F95     MOVWF _RSDT1f_RRD_STD, BANKED
51B6  6B98     CLRF _UAD1tf_RFData, BANKED
51B8  0E09     MOVLW 0x9
51BA  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
51BC  D857     RCALL PL830
51BE  EC42     CALL 0x6084, 0
51C0  F030     NOP
1150:          		if(!PFNf_b_set_eco)	//nacisnieto przycisk set?
51C2  BC08     BTFSC PFNf_b_set_nco, 6, ACCESS
51C4  D00A     BRA 0x51DA
1151:          		{
1152:          			PFNf_b_set_eco=1;
51C6  8C08     BSF PFNf_b_set_nco, 6, ACCESS
1153:          			EndNst();
51C8  EC36     CALL 0xC26C, 0
51CA  F061     NOP
1154:          			zmn2=1;
51CC  0E01     MOVLW 0x1
51CE  0100     MOVLB 0x0
51D0  6FDB     MOVWF zmn2, BANKED
1155:          			eco=PFN.ECO;	
51D2  C1F2     MOVFF 0x1F2, eco
51D4  F1B6     NOP
1156:          
1157:                      PFNf_set_ncw=0;        
51D6  9210     BCF PFNf_str_nco, 1, ACCESS
1158:                      PFNf_b_set_ncw=0; 			
51D8  9009     BCF PFNf_b_str_nco, 0, ACCESS
1159:          		}
1160:          		if(zmn2||zmn)				//nastawa ulegla zmianie?
51DA  0100     MOVLB 0x0
51DC  51DB     MOVF zmn2, W, BANKED
51DE  E102     BNZ 0x51E4
51E0  51E9     MOVF zmn, W, BANKED
51E2  E00F     BZ 0x5202
1161:          		{
1162:          			PFNf_newECO=(eco!=PFN.ECO);
51E4  0101     MOVLB 0x1
51E6  51B6     MOVF 0xB6, W, BANKED
51E8  19F2     XORWF 0xF2, W, BANKED
51EA  11F3     IORWF 0xF3, W, BANKED
51EC  E002     BZ 0x51F2
51EE  8E0B     BSF PFNf_lato, 7, ACCESS
51F0  D001     BRA 0x51F4
51F2  9E0B     BCF PFNf_lato, 7, ACCESS
1163:          			zmn2=0;
51F4  D838     RCALL PL766
1164:          			StartRTdS(_RTSET);
51F6  EC55     CALL 0xBCAA, 0
51F8  F05E     NOP
1165:          			PrintNstECO(PFN.ECO);
51FA  0101     MOVLB 0x1
51FC  51F2     MOVF 0xF2, W, BANKED
51FE  EC44     CALL 0x9688, 0
5200  F04B     NOP
1166:          		}
1167:          	}
1168:          //-----------------
1169:          	if(!PFNf_set_ncw&&!PFNf_set_nco&&!PFNf_set_eco)	//tryb modyfikacji nastawy jest nieaktywny?
5202  A210     BTFSS PFNf_str_nco, 1, ACCESS
5204  B010     BTFSC PFNf_str_nco, 0, ACCESS
5206  0012     RETURN 0
5208  BC0F     BTFSC PFNf_set_fnserw, 6, ACCESS
520A  0012     RETURN 0
1170:          	{
1171:          		if(!PFNf_str_ncw&&!PFNf_str_nco) EndNst();
520C  A610     BTFSS PFNf_str_nco, 3, ACCESS
520E  B410     BTFSC PFNf_str_nco, 2, ACCESS
5210  D002     BRA 0x5216
5212  EC36     CALL 0xC26C, 0
5214  F061     NOP
1172:          		PFNf_b_set_ncw=0;
5216  9009     BCF PFNf_b_str_nco, 0, ACCESS
1173:          		PFNf_b_set_nco=0;
5218  9E08     BCF PFNf_b_set_nco, 7, ACCESS
1174:          		PFNf_b_set_eco=0;
521A  9C08     BCF PFNf_b_set_nco, 6, ACCESS
1175:          	}
1176:          
1177:          }
521C  0012     RETURN 0
1178:          #endif
1179:          //--------------------------------------------------------------
1180:          void DecWsw(void)
1181:          {    
1182:              if(PFNf_fsetLaddr||PFNf_fshowLaddr)              //aktywna funkcja przypisania/wizualizacji adresu LIN?
00F2  B00B     BTFSC PFNf_lato, 0, ACCESS
00F4  D002     BRA 0xFA
00F6  A20B     BTFSS PFNf_lato, 1, ACCESS
00F8  D02B     BRA 0x150
1183:              {
1184:          #if _KEY_BBOARD==0             
1185:                  if(!RdPrt(S_SET)) PFNf_setKey=0;
1186:          #endif
1187:          #if _KEY_BBOARD==1             
1188:                  if(!RdPrt(S_KOM)) PFNf_setKey=0;
00FA  0E02     MOVLW 0x2
00FC  EC02     CALL 0xBA04, 0
00FE  F05D     NOP
0100  E201     BC 0x104
0102  980F     BCF PFNf_set_fnserw, 4, ACCESS
1189:          #endif            
1190:                  //--------------
1191:                  EndErr();
0104  ECC2     CALL 0xC184, 0
0106  F060     NOP
1192:                  if(PFN.ALIN>=0x05) PrintLN(0);
0108  0E04     MOVLW 0x4
010A  65ED     CPFSGT 0xED, BANKED
010C  D004     BRA 0x116
010E  0E00     MOVLW 0x0
0110  ECB1     CALL 0xA562, 0
0112  F052     NOP
0114  D003     BRA 0x11C
1193:                  else PrintLN(PFN.ALIN);
0116  51ED     MOVF 0xED, W, BANKED
0118  ECB1     CALL 0xA562, 0
011A  F052     NOP
1194:                  SetPulseLLed();
011C  EC31     CALL 0xB062, 0
011E  F058     NOP
1195:                  if(PFNf_fsetLaddr) PFNf_fshowLaddr=0;
0120  B00B     BTFSC PFNf_lato, 0, ACCESS
0122  920B     BCF PFNf_lato, 1, ACCESS
1196:                  if(RTdS(_RTALIN)>30)                        //czas przez jaki wyswietlany jest adres LIN
0124  0E0A     MOVLW 0xA
0126  EC8B     CALL 0xBF16, 0
0128  F05F     NOP
012A  6FA5     MOVWF f3, BANKED
012C  0E1E     MOVLW 0x1E
012E  65A5     CPFSGT f3, BANKED
0130  D098     BRA 0x262
1197:                  {
1198:                      PFNf_fshowLaddr=0;
0132  920B     BCF PFNf_lato, 1, ACCESS
1199:                      if(PFNf_fsetLaddr)
0134  A00B     BTFSS PFNf_lato, 0, ACCESS
0136  D095     BRA 0x262
1200:                      {
1201:          #if _KEY_BBOARD==0                    
1202:                          if(!RdPrt(S_SET))           //poszczony przycisk SET?
1203:                          {
1204:                              PFNf_fsetLaddr=0;
1205:                              SetPrt(S_SET,0);
1206:                          }
1207:          #endif
1208:          #if _KEY_BBOARD==1                    
1209:                          if(!RdPrt(S_KOM))           //poszczony przycisk KOM?
0138  0E02     MOVLW 0x2
013A  EC02     CALL 0xBA04, 0
013C  F05D     NOP
013E  E301     BNC 0x142
0140  D090     BRA 0x262
1210:                          {
1211:                              PFNf_fsetLaddr=0;
0142  900B     BCF PFNf_lato, 0, ACCESS
1212:                              SetPrt(S_KOM,0);
0144  0E00     MOVLW 0x0
0146  6F74     MOVWF _PFNf_prODP, BANKED
0148  0E02     MOVLW 0x2
014A  ECDC     CALL 0xADB8, 0
014C  F056     NOP
1213:                          }
1214:          #endif                    
1215:                      }
1216:                  }
1217:              }
014E  D089     BRA 0x262
1218:              else
1219:              {
1220:                  if(PFNf_ferr||PFNf_fmsg||PFNf_prODP)        //blad lub komunikat?
0150  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
0152  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
0154  D002     BRA 0x15A
0156  A80E     BTFSS PFNf_popFN, 4, ACCESS
0158  D06A     BRA 0x22E
1221:                  {
1222:                      if(!PFNf_fshowLpulse)       //nieaktywna pulsacja rozswietlenia?
015A  B40B     BTFSC PFNf_lato, 2, ACCESS
015C  D004     BRA 0x166
1223:                      {
1224:                          SetLightLLed(1); 	//rozswietlenie maksymalne
015E  0E01     MOVLW 0x1
0160  ECE4     CALL 0xA5C8, 0
0162  F052     NOP
1225:                      }
0164  D00D     BRA 0x180
1226:                      else
1227:                      {
1228:                          SetPulseLLed();                         //pulsacja rozswietlenia
0166  EC31     CALL 0xB062, 0
0168  F058     NOP
1229:                          if(PFNf_foneLpulse&&(RTdS(_RTALIN)>30)) //czas po jakim nastapi wylaczenie pulsacji
016A  AE0A     BTFSS PFNf_firstEdge, 7, ACCESS
016C  D009     BRA 0x180
016E  0E0A     MOVLW 0xA
0170  EC8B     CALL 0xBF16, 0
0172  F05F     NOP
0174  6FA5     MOVWF f3, BANKED
0176  0E1E     MOVLW 0x1E
0178  65A5     CPFSGT f3, BANKED
017A  D002     BRA 0x180
1230:                          {
1231:                              PFNf_fshowLpulse=0;
017C  940B     BCF PFNf_lato, 2, ACCESS
1232:                              PFNf_foneLpulse=0;
017E  9E0A     BCF PFNf_firstEdge, 7, ACCESS
1233:                          }
1234:                      }
1235:                      NastawaCOCW();
0180  ECBB     CALL 0x4F76, 0
0182  F027     NOP
1236:          
1237:                      if(PFNf_ferr)
0184  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
0186  D037     BRA 0x1F6
1238:                      {
1239:                          if(!PFNf_KnfDisErr||PFNf_opgres)
0188  AE05     BTFSS PFNf_KnfDisErr, 7, ACCESS
018A  D002     BRA 0x190
018C  A80D     BTFSS PFNf_plmCO, 4, ACCESS
018E  D030     BRA 0x1F0
1240:                          {
1241:                              if(!PFNf_set_nco&&!PFNf_set_ncw&&!PFNf_set_eco) ClrMarkMinMax();
0190  A010     BTFSS PFNf_str_nco, 0, ACCESS
0192  B210     BTFSC PFNf_str_nco, 1, ACCESS
0194  D003     BRA 0x19C
0196  AC0F     BTFSS PFNf_set_fnserw, 6, ACCESS
0198  EC03     CALL 0xBC06, 0
019A  F05E     NOP
1242:                              if(PFNf_opgres) PrintErrMsg(_PRN_ERR,led_E,PFN.KERR,0,0,PFNf_opgres);							//migajacy kod awaryjny z blokada
019C  A80D     BTFSS PFNf_plmCO, 4, ACCESS
019E  D008     BRA 0x1B0
01A0  0E79     MOVLW 0x79
01A2  0100     MOVLB 0x0
01A4  ECEE     CALL 0x9DC, 0
01A6  F004     NOP
01A8  0E00     MOVLW 0x0
01AA  EC4E     CALL 0x489C, 0
01AC  F024     NOP
01AE  D059     BRA 0x262
1243:                              else
1244:                              if(PFN.KERR!=0x0E&&PFN.KERR!=0x09) PrintErrMsg(_PRN_MSG,led_E,PFN.KERR,0,0,PFNf_opgres);		//migajacy kod awaryjny bez blokady
01B0  0E0E     MOVLW 0xE
01B2  0101     MOVLB 0x1
01B4  19E3     XORWF 0xE3, W, BANKED
01B6  E00B     BZ 0x1CE
01B8  0E09     MOVLW 0x9
01BA  19E3     XORWF 0xE3, W, BANKED
01BC  E008     BZ 0x1CE
01BE  0E79     MOVLW 0x79
01C0  0100     MOVLB 0x0
01C2  ECEE     CALL 0x9DC, 0
01C4  F004     NOP
01C6  0E04     MOVLW 0x4
01C8  EC4E     CALL 0x489C, 0
01CA  F024     NOP
01CC  D04A     BRA 0x262
1245:                              else PrintErrMsg(_PRN_MSG,led_E,PFN.KERR,PFN.KERR==0x0E,PFN.KERR==0x09,PFNf_opgres);			//naprzemienny kod awaryjny
01CE  0E79     MOVLW 0x79
01D0  0100     MOVLB 0x0
01D2  6F7E     MOVWF _PFNf_set_eco, BANKED
01D4  C1E3     MOVFF 0x1E3, _PFNf_set_fnserw
01D6  F07F     NOP
01D8  0E0E     MOVLW 0xE
01DA  EC0C     CALL 0xA18, 0
01DC  F005     NOP
01DE  6F80     MOVWF _PFNf_set_nco, BANKED
01E0  0E09     MOVLW 0x9
01E2  EC0C     CALL 0xA18, 0
01E4  F005     NOP
01E6  EC06     CALL 0xA0C, 0
01E8  F005     NOP
01EA  EC4E     CALL 0x489C, 0
01EC  F024     NOP
01EE  D039     BRA 0x262
1246:                          }
1247:                          else
1248:                          {
1249:                              EndErr();
01F0  ECC2     CALL 0xC184, 0
01F2  F060     NOP
01F4  D036     BRA 0x262
1250:                          }
1251:                      }
1252:                      else
1253:                      if(PFNf_fmsg)
01F6  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
01F8  D013     BRA 0x220
1254:                      {
1255:                          if(!PFNf_KnfDisErr)
01FA  BE05     BTFSC PFNf_KnfDisErr, 7, ACCESS
01FC  D7F9     BRA 0x1F0
1256:                          {
1257:                              if(!PFNf_set_nco&&!PFNf_set_ncw&&!PFNf_set_eco) ClrMarkMinMax();
01FE  A010     BTFSS PFNf_str_nco, 0, ACCESS
0200  B210     BTFSC PFNf_str_nco, 1, ACCESS
0202  D003     BRA 0x20A
0204  AC0F     BTFSS PFNf_set_fnserw, 6, ACCESS
0206  EC03     CALL 0xBC06, 0
0208  F05E     NOP
1258:                              PrintErrMsg(_PRN_MSG,led_E,PFN.KAWR,1,1,PFNf_opgres);			//staly kod awaryjny
020A  0E79     MOVLW 0x79
020C  0100     MOVLB 0x0
020E  6F7E     MOVWF _PFNf_set_eco, BANKED
0210  C1E2     MOVFF 0x1E2, _PFNf_set_fnserw
0212  F07F     NOP
0214  0E01     MOVLW 0x1
0216  6F80     MOVWF _PFNf_set_nco, BANKED
0218  DBF9     RCALL PL452
021A  EC4E     CALL 0x489C, 0
021C  F024     NOP
1259:                          }else EndErr();
021E  D021     BRA 0x262
1260:                      }
1261:                      else
1262:                      if(PFNf_prODP)
0220  A80E     BTFSS PFNf_popFN, 4, ACCESS
0222  D01F     BRA 0x262
1263:                      {    
1264:                          PrintPo(PFN.CS);
0224  0101     MOVLB 0x1
0226  51DA     MOVF 0xDA, W, BANKED
0228  EC0D     CALL 0x9C1A, 0
022A  F04E     NOP
022C  D7E1     BRA 0x1F0
1265:                          EndErr();
1266:                      }
1267:                  }
1268:                  else
1269:                  {
1270:                      if(!PFNf_fshowLpulse)                       //nieaktywna pulsacja rozswietlenia?
022E  B40B     BTFSC PFNf_lato, 2, ACCESS
0230  D00A     BRA 0x246
1271:                      {
1272:                          if(PFNf_rozruch)
0232  A60F     BTFSS PFNf_set_fnserw, 3, ACCESS
0234  D004     BRA 0x23E
1273:                          {
1274:                              SetLightLLed(1);	//rozswietlenie maksymalne
0236  0E01     MOVLW 0x1
0238  ECE4     CALL 0xA5C8, 0
023A  F052     NOP
1275:                          }
023C  D7D9     BRA 0x1F0
1276:                          else
1277:                          {
1278:                              SetLightLLed(0);                   //sterowane rozswietlenie
023E  0E00     MOVLW 0x0
0240  ECE4     CALL 0xA5C8, 0
0242  F052     NOP
0244  D7D5     BRA 0x1F0
1279:                          }
1280:                      }
1281:                      else
1282:                      {
1283:                          SetPulseLLed();                         //pulsacja rozswietlenia
0246  EC31     CALL 0xB062, 0
0248  F058     NOP
1284:                          if(PFNf_foneLpulse&&(RTdS(_RTALIN)>30)) //czas po jakim nastapi wylaczenie pulsacji
024A  AE0A     BTFSS PFNf_firstEdge, 7, ACCESS
024C  D7D1     BRA 0x1F0
024E  0E0A     MOVLW 0xA
0250  EC8B     CALL 0xBF16, 0
0252  F05F     NOP
0254  6FA5     MOVWF f3, BANKED
0256  0E1E     MOVLW 0x1E
0258  65A5     CPFSGT f3, BANKED
025A  D7CA     BRA 0x1F0
1285:                          {
1286:                              PFNf_fshowLpulse=0;
025C  940B     BCF PFNf_lato, 2, ACCESS
1287:                              PFNf_foneLpulse=0;
025E  9E0A     BCF PFNf_firstEdge, 7, ACCESS
0260  D7C7     BRA 0x1F0
1288:                          }
1289:                      }
1290:                      EndErr();
1291:                  }
1292:              }
1293:          	if(!PFNf_fsetLaddr&&!PFNf_fshowLaddr&&!PFNf_opKNF&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
0262  A00B     BTFSS PFNf_lato, 0, ACCESS
0264  B20B     BTFSC PFNf_lato, 1, ACCESS
0266  D2E4     BRA 0x830
0268  A40D     BTFSS PFNf_plmCO, 2, ACCESS
026A  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
026C  D2E1     BRA 0x830
026E  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
0270  B80E     BTFSC PFNf_popFN, 4, ACCESS
0272  D2DE     BRA 0x830
1294:          	{
1295:                  if(PFNf_fshowLpulse)       //aktywna pulsacja rozswietlenia?
0274  A40B     BTFSS PFNf_lato, 2, ACCESS
0276  D00D     BRA 0x292
1296:                  {
1297:                      SetPulseLLed();                         //pulsacja rozswietlenia
0278  EC31     CALL 0xB062, 0
027A  F058     NOP
1298:                      if(PFNf_foneLpulse&&(RTdS(_RTALIN)>30)) //czas po jakim nastapi wylaczenie pulsacji
027C  AE0A     BTFSS PFNf_firstEdge, 7, ACCESS
027E  D009     BRA 0x292
0280  0E0A     MOVLW 0xA
0282  EC8B     CALL 0xBF16, 0
0284  F05F     NOP
0286  6FA5     MOVWF f3, BANKED
0288  0E1E     MOVLW 0x1E
028A  65A5     CPFSGT f3, BANKED
028C  D002     BRA 0x292
1299:                      {
1300:                          PFNf_fshowLpulse=0;
028E  940B     BCF PFNf_lato, 2, ACCESS
1301:                          PFNf_foneLpulse=0;
0290  9E0A     BCF PFNf_firstEdge, 7, ACCESS
1302:                      }
1303:                  }        
1304:          		if(PFNf_ofoff)
0292  A00D     BTFSS PFNf_plmCO, 0, ACCESS
0294  D02D     BRA 0x2F0
1305:          		{
1306:          			//decyzje o wygaszeniu
1307:          			if(PFNf_errCS&&!PFNf_tdzCO) ClrDig(0,1,1);
0296  BA09     BTFSC PFNf_b_str_nco, 5, ACCESS
0298  B810     BTFSC PFNf_str_nco, 4, ACCESS
029A  D007     BRA 0x2AA
029C  0E01     MOVLW 0x1
029E  0100     MOVLB 0x0
02A0  6F7E     MOVWF _PFNf_set_eco, BANKED
02A2  6F7F     MOVWF _PFNf_set_fnserw, BANKED
02A4  0E00     MOVLW 0x0
02A6  EC54     CALL 0x9AA8, 0
02A8  F04D     NOP
1308:          			if(!PFNf_tdzCW) ClrDig(1,0,0);
02AA  BA10     BTFSC PFNf_str_nco, 5, ACCESS
02AC  D005     BRA 0x2B8
02AE  0E00     MOVLW 0x0
02B0  0100     MOVLB 0x0
02B2  DBC8     RCALL PL800
02B4  EC54     CALL 0x9AA8, 0
02B6  F04D     NOP
1309:          			//wskazy
1310:          			if(!PFNf_errCS&&!PFNf_tdzCO) {Mark(_GZ_DCO,0);PrintCS(PFN.CS,1);}
02B8  AA09     BTFSS PFNf_b_str_nco, 5, ACCESS
02BA  B810     BTFSC PFNf_str_nco, 4, ACCESS
02BC  D00B     BRA 0x2D4
02BE  0E00     MOVLW 0x0
02C0  0100     MOVLB 0x0
02C2  6B7A     CLRF _PFNf_res, BANKED
02C4  EC1F     CALL 0xB83E, 0
02C6  F05C     NOP
02C8  0E01     MOVLW 0x1
02CA  6F7E     MOVWF _PFNf_set_eco, BANKED
02CC  0101     MOVLB 0x1
02CE  51DA     MOVF 0xDA, W, BANKED
02D0  ECBA     CALL 0x9574, 0
02D2  F04A     NOP
1311:          			if(PFNf_tdzCW&&!PFNf_errCW) PrintCW(PFN.CW,1);
02D4  BA10     BTFSC PFNf_str_nco, 5, ACCESS
02D6  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
02D8  D004     BRA 0x2E2
02DA  0E01     MOVLW 0x1
02DC  DB76     RCALL PL88
02DE  EC2F     CALL 0xAA5E, 0
02E0  F055     NOP
1312:          			if(PFNf_tdzCO&&!PFNf_errCO) PrintCO(PFN.CO,1,PFNf_fL3);
02E2  B810     BTFSC PFNf_str_nco, 4, ACCESS
02E4  B809     BTFSC PFNf_b_str_nco, 4, ACCESS
02E6  D2A4     BRA 0x830
02E8  DB4F     RCALL PL28
02EA  EC51     CALL 0x98A2, 0
02EC  F04C     NOP
02EE  D2A0     BRA 0x830
1313:          		}
1314:          		else
1315:          		{
1316:          			//-----------------------------------
1317:          			//tryb LATO
1318:          			if(PFNf_oflato)
02F0  AC0C     BTFSS PFNf_off, 6, ACCESS
02F2  D121     BRA 0x536
1319:          			{
1320:          				if(!PFNf_oaleg||PFNf_set_aleg)
02F4  A40C     BTFSS PFNf_off, 2, ACCESS
02F6  D002     BRA 0x2FC
02F8  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
02FA  D0F5     BRA 0x4E6
1321:          				{
1322:          					if(PFNf_obgCO||PFNf_tdzCO)												//temp. dyzurna CO?
02FC  B60C     BTFSC PFNf_off, 3, ACCESS
02FE  D002     BRA 0x304
0300  A810     BTFSS PFNf_str_nco, 4, ACCESS
0302  D06D     BRA 0x3DE
1323:          					{
1324:          						if(PFNf_prn_res)
0304  A20F     BTFSS PFNf_set_fnserw, 1, ACCESS
0306  D037     BRA 0x376
1325:          						{
1326:          							if(PFNf_prn_cs)													//czasowy wskaz cisnienia
0308  AA0E     BTFSS PFNf_popFN, 5, ACCESS
030A  D020     BRA 0x34C
1327:          							{
1328:          								if(!PFNf_EnAleg)
030C  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
030E  D005     BRA 0x31A
1329:          								{
1330:          									PrintCS(PFN.CS,0);											//wylaczny wskaz CS
0310  0E00     MOVLW 0x0
0312  DB56     RCALL PL72
0314  ECBA     CALL 0x9574, 0
0316  F04A     NOP
1331:          								}
0318  D289     BRA 0x82C
1332:          								else
1333:          								{
1334:          									if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) PrintCS(PFN.CS,1);					//dzielony wskaz CS
031A  DB46     RCALL PL66
031C  E302     BNC 0x322
031E  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0320  D005     BRA 0x32C
0322  0E01     MOVLW 0x1
0324  DB4D     RCALL PL72
0326  ECBA     CALL 0x9574, 0
0328  F04A     NOP
032A  D280     BRA 0x82C
1335:          									else 
1336:          									{
1337:          											if(!PFNf_errCW) 
032C  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
032E  D009     BRA 0x342
1338:          											{
1339:          												PrintCS(PFN.CS,1);								//dzielony wskaz CS
0330  0E01     MOVLW 0x1
0332  DB46     RCALL PL72
0334  ECBA     CALL 0x9574, 0
0336  F04A     NOP
1340:          												PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
0338  0E01     MOVLW 0x1
033A  DB4C     RCALL PL188
033C  EC2F     CALL 0xAA5E, 0
033E  F055     NOP
1341:          											}
0340  D275     BRA 0x82C
1342:          											else PrintCS(PFN.CS,0);								//wylaczny wskaz CS
0342  0E00     MOVLW 0x0
0344  DB3D     RCALL PL72
0346  ECBA     CALL 0x9574, 0
0348  F04A     NOP
034A  D270     BRA 0x82C
1343:          									}
1344:          								}											
1345:          							}
1346:          							else
1347:          							if(PFNf_prn_in) PrintIN(PFN.IN);						//wylaczny wskaz IN
034C  AC0E     BTFSS PFNf_popFN, 6, ACCESS
034E  D005     BRA 0x35A
0350  0101     MOVLB 0x1
0352  51DB     MOVF zmn2, W, BANKED
0354  ECEC     CALL 0x9FD8, 0
0356  F04F     NOP
0358  D269     BRA 0x82C
1348:                                      else
1349:                                      if(PFNf_prn_pp) PrintPP(PFN.PP);						//wylaczny wskaz PP
035A  A00F     BTFSS PFNf_set_fnserw, 0, ACCESS
035C  D005     BRA 0x368
035E  0101     MOVLB 0x1
0360  51DC     MOVF pp, W, BANKED
0362  EC4A     CALL 0x9C94, 0
0364  F04E     NOP
0366  D262     BRA 0x82C
1350:                                      else
1351:                                      if(PFNf_prn_pg) PrintPG(PFN.PG);						//wylaczny wskaz PG                            
0368  AE0E     BTFSS PFNf_popFN, 7, ACCESS
036A  D260     BRA 0x82C
036C  0101     MOVLB 0x1
036E  51DD     MOVF MOTFkrk, W, BANKED
0370  EC82     CALL 0xAB04, 0
0372  F055     NOP
1352:                                      
1353:          							/*else
1354:          							{
1355:          								if(PFNf_prn_in) PrintIN(PFN.IN);							//wylaczny wskaz IN
1356:          							}*/
1357:          						}
0374  D25B     BRA 0x82C
1358:          						else
1359:          						{	
1360:          							if(!PFNf_EnAleg)
0376  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
0378  D013     BRA 0x3A0
1361:          							{
1362:          								if(!PFNf_errCO) PrintCO(PFN.CO,0,PFNf_fL3); 						//wylaczny wskaz temperatury CO
037A  B809     BTFSC PFNf_b_str_nco, 4, ACCESS
037C  D007     BRA 0x38C
037E  0E00     MOVLW 0x0
0380  0100     MOVLB 0x0
0382  6F7E     MOVWF _PFNf_set_eco, BANKED
0384  DB17     RCALL PL68
0386  EC51     CALL 0x98A2, 0
0388  F04C     NOP
038A  D005     BRA 0x396
1363:          								else ClrDig(0,1,0);
038C  0E01     MOVLW 0x1
038E  0100     MOVLB 0x0
0390  DB39     RCALL PL424
0392  EC54     CALL 0x9AA8, 0
0394  F04D     NOP
1364:          								ClrDig(1,0,0);
0396  0E00     MOVLW 0x0
0398  DB55     RCALL PL800
039A  EC54     CALL 0x9AA8, 0
039C  F04D     NOP
1365:          							}
039E  D246     BRA 0x82C
1366:          							else
1367:          							{
1368:          								if(PFN.PCW<PFN.minPCW||!PFNf_timZAS)
03A0  DB03     RCALL PL66
03A2  E302     BNC 0x3A8
03A4  BC10     BTFSC PFNf_str_nco, 6, ACCESS
03A6  D00A     BRA 0x3BC
1369:          								{
1370:           									PrintCO(PFN.CO,1,PFNf_fL3); 						//dzielony wskaz temperatury CO
03A8  DAEF     RCALL PL28
03AA  EC51     CALL 0x98A2, 0
03AC  F04C     NOP
1371:          									ClrDig(1,0,1);
03AE  0E00     MOVLW 0x0
03B0  6F7E     MOVWF _PFNf_set_eco, BANKED
03B2  0E01     MOVLW 0x1
03B4  6F7F     MOVWF _PFNf_set_fnserw, BANKED
03B6  EC54     CALL 0x9AA8, 0
03B8  F04D     NOP
1372:          								}
03BA  D238     BRA 0x82C
1373:          								else 
1374:          								{
1375:          									if(!PFNf_errCW) 
03BC  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
03BE  D008     BRA 0x3D0
03C0  DAE3     RCALL PL28
1376:          									{
1377:          										PrintCO(PFN.CO,1,PFNf_fL3); 						//dzielony wskaz temperatury CO
03C2  EC51     CALL 0x98A2, 0
03C4  F04C     NOP
1378:          										PrintCW(PFN.CW,1);									//dzielony wskaz temp CW
03C6  0E01     MOVLW 0x1
03C8  DB05     RCALL PL188
03CA  EC2F     CALL 0xAA5E, 0
03CC  F055     NOP
1379:          									}
03CE  D22E     BRA 0x82C
1380:          									else PrintCO(PFN.CO,0,PFNf_fL3); 						//wylaczny wskaz temperatury CO
03D0  0E00     MOVLW 0x0
03D2  0100     MOVLB 0x0
03D4  6F7E     MOVWF _PFNf_set_eco, BANKED
03D6  DAEE     RCALL PL68
03D8  EC51     CALL 0x98A2, 0
03DA  F04C     NOP
03DC  D227     BRA 0x82C
1381:          								}
1382:          							}
1383:          						}
1384:          					}
1385:          					else																	//wskaz/praca CW
1386:          					{
1387:          						if(PFNf_prn_res)
03DE  A20F     BTFSS PFNf_set_fnserw, 1, ACCESS
03E0  D043     BRA 0x468
1388:          						{
1389:          							if(PFNf_prn_cs)													//czasowy wskaz cisnienia
03E2  AA0E     BTFSS PFNf_popFN, 5, ACCESS
03E4  D02C     BRA 0x43E
1390:          							{
1391:          								if(!PFNf_errCW&&PFNf_obgCW)
03E6  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
03E8  A80C     BTFSS PFNf_off, 4, ACCESS
03EA  D009     BRA 0x3FE
1392:          								{
1393:          									PrintCS(PFN.CS,1);										//dzielony wskaz temp CS
03EC  0E01     MOVLW 0x1
03EE  DAE8     RCALL PL72
03F0  ECBA     CALL 0x9574, 0
03F2  F04A     NOP
1394:          									PrintCW(PFN.CW,1);										//dzielony wskaz temp CW
03F4  0E01     MOVLW 0x1
03F6  DAEE     RCALL PL188
03F8  EC2F     CALL 0xAA5E, 0
03FA  F055     NOP
1395:          								}
03FC  D217     BRA 0x82C
1396:          								else
1397:          								{
1398:          									if(!PFNf_EnAleg)
03FE  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
0400  D005     BRA 0x40C
1399:          									{
1400:          										PrintCS(PFN.CS,0);											//wylaczny wskaz CS
0402  0E00     MOVLW 0x0
0404  DADD     RCALL PL72
0406  ECBA     CALL 0x9574, 0
0408  F04A     NOP
1401:          									}
040A  D210     BRA 0x82C
1402:          									else
1403:          									{
1404:          										if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) PrintCS(PFN.CS,1);					//dzielony wskaz CS
040C  DACD     RCALL PL66
040E  E302     BNC 0x414
0410  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0412  D005     BRA 0x41E
0414  0E01     MOVLW 0x1
0416  DAD4     RCALL PL72
0418  ECBA     CALL 0x9574, 0
041A  F04A     NOP
041C  D207     BRA 0x82C
1405:          										else 
1406:          										{
1407:          												if(!PFNf_errCW) 
041E  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0420  D009     BRA 0x434
1408:          												{
1409:          													PrintCS(PFN.CS,1);								//dzielony wskaz CS
0422  0E01     MOVLW 0x1
0424  DACD     RCALL PL72
0426  ECBA     CALL 0x9574, 0
0428  F04A     NOP
1410:          													PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
042A  0E01     MOVLW 0x1
042C  DAD3     RCALL PL188
042E  EC2F     CALL 0xAA5E, 0
0430  F055     NOP
1411:          												}
0432  D1FC     BRA 0x82C
1412:          												else PrintCS(PFN.CS,0);								//wylaczny wskaz CS
0434  0E00     MOVLW 0x0
0436  DAC4     RCALL PL72
0438  ECBA     CALL 0x9574, 0
043A  F04A     NOP
043C  D1F7     BRA 0x82C
1413:          										}
1414:          									}
1415:          								}
1416:          							}
1417:          							else
1418:          							if(PFNf_prn_in) 
043E  AC0E     BTFSS PFNf_popFN, 6, ACCESS
0440  D005     BRA 0x44C
1419:                                      {
1420:                                          PrintCo(PFN.rCO);                                   //wylaczny wskaz CO (wartosc rzeczywista lub przefiltrowana)
0442  0101     MOVLB 0x1
0444  51F4     MOVF 0xF4, W, BANKED
0446  EC4A     CALL 0xA494, 0
0448  F052     NOP
1421:                                          /*if(RSDT1.vSTD>=2)
1422:                                          {
1423:                                              PrintCo(PFN.rCO);                               //wylaczny wskaz CO (wartosc rzeczywista)
1424:                                          }
1425:                                          else
1426:                                          {
1427:                                              PrintCo(PFN.CO);                                //wylaczny wskaz CO  (filtr)                                      
1428:                                          }*/
1429:                                      }
044A  D1F0     BRA 0x82C
1430:                                      else
1431:                                      if(PFNf_prn_pp) PrintPP(PFN.PP);						//wylaczny wskaz PP
044C  A00F     BTFSS PFNf_set_fnserw, 0, ACCESS
044E  D005     BRA 0x45A
0450  0101     MOVLB 0x1
0452  51DC     MOVF pp, W, BANKED
0454  EC4A     CALL 0x9C94, 0
0456  F04E     NOP
0458  D1E9     BRA 0x82C
1432:                                      else
1433:                                      if(PFNf_prn_pg) PrintPG(PFN.PG);						//wylaczny wskaz PG                            
045A  AE0E     BTFSS PFNf_popFN, 7, ACCESS
045C  D1E7     BRA 0x82C
045E  0101     MOVLB 0x1
0460  51DD     MOVF MOTFkrk, W, BANKED
0462  EC82     CALL 0xAB04, 0
0464  F055     NOP
0466  D1E2     BRA 0x82C
1434:          						}		
1435:          						else																//tylko wskaz temp. CW przy pobudzeniu
1436:          						{
1437:           							if(!PFNf_EnAleg)
0468  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
046A  D016     BRA 0x498
1438:          							{
1439:          								if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
046C  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
046E  A80C     BTFSS PFNf_off, 4, ACCESS
0470  D004     BRA 0x47A
0472  DA94     RCALL PL60
0474  EC2F     CALL 0xAA5E, 0
0476  F055     NOP
0478  D00A     BRA 0x48E
1440:          								else
1441:          								if(!PFNf_errCW&&PFNf_set_aleg) PrintCW(PFN.CW,0);
047A  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
047C  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
047E  D004     BRA 0x488
0480  DA8D     RCALL PL60
0482  EC2F     CALL 0xAA5E, 0
0484  F055     NOP
0486  D003     BRA 0x48E
1442:          								else ClrDig(1,0,0);
0488  DAB8     RCALL PL398
048A  EC54     CALL 0x9AA8, 0
048C  F04D     NOP
1443:          								ClrDig(0,1,0);															//wygaszenie najmlodszych cyfr
048E  0E01     MOVLW 0x1
0490  DAB9     RCALL PL424
0492  EC54     CALL 0x9AA8, 0
0494  F04D     NOP
1444:          							}
0496  D1CA     BRA 0x82C
1445:          							else
1446:          							{
1447:          								if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
0498  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
049A  A80C     BTFSS PFNf_off, 4, ACCESS
049C  D004     BRA 0x4A6
049E  DA7E     RCALL PL60
04A0  EC2F     CALL 0xAA5E, 0
04A2  F055     NOP
04A4  D01B     BRA 0x4DC
1448:          								else
1449:          								if(!PFNf_errCW&&PFNf_set_aleg) PrintCW(PFN.CW,0);
04A6  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
04A8  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
04AA  D004     BRA 0x4B4
04AC  DA77     RCALL PL60
04AE  EC2F     CALL 0xAA5E, 0
04B0  F055     NOP
04B2  D014     BRA 0x4DC
1450:          								else
1451:          								if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);
04B4  DA79     RCALL PL66
04B6  E302     BNC 0x4BC
04B8  BC10     BTFSC PFNf_str_nco, 6, ACCESS
04BA  D004     BRA 0x4C4
04BC  DABD     RCALL PL592
04BE  EC54     CALL 0x9AA8, 0
04C0  F04D     NOP
04C2  D00C     BRA 0x4DC
1452:          								else
1453:          								{
1454:           									ClrDig(0,0,0);
04C4  0E00     MOVLW 0x0
04C6  0100     MOVLB 0x0
04C8  6F7E     MOVWF _PFNf_set_eco, BANKED
04CA  6F7F     MOVWF _PFNf_set_fnserw, BANKED
04CC  EC54     CALL 0x9AA8, 0
04CE  F04D     NOP
1455:          									if(!PFNf_errCW) PrintCW(PFN.CW,0);
04D0  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
04D2  D004     BRA 0x4DC
04D4  0E00     MOVLW 0x0
04D6  DA7E     RCALL PL188
04D8  EC2F     CALL 0xAA5E, 0
04DA  F055     NOP
1456:          								}
1457:          								ClrDig(0,1,0);
04DC  0E01     MOVLW 0x1
04DE  DA92     RCALL PL424
04E0  EC54     CALL 0x9AA8, 0
04E2  F04D     NOP
04E4  D1A3     BRA 0x82C
1458:          							}
1459:          						}
1460:          					}
1461:          				}
1462:          				else
1463:          				{
1464:          					if(!PFNf_EnAleg)
04E6  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
04E8  D00F     BRA 0x508
1465:          					{
1466:          						if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
04EA  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
04EC  A80C     BTFSS PFNf_off, 4, ACCESS
04EE  D004     BRA 0x4F8
04F0  DA55     RCALL PL60
04F2  EC2F     CALL 0xAA5E, 0
04F4  F055     NOP
04F6  D003     BRA 0x4FE
1467:          						else ClrDig(1,0,0);
04F8  DA80     RCALL PL398
04FA  EC54     CALL 0x9AA8, 0
04FC  F04D     NOP
1468:          						ClrDig(0,1,0);															//wygaszenie najmlodszych cyfr
04FE  0E01     MOVLW 0x1
0500  DA81     RCALL PL424
0502  EC54     CALL 0x9AA8, 0
0504  F04D     NOP
1469:          					}
0506  D192     BRA 0x82C
1470:          					else
1471:          					{
1472:          						
1473:          						if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
0508  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
050A  A80C     BTFSS PFNf_off, 4, ACCESS
050C  D004     BRA 0x516
050E  DA46     RCALL PL60
0510  EC2F     CALL 0xAA5E, 0
0512  F055     NOP
0514  D00B     BRA 0x52C
1474:          						else
1475:          						if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);
0516  DA48     RCALL PL66
0518  E302     BNC 0x51E
051A  BC10     BTFSC PFNf_str_nco, 6, ACCESS
051C  D004     BRA 0x526
051E  DA8C     RCALL PL592
0520  EC54     CALL 0x9AA8, 0
0522  F04D     NOP
0524  D003     BRA 0x52C
1476:          						else ClrDig(1,0,0);
0526  DA69     RCALL PL398
0528  EC54     CALL 0x9AA8, 0
052A  F04D     NOP
1477:          						ClrDig(0,1,0);
052C  0E01     MOVLW 0x1
052E  DA6A     RCALL PL424
0530  EC54     CALL 0x9AA8, 0
0532  F04D     NOP
0534  D17B     BRA 0x82C
1478:          					}
1479:          				}				
1480:          			}
1481:          			else
1482:          			//-----------------------------------
1483:          			//tryb ZIMA
1484:          			if(PFNf_ofzima)
0536  A20D     BTFSS PFNf_plmCO, 1, ACCESS
0538  D179     BRA 0x82C
1485:          			{
1486:          				if(!PFNf_ofnserw&&!PFNf_oaleg&&!PFNf_set_fnserw&&!PFNf_set_aleg)
053A  AE0C     BTFSS PFNf_off, 7, ACCESS
053C  B40C     BTFSC PFNf_off, 2, ACCESS
053E  D121     BRA 0x782
0540  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
0542  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
0544  D11E     BRA 0x782
1487:          				{
1488:          					if(!PFNf_obgCO&&!PFNf_obgCW)										//oba obiegi nieaktywne?
0546  A60C     BTFSS PFNf_off, 3, ACCESS
0548  B80C     BTFSC PFNf_off, 4, ACCESS
054A  D073     BRA 0x632
1489:          					{
1490:          						if(PFNf_prn_res)
054C  A20F     BTFSS PFNf_set_fnserw, 1, ACCESS
054E  D037     BRA 0x5BE
1491:          						{
1492:          							if(PFNf_prn_cs)
0550  AA0E     BTFSS PFNf_popFN, 5, ACCESS
0552  D020     BRA 0x594
1493:          							{
1494:          								if(!PFNf_EnAleg)
0554  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
0556  D005     BRA 0x562
1495:          								{
1496:          									PrintCS(PFN.CS,0);							//wylaczny wskaz CS
0558  0E00     MOVLW 0x0
055A  DA32     RCALL PL72
055C  ECBA     CALL 0x9574, 0
055E  F04A     NOP
1497:          								}
0560  D165     BRA 0x82C
1498:          								else
1499:          								{
1500:          									if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) PrintCS(PFN.CS,1);					//dzielony wskaz CS
0562  DA22     RCALL PL66
0564  E302     BNC 0x56A
0566  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0568  D005     BRA 0x574
056A  0E01     MOVLW 0x1
056C  DA29     RCALL PL72
056E  ECBA     CALL 0x9574, 0
0570  F04A     NOP
0572  D15C     BRA 0x82C
1501:          									else 
1502:          									{
1503:          											if(!PFNf_errCW) 
0574  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0576  D009     BRA 0x58A
1504:          											{
1505:          												PrintCS(PFN.CS,1);								//dzielony wskaz CS
0578  0E01     MOVLW 0x1
057A  DA22     RCALL PL72
057C  ECBA     CALL 0x9574, 0
057E  F04A     NOP
1506:          												PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
0580  0E01     MOVLW 0x1
0582  DA28     RCALL PL188
0584  EC2F     CALL 0xAA5E, 0
0586  F055     NOP
1507:          											}
0588  D151     BRA 0x82C
1508:          											else PrintCS(PFN.CS,0);								//wylaczny wskaz CS
058A  0E00     MOVLW 0x0
058C  DA19     RCALL PL72
058E  ECBA     CALL 0x9574, 0
0590  F04A     NOP
0592  D14C     BRA 0x82C
1509:          									}
1510:          								}								
1511:          							}
1512:          							else
1513:          							if(PFNf_prn_in) PrintIN(PFN.IN);						//wylaczny wskaz IN
0594  AC0E     BTFSS PFNf_popFN, 6, ACCESS
0596  D005     BRA 0x5A2
0598  0101     MOVLB 0x1
059A  51DB     MOVF zmn2, W, BANKED
059C  ECEC     CALL 0x9FD8, 0
059E  F04F     NOP
05A0  D145     BRA 0x82C
1514:                                      else
1515:                                      if(PFNf_prn_pp) PrintPP(PFN.PP);						//wylaczny wskaz PP
05A2  A00F     BTFSS PFNf_set_fnserw, 0, ACCESS
05A4  D005     BRA 0x5B0
05A6  0101     MOVLB 0x1
05A8  51DC     MOVF pp, W, BANKED
05AA  EC4A     CALL 0x9C94, 0
05AC  F04E     NOP
05AE  D13E     BRA 0x82C
1516:                                      else
1517:                                      if(PFNf_prn_pg) PrintPG(PFN.PG);						//wylaczny wskaz PG
05B0  AE0E     BTFSS PFNf_popFN, 7, ACCESS
05B2  D13C     BRA 0x82C
05B4  0101     MOVLB 0x1
05B6  51DD     MOVF MOTFkrk, W, BANKED
05B8  EC82     CALL 0xAB04, 0
05BA  F055     NOP
05BC  D137     BRA 0x82C
1518:                                      /*
1519:          							{
1520:          								if(PFNf_prn_in) PrintIN(PFN.IN);							//wylaczny wskaz IN
1521:          							} 
1522:                                       */                           
1523:          						}
1524:          						else 
1525:          						{
1526:          							if(!PFNf_EnAleg)
05BE  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
05C0  D00F     BRA 0x5E0
1527:          							{
1528:          								if(PFNf_fL3) PrintCO(PFN.CO,1,PFNf_fL3);
05C2  A00A     BTFSS PFNf_firstEdge, 0, ACCESS
05C4  D004     BRA 0x5CE
05C6  D9E0     RCALL PL28
05C8  EC51     CALL 0x98A2, 0
05CA  F04C     NOP
05CC  D005     BRA 0x5D8
1529:          								else ClrDig(0,1,0);
05CE  0E01     MOVLW 0x1
05D0  0100     MOVLB 0x0
05D2  DA18     RCALL PL424
05D4  EC54     CALL 0x9AA8, 0
05D6  F04D     NOP
1530:          								ClrDig(1,0,0);
05D8  DA26     RCALL PL524
05DA  EC54     CALL 0x9AA8, 0
05DC  F04D     NOP
1531:          							}
05DE  D126     BRA 0x82C
1532:          							else
1533:          							{
1534:          								if(PFNf_fL3)
05E0  A00A     BTFSS PFNf_firstEdge, 0, ACCESS
05E2  D013     BRA 0x60A
05E4  D9D1     RCALL PL28
1535:          								{
1536:           									PrintCO(PFN.CO,1,PFNf_fL3);
05E6  EC51     CALL 0x98A2, 0
05E8  F04C     NOP
05EA  D9DE     RCALL PL66
1537:          									if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);
05EC  E302     BNC 0x5F2
05EE  BC10     BTFSC PFNf_str_nco, 6, ACCESS
05F0  D005     BRA 0x5FC
05F2  0E00     MOVLW 0x0
05F4  DA1C     RCALL PL528
05F6  EC54     CALL 0x9AA8, 0
05F8  F04D     NOP
05FA  D118     BRA 0x82C
1538:          									else
1539:          									{
1540:          										if(!PFNf_errCW) PrintCW(PFN.CW,1);
05FC  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
05FE  D116     BRA 0x82C
0600  0E01     MOVLW 0x1
0602  D9E3     RCALL PL88
0604  EC2F     CALL 0xAA5E, 0
0606  F055     NOP
0608  D111     BRA 0x82C
1541:          									}
1542:          								}
1543:          								else
1544:          								{
1545:           									ClrDig(0,1,0);
060A  0E01     MOVLW 0x1
060C  0100     MOVLB 0x0
060E  D9FA     RCALL PL424
0610  EC54     CALL 0x9AA8, 0
0612  F04D     NOP
0614  D9C9     RCALL PL66
1546:          									if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);
0616  E302     BNC 0x61C
0618  BC10     BTFSC PFNf_str_nco, 6, ACCESS
061A  D005     BRA 0x626
061C  0E00     MOVLW 0x0
061E  DA07     RCALL PL528
0620  EC54     CALL 0x9AA8, 0
0622  F04D     NOP
0624  D103     BRA 0x82C
1547:          									else
1548:          									{
1549:          										if(!PFNf_errCW) PrintCW(PFN.CW,0);
0626  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0628  D101     BRA 0x82C
062A  D9B8     RCALL PL60
062C  EC2F     CALL 0xAA5E, 0
062E  F055     NOP
0630  D0FD     BRA 0x82C
1550:          									}
1551:          								}
1552:          							}
1553:          						}
1554:          					}
1555:          					else																//dowolny obieg aktywny
1556:          					{
1557:          						if(PFNf_obgCO)													//aktywny obieg CO?
0632  A60C     BTFSS PFNf_off, 3, ACCESS
0634  D078     BRA 0x726
1558:          						{
1559:          							if(PFNf_prn_res)
0636  A20F     BTFSS PFNf_set_fnserw, 1, ACCESS
0638  D037     BRA 0x6A8
1560:          							{
1561:          								if(PFNf_prn_cs)
063A  AA0E     BTFSS PFNf_popFN, 5, ACCESS
063C  D020     BRA 0x67E
1562:          								{
1563:          									if(!PFNf_EnAleg)
063E  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
0640  D005     BRA 0x64C
1564:          									{
1565:          										PrintCS(PFN.CS,0);							//wylaczny wskaz CS
0642  0E00     MOVLW 0x0
0644  D9BD     RCALL PL72
0646  ECBA     CALL 0x9574, 0
0648  F04A     NOP
1566:          									}
064A  D0F0     BRA 0x82C
1567:          									else
1568:          									{
1569:          										if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) PrintCS(PFN.CS,1);					//dzielony wskaz CS
064C  D9AD     RCALL PL66
064E  E302     BNC 0x654
0650  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0652  D005     BRA 0x65E
0654  0E01     MOVLW 0x1
0656  D9B4     RCALL PL72
0658  ECBA     CALL 0x9574, 0
065A  F04A     NOP
065C  D0E7     BRA 0x82C
1570:          										else 
1571:          										{
1572:          												if(!PFNf_errCW) 
065E  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0660  D009     BRA 0x674
1573:          												{
1574:          													PrintCS(PFN.CS,1);								//dzielony wskaz CS
0662  0E01     MOVLW 0x1
0664  D9AD     RCALL PL72
0666  ECBA     CALL 0x9574, 0
0668  F04A     NOP
1575:          													PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
066A  0E01     MOVLW 0x1
066C  D9B3     RCALL PL188
066E  EC2F     CALL 0xAA5E, 0
0670  F055     NOP
1576:          												}
0672  D0DC     BRA 0x82C
1577:          												else PrintCS(PFN.CS,0);								//wylaczny wskaz CS
0674  0E00     MOVLW 0x0
0676  D9A4     RCALL PL72
0678  ECBA     CALL 0x9574, 0
067A  F04A     NOP
067C  D0D7     BRA 0x82C
1578:          										}
1579:          									}
1580:          								}
1581:          								else
1582:          								if(PFNf_prn_in) PrintIN(PFN.IN);						//wylaczny wskaz IN
067E  AC0E     BTFSS PFNf_popFN, 6, ACCESS
0680  D005     BRA 0x68C
0682  0101     MOVLB 0x1
0684  51DB     MOVF zmn2, W, BANKED
0686  ECEC     CALL 0x9FD8, 0
0688  F04F     NOP
068A  D0D0     BRA 0x82C
1583:          								else
1584:          								if(PFNf_prn_pp) PrintPP(PFN.PP);						//wylaczny wskaz PP
068C  A00F     BTFSS PFNf_set_fnserw, 0, ACCESS
068E  D005     BRA 0x69A
0690  0101     MOVLB 0x1
0692  51DC     MOVF pp, W, BANKED
0694  EC4A     CALL 0x9C94, 0
0696  F04E     NOP
0698  D0C9     BRA 0x82C
1585:          								else
1586:          								if(PFNf_prn_pg) PrintPG(PFN.PG);						//wylaczny wskaz PG
069A  AE0E     BTFSS PFNf_popFN, 7, ACCESS
069C  D0C7     BRA 0x82C
069E  0101     MOVLB 0x1
06A0  51DD     MOVF MOTFkrk, W, BANKED
06A2  EC82     CALL 0xAB04, 0
06A4  F055     NOP
06A6  D0C2     BRA 0x82C
1587:          							}
1588:          							else														//wskaz CO
1589:          							{
1590:          								//wskaz temp CO
1591:          								if(!PFNf_errCO) 
06A8  B809     BTFSC PFNf_b_str_nco, 4, ACCESS
06AA  D01E     BRA 0x6E8
1592:          								{
1593:          									if(!PFNf_EnAleg)
06AC  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
06AE  D007     BRA 0x6BE
1594:          									{
1595:          										PrintCO(PFN.CO,0,PFNf_fL3);							//wylaczny wskaz temp CO
06B0  0E00     MOVLW 0x0
06B2  0100     MOVLB 0x0
06B4  6F7E     MOVWF _PFNf_set_eco, BANKED
06B6  D97E     RCALL PL68
06B8  EC51     CALL 0x98A2, 0
06BA  F04C     NOP
1596:          									}
06BC  D01A     BRA 0x6F2
1597:          									else
1598:          									{
1599:          										if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) PrintCO(PFN.CO,1,PFNf_fL3);	//dzielony wskaz temp CO
06BE  D974     RCALL PL66
06C0  E302     BNC 0x6C6
06C2  BC10     BTFSC PFNf_str_nco, 6, ACCESS
06C4  D004     BRA 0x6CE
06C6  D960     RCALL PL28
06C8  EC51     CALL 0x98A2, 0
06CA  F04C     NOP
06CC  D012     BRA 0x6F2
1600:          										else 
1601:          										{
1602:          											if(!PFNf_errCW) 
06CE  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
06D0  D004     BRA 0x6DA
06D2  D95A     RCALL PL28
1603:          											{
1604:          												PrintCO(PFN.CO,1,PFNf_fL3);						//dzielony wskaz temp CO
06D4  EC51     CALL 0x98A2, 0
06D6  F04C     NOP
1605:          											}
06D8  D00C     BRA 0x6F2
1606:          											else PrintCO(PFN.CO,0,PFNf_fL3);					//wylaczny wskaz temp CO
06DA  0E00     MOVLW 0x0
06DC  0100     MOVLB 0x0
06DE  6F7E     MOVWF _PFNf_set_eco, BANKED
06E0  D969     RCALL PL68
06E2  EC51     CALL 0x98A2, 0
06E4  F04C     NOP
06E6  D005     BRA 0x6F2
1607:          										}
1608:          									}
1609:          								}
1610:          								else ClrDig(0,1,0);
06E8  0E01     MOVLW 0x1
06EA  0100     MOVLB 0x0
06EC  D98B     RCALL PL424
06EE  EC54     CALL 0x9AA8, 0
06F0  F04D     NOP
1611:          								//wskaz temp CW
1612:          								if(!PFNf_EnAleg)
06F2  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
06F4  D004     BRA 0x6FE
06F6  D997     RCALL PL524
1613:          								{
1614:          									ClrDig(1,0,0);											//wygaszony wskaz WU
06F8  EC54     CALL 0x9AA8, 0
06FA  F04D     NOP
1615:          								}
06FC  D097     BRA 0x82C
1616:          								else
1617:          								{
1618:          									if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);					//dwie kreski na WU
06FE  D954     RCALL PL66
0700  E302     BNC 0x706
0702  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0704  D005     BRA 0x710
0706  0E00     MOVLW 0x0
0708  D992     RCALL PL528
070A  EC54     CALL 0x9AA8, 0
070C  F04D     NOP
070E  D08E     BRA 0x82C
1619:          									else 
1620:          									{
1621:          										if(!PFNf_errCW) PrintCW(PFN.CW,1);					//dzielony wskaz temp CW
0710  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0712  D005     BRA 0x71E
0714  0E01     MOVLW 0x1
0716  D959     RCALL PL88
0718  EC2F     CALL 0xAA5E, 0
071A  F055     NOP
071C  D087     BRA 0x82C
1622:          										else ClrDig(1,0,0);									//wygaszony wskaz WU
071E  D968     RCALL PL396
0720  EC54     CALL 0x9AA8, 0
0722  F04D     NOP
0724  D083     BRA 0x82C
1623:          									}
1624:          								}
1625:          							}
1626:          						}
1627:          						else															//aktywny obieg CW
1628:          						{
1629:          							if(PFNf_prn_res)
0726  A20F     BTFSS PFNf_set_fnserw, 1, ACCESS
0728  D026     BRA 0x776
1630:          							{
1631:          								if(PFNf_prn_cs)											//aktywny wskaz cisnienia?
072A  AA0E     BTFSS PFNf_popFN, 5, ACCESS
072C  D00F     BRA 0x74C
1632:          								{
1633:          									PrintCS(PFN.CS,1);									//dzielony wskaz CS	
072E  0E01     MOVLW 0x1
0730  D947     RCALL PL72
0732  ECBA     CALL 0x9574, 0
0734  F04A     NOP
1634:          									if(!PFNf_errCW) 
0736  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0738  D005     BRA 0x744
1635:          									{
1636:          										PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
073A  0E01     MOVLW 0x1
073C  D94B     RCALL PL188
073E  EC2F     CALL 0xAA5E, 0
0740  F055     NOP
1637:          									}
0742  D074     BRA 0x82C
1638:          									else ClrDig(1,0,0);									//dwie kreski
0744  D970     RCALL PL524
0746  EC54     CALL 0x9AA8, 0
0748  F04D     NOP
074A  D070     BRA 0x82C
1639:          								}
1640:          								else
1641:          								if(PFNf_prn_in) 
074C  AC0E     BTFSS PFNf_popFN, 6, ACCESS
074E  D005     BRA 0x75A
1642:                                          {
1643:                                              PrintCo(PFN.rCO);                                   //wylaczny wskaz CO (wartosc rzeczywista lub przefiltrowana)
0750  0101     MOVLB 0x1
0752  51F4     MOVF 0xF4, W, BANKED
0754  EC4A     CALL 0xA494, 0
0756  F052     NOP
1644:                                              /*if(RSDT1.vSTD>=2)
1645:                                              {
1646:                                                  PrintCo(PFN.rCO);                               //wylaczny wskaz CO (wartosc rzeczywista)
1647:                                              }
1648:                                              else
1649:                                              {
1650:                                                  PrintCo(PFN.CO);                               //wylaczny wskaz CO  (filtr)                                      
1651:                                              }*/
1652:                                          }
0758  D069     BRA 0x82C
1653:          								else
1654:          								if(PFNf_prn_pp) PrintPP(PFN.PP);						//wylaczny wskaz PP
075A  A00F     BTFSS PFNf_set_fnserw, 0, ACCESS
075C  D005     BRA 0x768
075E  0101     MOVLB 0x1
0760  51DC     MOVF pp, W, BANKED
0762  EC4A     CALL 0x9C94, 0
0764  F04E     NOP
0766  D062     BRA 0x82C
1655:          								else
1656:          								if(PFNf_prn_pg) PrintPG(PFN.PG);						//wylaczny wskaz PG                                
0768  AE0E     BTFSS PFNf_popFN, 7, ACCESS
076A  D060     BRA 0x82C
076C  0101     MOVLB 0x1
076E  51DD     MOVF MOTFkrk, W, BANKED
0770  EC82     CALL 0xAB04, 0
0772  F055     NOP
0774  D05B     BRA 0x82C
1657:          							}
1658:          							else														//wskaz CW
1659:          							{
1660:          								if(!PFNf_errCW) PrintCW(PFN.CW,0);						//wylaczny wskaz temp CW
0776  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0778  D059     BRA 0x82C
077A  D910     RCALL PL60
077C  EC2F     CALL 0xAA5E, 0
077E  F055     NOP
0780  D055     BRA 0x82C
1661:          							}
1662:          						}                        
1663:          						/*else															//aktywny obieg CW
1664:          						{
1665:          							if(PFNf_prn_res)
1666:          							{
1667:          								if(PFNf_prn_cs)											//aktywny wskaz cisnienia?
1668:          								{
1669:          									PrintCS(PFN.CS,1);									//dzielony wskaz CS	
1670:          									if(!PFNf_errCW) 
1671:          									{
1672:          										PrintCW(PFN.CW,1);								//dzielony wskaz temp CW
1673:          									}
1674:          									else ClrDig(1,0,0);									//dwie kreski
1675:          								}
1676:          							}
1677:          							else														//wskaz CW
1678:          							{
1679:          								if(!PFNf_errCW) PrintCW(PFN.CW,0);						//wylaczny wskaz temp CW
1680:          							}
1681:          						}*/
1682:          					}
1683:          				}
1684:          				else																	//aktywna funkcja serwisowa lub antylegionella
1685:          				{
1686:          					if(PFNf_ofnserw||PFNf_set_fnserw) 									//aktywna funkcja serwisowa?								
0782  BE0C     BTFSC PFNf_off, 7, ACCESS
0784  D002     BRA 0x78A
0786  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
0788  D012     BRA 0x7AE
1687:          					{
1688:          						if(!PFNf_fshowLpulse) SetLightLLed(1); 												//rozswietlenie maksymalne
078A  B40B     BTFSC PFNf_lato, 2, ACCESS
078C  D003     BRA 0x794
078E  0E01     MOVLW 0x1
0790  ECE4     CALL 0xA5C8, 0
0792  F052     NOP
1689:          						if(!PFNf_errCO) PrintCO(PFN.CO,1,PFNf_fL3);						//dzielony wskaz temp CO z predkoscia obrotowa
0794  B809     BTFSC PFNf_b_str_nco, 4, ACCESS
0796  D003     BRA 0x79E
0798  D8F7     RCALL PL28
079A  EC51     CALL 0x98A2, 0
079C  F04C     NOP
1690:          						PrintVNT(PFN.VNT,1);
079E  0E01     MOVLW 0x1
07A0  0100     MOVLB 0x0
07A2  6F7E     MOVWF _PFNf_set_eco, BANKED
07A4  0101     MOVLB 0x1
07A6  51DF     MOVF RSerial1, W, BANKED
07A8  ECFF     CALL 0xA7FE, 0
07AA  F053     NOP
1691:          					}
07AC  D03F     BRA 0x82C
1692:          					else																//aktywna funkcja antylegionella
1693:          					{
1694:          						if(!PFNf_EnAleg)
07AE  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
07B0  D016     BRA 0x7DE
1695:          						{
1696:          							if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
07B2  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
07B4  A80C     BTFSS PFNf_off, 4, ACCESS
07B6  D004     BRA 0x7C0
07B8  D8F1     RCALL PL60
07BA  EC2F     CALL 0xAA5E, 0
07BC  F055     NOP
07BE  D00A     BRA 0x7D4
1697:          							else
1698:          							if(!PFNf_errCW&&PFNf_set_aleg) PrintCW(PFN.CW,0);
07C0  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
07C2  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
07C4  D004     BRA 0x7CE
07C6  D8EA     RCALL PL60
07C8  EC2F     CALL 0xAA5E, 0
07CA  F055     NOP
07CC  D003     BRA 0x7D4
1699:          							else ClrDig(1,0,0);
07CE  D910     RCALL PL396
07D0  EC54     CALL 0x9AA8, 0
07D2  F04D     NOP
1700:          							ClrDig(0,1,0);															//wygaszenie najmlodszych cyfr
07D4  0E01     MOVLW 0x1
07D6  D916     RCALL PL424
07D8  EC54     CALL 0x9AA8, 0
07DA  F04D     NOP
1701:          						}
07DC  D027     BRA 0x82C
1702:          						else
1703:          						{
1704:          							if(!PFNf_errCW&&PFNf_obgCW) PrintCW(PFN.CW,0);
07DE  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
07E0  A80C     BTFSS PFNf_off, 4, ACCESS
07E2  D004     BRA 0x7EC
07E4  D8DB     RCALL PL60
07E6  EC2F     CALL 0xAA5E, 0
07E8  F055     NOP
07EA  D01C     BRA 0x824
1705:          							else
1706:          							if(!PFNf_errCW&&PFNf_set_aleg) PrintCW(PFN.CW,0);
07EC  AC09     BTFSS PFNf_b_str_nco, 6, ACCESS
07EE  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
07F0  D004     BRA 0x7FA
07F2  D8D4     RCALL PL60
07F4  EC2F     CALL 0xAA5E, 0
07F6  F055     NOP
07F8  D015     BRA 0x824
1707:          							else
1708:          							if(PFN.PCW<PFN.minPCW||!PFNf_timZAS) ClrDig(1,0,1);
07FA  D8D6     RCALL PL66
07FC  E302     BNC 0x802
07FE  BC10     BTFSC PFNf_str_nco, 6, ACCESS
0800  D008     BRA 0x812
0802  0E00     MOVLW 0x0
0804  0100     MOVLB 0x0
0806  6F7E     MOVWF _PFNf_set_eco, BANKED
0808  0E01     MOVLW 0x1
080A  6F7F     MOVWF _PFNf_set_fnserw, BANKED
080C  EC54     CALL 0x9AA8, 0
080E  F04D     NOP
0810  D009     BRA 0x824
1709:          							else
1710:          							{
1711:          								if(!PFNf_errCW) PrintCW(PFN.CW,0);
0812  BC09     BTFSC PFNf_b_str_nco, 6, ACCESS
0814  D004     BRA 0x81E
0816  D8C2     RCALL PL60
0818  EC2F     CALL 0xAA5E, 0
081A  F055     NOP
081C  D003     BRA 0x824
1712:          								else ClrDig(1,0,0);
081E  D8E8     RCALL PL396
0820  EC54     CALL 0x9AA8, 0
0822  F04D     NOP
1713:          							}
1714:          							ClrDig(0,1,0);
0824  0E01     MOVLW 0x1
0826  D8EE     RCALL PL424
0828  EC54     CALL 0x9AA8, 0
082A  F04D     NOP
1715:          						}
1716:          					}
1717:          				}			
1718:          			}
1719:          			//-----------------------------------
1720:          			//nastawa CO/CW
1721:          			NastawaCOCW();
082C  ECBB     CALL 0x4F76, 0
082E  F027     NOP
1722:          			//-----------------------------------
1723:          		}
1724:          	}
1725:          	//znaki wysterowywane niezale¿nie (sygna³y z UNI-02)
1726:          	Mark(_GZ_PLW,PFNf_plmCW);												//znacznik plomien CW
0830  0E00     MOVLW 0x0
0832  B00E     BTFSC PFNf_popFN, 0, ACCESS
0834  0E01     MOVLW 0x1
0836  0100     MOVLB 0x0
0838  6F7A     MOVWF _PFNf_res, BANKED
083A  0E09     MOVLW 0x9
083C  EC1F     CALL 0xB83E, 0
083E  F05C     NOP
1727:          	Mark(_GZ_PLC,PFNf_plmCO);												//znacznik plomien CO
0840  0E00     MOVLW 0x0
0842  BE0D     BTFSC PFNf_plmCO, 7, ACCESS
0844  0E01     MOVLW 0x1
0846  6F7A     MOVWF _PFNf_res, BANKED
0848  0E08     MOVLW 0x8
084A  EC1F     CALL 0xB83E, 0
084C  F05C     NOP
1728:          	Mark(_GZ_PGD,PFNf_pgd&&!PFNf_oflato&&!PFNf_ofoff&&!PFNf_opKNF);			//znacznik funkcja pogodowa
084E  6BA6     CLRF sign, BANKED
0850  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
0852  BC0C     BTFSC PFNf_off, 6, ACCESS
0854  D005     BRA 0x860
0856  A00D     BTFSS PFNf_plmCO, 0, ACCESS
0858  B40D     BTFSC PFNf_plmCO, 2, ACCESS
085A  D002     BRA 0x860
085C  0E01     MOVLW 0x1
085E  6FA6     MOVWF sign, BANKED
0860  C0A6     MOVFF sign, _PFNf_res
0862  F07A     NOP
0864  0E07     MOVLW 0x7
0866  EC1F     CALL 0xB83E, 0
0868  F05C     NOP
1729:          	Mark(_GZ_DCO,PFNf_ofzima&&!PFNf_ofoff&&!PFNf_opKNF);					//znacznik KALORYFER
086A  6BA7     CLRF x, BANKED
086C  B20D     BTFSC PFNf_plmCO, 1, ACCESS
086E  B00D     BTFSC PFNf_plmCO, 0, ACCESS
0870  D004     BRA 0x87A
0872  B40D     BTFSC PFNf_plmCO, 2, ACCESS
0874  D002     BRA 0x87A
0876  0E01     MOVLW 0x1
0878  6FA7     MOVWF x, BANKED
087A  C0A7     MOVFF x, _PFNf_res
087C  F07A     NOP
087E  0E00     MOVLW 0x0
0880  EC1F     CALL 0xB83E, 0
0882  F05C     NOP
1730:          	Mark(_GZ_DCW,(PFNf_ofzima||PFNf_oflato)&&!PFNf_ofoff&&!PFNf_opKNF);		//znacznik KRAN
0884  6BA8     CLRF sign, BANKED
0886  B20D     BTFSC PFNf_plmCO, 1, ACCESS
0888  D002     BRA 0x88E
088A  AC0C     BTFSS PFNf_off, 6, ACCESS
088C  D005     BRA 0x898
088E  A00D     BTFSS PFNf_plmCO, 0, ACCESS
0890  B40D     BTFSC PFNf_plmCO, 2, ACCESS
0892  D002     BRA 0x898
0894  0E01     MOVLW 0x1
0896  6FA8     MOVWF sign, BANKED
0898  C0A8     MOVFF sign, _PFNf_res
089A  F07A     NOP
089C  0E01     MOVLW 0x1
089E  EC1F     CALL 0xB83E, 0
08A0  F05C     NOP
1731:          	Mark(_GZ_OFF,PFNf_ofoff&&!PFNf_opKNF);									//znacznik OFF
08A2  6BA9     CLRF dt, BANKED
08A4  B00D     BTFSC PFNf_plmCO, 0, ACCESS
08A6  B40D     BTFSC PFNf_plmCO, 2, ACCESS
08A8  D002     BRA 0x8AE
08AA  0E01     MOVLW 0x1
08AC  6FA9     MOVWF dt, BANKED
08AE  C0A9     MOVFF dt, _PFNf_res
08B0  F07A     NOP
08B2  0E0A     MOVLW 0xA
08B4  EC1F     CALL 0xB83E, 0
08B6  F05C     NOP
1732:                  if(PFNf_fsetLaddr)
08B8  A00B     BTFSS PFNf_lato, 0, ACCESS
08BA  D004     BRA 0x8C4
1733:          		Mark(_GZ_SRV,1);
08BC  D8C6     RCALL PL826
08BE  EC1F     CALL 0xB83E, 0
08C0  F05C     NOP
08C2  D015     BRA 0x8EE
1734:                  else
1735:                  if(PFNf_set_fnserw||PFNf_set_aleg)
08C4  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
08C6  D002     BRA 0x8CC
08C8  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
08CA  D005     BRA 0x8D6
1736:          		Mark(_GZ_SRV,2);								//znacznik KLUCZ migajacy
08CC  0E02     MOVLW 0x2
08CE  6F7A     MOVWF _PFNf_res, BANKED
08D0  EC1F     CALL 0xB83E, 0
08D2  F05C     NOP
08D4  D00C     BRA 0x8EE
1737:          	else
1738:          	if((PFNf_oaleg||PFNf_ofnserw))
08D6  B40C     BTFSC PFNf_off, 2, ACCESS
08D8  D002     BRA 0x8DE
08DA  AE0C     BTFSS PFNf_off, 7, ACCESS
08DC  D004     BRA 0x8E6
1739:          		Mark(_GZ_SRV,1);								//znacznik KLUCZ staly
08DE  D8B5     RCALL PL826
08E0  EC1F     CALL 0xB83E, 0
08E2  F05C     NOP
08E4  D004     BRA 0x8EE
1740:          	else
1741:          		Mark(_GZ_SRV,0);								//znacznik KLUCZ wygaszony
08E6  6B7A     CLRF _PFNf_res, BANKED
08E8  0E02     MOVLW 0x2
08EA  EC1F     CALL 0xB83E, 0
08EC  F05C     NOP
1742:          
1743:          	if(!PFNf_opKNF&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_set_ncw&&!PFNf_set_nco&&!PFNf_set_eco)
08EE  A40D     BTFSS PFNf_plmCO, 2, ACCESS
08F0  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
08F2  0012     RETURN 0
08F4  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
08F6  B210     BTFSC PFNf_str_nco, 1, ACCESS
08F8  0012     RETURN 0
08FA  A010     BTFSS PFNf_str_nco, 0, ACCESS
08FC  BC0F     BTFSC PFNf_set_fnserw, 6, ACCESS
08FE  0012     RETURN 0
1744:          	{
1745:          		if(PFNf_ofnserw||PFNf_set_fnserw||PFNf_oaleg||PFNf_set_aleg)
0900  AE0C     BTFSS PFNf_off, 7, ACCESS
0902  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
0904  D005     BRA 0x910
0906  B40C     BTFSC PFNf_off, 2, ACCESS
0908  D003     BRA 0x910
090A  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
090C  EF03     GOTO 0xBC06
090E  F05E     NOP
1746:          		{
1747:          			if(PFNf_oaleg||PFNf_set_aleg)		//antylegionella
0910  B40C     BTFSC PFNf_off, 2, ACCESS
0912  D002     BRA 0x918
0914  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
0916  D014     BRA 0x940
1748:          			{
1749:          	 			Mark(_GZ_MNCW,0);													//wygas min CW
0918  6B7A     CLRF _PFNf_res, BANKED
091A  0E0C     MOVLW 0xC
091C  EC1F     CALL 0xB83E, 0
091E  F05C     NOP
1750:          				Mark(_GZ_MXCW,PFNf_oaleg||PFNf_set_aleg);							//zapal max CW dla antylegionella
0920  0E01     MOVLW 0x1
0922  6FAA     MOVWF f, BANKED
0924  A40C     BTFSS PFNf_off, 2, ACCESS
0926  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
0928  D001     BRA 0x92C
092A  6BAA     CLRF f, BANKED
092C  C0AA     MOVFF f, _PFNf_res
092E  F07A     NOP
0930  0E0B     MOVLW 0xB
0932  EC1F     CALL 0xB83E, 0
0934  F05C     NOP
1751:          				Mark(_GZ_MXCO,0);
0936  6B7A     CLRF _PFNf_res, BANKED
0938  0E0D     MOVLW 0xD
093A  EC1F     CALL 0xB83E, 0
093C  F05C     NOP
093E  D020     BRA 0x980
1752:          				Mark(_GZ_MNCO,0);
1753:          			}
1754:          			else								//funkca serwisowa
1755:          			{
1756:          				Mark(_GZ_MNCW,(PFNf_ofnserw||PFNf_set_fnserw)&&!PFNf_fns_max);		//zapal min CW dla serwisowej przy fmax=0
0940  6BAB     CLRF 0xAB, BANKED
0942  BE0C     BTFSC PFNf_off, 7, ACCESS
0944  D002     BRA 0x94A
0946  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
0948  D004     BRA 0x952
094A  BA0A     BTFSC PFNf_firstEdge, 5, ACCESS
094C  D002     BRA 0x952
094E  0E01     MOVLW 0x1
0950  6FAB     MOVWF 0xAB, BANKED
0952  C0AB     MOVFF 0xAB, _PFNf_res
0954  F07A     NOP
0956  0E0C     MOVLW 0xC
0958  EC1F     CALL 0xB83E, 0
095A  F05C     NOP
1757:          				Mark(_GZ_MXCW,(PFNf_ofnserw||PFNf_set_fnserw)&&PFNf_fns_max);		//zapal min CW dla serwisowej przy fmax=1	
095C  6BAC     CLRF 0xAC, BANKED
095E  BE0C     BTFSC PFNf_off, 7, ACCESS
0960  D002     BRA 0x966
0962  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
0964  D004     BRA 0x96E
0966  AA0A     BTFSS PFNf_firstEdge, 5, ACCESS
0968  D002     BRA 0x96E
096A  0E01     MOVLW 0x1
096C  6FAC     MOVWF 0xAC, BANKED
096E  C0AC     MOVFF 0xAC, _PFNf_res
0970  F07A     NOP
0972  0E0B     MOVLW 0xB
0974  EC1F     CALL 0xB83E, 0
0976  F05C     NOP
1758:          				Mark(_GZ_MXCO,0);
0978  6B7A     CLRF _PFNf_res, BANKED
097A  0E0D     MOVLW 0xD
097C  EC1F     CALL 0xB83E, 0
097E  F05C     NOP
1759:          				Mark(_GZ_MNCO,0);
0980  6B7A     CLRF _PFNf_res, BANKED
0982  0E0E     MOVLW 0xE
0984  EF1F     GOTO 0xB83E
0986  F05C     NOP
1760:          			}
1761:          		}
1762:          		else
1763:          		{
1764:          			ClrMarkMinMax();
1765:          		}
1766:          	}
1767:          }
1768:          #else
1769:          //****************************************************************************************************88
1770:          void DecWsw(void)
1771:          {
1772:          	if(PFNf_ferr||PFNf_fmsg) 
1773:          	{
1774:          		ClrMarkMinMax();
1775:          		if(PFNf_ferr) PrintErr(led_E,PFN.KERR,1);
1776:          		else 
1777:          		{
1778:          			if(!PFNf_KnfDisErr) PrintErr(led_E,PFN.KAWR,0);
1779:          			else EndErr();
1780:          		}
1781:          	}
1782:          	else EndErr();
1783:          	if(!PFNf_aktywne_KNF&&!PFNf_ferr)
1784:          	{
1785:          		if(PFNf_off)
1786:          		{
1787:          			//decyzje o wygaszeniu
1788:          			if(PFNf_errCS&&!PFNf_tdzCO) ClrDig(0,1,1);
1789:          			if(!PFNf_tdzCW) ClrDig(1,0,0);
1790:          			//wskazy
1791:          			if(!PFNf_errCS&&!PFNf_tdzCO) {Mark(_GZ_DCO,0);PrintCS(PFN.CS,1);}
1792:          			if(PFNf_tdzCW&&!PFNf_errCW) PrintCW(PFN.CW,1);
1793:          			if(PFNf_tdzCO&&!PFNf_errCO) PrintCO(PFN.CO,1,PFNf_fL3);
1794:          		}
1795:          		else
1796:          		{
1797:          			//-----------------------------------
1798:          			//tryb LATO
1799:          			if(PFNf_lato)
1800:          			{
1801:          				if(!PFNf_aleg)
1802:          				{
1803:          					if(PFNf_errCW) ClrDig(1,0,1);
1804:          					if(!PFNf_tdzCO&&!PFNf_prn_cs) ClrDig(0,1,0);
1805:          					if(PFNf_prn_cs&&!PFNf_errCS) {Mark(_GZ_DCO,0);PrintCS(PFN.CS,1);}
1806:          					if(PFNf_tdzCO&&!PFNf_errCO&&!(PFNf_prn_cs&&!PFNf_errCS)) PrintCO(PFN.CO,1,PFNf_fL3);
1807:          					if(!PFNf_errCW) PrintCW(PFN.CW,1);
1808:          				}
1809:          				else
1810:          				{
1811:          					ClrDig(0,1,0);
1812:          					if(!PFNf_errCO) PrintCW(PFN.CW,1);
1813:          				}				
1814:          			}
1815:          			else
1816:          			//-----------------------------------
1817:          			//tryb ZIMA
1818:          			if(PFNf_zima)
1819:          			{
1820:          				if(!PFNf_fnserw&&!PFNf_aleg)
1821:          				{
1822:          					if(PFNf_errCW) ClrDig(1,0,1);
1823:          					if(PFNf_errCO&&!(PFNf_prn_cs&&!PFNf_errCS)) ClrDig(0,1,1);
1824:          					if(PFNf_prn_cs&&!PFNf_errCS) {Mark(_GZ_DCO,1);PrintCS(PFN.CS,1);}
1825:          					if(!PFNf_errCO&&!(PFNf_prn_cs&&!PFNf_errCS)) PrintCO(PFN.CO,1,PFNf_fL3);
1826:          					if(!PFNf_errCW) PrintCW(PFN.CW,1);
1827:          				}
1828:          				else
1829:          				{
1830:          					if(PFNf_fnserw)
1831:          					{
1832:          						ClrDig(1,0,0);
1833:          						if(!PFNf_errCO) PrintCO(PFN.CO,1,PFNf_fL3);
1834:          					}
1835:          					else
1836:          					{
1837:          						ClrDig(0,1,0);
1838:          						if(!PFNf_errCO) PrintCW(PFN.CW,1);
1839:          					}
1840:          				}			
1841:          			}
1842:          			//-----------------------------------
1843:          			//nastawa CO/CW
1844:          			if(PFNf_set_ncw)	//wybrano nastawe CW?
1845:          			{
1846:          				ReadParam(&PFN.PCW,&zmn,&zps,PFN.minPCW,PFN.maxPCW,0,1);
1847:          				//if(zmn) PFNf_newPCW=1;
1848:          				if(!PFNf_b_set_ncw)	//nacisnieto przycisk set?
1849:          				{
1850:          					PFNf_b_set_ncw=1;
1851:          					EndNst();
1852:          					zmn=1;				
1853:          				}
1854:          				if(zmn)				//nastawa ulegla zmianie?
1855:          				{
1856:          					PFNf_newPCW=1;
1857:          	 				StartRTdS(_RTSET);
1858:          					MarkMinMax(1,0);
1859:          					PrintNstCW(PFN.PCW,0);
1860:          				}
1861:          			}
1862:          			if(PFNf_set_nco)	//wybrano nastawe CO?
1863:          			{
1864:          				ReadParam(&PFN.PCO,&zmn,&zps,PFN.minPCO,PFN.maxPCO,0,1);
1865:          				//if(zmn) PFNf_newPCO=1;
1866:          				if(!PFNf_b_set_nco)	//nacisnieto przycisk set?
1867:          				{
1868:          					PFNf_b_set_nco=1;
1869:          					EndNst();
1870:          					zmn=1;				
1871:          				}
1872:          				if(zmn)				//nastawa ulegla zmianie?
1873:          				{
1874:          					PFNf_newPCO=1;
1875:          					StartRTdS(_RTSET);
1876:          					MarkMinMax(0,1);
1877:          					PrintNstCO(PFN.PCO,PFNf_pgd,0);
1878:          				}
1879:          			}
1880:          			if(!PFNf_set_ncw&&!PFNf_set_nco)	//tryb modyfikacji nastawy jest nieaktywny?
1881:          			{
1882:          				if(PFNf_b_set_ncw||PFNf_b_set_nco)	//deaktywacja trybu nastapila chwile wczesniej?
1883:          				{
1884:          					MarkMinMax(0,0);
1885:          	 			}
1886:          				EndNst();
1887:          				PFNf_b_set_ncw=0;
1888:          				PFNf_b_set_nco=0;
1889:          			}
1890:          			//-----------------------------------
1891:          		}
1892:          		//Mark(_GZ_OFF,PFNf_off);
1893:          		if(!PFNf_aleg) MarkSVAL((PFNf_fnserw)?2:0,PFNf_fns_max,0);	//sterowanie znacznikiem min/max
1894:          		if(!PFNf_fnserw) MarkSVAL((PFNf_aleg)?2:0,1,1);				//sterowanie znacznikiem min/max
1895:          	}
1896:          	//znaki wysterowywane niezale¿nie (sygna³y z UNI-01)
1897:          	Mark(_GZ_PLW,PFNf_plmCW);												//znacznik plomien CW
1898:          	Mark(_GZ_PLC,PFNf_plmCO);												//znacznik plomien CO
1899:          	Mark(_GZ_PGD,PFNf_pgd&&!PFNf_aktywne_KNF);								//znacznik funkcja pogodowa
1900:          	Mark(_GZ_DCO,(PFNf_zima||(PFNf_lato&&PFNf_tdzCO)||(PFNf_off&&PFNf_tdzCO))&&!PFNf_aktywne_KNF);					//znacznik KALORYFER
1901:          	Mark(_GZ_DCW,(PFNf_zima||PFNf_lato||(PFNf_off&&PFNf_tdzCW))&&!PFNf_aktywne_KNF);								//znacznik KRAN
1902:          	//Mark(_GZ_OFF,PFNf_off&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_aktywne_KNF);		//znacznik OFF
1903:          	Mark(_GZ_OFF,PFNf_off&&!PFNf_aktywne_KNF);		//znacznik OFF
1904:          }
1905:          //********************************************************************************************************
1906:          #endif
1907:          //---------------------------------------------------------------
1908:          //Decyzja o uruchomieniu procedury oczekiwania na polaczenie
1909:          void DecRes(void)
1910:          {
1911:          	switch(PFN.KRS)
BA2C  D00D     BRA 0xBA48
BA48  0101     MOVLB 0x1
BA4A  51F6     MOVF 0xF6, W, BANKED
BA4C  E0F0     BZ 0xBA2E
BA4E  0A01     XORLW 0x1
BA50  E0F4     BZ 0xBA3A
1912:          	{
1913:          		case 0:
1914:          		{	
1915:          			if(PFNf_opgres&&PFNf_ferr)
BA2E  B80D     BTFSC PFNf_plmCO, 4, ACCESS
BA30  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
BA32  0012     RETURN 0
1916:          			{
1917:          				PFN.KRS=1;
BA34  0E01     MOVLW 0x1
BA36  6FF6     MOVWF 0xF6, BANKED
BA38  0C01     RETLW 0x1
1918:          			}
1919:          			break;
1920:          		}
1921:          		case 1:
1922:          		{
1923:          			if(!PFNf_opgres||!PFNf_ferr)
BA3A  A80D     BTFSS PFNf_plmCO, 4, ACCESS
BA3C  D002     BRA 0xBA42
BA3E  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
BA40  0012     RETURN 0
1924:          			{
1925:          				PFNf_toInit=1;
BA42  8011     BSF PFNf_zima, 0, ACCESS
1926:          				PFN.KRS=0;
BA44  6BF6     CLRF 0xF6, BANKED
BA46  0012     RETURN 0
1927:          			}
1928:          		}
1929:          	}
1930:          }
0018  804B     BSF 0x4B, 0, ACCESS
001A  CFD8     MOVFF STATUS, 0x65
001C  F065     NOP
001E  CFE8     MOVFF WREG, 0x66
0020  F066     NOP
0022  CFE0     MOVFF BSR, _PFNf_ofnserw
0024  F067     NOP
0026  CFE9     MOVFF FSR0, _PFNf_ofoff
0028  F068     NOP
002A  CFEA     MOVFF FSR0H, _PFNf_ofzima
002C  F069     NOP
002E  CFE1     MOVFF FSR1, _PFNf_opKNF
0030  F06A     NOP
0032  CFE2     MOVFF FSR1H, _PFNf_opgprg
0034  F06B     NOP
0036  CFD9     MOVFF FSR2, _PFNf_opgres
0038  F06C     NOP
003A  CFDA     MOVFF FSR2H, _PFNf_pgd
003C  F06D     NOP
003E  CFF3     MOVFF PROD, _PFNf_pgdTP
0040  F06E     NOP
0042  CFF4     MOVFF PRODH, _PFNf_plmCO
0044  F06F     NOP
0046  CFF6     MOVFF TBLPTR, _PFNf_plmCW
0048  F070     NOP
004A  CFF7     MOVFF TBLPTRH, _PFNf_pmpPWM
004C  F071     NOP
004E  CFF8     MOVFF TBLPTRU, _PFNf_pobRT
0050  F072     NOP
0052  CFF5     MOVFF TABLAT, _PFNf_popFN
0054  F073     NOP
BA52  0012     RETURN 0
1931:          //------------------
1932:          //------------------
1933:          void InitGlobal(void)
1934:          {
1935:          	//RCON
1936:          	IPEN=1;			//enable priority levels
C216  8ED0     BSF RCON, 7, ACCESS
1937:          	//INTCON
1938:          	GIEH=1;			//enable oll un-masked interrupts
C218  8EF2     BSF INTCON, 7, ACCESS
1939:          	GIEL=1;			//enable oll un-masked interrupts
C21A  8CF2     BSF INTCON, 6, ACCESS
1940:          }
C21C  0012     RETURN 0
1941:          //------------------		
1942:          //------------------
1943:          //------------------		
1944:          //------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/lled.c  ---------------------
1:             /*lled.c*/
2:             //Procedury zwiazane z podswietleniem wyswietlacza
3:             /*---------------------------------------------------------------------------------*/
4:             //#include <pic18.h>
5:             #include <xc.h>
6:             #include "global.h"					//parametry globalne
7:             #include "lled.h"					//parametry lokalne
8:             #include "pwm2.tp.h"				
9:             
10:            extern DtPWM PWM;
11:            /*---------------------------------------------------------------------------------*/
12:            //Inicjalizacja z maksymalnym podswietleniem	
13:            void InitLLED(void)
14:            {		
15:            	PWM.LLed=_LLHIGH;
C206  0E64     MOVLW 0x64
C208  0100     MOVLB 0x0
C20A  6FD1     MOVWF 0xD1, BANKED
16:            }		
C20C  0C64     RETLW 0x64
17:            /*---------------------------------------------------------------------------------*/
18:            //Zwraca wartosc wypelnienia PWM dla podanej wartosci %
19:            unsigned char ProcToLLedPwm(unsigned char prc)
AFE0  6F83     MOVWF _PFNf_str_ncw, BANKED
20:            {
21:            	unsigned int p;
22:            
23:            	if(prc>100) prc=100;
AFE2  0E64     MOVLW 0x64
AFE4  0100     MOVLB 0x0
AFE6  6583     CPFSGT _PFNf_str_ncw, BANKED
AFE8  D001     BRA 0xAFEC
AFEA  6F83     MOVWF _PFNf_str_ncw, BANKED
24:            	p=PWM.HIPWM;
AFEC  C0D0     MOVFF 0xD0, _PFNf_set_ncw
AFEE  F081     NOP
AFF0  6B82     CLRF _PFNf_str_nco, BANKED
25:            	p=(prc*p)/100;	//pmppwm/100 - ziarno przypadajace na 1%
AFF2  C083     MOVFF _PFNf_str_ncw, _PFNf_prODP
AFF4  F074     NOP
AFF6  6B75     CLRF _PFNf_prn_cs, BANKED
AFF8  C081     MOVFF _PFNf_set_ncw, _PFNf_prn_in
AFFA  F076     NOP
AFFC  C082     MOVFF _PFNf_str_nco, _PFNf_prn_pg
AFFE  F077     NOP
B000  EC3E     CALL 0xBA7C, 0
B002  F05D     NOP
B004  C074     MOVFF _PFNf_prODP, _PFNf_res
B006  F07A     NOP
B008  C075     MOVFF _PFNf_prn_cs, _PFNf_rozruch
B00A  F07B     NOP
B00C  6B7D     CLRF _PFNf_set_aleg, BANKED
B00E  0E64     MOVLW 0x64
B010  6F7C     MOVWF _PFNf_setKey, BANKED
B012  EC92     CALL 0xAD24, 0
B014  F056     NOP
B016  C07A     MOVFF _PFNf_res, _PFNf_set_ncw
B018  F081     NOP
B01A  C07B     MOVFF _PFNf_rozruch, _PFNf_str_nco
B01C  F082     NOP
26:            	return (unsigned char)p;
B01E  5181     MOVF _PFNf_set_ncw, W, BANKED
27:            }
B020  0012     RETURN 0
28:            /*---------------------------------------------------------------------------------*/
29:            //Ustaw maksymalne rozswietlenie wyswietlacza
30:            /*void LLedToHigh(void)
31:            {
32:            	if((PWM.LLed<_LLHIGH)&&(RTcS(_RTLLED2)>1))
33:            	{
34:            		StartRTcS(_RTLLED2);
35:            		if((PWM.LLed+_LLLUP)<_LLHIGH)
36:            		{	
37:            	 		PWM.LLed+=_LLLUP;
38:            		}	
39:            		else
40:            		{
41:            			PWM.LLed=_LLHIGH;
42:            		}
43:            	}
44:            	WritePWM2(ProcToLLedPwm(PWM.LLed));
45:            }*/
46:            void LLedToHigh(const unsigned char up)
AC42  0100     MOVLB 0x0
AC44  6F86     MOVWF _PFNf_timZAS, BANKED
47:            {
48:            	if((PWM.LLed<_LLHIGH)&&(RTcS(_RTLLED2)>1))
AC46  0E64     MOVLW 0x64
AC48  61D1     CPFSLT 0xD1, BANKED
AC4A  D01D     BRA 0xAC86
AC4C  0E00     MOVLW 0x0
AC4E  EC7F     CALL 0xBEFE, 0
AC50  F05F     NOP
AC52  6F84     MOVWF _PFNf_tdzCO, BANKED
AC54  0E01     MOVLW 0x1
AC56  6584     CPFSGT _PFNf_tdzCO, BANKED
AC58  D016     BRA 0xAC86
49:            	{
50:            		StartRTcS(_RTLLED2);
AC5A  0E00     MOVLW 0x0
AC5C  EC03     CALL 0xC006, 0
AC5E  F060     NOP
51:            		if((PWM.LLed+up)<_LLHIGH)
AC60  5186     MOVF _PFNf_timZAS, W, BANKED
AC62  C0D1     MOVFF 0xD1, _PFNf_tdzCO
AC64  F084     NOP
AC66  6B85     CLRF _PFNf_tdzCW, BANKED
AC68  2784     ADDWF _PFNf_tdzCO, F, BANKED
AC6A  0E00     MOVLW 0x0
AC6C  2385     ADDWFC _PFNf_tdzCW, F, BANKED
AC6E  BF85     BTFSC _PFNf_tdzCW, 7, BANKED
AC70  D005     BRA 0xAC7C
AC72  5185     MOVF _PFNf_tdzCW, W, BANKED
AC74  E106     BNZ 0xAC82
AC76  0E64     MOVLW 0x64
AC78  5D84     SUBWF _PFNf_tdzCO, W, BANKED
AC7A  E203     BC 0xAC82
52:            		{
53:            	 		PWM.LLed+=up;
AC7C  5186     MOVF _PFNf_timZAS, W, BANKED
AC7E  27D1     ADDWF 0xD1, F, BANKED
54:            		}
AC80  D002     BRA 0xAC86
55:            		else
56:            		{
57:            			PWM.LLed=_LLHIGH;
AC82  0E64     MOVLW 0x64
AC84  6FD1     MOVWF 0xD1, BANKED
58:            		}
59:            	}
60:            	WritePWM2(ProcToLLedPwm(PWM.LLed));
AC86  51D1     MOVF 0xD1, W, BANKED
AC88  ECF0     CALL 0xAFE0, 0
AC8A  F057     NOP
AC8C  EFBC     GOTO 0xC178
AC8E  F060     NOP
61:            }
62:            /*---------------------------------------------------------------------------------*/
63:            //Powolne wygaszzenie rozswietlenia wyswietlacza
64:            /*void LLedToLow(void)
65:            {
66:            	if((PWM.LLed>_LLLOW)&&(RTcS(_RTLLED2)>1))
67:            	{
68:            		StartRTcS(_RTLLED2);
69:            		if((PWM.LLed-_LLLDW)>_LLLOW)
70:            		{	
71:            	 		PWM.LLed-=_LLLDW;
72:            		}	
73:            		else
74:            		{
75:            			PWM.LLed=_LLLOW;
76:            		}
77:            	}
78:            	WritePWM2(ProcToLLedPwm(PWM.LLed));
79:            }*/
80:            void LLedToLow(const unsigned char dw)
ABF4  0100     MOVLB 0x0
ABF6  6F86     MOVWF _PFNf_timZAS, BANKED
81:            {
82:            	if((PWM.LLed>_LLLOW)&&(RTcS(_RTLLED2)>1))
ABF8  0E0F     MOVLW 0xF
ABFA  65D1     CPFSGT 0xD1, BANKED
ABFC  D01D     BRA 0xAC38
ABFE  0E00     MOVLW 0x0
AC00  EC7F     CALL 0xBEFE, 0
AC02  F05F     NOP
AC04  6F84     MOVWF _PFNf_tdzCO, BANKED
AC06  0E01     MOVLW 0x1
AC08  6584     CPFSGT _PFNf_tdzCO, BANKED
AC0A  D016     BRA 0xAC38
83:            	{
84:            		StartRTcS(_RTLLED2);
AC0C  0E00     MOVLW 0x0
AC0E  EC03     CALL 0xC006, 0
AC10  F060     NOP
85:            		if((PWM.LLed-dw)>_LLLOW)
AC12  5186     MOVF _PFNf_timZAS, W, BANKED
AC14  C0D1     MOVFF 0xD1, _PFNf_tdzCO
AC16  F084     NOP
AC18  6B85     CLRF _PFNf_tdzCW, BANKED
AC1A  5F84     SUBWF _PFNf_tdzCO, F, BANKED
AC1C  0E00     MOVLW 0x0
AC1E  5B85     SUBWFB _PFNf_tdzCW, F, BANKED
AC20  BF85     BTFSC _PFNf_tdzCW, 7, BANKED
AC22  D008     BRA 0xAC34
AC24  5185     MOVF _PFNf_tdzCW, W, BANKED
AC26  E103     BNZ 0xAC2E
AC28  0E10     MOVLW 0x10
AC2A  5D84     SUBWF _PFNf_tdzCO, W, BANKED
AC2C  E303     BNC 0xAC34
86:            		{
87:            	 		PWM.LLed-=dw;
AC2E  5186     MOVF _PFNf_timZAS, W, BANKED
AC30  5FD1     SUBWF 0xD1, F, BANKED
88:            		}
AC32  D002     BRA 0xAC38
89:            		else
90:            		{
91:            			PWM.LLed=_LLLOW;
AC34  0E0F     MOVLW 0xF
AC36  6FD1     MOVWF 0xD1, BANKED
92:            		}
93:            	}
94:            	WritePWM2(ProcToLLedPwm(PWM.LLed));
AC38  51D1     MOVF 0xD1, W, BANKED
AC3A  ECF0     CALL 0xAFE0, 0
AC3C  F057     NOP
AC3E  EFBC     GOTO 0xC178
AC40  F060     NOP
95:            }
96:            /*---------------------------------------------------------------------------------*/
97:            //Steruj rozswietleniem wyswietlacza
98:            #if _KEY_BBOARD==0
99:            void SetLightLLed(unsigned char nowhigh)
100:           {
101:           	if(nowhigh||RdPrt(S_KUP)||RdPrt(S_KDW)||RdPrt(S_SET)||RdPrt(S_OFF))
102:           	{
103:           		StartRTS(_RTLLED);
104:           	}
105:           	if(RTS(_RTLLED)<_TTLOW)
106:           	{
107:           		LLedToHigh(_LLLUP);
108:           	}
109:           	else
110:           	{
111:           		LLedToLow(_LLLDW);
112:           	}
113:           }
114:           #endif
115:           #if _KEY_BBOARD==1
116:           void SetLightLLed(unsigned char nowhigh)
A5C8  0100     MOVLB 0x0
A5CA  6F88     MOVWF _PFNf_toInit, BANKED
117:           {
118:           	if(nowhigh||RdPrt(S_KUP_CO)||RdPrt(S_KDW_CO)||RdPrt(S_KUP_CW)||RdPrt(S_KDW_CW)||RdPrt(S_SET)||RdPrt(S_KOM)||RdPrt(S_OFF))
A5CC  5188     MOVF _PFNf_toInit, W, BANKED
A5CE  E11C     BNZ 0xA608
A5D0  0E05     MOVLW 0x5
A5D2  EC02     CALL 0xBA04, 0
A5D4  F05D     NOP
A5D6  E218     BC 0xA608
A5D8  0E06     MOVLW 0x6
A5DA  EC02     CALL 0xBA04, 0
A5DC  F05D     NOP
A5DE  E214     BC 0xA608
A5E0  0E03     MOVLW 0x3
A5E2  EC02     CALL 0xBA04, 0
A5E4  F05D     NOP
A5E6  E210     BC 0xA608
A5E8  0E04     MOVLW 0x4
A5EA  EC02     CALL 0xBA04, 0
A5EC  F05D     NOP
A5EE  E20C     BC 0xA608
A5F0  0E01     MOVLW 0x1
A5F2  EC02     CALL 0xBA04, 0
A5F4  F05D     NOP
A5F6  E208     BC 0xA608
A5F8  0E02     MOVLW 0x2
A5FA  EC02     CALL 0xBA04, 0
A5FC  F05D     NOP
A5FE  E204     BC 0xA608
A600  0E00     MOVLW 0x0
A602  EC02     CALL 0xBA04, 0
A604  F05D     NOP
A606  E303     BNC 0xA60E
119:           	{
120:           		StartRTS(_RTLLED);
A608  0E01     MOVLW 0x1
A60A  EC45     CALL 0xBC8A, 0
A60C  F05E     NOP
121:           	}
122:           	if(RTS(_RTLLED)<_TTLOW)
A60E  0E01     MOVLW 0x1
A610  EC73     CALL 0xBEE6, 0
A612  F05F     NOP
A614  6F87     MOVWF _PFNf_tmpZW, BANKED
A616  0E0F     MOVLW 0xF
A618  6187     CPFSLT _PFNf_tmpZW, BANKED
A61A  D003     BRA 0xA622
123:           	{
124:           		LLedToHigh(_LLLUP);
A61C  0E02     MOVLW 0x2
A61E  EF21     GOTO 0xAC42
A620  F056     NOP
125:           	}
126:           	else
127:           	{
128:           		LLedToLow(_LLLDW);
A622  0E01     MOVLW 0x1
A624  EFFA     GOTO 0xABF4
A626  F055     NOP
129:           	}
130:           }
131:           #endif
132:           /*---------------------------------------------------------------------------------*/
133:           //Pulsacja rozswietleniem wyswietlacza
134:           void SetPulseLLed(void)
135:           {
136:               static unsigned char c=0;
137:               if(!c)
B062  0101     MOVLB 0x1
B064  51C1     MOVF 0xC1, W, BANKED
B066  E10E     BNZ 0xB084
138:               {
139:                   LLedToHigh(_FLLLUP);
B068  0E05     MOVLW 0x5
B06A  EC21     CALL 0xAC42, 0
B06C  F056     NOP
140:                   if((RTdS(_RTFLED)>5))
B06E  0E09     MOVLW 0x9
B070  EC8B     CALL 0xBF16, 0
B072  F05F     NOP
B074  6F87     MOVWF _PFNf_tmpZW, BANKED
B076  0E05     MOVLW 0x5
B078  6587     CPFSGT _PFNf_tmpZW, BANKED
B07A  0C05     RETLW 0x5
141:                   {
142:                       c=1;
B07C  0E01     MOVLW 0x1
B07E  0101     MOVLB 0x1
B080  6FC1     MOVWF 0xC1, BANKED
B082  D00C     BRA 0xB09C
143:                       StartRTdS(_RTFLED);
144:                   }
145:               }
146:               else
147:               {
148:                   LLedToLow(_FLLLDW);
B084  0E05     MOVLW 0x5
B086  ECFA     CALL 0xABF4, 0
B088  F055     NOP
149:                   if((RTdS(_RTFLED)>5))
B08A  0E09     MOVLW 0x9
B08C  EC8B     CALL 0xBF16, 0
B08E  F05F     NOP
B090  6F87     MOVWF _PFNf_tmpZW, BANKED
B092  0E05     MOVLW 0x5
B094  6587     CPFSGT _PFNf_tmpZW, BANKED
B096  0C05     RETLW 0x5
150:                   {
151:                       c=0;
B098  0101     MOVLB 0x1
B09A  6BC1     CLRF 0xC1, BANKED
152:                       StartRTdS(_RTFLED);
B09C  0E09     MOVLW 0x9
B09E  EF55     GOTO 0xBCAA
B0A0  F05E     NOP
153:                   }
154:               }
155:           }
156:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/konsola.c  ------------------
1:             /*keypad.c*/
2:             //Funkcje obslugi przycisków p³ytki interfejsu
3:             // (!) Bazuje na funkcjach z plikow: rtimer.c
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "konsola.h"			//parametry lokalne
9:             #include "main.tp.h"
10:            #include "print.h"
11:            
12:            extern volatile unsigned char x,y;
13:            /*---------------------------------------------------------------------------------*/
14:            extern tpMAIN M;
15:            extern DataPFN PFN;
16:            
17:            #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
18:            unsigned char mypwm=_MG2_MOD;
19:            #endif
20:            extern volatile StPin xxky[];
21:            extern volatile StPin ky[];
22:            
23:            
24:            //Zapis nastawy PCW po ustalonym czasie do EEPROM
25:            void WriteParam(unsigned char *zapis)
26:            {
27:            		if(*zapis&&RTdS(_RTPCW)>=_TWRTPCW)
28:            		{
29:            			*zapis=0;
30:            			StartRTdS(_RTPCW);
31:            			//WriteEEPCW();
32:            		}
33:            }
34:            /*---------------------------------------------------------------------------------*/
35:            //Inkrementacja/Dekrementacja parametru
36:            //gdzie:
37:            //param- adres modyfikowanego parametru (16bit)
38:            //zmiana - znacznik ze wartosc parametru ulegla zmianie (0- brak zmianay, 1 - tylko podglad min/max, 2 - wartosc zmniejszona, 3 - wartosc zwiekszona)
39:            //zapis - znacznik sugestji/aktywacji zapisu parametru do pamieci
40:            //min- minimalna wartosc jaka moze przyjac parametr
41:            //max- maksymalna wartosc jaka moze przyjac parametr
42:            //rckl - po osiagnieciu max+1 nastepuje przeladowanie wartoscia min i odwrotnie po osiagnieciu min-1 nastepuje przeladowanie wartoscia max
43:            //fst - aktywacja funkcji przyspieszajacej inkrementacji/dekrementacji
44:            #if _KEY_BBOARD==0
45:            void ReadParam(unsigned int *param,unsigned char *zmiana,unsigned char *zapis,unsigned int min, unsigned int max, unsigned char rckl, unsigned char fst)
46:            //void ReadParam(volatile unsigned int *param,unsigned char *zmiana,unsigned char *zapis,unsigned int min, unsigned int max, unsigned char rckl, unsigned char fst)
47:            {
48:            	static unsigned char pnst;
49:            	unsigned char stp,ovi,ovd;
50:            
51:            #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
52:            /*	*param=max;
53:            	*zmiana=0;
54:            	*zapis=0;
55:            	if(!RdPrt(S_KDW))
56:            	{
57:            		ReadDataXONLI(RdPrt(S_KUP),&mypwm,_MG2_MOD,1,1);
58:            	}
59:            	if(!RdPrt(S_KUP))
60:            	{
61:            		if(PWM._ENOSC)
62:            		{
63:            			if(mypwm<PWM.MDMOD) mypwm=PWM.MDMOD;
64:            			ReadDataXONLD(RdPrt(S_KDW),&mypwm,PWM.MDMOD,1,1);
65:            		}
66:            		else
67:            		{
68:            			ReadDataXONLD(RdPrt(S_KDW),&mypwm,0,1,1);
69:            		}
70:            	}*/
71:            #else
72:            	ovi=0;
73:            	ovd=0;
74:            	if(*param<min) *param=min;
75:            	if(*param>max) *param=max;
76:            	if((max-min)>99) stp=5;
77:            	else stp=1;
78:            	if(!(RdPrt(S_KDW)&&RdPrt(S_KUP))) 					//nie nacisnieto jednoczesnie obu przyciskow?
79:            	{
80:            		if(!RdPrt(S_KDW))
81:            		{
82:            			ReadDataXONLID(RdPrt(S_KUP),&xxky[SS_KUP],param,&ovi,1,min,max,1,stp,fst);
83:            			if(rckl&&ovi) *param=min;
84:            			if(!rckl&&RdPrt(S_KUP)&&(*param==max)) *zmiana=1;	//wymuszony wskaz nastawy dla maksimum
85:            		}
86:            		else
87:            		if(!RdPrt(S_KUP))
88:            		{
89:            			ReadDataXONLID(RdPrt(S_KDW),&xxky[SS_KDW],param,&ovd,0,min,max,1,stp,fst);
90:            			if(rckl&&ovd) *param=max;
91:            			if(!rckl&&RdPrt(S_KDW)&&(*param==min)) *zmiana=1;	//wymuszony wskaz nastawy dla minimum
92:            		}
93:            		if(!RdPrt(S_KDW)&&!RdPrt(S_KUP)) //oba przyciski wycisniete
94:            		{
95:            			if(RTdS(_RTPCW)>_TFLPCW)	*zmiana=0;	 //podtrzymanie stanu znacznika modyfikacji przez czas _TWRTPCW-1
96:            		}
97:            
98:            		if(*param!=pnst)								//nastapila zmiana nastawy?
99:            		{
100:           			if(rckl&&ovi) *zmiana=3;
101:           			else
102:           			if(rckl&&ovd) *zmiana=2;
103:           			else *zmiana=(pnst<*param)?3:2;				//znacznik zmiany nastawy
104:           			pnst=*param;
105:           			StartRTdS(_RTPCW);							//zegar podtrzymania znacznika modyfikacji nastawy
106:           			*zapis=1;									//sugestia zapisu dla nowej nastawy (uwaga po zapisie nalezy wyzerowac)
107:           		}
108:           	}else *zmiana=0;									//nacisnieto dwa przyciski jednoczesnie
109:           #endif								
110:           }
111:           #endif
112:           #if _KEY_BBOARD==1
113:           void ReadParamCW(unsigned int *param,unsigned char *zmiana,unsigned char *zapis,unsigned int min, unsigned int max, unsigned char rckl, unsigned char fst)
114:           {
115:           	static unsigned char pnst;
116:           	unsigned char stp,ovi,ovd;
117:           
118:           #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
119:           /*	*param=max;
120:           	*zmiana=0;
121:           	*zapis=0;
122:           	if(!RdPrt(S_KDW_CW))
123:           	{
124:           		ReadDataXONLI(RdPrt(S_KUP_CW),&mypwm,_MG2_MOD,1,1);
125:           	}
126:           	if(!RdPrt(S_KUP_CW))
127:           	{
128:           		if(PWM._ENOSC)
129:           		{
130:           			if(mypwm<PWM.MDMOD) mypwm=PWM.MDMOD;
131:           			ReadDataXONLD(RdPrt(S_KDW_CW),&mypwm,PWM.MDMOD,1,1);
132:           		}
133:           		else
134:           		{
135:           			ReadDataXONLD(RdPrt(S_KDW_CW),&mypwm,0,1,1);
136:           		}
137:           	}*/
138:           #else
139:           	ovi=0;
5E82  6BA1     CLRF _UADtf_RErrREC, BANKED
140:           	ovd=0;
5E84  6BA2     CLRF _UADtf_TData, BANKED
141:           	if(*param<min) *param=min;
5E86  D8D6     RCALL PL142
5E88  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
5E8A  5CDE     SUBWF POSTINC2, W, ACCESS
5E8C  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
5E8E  58DE     SUBWFB POSTINC2, W, ACCESS
5E90  E202     BC 0x5E96
5E92  D8D0     RCALL PL142
5E94  D8E9     RCALL PL620
142:           	if(*param>max) *param=max;
5E96  D8CE     RCALL PL142
5E98  50DE     MOVF POSTINC2, W, ACCESS
5E9A  5D96     SUBWF _RSDT1f_RespLIDN, W, BANKED
5E9C  50DE     MOVF POSTINC2, W, ACCESS
5E9E  5997     SUBWFB _UAD1tf_RFBrSn, W, BANKED
5EA0  E202     BC 0x5EA6
5EA2  D8C8     RCALL PL142
5EA4  D8EA     RCALL PL700
143:           	if((max-min)>99) stp=5;
5EA6  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
5EA8  5D96     SUBWF _RSDT1f_RespLIDN, W, BANKED
5EAA  6F9A     MOVWF _UAD1tf_RFExt, BANKED
5EAC  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
5EAE  5997     SUBWFB _UAD1tf_RFBrSn, W, BANKED
5EB0  6F9B     MOVWF _UAD1tf_TFData, BANKED
5EB2  519B     MOVF _UAD1tf_TFData, W, BANKED
5EB4  E103     BNZ 0x5EBC
5EB6  0E64     MOVLW 0x64
5EB8  5D9A     SUBWF _UAD1tf_RFExt, W, BANKED
5EBA  E302     BNC 0x5EC0
5EBC  0E05     MOVLW 0x5
5EBE  D001     BRA 0x5EC2
144:           	else stp=1;
5EC0  0E01     MOVLW 0x1
5EC2  6FA0     MOVWF _UADtf_RErrBUF, BANKED
145:           	if(!(RdPrt(S_KDW_CW)&&RdPrt(S_KUP_CW))) 					//nie nacisnieto jednoczesnie obu przyciskow?
5EC4  0E04     MOVLW 0x4
5EC6  EC02     CALL 0xBA04, 0
5EC8  F05D     NOP
5ECA  E305     BNC 0x5ED6
5ECC  0E03     MOVLW 0x3
5ECE  EC02     CALL 0xBA04, 0
5ED0  F05D     NOP
5ED2  E301     BNC 0x5ED6
5ED4  D0AD     BRA 0x6030
146:           	{
147:           		if(!RdPrt(S_KDW_CW))
5ED6  0E04     MOVLW 0x4
5ED8  EC02     CALL 0xBA04, 0
5EDA  F05D     NOP
5EDC  E22C     BC 0x5F36
148:           		{
149:           			ReadDataXONLID(RdPrt(S_KUP_CW),&xxky[SS_KUP_CW],param,&ovi,1,min,max,1,stp,fst);
5EDE  0EBB     MOVLW 0xBB
5EE0  6F7C     MOVWF _PFNf_setKey, BANKED
5EE2  0E04     MOVLW 0x4
5EE4  D8BB     RCALL PL596
5EE6  0EA1     MOVLW 0xA1
5EE8  6F80     MOVWF _PFNf_set_nco, BANKED
5EEA  0E01     MOVLW 0x1
5EEC  6F81     MOVWF _PFNf_set_ncw, BANKED
5EEE  D8A7     RCALL PL372
5EF0  D8AF     RCALL PL554
5EF2  0E03     MOVLW 0x3
5EF4  EC02     CALL 0xBA04, 0
5EF6  F05D     NOP
5EF8  0E01     MOVLW 0x1
5EFA  A0D8     BTFSS STATUS, 0, ACCESS
5EFC  0E00     MOVLW 0x0
5EFE  ECE3     CALL 0x57C6, 0
5F00  F02B     NOP
150:           			if(rckl&&ovi) *param=min;
5F02  0100     MOVLB 0x0
5F04  5198     MOVF _UAD1tf_RFData, W, BANKED
5F06  E004     BZ 0x5F10
5F08  51A1     MOVF _UADtf_RErrREC, W, BANKED
5F0A  E002     BZ 0x5F10
5F0C  D893     RCALL PL142
5F0E  D8AC     RCALL PL620
151:           			if(!rckl&&RdPrt(S_KUP_CW)&&(*param==max)) *zmiana=1;	//wymuszony wskaz nastawy dla maksimum
5F10  5198     MOVF _UAD1tf_RFData, W, BANKED
5F12  E13A     BNZ 0x5F88
5F14  0E03     MOVLW 0x3
5F16  EC02     CALL 0xBA04, 0
5F18  F05D     NOP
5F1A  E336     BNC 0x5F88
5F1C  D88B     RCALL PL142
5F1E  5196     MOVF _RSDT1f_RespLIDN, W, BANKED
5F20  18DE     XORWF POSTINC2, W, ACCESS
5F22  E132     BNZ 0x5F88
5F24  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
5F26  18DE     XORWF POSTINC2, W, ACCESS
5F28  E12F     BNZ 0x5F88
5F2A  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
5F2C  6ED9     MOVWF FSR2, ACCESS
5F2E  6ADA     CLRF FSR2H, ACCESS
5F30  0E01     MOVLW 0x1
5F32  6EDF     MOVWF INDF2, ACCESS
5F34  D029     BRA 0x5F88
152:           		}
153:           		else
154:           		if(!RdPrt(S_KUP_CW))
5F36  0E03     MOVLW 0x3
5F38  EC02     CALL 0xBA04, 0
5F3A  F05D     NOP
5F3C  E225     BC 0x5F88
155:           		{
156:           			ReadDataXONLID(RdPrt(S_KDW_CW),&xxky[SS_KDW_CW],param,&ovd,0,min,max,1,stp,fst);
5F3E  0EC0     MOVLW 0xC0
5F40  6F7C     MOVWF _PFNf_setKey, BANKED
5F42  0E04     MOVLW 0x4
5F44  D88B     RCALL PL596
5F46  0EA2     MOVLW 0xA2
5F48  6F80     MOVWF _PFNf_set_nco, BANKED
5F4A  6B81     CLRF _PFNf_set_ncw, BANKED
5F4C  D878     RCALL PL372
5F4E  0E01     MOVLW 0x1
5F50  D87F     RCALL PL554
5F52  0E04     MOVLW 0x4
5F54  EC02     CALL 0xBA04, 0
5F56  F05D     NOP
5F58  0E01     MOVLW 0x1
5F5A  A0D8     BTFSS STATUS, 0, ACCESS
5F5C  0E00     MOVLW 0x0
5F5E  ECE3     CALL 0x57C6, 0
5F60  F02B     NOP
157:           			if(rckl&&ovd) *param=max;
5F62  0100     MOVLB 0x0
5F64  5198     MOVF _UAD1tf_RFData, W, BANKED
5F66  E004     BZ 0x5F70
5F68  51A2     MOVF _UADtf_TData, W, BANKED
5F6A  E002     BZ 0x5F70
5F6C  D863     RCALL PL142
5F6E  D885     RCALL PL700
158:           			if(!rckl&&RdPrt(S_KDW_CW)&&(*param==min)) *zmiana=1;	//wymuszony wskaz nastawy dla minimum
5F70  5198     MOVF _UAD1tf_RFData, W, BANKED
5F72  E10A     BNZ 0x5F88
5F74  0E04     MOVLW 0x4
5F76  EC02     CALL 0xBA04, 0
5F78  F05D     NOP
5F7A  E306     BNC 0x5F88
5F7C  D85B     RCALL PL142
5F7E  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
5F80  18DE     XORWF POSTINC2, W, ACCESS
5F82  E102     BNZ 0x5F88
5F84  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
5F86  D7CF     BRA 0x5F26
159:           		}
160:           		if(!RdPrt(S_KDW_CW)&&!RdPrt(S_KUP_CW)) //oba przyciski wycisniete
5F88  0E04     MOVLW 0x4
5F8A  EC02     CALL 0xBA04, 0
5F8C  F05D     NOP
5F8E  E20E     BC 0x5FAC
5F90  0E03     MOVLW 0x3
5F92  EC02     CALL 0xBA04, 0
5F94  F05D     NOP
5F96  E20A     BC 0x5FAC
161:           		{
162:           			if(RTdS(_RTPCW)>_TFLPCW)	*zmiana=0;	 //podtrzymanie stanu znacznika modyfikacji przez czas _TWRTPCW-1
5F98  0E01     MOVLW 0x1
5F9A  EC8B     CALL 0xBF16, 0
5F9C  F05F     NOP
5F9E  6F9A     MOVWF _UAD1tf_RFExt, BANKED
5FA0  0E05     MOVLW 0x5
5FA2  659A     CPFSGT _UAD1tf_RFExt, BANKED
5FA4  D003     BRA 0x5FAC
5FA6  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
5FA8  EC96     CALL 0x692C, 0
5FAA  F034     NOP
163:           		}
164:           
165:           		if(*param!=pnst)								//nastapila zmiana nastawy?
5FAC  D843     RCALL PL142
5FAE  CFDE     MOVFF POSTINC2, _UAD1tf_RFExt
5FB0  F09A     NOP
5FB2  CFDD     MOVFF POSTDEC2, _UAD1tf_TFData
5FB4  F09B     NOP
5FB6  0101     MOVLB 0x1
5FB8  51C0     MOVF 0xC0, W, BANKED
5FBA  0100     MOVLB 0x0
5FBC  199A     XORWF _UAD1tf_RFExt, W, BANKED
5FBE  119B     IORWF _UAD1tf_TFData, W, BANKED
5FC0  B4D8     BTFSC STATUS, 2, ACCESS
5FC2  0012     RETURN 0
166:           		{
167:           			if(rckl&&ovi) *zmiana=3;
5FC4  5198     MOVF _UAD1tf_RFData, W, BANKED
5FC6  E007     BZ 0x5FD6
5FC8  51A1     MOVF _UADtf_RErrREC, W, BANKED
5FCA  E005     BZ 0x5FD6
5FCC  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
5FCE  6ED9     MOVWF FSR2, ACCESS
5FD0  6ADA     CLRF FSR2H, ACCESS
5FD2  0E03     MOVLW 0x3
5FD4  D008     BRA 0x5FE6
168:           			else
169:           			if(rckl&&ovd) *zmiana=2;
5FD6  5198     MOVF _UAD1tf_RFData, W, BANKED
5FD8  E008     BZ 0x5FEA
5FDA  51A2     MOVF _UADtf_TData, W, BANKED
5FDC  E006     BZ 0x5FEA
5FDE  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
5FE0  6ED9     MOVWF FSR2, ACCESS
5FE2  6ADA     CLRF FSR2H, ACCESS
5FE4  0E02     MOVLW 0x2
5FE6  6EDF     MOVWF INDF2, ACCESS
5FE8  D016     BRA 0x6016
170:           			else *zmiana=(pnst<*param)?3:2;				//znacznik zmiany nastawy
5FEA  D824     RCALL PL142
5FEC  0101     MOVLB 0x1
5FEE  51C0     MOVF 0xC0, W, BANKED
5FF0  0100     MOVLB 0x0
5FF2  6F9C     MOVWF _UAD1tf_TFEnd, BANKED
5FF4  6B9D     CLRF _UADtf_RData, BANKED
5FF6  50DE     MOVF POSTINC2, W, ACCESS
5FF8  5D9C     SUBWF _UAD1tf_TFEnd, W, BANKED
5FFA  50DE     MOVF POSTINC2, W, ACCESS
5FFC  599D     SUBWFB _UADtf_RData, W, BANKED
5FFE  E303     BNC 0x6006
6000  6B9F     CLRF _UADtf_REnd, BANKED
6002  0E02     MOVLW 0x2
6004  D002     BRA 0x600A
6006  6B9F     CLRF _UADtf_REnd, BANKED
6008  0E03     MOVLW 0x3
600A  6F9E     MOVWF _UADtf_REXT, BANKED
600C  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
600E  6ED9     MOVWF FSR2, ACCESS
6010  6ADA     CLRF FSR2H, ACCESS
6012  C09E     MOVFF _UADtf_REXT, INDF2
6014  FFDF     NOP
171:           			pnst=*param;
6016  D80E     RCALL PL142
6018  50DF     MOVF INDF2, W, ACCESS
601A  0101     MOVLB 0x1
601C  6FC0     MOVWF 0xC0, BANKED
172:           			StartRTdS(_RTPCW);							//zegar podtrzymania znacznika modyfikacji nastawy
601E  0E01     MOVLW 0x1
6020  EC55     CALL 0xBCAA, 0
6022  F05E     NOP
173:           			*zapis=1;									//sugestia zapisu dla nowej nastawy (uwaga po zapisie nalezy wyzerowac)
6024  C092     MOVFF _RSDT1f_RD_LIN, FSR2
6026  FFD9     NOP
6028  C093     MOVFF _RSDT1f_RD_STD, FSR2H
602A  FFDA     NOP
602C  EF3B     GOTO 0x6276
602E  F031     NOP
174:           		}
175:           	}else *zmiana=0;									//nacisnieto dwa przyciski jednoczesnie
6030  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
6032  D01F     BRA PL656
176:           #endif								
177:           }
178:           void ReadParamCO(unsigned int *param,unsigned char *zmiana,unsigned char *zapis,unsigned int min, unsigned int max, unsigned char rckl, unsigned char fst)
179:           {
180:           	static unsigned char pnst;
181:           	unsigned char stp,ovi,ovd;
182:           
183:           #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
184:           /*	*param=max;
185:           	*zmiana=0;
186:           	*zapis=0;
187:           	if(!RdPrt(S_KDW_CO))
188:           	{
189:           		ReadDataXONLI(RdPrt(S_KUP_CO),&mypwm,_MG2_MOD,1,1);
190:           	}
191:           	if(!RdPrt(S_KUP_CO))
192:           	{
193:           		if(PWM._ENOSC)
194:           		{
195:           			if(mypwm<PWM.MDMOD) mypwm=PWM.MDMOD;
196:           			ReadDataXONLD(RdPrt(S_KDW_CO),&mypwm,PWM.MDMOD,1,1);
197:           		}
198:           		else
199:           		{
200:           			ReadDataXONLD(RdPrt(S_KDW_CO),&mypwm,0,1,1);
201:           		}
202:           	}*/
203:           #else
204:           	ovi=0;
6084  6BA2     CLRF _UADtf_TData, BANKED
205:           	ovd=0;
6086  6BA3     CLRF _UADtf_TEXT, BANKED
206:           	if(*param<min) *param=min;
6088  D8CD     RCALL PL148
608A  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
608C  5CDE     SUBWF POSTINC2, W, ACCESS
608E  5196     MOVF _RSDT1f_RespLIDN, W, BANKED
6090  58DE     SUBWFB POSTINC2, W, ACCESS
6092  E202     BC 0x6098
6094  D8C7     RCALL PL148
6096  D8E5     RCALL PL630
207:           	if(*param>max) *param=max;
6098  D8C5     RCALL PL148
609A  50DE     MOVF POSTINC2, W, ACCESS
609C  5D97     SUBWF _UAD1tf_RFBrSn, W, BANKED
609E  50DE     MOVF POSTINC2, W, ACCESS
60A0  5998     SUBWFB _UAD1tf_RFData, W, BANKED
60A2  E202     BC 0x60A8
60A4  D8BF     RCALL PL148
60A6  D8E2     RCALL PL736
208:           	if((max-min)>99) stp=5;
60A8  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
60AA  5D97     SUBWF _UAD1tf_RFBrSn, W, BANKED
60AC  6F9B     MOVWF _UAD1tf_TFData, BANKED
60AE  5196     MOVF _RSDT1f_RespLIDN, W, BANKED
60B0  5998     SUBWFB _UAD1tf_RFData, W, BANKED
60B2  6F9C     MOVWF _UAD1tf_TFEnd, BANKED
60B4  519C     MOVF _UAD1tf_TFEnd, W, BANKED
60B6  E103     BNZ 0x60BE
60B8  0E64     MOVLW 0x64
60BA  5D9B     SUBWF _UAD1tf_TFData, W, BANKED
60BC  E302     BNC 0x60C2
60BE  0E05     MOVLW 0x5
60C0  D001     BRA 0x60C4
209:           	else stp=1;
60C2  0E01     MOVLW 0x1
60C4  6FA1     MOVWF _UADtf_RErrREC, BANKED
210:           	if(!(RdPrt(S_KDW_CO)&&RdPrt(S_KUP_CO))) 					//nie nacisnieto jednoczesnie obu przyciskow?
60C6  0E06     MOVLW 0x6
60C8  EC02     CALL 0xBA04, 0
60CA  F05D     NOP
60CC  E305     BNC 0x60D8
60CE  0E05     MOVLW 0x5
60D0  EC02     CALL 0xBA04, 0
60D2  F05D     NOP
60D4  E301     BNC 0x60D8
60D6  D0A3     BRA 0x621E
211:           	{
212:           		if(!RdPrt(S_KDW_CO))
60D8  0E06     MOVLW 0x6
60DA  EC02     CALL 0xBA04, 0
60DC  F05D     NOP
60DE  E22A     BC 0x6134
213:           		{
214:           			ReadDataXONLID(RdPrt(S_KUP_CO),&xxky[SS_KUP_CO],param,&ovi,1,min,max,1,stp,fst);
60E0  0EC5     MOVLW 0xC5
60E2  6F7C     MOVWF _PFNf_setKey, BANKED
60E4  0E04     MOVLW 0x4
60E6  D8B7     RCALL PL598
60E8  0EA2     MOVLW 0xA2
60EA  6F80     MOVWF _PFNf_set_nco, BANKED
60EC  0E01     MOVLW 0x1
60EE  6F81     MOVWF _PFNf_set_ncw, BANKED
60F0  D8A3     RCALL PL370
60F2  D8AB     RCALL PL570
60F4  0E05     MOVLW 0x5
60F6  EC02     CALL 0xBA04, 0
60F8  F05D     NOP
60FA  0E01     MOVLW 0x1
60FC  A0D8     BTFSS STATUS, 0, ACCESS
60FE  0E00     MOVLW 0x0
6100  ECE3     CALL 0x57C6, 0
6102  F02B     NOP
215:           			if(rckl&&ovi) *param=min;
6104  0100     MOVLB 0x0
6106  5199     MOVF _UAD1tf_RFEnd, W, BANKED
6108  E004     BZ 0x6112
610A  51A2     MOVF _UADtf_TData, W, BANKED
610C  E002     BZ 0x6112
610E  D88A     RCALL PL148
6110  D8A8     RCALL PL630
216:           			if(!rckl&&RdPrt(S_KUP_CO)&&(*param==max)) *zmiana=1;	//wymuszony wskaz nastawy dla maksimum
6112  5199     MOVF _UAD1tf_RFEnd, W, BANKED
6114  E138     BNZ 0x6186
6116  0E05     MOVLW 0x5
6118  EC02     CALL 0xBA04, 0
611A  F05D     NOP
611C  E334     BNC 0x6186
611E  D882     RCALL PL148
6120  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
6122  18DE     XORWF POSTINC2, W, ACCESS
6124  E130     BNZ 0x6186
6126  5198     MOVF _UAD1tf_RFData, W, BANKED
6128  18DE     XORWF POSTINC2, W, ACCESS
612A  E12D     BNZ 0x6186
612C  D880     RCALL PL282
612E  0E01     MOVLW 0x1
6130  6EDF     MOVWF INDF2, ACCESS
6132  D029     BRA 0x6186
217:           		}
218:           		else
219:           		if(!RdPrt(S_KUP_CO))
6134  0E05     MOVLW 0x5
6136  EC02     CALL 0xBA04, 0
6138  F05D     NOP
613A  E225     BC 0x6186
220:           		{
221:           			ReadDataXONLID(RdPrt(S_KDW_CO),&xxky[SS_KDW_CO],param,&ovd,0,min,max,1,stp,fst);
613C  0ECA     MOVLW 0xCA
613E  6F7C     MOVWF _PFNf_setKey, BANKED
6140  0E04     MOVLW 0x4
6142  D889     RCALL PL598
6144  0EA3     MOVLW 0xA3
6146  6F80     MOVWF _PFNf_set_nco, BANKED
6148  6B81     CLRF _PFNf_set_ncw, BANKED
614A  D876     RCALL PL370
614C  0E01     MOVLW 0x1
614E  D87D     RCALL PL570
6150  0E06     MOVLW 0x6
6152  EC02     CALL 0xBA04, 0
6154  F05D     NOP
6156  0E01     MOVLW 0x1
6158  A0D8     BTFSS STATUS, 0, ACCESS
615A  0E00     MOVLW 0x0
615C  ECE3     CALL 0x57C6, 0
615E  F02B     NOP
222:           			if(rckl&&ovd) *param=max;
6160  0100     MOVLB 0x0
6162  5199     MOVF _UAD1tf_RFEnd, W, BANKED
6164  E004     BZ 0x616E
6166  51A3     MOVF _UADtf_TEXT, W, BANKED
6168  E002     BZ 0x616E
616A  D85C     RCALL PL148
616C  D87F     RCALL PL736
223:           			if(!rckl&&RdPrt(S_KDW_CO)&&(*param==min)) *zmiana=1;	//wymuszony wskaz nastawy dla minimum
616E  5199     MOVF _UAD1tf_RFEnd, W, BANKED
6170  E10A     BNZ 0x6186
6172  0E06     MOVLW 0x6
6174  EC02     CALL 0xBA04, 0
6176  F05D     NOP
6178  E306     BNC 0x6186
617A  D854     RCALL PL148
617C  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
617E  18DE     XORWF POSTINC2, W, ACCESS
6180  E102     BNZ 0x6186
6182  5196     MOVF _RSDT1f_RespLIDN, W, BANKED
6184  D7D1     BRA 0x6128
224:           		}
225:           		if(!RdPrt(S_KDW_CO)&&!RdPrt(S_KUP_CO)) //oba przyciski wycisniete
6186  0E06     MOVLW 0x6
6188  EC02     CALL 0xBA04, 0
618A  F05D     NOP
618C  E20D     BC 0x61A8
618E  0E05     MOVLW 0x5
6190  EC02     CALL 0xBA04, 0
6192  F05D     NOP
6194  E209     BC 0x61A8
226:           		{
227:           			if(RTdS(_RTPCW)>_TFLPCW)	*zmiana=0;	 //podtrzymanie stanu znacznika modyfikacji przez czas _TWRTPCW-1
6196  0E01     MOVLW 0x1
6198  EC8B     CALL 0xBF16, 0
619A  F05F     NOP
619C  6F9B     MOVWF _UAD1tf_TFData, BANKED
619E  0E05     MOVLW 0x5
61A0  659B     CPFSGT _UAD1tf_TFData, BANKED
61A2  D002     BRA 0x61A8
61A4  D844     RCALL PL282
61A6  6ADF     CLRF INDF2, ACCESS
228:           		}
229:           
230:           		if(*param!=pnst)								//nastapila zmiana nastawy?
61A8  D83D     RCALL PL148
61AA  CFDE     MOVFF POSTINC2, _UAD1tf_TFData
61AC  F09B     NOP
61AE  CFDD     MOVFF POSTDEC2, _UAD1tf_TFEnd
61B0  F09C     NOP
61B2  0101     MOVLB 0x1
61B4  51BF     MOVF 0xBF, W, BANKED
61B6  0100     MOVLB 0x0
61B8  199B     XORWF _UAD1tf_TFData, W, BANKED
61BA  119C     IORWF _UAD1tf_TFEnd, W, BANKED
61BC  B4D8     BTFSC STATUS, 2, ACCESS
61BE  0012     RETURN 0
231:           		{
232:           			if(rckl&&ovi) *zmiana=3;
61C0  5199     MOVF _UAD1tf_RFEnd, W, BANKED
61C2  E005     BZ 0x61CE
61C4  51A2     MOVF _UADtf_TData, W, BANKED
61C6  E003     BZ 0x61CE
61C8  D832     RCALL PL282
61CA  0E03     MOVLW 0x3
61CC  D006     BRA 0x61DA
233:           			else
234:           			if(rckl&&ovd) *zmiana=2;
61CE  5199     MOVF _UAD1tf_RFEnd, W, BANKED
61D0  E006     BZ 0x61DE
61D2  51A3     MOVF _UADtf_TEXT, W, BANKED
61D4  E004     BZ 0x61DE
61D6  D82B     RCALL PL282
61D8  0E02     MOVLW 0x2
61DA  6EDF     MOVWF INDF2, ACCESS
61DC  D014     BRA 0x6206
235:           			else *zmiana=(pnst<*param)?3:2;				//znacznik zmiany nastawy
61DE  D822     RCALL PL148
61E0  0101     MOVLB 0x1
61E2  51BF     MOVF 0xBF, W, BANKED
61E4  0100     MOVLB 0x0
61E6  6F9D     MOVWF _UADtf_RData, BANKED
61E8  6B9E     CLRF _UADtf_REXT, BANKED
61EA  50DE     MOVF POSTINC2, W, ACCESS
61EC  5D9D     SUBWF _UADtf_RData, W, BANKED
61EE  50DE     MOVF POSTINC2, W, ACCESS
61F0  599E     SUBWFB _UADtf_REXT, W, BANKED
61F2  E303     BNC 0x61FA
61F4  6BA0     CLRF _UADtf_RErrBUF, BANKED
61F6  0E02     MOVLW 0x2
61F8  D002     BRA 0x61FE
61FA  6BA0     CLRF _UADtf_RErrBUF, BANKED
61FC  0E03     MOVLW 0x3
61FE  6F9F     MOVWF _UADtf_REnd, BANKED
6200  D816     RCALL PL282
6202  C09F     MOVFF _UADtf_REnd, INDF2
6204  FFDF     NOP
6206  D80E     RCALL PL148
236:           			pnst=*param;
6208  50DF     MOVF INDF2, W, ACCESS
620A  0101     MOVLB 0x1
620C  6FBF     MOVWF 0xBF, BANKED
237:           			StartRTdS(_RTPCW);							//zegar podtrzymania znacznika modyfikacji nastawy
620E  0E01     MOVLW 0x1
6210  EC55     CALL 0xBCAA, 0
6212  F05E     NOP
238:           			*zapis=1;									//sugestia zapisu dla nowej nastawy (uwaga po zapisie nalezy wyzerowac)
6214  C093     MOVFF _RSDT1f_RD_STD, FSR2
6216  FFD9     NOP
6218  C094     MOVFF _RSDT1f_RRD_KNF, FSR2H
621A  FFDA     NOP
621C  D02C     BRA PL772
239:           		}
240:           	}else *zmiana=0;									//nacisnieto dwa przyciski jednoczesnie
621E  D807     RCALL PL282
6220  6ADF     CLRF INDF2, ACCESS
241:           #endif								
242:           }
6222  0C00     RETLW 0x0
243:           #endif
244:           /*---------------------------------------------------------------------------------*/
245:           #if _KEY_BBOARD==0
246:           void TrybPracy(void)
247:           {
248:           	//static bit bf_oaleg;
249:           	volatile unsigned char key,key2,EnEco,tm;
250:           	if(!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres)
251:           	{
252:           
253:               //--------------------------PRZELACZNIK FUNKCJI------------------------------
254:                   //przytrzymano przycisk RESET (wylaczenie/zalaczenie sterownika)
255:                   if(!RdPrt(S_SET))
256:                   {
257:                       key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
258:                       if(key!=_KDFST&&key>=_TKOFF)
259:                       {	
260:                           WaitToLowEx(&ky[SS_OFF]);
261:                           if(PFN.vUNI02>=9)
262:                           {
263:                               if(PFNf_off)            //powrot ze stanu off?
264:                               {
265:                                   if(PFNf_popFN)      //zapamietany, poprzedni stan przelacznika = LATO?
266:                                   {
267:                                       PFNf_lato=1;
268:                                       PFNf_zima=0;                        
269:                                   }
270:                                   else
271:                                   {
272:                                       PFNf_lato=0;
273:                                       PFNf_zima=1;                        
274:                                   }
275:                               }
276:                           }
277:                           PFNf_off=!PFNf_off;
278:                           PFNf_set_nco=0;
279:                           PFNf_set_ncw=0;
280:                           PFNf_set_eco=0;
281:                           PFNf_str_nco=0;
282:                           PFNf_str_ncw=0;
283:                           PFNf_prn_res=0;
284:                           PFNf_set_fnserw=0;
285:                           PFNf_fnserw=0;
286:                           PFNf_set_aleg=0;
287:                           PFNf_aleg=0;
288:                           ResBufKeyEx(&ky[SS_KUP]);
289:                           ResBufKeyEx(&ky[SS_KDW]);
290:                           ResBufKeyEx(&ky[SS_SET]);
291:                       }
292:                   }
293:           //---------------------
294:                   if(!PFNf_off&&!PFNf_lato&&!PFNf_zima)		//stan nieustalony?
295:                   {
296:                       PFNf_lato=0;
297:                       PFNf_zima=1;
298:                   }
299:                   //przytrzymano przycisk SET (zmiana trybu pracy)
300:                   if(!RdPrt(S_OFF)&&!RdPrt(S_KUP)&&!RdPrt(S_KDW)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_prODP)
301:                   {
302:                       key=PresKeyEX(RdPrt(S_SET),&ky[SS_SET]);
303:                       if(key!=_KDFST&&key>=_TKSET)
304:                       {	
305:                           WaitToLowEx(&ky[SS_SET]);	
306:                           PFNf_lato=!PFNf_lato;
307:                           PFNf_zima=!PFNf_lato;
308:                           PFNf_set_nco=0;
309:                           PFNf_set_ncw=0;
310:                           PFNf_set_eco=0;
311:                           PFNf_fnserw=0;				//przerwanie funkcji serwisowej
312:                           PFNf_aleg=0;				//przerwanie funkcji antylegionella
313:                           PFNf_prn_res=0;
314:                       }
315:                   }
316:           //--------------------------NASTAWY------------------------------
317:                   //nacisnieto przycisk SET (wybor nastawy CO, funkcji serwisowej, antylegionella)
318:                   if(PFNf_oaleg) PFNf_set_aleg=0;
319:                   if(PFNf_ofnserw) PFNf_set_fnserw=0; 
320:           
321:                   if(!RdPrt(S_OFF)&&!RdPrt(S_KUP)&&!RdPrt(S_KDW)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_prODP)
322:                   {
323:                       key=PresKeyEX(RdPrt(S_SET),&ky[SS_SET]);
324:                       if(key==_KDFST)
325:                       {
326:                           ResBufKeyEx(&ky[SS_SET]);		//resetuj podtrzymanie
327:                           PFNf_b_set_nco=0;
328:                           PFNf_b_set_ncw=0;
329:                           PFNf_b_set_eco=0;
330:                           PFNf_set_ncw=0;
331:                           PFNf_set_eco=0;
332:                           PFNf_prn_res=0;
333:                           if(PFNf_set_nco)
334:                           {
335:                               if(PFNf_newPCO) 			//nastawa ulegla zmianie (potraktuj klawisz SET jako potwierdzenie
336:                               {
337:                                   PFNf_newPCO=0;
338:                                   PFNf_set_nco=0;
339:                                   PFNf_b_set_nco=0;
340:                                   PFNf_set_ncw=0;
341:                                   PFNf_b_set_ncw=0;
342:                                   PFNf_set_eco=0;
343:                                   PFNf_b_set_eco=0;
344:                                   PFNf_set_fnserw=0;
345:                                   PFNf_set_aleg=0;
346:                                   SetPrt(S_KDW,0);
347:                                   SetPrt(S_KUP,0);
348:                                   SetPrt(S_SET,0);
349:                                   ResBufKeyEx(&ky[SS_KDW]);		//resetuj podtrzymanie
350:                                   ResBufKeyEx(&ky[SS_KUP]);		//resetuj podtrzymanie
351:                               }
352:                               else
353:                               if(PFNf_zima&&!PFNf_obgCW&&!PFNf_set_fnserw) {PFNf_set_nco=0;PFNf_set_fnserw=1;PFNf_fns_max=1;}
354:                               else
355:                               if(PFNf_EnAleg&&!PFNf_set_aleg) {PFNf_set_nco=0;PFNf_set_aleg=1;}
356:                               else
357:                               {
358:                                   PFNf_newPCO=0;
359:                                   PFNf_set_nco=0;
360:                                   PFNf_b_set_nco=0;
361:                                   PFNf_set_ncw=0;
362:                                   PFNf_b_set_ncw=0;
363:                                   PFNf_set_eco=0;
364:                                   PFNf_b_set_eco=0;
365:                                   PFNf_set_fnserw=0;
366:                                   PFNf_set_aleg=0;
367:                                   SetPrt(S_KDW,0);
368:                                   SetPrt(S_KUP,0);
369:                                   SetPrt(S_SET,0);
370:                                   ResBufKeyEx(&ky[SS_KDW]);		//resetuj podtrzymanie
371:                                   ResBufKeyEx(&ky[SS_KUP]);		//resetuj podtrzymanie
372:                               }
373:                           }
374:                           else
375:                           if(PFNf_set_fnserw&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
376:                           {
377:                               if(PFNf_EnAleg&&!PFNf_set_aleg) {PFNf_set_fnserw=0;PFNf_set_aleg=1;}
378:                               else
379:                               {
380:                                   PFNf_newPCO=0;
381:                                   PFNf_set_nco=0;
382:                                   PFNf_b_set_nco=0;
383:                                   PFNf_set_ncw=0;
384:                                   PFNf_b_set_ncw=0;
385:                                   PFNf_set_eco=0;
386:                                   PFNf_b_set_eco=0;
387:                                   PFNf_set_fnserw=0;
388:                                   PFNf_set_aleg=0;
389:                               }
390:                           }
391:                           else
392:                           if(PFNf_set_aleg&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
393:                           {					
394:                               PFNf_newPCO=0;
395:                               PFNf_set_nco=0;
396:                               PFNf_b_set_nco=0;
397:                               PFNf_set_ncw=0;
398:                               PFNf_b_set_ncw=0;
399:                               PFNf_set_eco=0;
400:                               PFNf_b_set_eco=0;
401:                               PFNf_set_fnserw=0;
402:                               PFNf_set_aleg=0;
403:                           }					
404:                           else
405:                           {	
406:                               PFNf_set_fnserw=0;				
407:                               PFNf_set_aleg=0;
408:                               PFNf_set_nco=1;
409:                           }					
410:                           StartRTdS(_RTSET);
411:                           if(PFNf_set_nco)
412:                           {
413:                               PFNf_b_set_nco=0;
414:                               RestartKol2(_KL_NCWCO);
415:                               RestartKol(_KL_NCWCO);
416:                           }
417:                       }
418:                   }
419:                   if(RTdS(_RTSET)>_TSETNST)				//uplynal czas podtrzymania wybranego parametru?
420:                   {
421:                       PFNf_set_nco=0;
422:                       PFNf_b_set_nco=0;
423:                       PFNf_set_ncw=0;
424:                       PFNf_b_set_ncw=0;
425:                       PFNf_set_eco=0;
426:                       PFNf_b_set_eco=0;
427:                       PFNf_set_fnserw=0;
428:                       PFNf_set_aleg=0;
429:                   } 
430:           
431:                   if(!RdPrt(S_OFF)&&!RdPrt(S_KDW)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg)
432:                   {
433:                       if(PFNf_set_fnserw)
434:                       {
435:                           key=PresKeyEX(RdPrt(S_KUP),&ky[SS_KUP]);
436:                           if(key!=_KDFST&&key>=_TKALG)
437:                           {	
438:                               WaitToLowEx(&ky[SS_KUP]);
439:                               PFNf_fnserw=1;
440:                               PFNf_prn_res=0;
441:                               PFNf_set_nco=0;
442:                               PFNf_set_ncw=0;
443:                               PFNf_set_eco=0;
444:                               PFNf_b_ofnserw=0;
445:                               StartRTdS(_RTFSP);
446:                           }
447:                       }
448:                       if(PFNf_set_aleg)
449:                       {
450:                           key=PresKeyEX(RdPrt(S_KUP),&ky[SS_KUP]);
451:                           if(key!=_KDFST&&key>=_TKSRV)
452:                           {	
453:                               WaitToLowEx(&ky[SS_KUP]);
454:                               PFNf_aleg=1;
455:                               PFNf_set_nco=0;
456:                               PFNf_set_ncw=0;
457:                               PFNf_set_eco=0;
458:                               PFNf_b_oaleg=0;
459:                               StartRTdS(_RTFSP);
460:                           }
461:                       }
462:                   }
463:           
464:                   if(RTdS(_RTFSP)>_TAFSP)				//uplynal maksymalny czas na aktywacje funkcji serwisowej/antylegionella?
465:                   {
466:                       if(PFNf_aleg&&!PFNf_oaleg) PFNf_aleg=0;
467:                       if(PFNf_fnserw&&!PFNf_ofnserw) PFNf_fnserw=0;
468:                   }
469:           //---------------------
470:                   //nacisnieto przycisk UP lub DW (zmiana nastawy CW lub nastawy ECO)
471:                   if(!RdPrt(S_OFF)&&!RdPrt(S_SET)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_set_nco&&!PFNf_set_ncw&&!PFNf_set_eco&&!PFNf_prODP)
472:                   {
473:                       key=PresKeyEX(RdPrt(S_KDW),&ky[SS_KDW]);
474:                       key2=PresKeyEX(RdPrt(S_KUP),&ky[SS_KUP]);
475:           
476:                       //EnEco=(!PFNf_pgd&&PFNf_ofzima&&PFNf_pmpPWM&&PFNf_trbECO&&!PFNf_errIN&&!PFNf_obgCW)?1:0;
477:                       EnEco=(PFNf_ofzima&&PFNf_pmpPWM&&PFNf_trbECO&&!PFNf_errIN&&!PFNf_obgCW)?1:0;            
478:           
479:                       if(key==_KDFST||(!EnEco&&key>=_TKSET)||key2==_KDFST||(!EnEco&&key2>=_TKSET))		
480:                       {
481:                           ResBufKeyEx(&ky[SS_KDW]);		//resetuj podtrzymanie
482:                           ResBufKeyEx(&ky[SS_KUP]);		//resetuj podtrzymanie
483:                           RestartKol2(_KL_NCWCO);
484:                           RestartKol(_KL_NCWCO);
485:                           PFNf_b_set_ncw=0;
486:                           PFNf_prn_res=0;
487:                           PFNf_set_ncw=1;
488:                           PFNf_mod_ncw=0;
489:                           StartRTdS(_RTSET);
490:                       }
491:                       else
492:                       if((EnEco&&key>=(_TKSET*2))||(EnEco&&key2>=(_TKSET*2)))		
493:                       {
494:                           ResBufKeyEx(&ky[SS_KDW]);		//resetuj podtrzymanie
495:                           ResBufKeyEx(&ky[SS_KUP]);		//resetuj podtrzymanie
496:                           RestartKol2(_KL_NCWCO);
497:                           RestartKol(_KL_NCWCO);
498:                           PFNf_b_set_eco=0;
499:                           PFNf_prn_res=0;
500:                           PFNf_set_eco=1;
501:                           PFNf_mod_eco=0;
502:                           StartRTdS(_RTSET);
503:                       }
504:                   }
505:                   else
506:                   {
507:                       if(!PFNf_off&&PFNf_prODP)
508:                       {
509:                           WaitToLowEx(&ky[SS_KDW]);  
510:                           WaitToLowEx(&ky[SS_KUP]);
511:                       }
512:                   }
513:           
514:           
515:           //--------------------------FUNKCJE SPECJALNE------------------------------
516:           
517:                   tm=2*_TPCS;
518:           
519:                   if(RTdS(_RTPCS)>tm)									//uplynal czas podtrzymania wskazu cisnienia?
520:                   {
521:                       PFNf_prn_res=0;
522:                   }
523:                   /*if(PFNf_prn_res&&(PFNf_errCS||PFNf_fnoCS)&&PFNf_errIN)	//nie ma co pokazywac?
524:                   {
525:                       PFNf_prn_res=0;
526:                   }
527:                   if(PFNf_prn_res&&(PFNf_errCS||PFNf_fnoCS)&&(PFNf_obgCW||PFNf_oflato))	//awaria CS lub brak CS i (aktywny obieg CW lub tryb LATO)?
528:                   {
529:                       PFNf_prn_res=0;
530:                   }*/		
531:                   if(!PFNf_prn_res)
532:                   {
533:                       PFNf_prn_cs=0;
534:                       PFNf_prn_in=0;
535:                       PFNf_prn_pp=0;
536:                       PFNf_prn_pg=0;
537:                   }
538:                   else
539:                   {
540:                       if(RTdS(_RTPCS)<(tm/4))
541:                       {
542:                           PFNf_prn_cs=1;			
543:                           PFNf_prn_in=0;
544:                           PFNf_prn_pp=0;
545:                           PFNf_prn_pg=0;
546:                       }
547:                       else
548:                       if((RTdS(_RTPCS)>=(tm/4))&&(RTdS(_RTPCS)<(tm/2)))		//nadszedl czas podtrzymania wskazu temp wlotowej?
549:                       {
550:                           PFNf_prn_cs=0;
551:                           PFNf_prn_in=1;
552:                           PFNf_prn_pp=0;
553:                           PFNf_prn_pg=0;
554:                       }
555:                       else
556:                       if((RTdS(_RTPCS)>=(tm/2))&&(RTdS(_RTPCS)<((3*tm)/4)))
557:                       {
558:                           PFNf_prn_cs=0;
559:                           PFNf_prn_in=0;
560:                           PFNf_prn_pp=1;
561:                           PFNf_prn_pg=0;
562:                       }
563:                       else
564:                       if((RTdS(_RTPCS)>=((3*tm)/4)))
565:                       {
566:                           PFNf_prn_cs=0;
567:                           PFNf_prn_in=0;
568:                           PFNf_prn_pp=0;
569:                           PFNf_prn_pg=1;
570:                       }				
571:                   }      
572:           //---------------------
573:                   if(!PFNf_off&&(PFNf_fnserw||PFNf_ofnserw))					//aktywna funkcja serwisowa?
574:                   {
575:                       if(PresKeyEX(RdPrt(S_KUP),&ky[SS_KUP])>0)	//nacisnieto przycisk +?
576:                       {
577:                           ResBufKeyEx(&ky[SS_KUP]);		//resetuj podtrzymanie
578:                           PFNf_fns_max=1;
579:                       }
580:                       if(PresKeyEX(RdPrt(S_KDW),&ky[SS_KDW])>0)	//nacisnieto przycisk -?
581:                       {
582:                           ResBufKeyEx(&ky[SS_KDW]);		//resetuj podtrzymanie
583:                           PFNf_fns_max=0;
584:                       }
585:                   }
586:           //--------------------------RESET------------------------------
587:                   //nacisnieto przycisk RESET
588:                   key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
589:                   if(key==_KDFST)
590:                   {
591:                       if(PFNf_set_nco||PFNf_set_ncw||PFNf_set_eco||PFNf_str_nco||PFNf_str_ncw||PFNf_prn_res||PFNf_set_fnserw||PFNf_fnserw||PFNf_set_aleg||PFNf_aleg||PFNf_prODP)
592:                       {
593:                           WaitToLowEx(&ky[SS_OFF]);
594:                           PFNf_set_nco=0;
595:                           PFNf_set_ncw=0;
596:                           PFNf_str_nco=0;
597:                           PFNf_str_ncw=0;
598:                           PFNf_mod_ncw=0;
599:                           PFNf_set_eco=0;
600:                           PFNf_mod_eco=0;
601:                           PFNf_prn_res=0;
602:                           PFNf_set_fnserw=0;
603:                           PFNf_fnserw=0;
604:                           PFNf_set_aleg=0;
605:                           PFNf_aleg=0;
606:                       }
607:                       else
608:                       if(!PFNf_off&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
609:                       {
610:                           WaitToLowEx(&ky[SS_OFF]);
611:                           if(!PFNf_errCS||(PFNf_fnoCS&&!PFNf_errIN))
612:                           {
613:                               PFNf_prn_res=1;
614:                           }
615:                           StartRTdS(_RTPCS);
616:                       }
617:                   }
618:           	}
619:           	else
620:           	{
621:           		PFNf_set_nco=0;
622:           		PFNf_set_ncw=0;
623:           		PFNf_str_nco=0;
624:           		PFNf_str_ncw=0;
625:           		PFNf_set_eco=0;
626:           		PFNf_prn_res=0;
627:           		PFNf_set_fnserw=0;
628:           		PFNf_fnserw=0;
629:           		PFNf_set_aleg=0;
630:           		PFNf_aleg=0;
631:           	}
632:               
633:               if(!PFNf_opgres) PFNf_LINres=0;
634:               if(!PFNf_fsetLaddr) //nieaktywny tryb przypisania adresu LIN?
635:               {
636:                   //stan przycisku RESET
637:                   if(RdPrt(S_OFF)||PFNf_LINres)
638:                   {
639:                           PFNf_res=1;
640:                   }
641:                   else PFNf_res=0;
642:               }
643:           }
644:           #endif
645:           /*---------------------------------------------------------------------------------*/
646:           #if _KEY_BBOARD==1
647:           void TrybPracy(void)
648:           {
649:           	//static bit bf_oaleg;
650:           	volatile unsigned char key,key2,EnEco,tm;
651:           	if(!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres)
2032  A00B     BTFSS PFNf_lato, 0, ACCESS
2034  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
2036  D303     BRA 0x263E
2038  B80D     BTFSC PFNf_plmCO, 4, ACCESS
203A  D301     BRA 0x263E
652:           	{
653:           
654:               //--------------------------PRZELACZNIK FUNKCJI------------------------------
655:                   //przytrzymano przycisk RESET (wylaczenie/zalaczenie sterownika)
656:                   if(!RdPrt(S_SET)&&!RdPrt(S_KOM))
203C  0E01     MOVLW 0x1
203E  EC02     CALL 0xBA04, 0
2040  F05D     NOP
2042  E248     BC 0x20D4
2044  0E02     MOVLW 0x2
2046  EC02     CALL 0xBA04, 0
2048  F05D     NOP
204A  E244     BC 0x20D4
657:                   {
658:                       key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
204C  ECF7     CALL 0x11EE, 0
204E  F008     NOP
2050  EC02     CALL 0xBA04, 0
2052  F05D     NOP
2054  0E01     MOVLW 0x1
2056  A0D8     BTFSS STATUS, 0, ACCESS
2058  0E00     MOVLW 0x0
205A  EC20     CALL 0x6C40, 0
205C  F036     NOP
205E  6F84     MOVWF _PFNf_tdzCO, BANKED
659:                       if(key!=_KDFST&&key>=_TKOFF)
2060  0E64     MOVLW 0x64
2062  1984     XORWF _PFNf_tdzCO, W, BANKED
2064  E037     BZ 0x20D4
2066  0E0F     MOVLW 0xF
2068  6584     CPFSGT _PFNf_tdzCO, BANKED
206A  D034     BRA 0x20D4
660:                       {	
661:                           WaitToLowEx(&ky[SS_OFF]);
206C  ECF2     CALL 0x11E4, 0
206E  F008     NOP
2070  EC65     CALL 0xBCCA, 0
2072  F05E     NOP
662:                           if(PFN.vUNI02>=9)
2074  0E08     MOVLW 0x8
2076  0101     MOVLB 0x1
2078  65EC     CPFSGT 0xEC, BANKED
207A  D009     BRA 0x208E
663:                           {
664:                               if(PFNf_off)            //powrot ze stanu off?
207C  AA0C     BTFSS PFNf_off, 5, ACCESS
207E  D007     BRA 0x208E
665:                               {
666:                                   if(PFNf_popFN)      //zapamietany, poprzedni stan przelacznika = LATO?
2080  A60E     BTFSS PFNf_popFN, 3, ACCESS
2082  D003     BRA 0x208A
667:                                   {
668:                                       PFNf_lato=1;
2084  880B     BSF PFNf_lato, 4, ACCESS
669:                                       PFNf_zima=0;                        
2086  9811     BCF PFNf_zima, 4, ACCESS
670:                                   }
2088  D002     BRA 0x208E
671:                                   else
672:                                   {
673:                                       PFNf_lato=0;
208A  980B     BCF PFNf_lato, 4, ACCESS
674:                                       PFNf_zima=1;                        
208C  8811     BSF PFNf_zima, 4, ACCESS
675:                                   }
676:                               }
677:                           }
678:                           PFNf_off=!PFNf_off;
208E  BA0C     BTFSC PFNf_off, 5, ACCESS
2090  D002     BRA 0x2096
2092  8A0C     BSF PFNf_off, 5, ACCESS
2094  D001     BRA 0x2098
2096  9A0C     BCF PFNf_off, 5, ACCESS
679:                           PFNf_set_nco=0;
2098  9010     BCF PFNf_str_nco, 0, ACCESS
680:                           PFNf_set_ncw=0;
209A  9210     BCF PFNf_str_nco, 1, ACCESS
681:                           PFNf_set_eco=0;
209C  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
682:                           PFNf_str_nco=0;
209E  9410     BCF PFNf_str_nco, 2, ACCESS
683:                           PFNf_str_ncw=0;
20A0  9610     BCF PFNf_str_nco, 3, ACCESS
684:                           PFNf_prn_res=0;
20A2  DB1D     RCALL PL578
685:                           PFNf_set_fnserw=0;
686:                           PFNf_fnserw=0;
687:                           PFNf_set_aleg=0;
688:                           PFNf_aleg=0;
689:                           ResBufKeyEx(&ky[SS_KUP_CW]);
20A4  0EBF     MOVLW 0xBF
20A6  0100     MOVLB 0x0
20A8  6F74     MOVWF _PFNf_prODP, BANKED
20AA  0E03     MOVLW 0x3
20AC  6F75     MOVWF _PFNf_prn_cs, BANKED
20AE  EC77     CALL 0xBAEE, 0
20B0  F05D     NOP
690:                           ResBufKeyEx(&ky[SS_KDW_CW]);
20B2  EC34     CALL 0x4868, 0
20B4  F024     NOP
20B6  EC77     CALL 0xBAEE, 0
20B8  F05D     NOP
691:                           ResBufKeyEx(&ky[SS_KUP_CO]);
20BA  DAE6     RCALL PL338
20BC  EC77     CALL 0xBAEE, 0
20BE  F05D     NOP
692:                           ResBufKeyEx(&ky[SS_KDW_CO]);                
20C0  DADE     RCALL PL336
20C2  EC77     CALL 0xBAEE, 0
20C4  F05D     NOP
693:                           ResBufKeyEx(&ky[SS_SET]);
20C6  EC45     CALL 0x488A, 0
20C8  F024     NOP
20CA  EC77     CALL 0xBAEE, 0
20CC  F05D     NOP
694:                           ResBufKeyEx(&ky[SS_KOM]);                
20CE  DAF8     RCALL PL518
20D0  EC77     CALL 0xBAEE, 0
20D2  F05D     NOP
695:                       }
696:                   }
697:           //---------------------
698:                   if(!PFNf_off&&!PFNf_lato&&!PFNf_zima)		//stan nieustalony?
20D4  AA0C     BTFSS PFNf_off, 5, ACCESS
20D6  B80B     BTFSC PFNf_lato, 4, ACCESS
20D8  D004     BRA 0x20E2
20DA  B811     BTFSC PFNf_zima, 4, ACCESS
20DC  D002     BRA 0x20E2
699:                   {
700:                       PFNf_lato=0;
20DE  980B     BCF PFNf_lato, 4, ACCESS
701:                       PFNf_zima=1;
20E0  8811     BSF PFNf_zima, 4, ACCESS
702:                   }
703:                   //przytrzymano przycisk SET (zmiana trybu pracy)
704:                   if(!RdPrt(S_OFF)&&!RdPrt(S_KOM)&&!RdPrt(S_KUP_CW)&&!RdPrt(S_KDW_CW)&&!RdPrt(S_KUP_CO)&&!RdPrt(S_KDW_CO)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_prODP)
20E2  0E00     MOVLW 0x0
20E4  EC02     CALL 0xBA04, 0
20E6  F05D     NOP
20E8  E243     BC 0x2170
20EA  0E02     MOVLW 0x2
20EC  EC02     CALL 0xBA04, 0
20EE  F05D     NOP
20F0  E23F     BC 0x2170
20F2  0E03     MOVLW 0x3
20F4  EC02     CALL 0xBA04, 0
20F6  F05D     NOP
20F8  E23B     BC 0x2170
20FA  0E04     MOVLW 0x4
20FC  EC02     CALL 0xBA04, 0
20FE  F05D     NOP
2100  E237     BC 0x2170
2102  0E05     MOVLW 0x5
2104  EC02     CALL 0xBA04, 0
2106  F05D     NOP
2108  E233     BC 0x2170
210A  0E06     MOVLW 0x6
210C  EC02     CALL 0xBA04, 0
210E  F05D     NOP
2110  E22F     BC 0x2170
2112  AA0C     BTFSS PFNf_off, 5, ACCESS
2114  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
2116  D02C     BRA 0x2170
2118  A208     BTFSS PFNf_b_set_nco, 1, ACCESS
211A  B80E     BTFSC PFNf_popFN, 4, ACCESS
211C  D029     BRA 0x2170
705:                   {
706:                       key=PresKeyEX(RdPrt(S_SET),&ky[SS_SET]);
211E  0EB5     MOVLW 0xB5
2120  6F76     MOVWF _PFNf_prn_in, BANKED
2122  0E03     MOVLW 0x3
2124  6F77     MOVWF _PFNf_prn_pg, BANKED
2126  0E01     MOVLW 0x1
2128  EC02     CALL 0xBA04, 0
212A  F05D     NOP
212C  0E01     MOVLW 0x1
212E  A0D8     BTFSS STATUS, 0, ACCESS
2130  0E00     MOVLW 0x0
2132  EC20     CALL 0x6C40, 0
2134  F036     NOP
2136  6F84     MOVWF _PFNf_tdzCO, BANKED
707:                       if(key!=_KDFST&&key>=_TKSET)
2138  0E64     MOVLW 0x64
213A  1984     XORWF _PFNf_tdzCO, W, BANKED
213C  E019     BZ 0x2170
213E  0E07     MOVLW 0x7
2140  6584     CPFSGT _PFNf_tdzCO, BANKED
2142  D016     BRA 0x2170
708:                       {	
709:                           WaitToLowEx(&ky[SS_SET]);	
2144  0EB5     MOVLW 0xB5
2146  6F74     MOVWF _PFNf_prODP, BANKED
2148  0E03     MOVLW 0x3
214A  6F75     MOVWF _PFNf_prn_cs, BANKED
214C  EC65     CALL 0xBCCA, 0
214E  F05E     NOP
710:                           PFNf_lato=!PFNf_lato;
2150  B80B     BTFSC PFNf_lato, 4, ACCESS
2152  D002     BRA 0x2158
2154  880B     BSF PFNf_lato, 4, ACCESS
2156  D001     BRA 0x215A
2158  980B     BCF PFNf_lato, 4, ACCESS
711:                           PFNf_zima=!PFNf_lato;
215A  B80B     BTFSC PFNf_lato, 4, ACCESS
215C  D002     BRA 0x2162
215E  8811     BSF PFNf_zima, 4, ACCESS
2160  D001     BRA 0x2164
2162  9811     BCF PFNf_zima, 4, ACCESS
712:                           PFNf_set_nco=0;
2164  9010     BCF PFNf_str_nco, 0, ACCESS
713:                           PFNf_set_ncw=0;
2166  9210     BCF PFNf_str_nco, 1, ACCESS
714:                           PFNf_set_eco=0;
2168  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
715:                           PFNf_fnserw=0;				//przerwanie funkcji serwisowej
216A  9C0A     BCF PFNf_firstEdge, 6, ACCESS
716:                           PFNf_aleg=0;				//przerwanie funkcji antylegionella
216C  9208     BCF PFNf_b_set_nco, 1, ACCESS
717:                           PFNf_prn_res=0;
216E  920F     BCF PFNf_set_fnserw, 1, ACCESS
718:                       }
719:                   }
720:           //--------------------------NASTAWY------------------------------
721:                   //nacisnieto przycisk KOM (wybor funkcji serwisowej, antylegionella)
722:                   if(PFNf_oaleg) PFNf_set_aleg=0;
2170  B40C     BTFSC PFNf_off, 2, ACCESS
2172  9A0F     BCF PFNf_set_fnserw, 5, ACCESS
723:                   if(PFNf_ofnserw) PFNf_set_fnserw=0; 
2174  BE0C     BTFSC PFNf_off, 7, ACCESS
2176  9E0F     BCF PFNf_set_fnserw, 7, ACCESS
724:           
725:                   if(!RdPrt(S_SET)&&!RdPrt(S_OFF)&&!RdPrt(S_KUP_CW)&&!RdPrt(S_KDW_CW)&&!RdPrt(S_KUP_CO)&&!RdPrt(S_KDW_CO)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_prODP)
2178  0E01     MOVLW 0x1
217A  EC02     CALL 0xBA04, 0
217C  F05D     NOP
217E  E274     BC 0x2268
2180  0E00     MOVLW 0x0
2182  EC02     CALL 0xBA04, 0
2184  F05D     NOP
2186  E270     BC 0x2268
2188  0E03     MOVLW 0x3
218A  EC02     CALL 0xBA04, 0
218C  F05D     NOP
218E  E26C     BC 0x2268
2190  0E04     MOVLW 0x4
2192  EC02     CALL 0xBA04, 0
2194  F05D     NOP
2196  E268     BC 0x2268
2198  0E05     MOVLW 0x5
219A  EC02     CALL 0xBA04, 0
219C  F05D     NOP
219E  E264     BC 0x2268
21A0  0E06     MOVLW 0x6
21A2  EC02     CALL 0xBA04, 0
21A4  F05D     NOP
21A6  E260     BC 0x2268
21A8  AA0C     BTFSS PFNf_off, 5, ACCESS
21AA  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
21AC  D05D     BRA 0x2268
21AE  A208     BTFSS PFNf_b_set_nco, 1, ACCESS
21B0  B80E     BTFSC PFNf_popFN, 4, ACCESS
21B2  D05A     BRA 0x2268
726:                   {
727:                       key=PresKeyEX(RdPrt(S_KOM),&ky[SS_KOM]);
21B4  EC10     CALL 0x1220, 0
21B6  F009     NOP
21B8  EC02     CALL 0xBA04, 0
21BA  F05D     NOP
21BC  0E01     MOVLW 0x1
21BE  A0D8     BTFSS STATUS, 0, ACCESS
21C0  0E00     MOVLW 0x0
21C2  EC20     CALL 0x6C40, 0
21C4  F036     NOP
21C6  6F84     MOVWF _PFNf_tdzCO, BANKED
728:                       if(((PFNf_set_fnserw||PFNf_set_aleg)&&(key==_KDFST))||(!PFNf_set_fnserw&&!PFNf_set_aleg&&(key!=_KDFST&&key>=_TKSET)))
21C8  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
21CA  D002     BRA 0x21D0
21CC  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
21CE  D003     BRA 0x21D6
21D0  0E64     MOVLW 0x64
21D2  1984     XORWF _PFNf_tdzCO, W, BANKED
21D4  E009     BZ 0x21E8
21D6  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
21D8  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
21DA  D046     BRA 0x2268
21DC  0E64     MOVLW 0x64
21DE  1984     XORWF _PFNf_tdzCO, W, BANKED
21E0  E043     BZ 0x2268
21E2  0E07     MOVLW 0x7
21E4  6584     CPFSGT _PFNf_tdzCO, BANKED
21E6  D040     BRA 0x2268
729:                       {
730:                           if(PFNf_set_fnserw||PFNf_set_aleg)
21E8  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
21EA  D002     BRA 0x21F0
21EC  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
21EE  D004     BRA 0x21F8
731:                           {
732:                               ResBufKeyEx(&ky[SS_KOM]);		//resetuj podtrzymanie
21F0  DA67     RCALL PL518
21F2  EC77     CALL 0xBAEE, 0
21F4  F05D     NOP
733:                           }
21F6  D004     BRA 0x2200
734:                           else
735:                           {
736:                               WaitToLowEx(&ky[SS_KOM]);
21F8  EC06     CALL 0x120C, 0
21FA  F009     NOP
21FC  EC65     CALL 0xBCCA, 0
21FE  F05E     NOP
737:                           }
738:                           PFNf_b_set_nco=0;
2200  9E08     BCF PFNf_b_set_nco, 7, ACCESS
739:                           PFNf_b_set_ncw=0;
2202  9009     BCF PFNf_b_str_nco, 0, ACCESS
740:                           PFNf_b_set_eco=0;
2204  9C08     BCF PFNf_b_set_nco, 6, ACCESS
741:                           PFNf_set_ncw=0;
2206  9210     BCF PFNf_str_nco, 1, ACCESS
742:                           PFNf_set_eco=0;
2208  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
743:                           PFNf_prn_res=0;
220A  920F     BCF PFNf_set_fnserw, 1, ACCESS
744:                           if(PFNf_zima&&!PFNf_obgCW&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
220C  B811     BTFSC PFNf_zima, 4, ACCESS
220E  B80C     BTFSC PFNf_off, 4, ACCESS
2210  D00F     BRA 0x2230
2212  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
2214  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
2216  D00C     BRA 0x2230
2218  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
221A  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
221C  D009     BRA 0x2230
221E  B80E     BTFSC PFNf_popFN, 4, ACCESS
2220  D007     BRA 0x2230
745:                           {
746:                               PFNf_set_nco=0;
2222  9010     BCF PFNf_str_nco, 0, ACCESS
747:                               PFNf_set_fnserw=1;
2224  8E0F     BSF PFNf_set_fnserw, 7, ACCESS
748:                               PFNf_fns_max=1;
2226  8A0A     BSF PFNf_firstEdge, 5, ACCESS
749:                               StartRTdS(_RTSET);
2228  0E02     MOVLW 0x2
222A  EC55     CALL 0xBCAA, 0
222C  F05E     NOP
750:                           }
222E  D01C     BRA 0x2268
751:                           else
752:                           if(PFNf_set_fnserw&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
2230  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
2232  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
2234  D00D     BRA 0x2250
2236  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
2238  B80E     BTFSC PFNf_popFN, 4, ACCESS
223A  D00A     BRA 0x2250
753:                           {
754:                               if(PFNf_EnAleg&&!PFNf_set_aleg)
223C  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
223E  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
2240  D004     BRA 0x224A
755:                               {
756:                                   PFNf_set_fnserw=0;
2242  DA62     RCALL PL824
757:                                   PFNf_set_aleg=1;
758:                                   StartRTdS(_RTSET);
2244  EC55     CALL 0xBCAA, 0
2246  F05E     NOP
759:                               }
2248  D00F     BRA 0x2268
760:                               else
761:                               {
762:                                   PFNf_newPCO=0;
224A  900C     BCF PFNf_off, 0, ACCESS
763:                                   PFNf_set_nco=0;
224C  DA22     RCALL PL358
764:                                   PFNf_b_set_nco=0;
765:                                   PFNf_set_ncw=0;
766:                                   PFNf_b_set_ncw=0;
767:                                   PFNf_set_eco=0;
768:                                   PFNf_b_set_eco=0;
769:                                   PFNf_set_fnserw=0;
770:                                   PFNf_set_aleg=0;
224E  D00C     BRA 0x2268
771:                               }
772:                           }
773:                           else
774:                           if(!PFNf_zima&&PFNf_EnAleg&&!PFNf_set_aleg&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)    
2250  A811     BTFSS PFNf_zima, 4, ACCESS
2252  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
2254  D7FA     BRA 0x224A
2256  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
2258  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
225A  D7F7     BRA 0x224A
225C  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
225E  B80E     BTFSC PFNf_popFN, 4, ACCESS
2260  D7F4     BRA 0x224A
2262  DA52     RCALL PL824
775:                           {
776:                               PFNf_set_fnserw=0;
777:                               PFNf_set_aleg=1;
778:                               StartRTdS(_RTSET);                    
2264  EC55     CALL 0xBCAA, 0
2266  F05E     NOP
779:                           }
780:                           else
781:                           {
782:                               PFNf_newPCO=0;
783:                               PFNf_set_nco=0;
784:                               PFNf_b_set_nco=0;
785:                               PFNf_set_ncw=0;
786:                               PFNf_b_set_ncw=0;
787:                               PFNf_set_eco=0;
788:                               PFNf_b_set_eco=0;
789:                               PFNf_set_fnserw=0;
790:                               PFNf_set_aleg=0;                    
791:                           }
792:                       }
793:                   }
794:                   if(RTdS(_RTSET)>_TSETNST)				//uplynal czas podtrzymania wybranego parametru?
2268  0E02     MOVLW 0x2
226A  EC8B     CALL 0xBF16, 0
226C  F05F     NOP
226E  6F7D     MOVWF _PFNf_set_aleg, BANKED
2270  0E2D     MOVLW 0x2D
2272  657D     CPFSGT _PFNf_set_aleg, BANKED
2274  D001     BRA 0x2278
2276  DA0D     RCALL PL358
795:                   {
796:                       PFNf_set_nco=0;
797:                       PFNf_b_set_nco=0;
798:                       PFNf_set_ncw=0;
799:                       PFNf_b_set_ncw=0;
800:                       PFNf_set_eco=0;
801:                       PFNf_b_set_eco=0;
802:                       PFNf_set_fnserw=0;
803:                       PFNf_set_aleg=0;
804:                   } 
805:                   //aktywacja funkcji serwisowej lub antylegionella przyciskiem +
806:                   if(!RdPrt(S_SET)&&!RdPrt(S_OFF)&&!RdPrt(S_KDW_CW)&&!RdPrt(S_KDW_CO)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg)
2278  0E01     MOVLW 0x1
227A  EC02     CALL 0xBA04, 0
227C  F05D     NOP
227E  E244     BC 0x2308
2280  0E00     MOVLW 0x0
2282  EC02     CALL 0xBA04, 0
2284  F05D     NOP
2286  E240     BC 0x2308
2288  0E04     MOVLW 0x4
228A  EC02     CALL 0xBA04, 0
228C  F05D     NOP
228E  E23C     BC 0x2308
2290  0E06     MOVLW 0x6
2292  EC02     CALL 0xBA04, 0
2294  F05D     NOP
2296  E238     BC 0x2308
2298  AA0C     BTFSS PFNf_off, 5, ACCESS
229A  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
229C  D035     BRA 0x2308
229E  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
22A0  D033     BRA 0x2308
807:                   {
808:                       if(PFNf_set_fnserw)
22A2  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
22A4  D016     BRA 0x22D2
809:                       {
810:                           key=PresKeyEX(RdPrt(S_KUP_CO),&ky[SS_KUP_CO]);
22A6  DA07     RCALL PL382
22A8  EC02     CALL 0xBA04, 0
22AA  F05D     NOP
22AC  0E01     MOVLW 0x1
22AE  A0D8     BTFSS STATUS, 0, ACCESS
22B0  0E00     MOVLW 0x0
22B2  EC20     CALL 0x6C40, 0
22B4  F036     NOP
22B6  6F84     MOVWF _PFNf_tdzCO, BANKED
811:                           if(key!=_KDFST&&key>=_TKALG)
22B8  0E64     MOVLW 0x64
22BA  1984     XORWF _PFNf_tdzCO, W, BANKED
22BC  E00A     BZ 0x22D2
22BE  0E09     MOVLW 0x9
22C0  6584     CPFSGT _PFNf_tdzCO, BANKED
22C2  D007     BRA 0x22D2
812:                           {	
813:                               WaitToLowEx(&ky[SS_KUP_CO]);
22C4  DA17     RCALL PL688
22C6  EC65     CALL 0xBCCA, 0
22C8  F05E     NOP
814:                               PFNf_fnserw=1;
22CA  EC4E     CALL 0x449C, 0
22CC  F022     NOP
815:                               PFNf_prn_res=0;
816:                               PFNf_set_nco=0;
817:                               PFNf_set_ncw=0;
818:                               PFNf_set_eco=0;
819:                               PFNf_b_ofnserw=0;
820:                               StartRTdS(_RTFSP);
22CE  EC55     CALL 0xBCAA, 0
22D0  F05E     NOP
821:                           }
822:                       }
823:                       if(PFNf_set_aleg)
22D2  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
22D4  D019     BRA 0x2308
824:                       {
825:                           key=PresKeyEX(RdPrt(S_KUP_CW),&ky[SS_KUP_CW]);
22D6  D9FE     RCALL PL564
22D8  EC02     CALL 0xBA04, 0
22DA  F05D     NOP
22DC  0E01     MOVLW 0x1
22DE  A0D8     BTFSS STATUS, 0, ACCESS
22E0  0E00     MOVLW 0x0
22E2  EC20     CALL 0x6C40, 0
22E4  F036     NOP
22E6  6F84     MOVWF _PFNf_tdzCO, BANKED
826:                           if(key!=_KDFST&&key>=_TKSRV)
22E8  0E64     MOVLW 0x64
22EA  1984     XORWF _PFNf_tdzCO, W, BANKED
22EC  E00D     BZ 0x2308
22EE  0E09     MOVLW 0x9
22F0  6584     CPFSGT _PFNf_tdzCO, BANKED
22F2  D00A     BRA 0x2308
827:                           {	
828:                               WaitToLowEx(&ky[SS_KUP_CW]);
22F4  0EBF     MOVLW 0xBF
22F6  6F74     MOVWF _PFNf_prODP, BANKED
22F8  0E03     MOVLW 0x3
22FA  6F75     MOVWF _PFNf_prn_cs, BANKED
22FC  EC65     CALL 0xBCCA, 0
22FE  F05E     NOP
829:                               PFNf_aleg=1;
2300  EC61     CALL 0x44C2, 0
2302  F022     NOP
830:                               PFNf_set_nco=0;
831:                               PFNf_set_ncw=0;
832:                               PFNf_set_eco=0;
833:                               PFNf_b_oaleg=0;
834:                               StartRTdS(_RTFSP);
2304  EC55     CALL 0xBCAA, 0
2306  F05E     NOP
835:                           }
836:                       }
837:                   }
838:                   if(RTdS(_RTFSP)>_TAFSP)				//uplynal maksymalny czas na aktywacje funkcji serwisowej/antylegionella?
2308  0E07     MOVLW 0x7
230A  EC8B     CALL 0xBF16, 0
230C  F05F     NOP
230E  6F7D     MOVWF _PFNf_set_aleg, BANKED
2310  0E19     MOVLW 0x19
2312  657D     CPFSGT _PFNf_set_aleg, BANKED
2314  D008     BRA 0x2326
839:                   {
840:                       if(PFNf_aleg&&!PFNf_oaleg) PFNf_aleg=0;
2316  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
2318  B40C     BTFSC PFNf_off, 2, ACCESS
231A  D001     BRA 0x231E
231C  9208     BCF PFNf_b_set_nco, 1, ACCESS
841:                       if(PFNf_fnserw&&!PFNf_ofnserw) PFNf_fnserw=0;
231E  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
2320  BE0C     BTFSC PFNf_off, 7, ACCESS
2322  D001     BRA 0x2326
2324  9C0A     BCF PFNf_firstEdge, 6, ACCESS
842:                   }
843:           //---------------------
844:                   //nacisnieto przycisk UP lub DW (zmiana nastawy CW)
845:                   //if(!RdPrt(S_OFF)&&!RdPrt(S_SET)&&!RdPrt(S_KOM)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_set_nco&&!PFNf_set_ncw&&!PFNf_set_eco&&!PFNf_prODP)
846:                   if(!RdPrt(S_KUP_CO)&&!RdPrt(S_KDW_CO)&&!RdPrt(S_OFF)&&!RdPrt(S_SET)&&!RdPrt(S_KOM)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_set_ncw&&!PFNf_prODP)            
2326  0E05     MOVLW 0x5
2328  EC02     CALL 0xBA04, 0
232A  F05D     NOP
232C  E251     BC 0x23D0
232E  0E06     MOVLW 0x6
2330  EC02     CALL 0xBA04, 0
2332  F05D     NOP
2334  E24D     BC 0x23D0
2336  0E00     MOVLW 0x0
2338  EC02     CALL 0xBA04, 0
233A  F05D     NOP
233C  E249     BC 0x23D0
233E  0E01     MOVLW 0x1
2340  EC02     CALL 0xBA04, 0
2342  F05D     NOP
2344  E245     BC 0x23D0
2346  0E02     MOVLW 0x2
2348  EC02     CALL 0xBA04, 0
234A  F05D     NOP
234C  E241     BC 0x23D0
234E  AA0C     BTFSS PFNf_off, 5, ACCESS
2350  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
2352  D03E     BRA 0x23D0
2354  A208     BTFSS PFNf_b_set_nco, 1, ACCESS
2356  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
2358  D03B     BRA 0x23D0
235A  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
235C  B210     BTFSC PFNf_str_nco, 1, ACCESS
235E  D038     BRA 0x23D0
2360  B80E     BTFSC PFNf_popFN, 4, ACCESS
2362  D036     BRA 0x23D0
847:                   {
848:                       key=PresKeyEX(RdPrt(S_KDW_CW),&ky[SS_KDW_CW]);
2364  0EC4     MOVLW 0xC4
2366  6F76     MOVWF _PFNf_prn_in, BANKED
2368  0E03     MOVLW 0x3
236A  6F77     MOVWF _PFNf_prn_pg, BANKED
236C  0E04     MOVLW 0x4
236E  EC02     CALL 0xBA04, 0
2370  F05D     NOP
2372  0E01     MOVLW 0x1
2374  A0D8     BTFSS STATUS, 0, ACCESS
2376  0E00     MOVLW 0x0
2378  EC20     CALL 0x6C40, 0
237A  F036     NOP
237C  6F84     MOVWF _PFNf_tdzCO, BANKED
237E  D9AA     RCALL PL564
849:                       key2=PresKeyEX(RdPrt(S_KUP_CW),&ky[SS_KUP_CW]);
2380  EC02     CALL 0xBA04, 0
2382  F05D     NOP
2384  0E01     MOVLW 0x1
2386  A0D8     BTFSS STATUS, 0, ACCESS
2388  0E00     MOVLW 0x0
238A  EC20     CALL 0x6C40, 0
238C  F036     NOP
238E  6F82     MOVWF _PFNf_str_nco, BANKED
850:           
851:                       if(key==_KDFST||(key>=_TKSET)||key2==_KDFST||(key2>=_TKSET))		
2390  0E64     MOVLW 0x64
2392  1984     XORWF _PFNf_tdzCO, W, BANKED
2394  E009     BZ 0x23A8
2396  0E08     MOVLW 0x8
2398  6184     CPFSLT _PFNf_tdzCO, BANKED
239A  D006     BRA 0x23A8
239C  0E64     MOVLW 0x64
239E  1982     XORWF _PFNf_str_nco, W, BANKED
23A0  E003     BZ 0x23A8
23A2  0E07     MOVLW 0x7
23A4  6582     CPFSGT _PFNf_str_nco, BANKED
23A6  D014     BRA 0x23D0
852:                       {
853:                           ResBufKeyEx(&ky[SS_KDW_CW]);		//resetuj podtrzymanie
23A8  EC34     CALL 0x4868, 0
23AA  F024     NOP
23AC  EC77     CALL 0xBAEE, 0
23AE  F05D     NOP
23B0  D99C     RCALL PL684
854:                           ResBufKeyEx(&ky[SS_KUP_CW]);		//resetuj podtrzymanie
23B2  EC77     CALL 0xBAEE, 0
23B4  F05D     NOP
855:                           RestartKol2(_KL_NCWCO);
23B6  0E01     MOVLW 0x1
23B8  ECBF     CALL 0xBB7E, 0
23BA  F05D     NOP
856:                           RestartKol(_KL_NCWCO);
23BC  0E01     MOVLW 0x1
23BE  ECCE     CALL 0xBD9C, 0
23C0  F05E     NOP
857:                           PFNf_b_set_ncw=0;
23C2  9009     BCF PFNf_b_str_nco, 0, ACCESS
858:                           PFNf_prn_res=0;
23C4  920F     BCF PFNf_set_fnserw, 1, ACCESS
859:                           PFNf_set_ncw=1;
23C6  8210     BSF PFNf_str_nco, 1, ACCESS
860:                           PFNf_mod_ncw=0;
23C8  9C0B     BCF PFNf_lato, 6, ACCESS
861:                           StartRTdS(_RTSET);
23CA  0E02     MOVLW 0x2
23CC  EC55     CALL 0xBCAA, 0
23CE  F05E     NOP
862:                       }
863:                   }
864:           //---------------------
865:                   //nacisnieto przycisk UP lub DW (zmiana nastawy CO lub nastawy ECO)
866:                   //if(!RdPrt(S_OFF)&&!RdPrt(S_SET)&&!RdPrt(S_KOM)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_set_nco&&!PFNf_set_ncw&&!PFNf_set_eco&&!PFNf_prODP)
867:                   if(!RdPrt(S_KUP_CW)&&!RdPrt(S_KDW_CW)&&!RdPrt(S_OFF)&&!RdPrt(S_SET)&&!RdPrt(S_KOM)&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg&&!PFNf_set_fnserw&&!PFNf_set_aleg&&!PFNf_set_nco&&!PFNf_set_eco&&!PFNf_prODP)            
23D0  0E03     MOVLW 0x3
23D2  EC02     CALL 0xBA04, 0
23D4  F05D     NOP
23D6  E27C     BC 0x24D0
23D8  0E04     MOVLW 0x4
23DA  EC02     CALL 0xBA04, 0
23DC  F05D     NOP
23DE  E278     BC 0x24D0
23E0  0E00     MOVLW 0x0
23E2  EC02     CALL 0xBA04, 0
23E4  F05D     NOP
23E6  E274     BC 0x24D0
23E8  0E01     MOVLW 0x1
23EA  EC02     CALL 0xBA04, 0
23EC  F05D     NOP
23EE  E270     BC 0x24D0
23F0  0E02     MOVLW 0x2
23F2  EC02     CALL 0xBA04, 0
23F4  F05D     NOP
23F6  E26C     BC 0x24D0
23F8  AA0C     BTFSS PFNf_off, 5, ACCESS
23FA  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
23FC  D069     BRA 0x24D0
23FE  A208     BTFSS PFNf_b_set_nco, 1, ACCESS
2400  BE0F     BTFSC PFNf_set_fnserw, 7, ACCESS
2402  D066     BRA 0x24D0
2404  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
2406  B010     BTFSC PFNf_str_nco, 0, ACCESS
2408  D063     BRA 0x24D0
240A  AC0F     BTFSS PFNf_set_fnserw, 6, ACCESS
240C  B80E     BTFSC PFNf_popFN, 4, ACCESS
240E  D060     BRA 0x24D0
868:                   {
869:                       key=PresKeyEX(RdPrt(S_KDW_CO),&ky[SS_KDW_CO]);
2410  D95C     RCALL PL560
2412  EC02     CALL 0xBA04, 0
2414  F05D     NOP
2416  0E01     MOVLW 0x1
2418  A0D8     BTFSS STATUS, 0, ACCESS
241A  0E00     MOVLW 0x0
241C  EC20     CALL 0x6C40, 0
241E  F036     NOP
2420  6F84     MOVWF _PFNf_tdzCO, BANKED
2422  D949     RCALL PL382
870:                       key2=PresKeyEX(RdPrt(S_KUP_CO),&ky[SS_KUP_CO]);
2424  EC02     CALL 0xBA04, 0
2426  F05D     NOP
2428  0E01     MOVLW 0x1
242A  A0D8     BTFSS STATUS, 0, ACCESS
242C  0E00     MOVLW 0x0
242E  EC20     CALL 0x6C40, 0
2430  F036     NOP
2432  6F82     MOVWF _PFNf_str_nco, BANKED
871:           
872:                       EnEco=(PFNf_ofzima&&PFNf_pmpPWM&&PFNf_trbECO&&!PFNf_errIN&&!PFNf_obgCW)?1:0;            
2434  6B80     CLRF _PFNf_set_nco, BANKED
2436  B20D     BTFSC PFNf_plmCO, 1, ACCESS
2438  A20E     BTFSS PFNf_popFN, 1, ACCESS
243A  D007     BRA 0x244A
243C  B211     BTFSC PFNf_zima, 1, ACCESS
243E  BE09     BTFSC PFNf_b_str_nco, 7, ACCESS
2440  D004     BRA 0x244A
2442  B80C     BTFSC PFNf_off, 4, ACCESS
2444  D002     BRA 0x244A
2446  0E01     MOVLW 0x1
2448  6F80     MOVWF _PFNf_set_nco, BANKED
244A  C080     MOVFF _PFNf_set_nco, _PFNf_set_ncw
244C  F081     NOP
873:           
874:                       if(key==_KDFST||(!EnEco&&key>=_TKSET)||key2==_KDFST||(!EnEco&&key2>=_TKSET))		
244E  0E64     MOVLW 0x64
2450  1984     XORWF _PFNf_tdzCO, W, BANKED
2452  E00D     BZ 0x246E
2454  5181     MOVF _PFNf_set_ncw, W, BANKED
2456  E103     BNZ 0x245E
2458  0E08     MOVLW 0x8
245A  6184     CPFSLT _PFNf_tdzCO, BANKED
245C  D008     BRA 0x246E
245E  0E64     MOVLW 0x64
2460  1982     XORWF _PFNf_str_nco, W, BANKED
2462  E005     BZ 0x246E
2464  5181     MOVF _PFNf_set_ncw, W, BANKED
2466  E116     BNZ 0x2494
2468  0E07     MOVLW 0x7
246A  6582     CPFSGT _PFNf_str_nco, BANKED
246C  D013     BRA 0x2494
875:                       {
876:                           ResBufKeyEx(&ky[SS_KDW_CO]);		//resetuj podtrzymanie
246E  D907     RCALL PL336
2470  EC77     CALL 0xBAEE, 0
2472  F05D     NOP
2474  D909     RCALL PL338
877:                           ResBufKeyEx(&ky[SS_KUP_CO]);		//resetuj podtrzymanie
2476  EC77     CALL 0xBAEE, 0
2478  F05D     NOP
878:                           RestartKol2(_KL_NCWCO);
247A  0E01     MOVLW 0x1
247C  ECBF     CALL 0xBB7E, 0
247E  F05D     NOP
879:                           RestartKol(_KL_NCWCO);
2480  0E01     MOVLW 0x1
2482  ECCE     CALL 0xBD9C, 0
2484  F05E     NOP
880:                           PFNf_b_set_nco=0;
2486  9E08     BCF PFNf_b_set_nco, 7, ACCESS
881:                           PFNf_prn_res=0;
2488  920F     BCF PFNf_set_fnserw, 1, ACCESS
882:                           PFNf_set_nco=1;
248A  8010     BSF PFNf_str_nco, 0, ACCESS
883:                           StartRTdS(_RTSET);
248C  0E02     MOVLW 0x2
248E  EC55     CALL 0xBCAA, 0
2490  F05E     NOP
884:                       }
2492  D02A     BRA 0x24E8
885:                       else
886:                       if((EnEco&&key>=(_TKSET*2))||(EnEco&&key2>=(_TKSET*2)))		
2494  5181     MOVF _PFNf_set_ncw, W, BANKED
2496  E003     BZ 0x249E
2498  0E10     MOVLW 0x10
249A  6184     CPFSLT _PFNf_tdzCO, BANKED
249C  D005     BRA 0x24A8
249E  5181     MOVF _PFNf_set_ncw, W, BANKED
24A0  E023     BZ 0x24E8
24A2  0E0F     MOVLW 0xF
24A4  6582     CPFSGT _PFNf_str_nco, BANKED
24A6  D020     BRA 0x24E8
887:                       {
888:                           ResBufKeyEx(&ky[SS_KDW_CO]);		//resetuj podtrzymanie
24A8  D8EA     RCALL PL336
24AA  EC77     CALL 0xBAEE, 0
24AC  F05D     NOP
24AE  D8EC     RCALL PL338
889:                           ResBufKeyEx(&ky[SS_KUP_CO]);		//resetuj podtrzymanie
24B0  EC77     CALL 0xBAEE, 0
24B2  F05D     NOP
890:                           RestartKol2(_KL_NCWCO);
24B4  0E01     MOVLW 0x1
24B6  ECBF     CALL 0xBB7E, 0
24B8  F05D     NOP
891:                           RestartKol(_KL_NCWCO);
24BA  0E01     MOVLW 0x1
24BC  ECCE     CALL 0xBD9C, 0
24BE  F05E     NOP
892:                           PFNf_b_set_eco=0;
24C0  9C08     BCF PFNf_b_set_nco, 6, ACCESS
893:                           PFNf_prn_res=0;
24C2  920F     BCF PFNf_set_fnserw, 1, ACCESS
894:                           PFNf_set_eco=1;
24C4  8C0F     BSF PFNf_set_fnserw, 6, ACCESS
895:                           PFNf_mod_eco=0;
24C6  9A0B     BCF PFNf_lato, 5, ACCESS
896:                           StartRTdS(_RTSET);
24C8  0E02     MOVLW 0x2
24CA  EC55     CALL 0xBCAA, 0
24CC  F05E     NOP
24CE  D00C     BRA 0x24E8
897:                       }
898:                   }
899:                   else
900:                   {
901:                       if(!PFNf_off&&PFNf_prODP)
24D0  AA0C     BTFSS PFNf_off, 5, ACCESS
24D2  A80E     BTFSS PFNf_popFN, 4, ACCESS
24D4  D009     BRA 0x24E8
902:                       {
903:                           WaitToLowEx(&ky[SS_KDW_CO]);  
24D6  0ECE     MOVLW 0xCE
24D8  6F74     MOVWF _PFNf_prODP, BANKED
24DA  0E03     MOVLW 0x3
24DC  6F75     MOVWF _PFNf_prn_cs, BANKED
24DE  EC65     CALL 0xBCCA, 0
24E0  F05E     NOP
24E2  D908     RCALL PL688
904:                           WaitToLowEx(&ky[SS_KUP_CO]);
24E4  EC65     CALL 0xBCCA, 0
24E6  F05E     NOP
905:                       }
906:                   }
907:           //--------------------------FUNKCJE SPECJALNE------------------------------
908:           
909:                   tm=2*_TPCS;
24E8  0E64     MOVLW 0x64
24EA  6F83     MOVWF _PFNf_str_ncw, BANKED
910:           
911:                   if(RTdS(_RTPCS)>tm)									//uplynal czas podtrzymania wskazu cisnienia?
24EC  0E03     MOVLW 0x3
24EE  EC8B     CALL 0xBF16, 0
24F0  F05F     NOP
24F2  6183     CPFSLT _PFNf_str_ncw, BANKED
24F4  D001     BRA 0x24F8
912:                   {
913:                       PFNf_prn_res=0;
24F6  920F     BCF PFNf_set_fnserw, 1, ACCESS
914:                   }
915:           		
916:                   if(!PFNf_prn_res)
24F8  B20F     BTFSC PFNf_set_fnserw, 1, ACCESS
24FA  D002     BRA 0x2500
917:                   {
918:                       PFNf_prn_cs=0;
24FC  9A0E     BCF PFNf_popFN, 5, ACCESS
24FE  D00A     BRA 0x2514
919:                       PFNf_prn_in=0;
920:                       PFNf_prn_pp=0;
921:                       PFNf_prn_pg=0;
922:                   }
923:                   else
924:                   {
925:                       if(RTdS(_RTPCS)<(tm/4))
2500  0E03     MOVLW 0x3
2502  EC8B     CALL 0xBF16, 0
2504  F05F     NOP
2506  6F7D     MOVWF _PFNf_set_aleg, BANKED
2508  4183     RRNCF _PFNf_str_ncw, W, BANKED
250A  42E8     RRNCF WREG, F, ACCESS
250C  0B3F     ANDLW 0x3F
250E  5D7D     SUBWF _PFNf_set_aleg, W, BANKED
2510  E203     BC 0x2518
926:                       {
927:                           PFNf_prn_cs=1;			
2512  8A0E     BSF PFNf_popFN, 5, ACCESS
928:                           PFNf_prn_in=0;
2514  9C0E     BCF PFNf_popFN, 6, ACCESS
2516  D014     BRA 0x2540
929:                           PFNf_prn_pp=0;
930:                           PFNf_prn_pg=0;
931:                       }
932:                       else
933:                       if((RTdS(_RTPCS)>=(tm/4))&&(RTdS(_RTPCS)<(tm/2)))		//nadszedl czas podtrzymania wskazu temp wlotowej?
2518  D8F2     RCALL PL704
251A  90D8     BCF STATUS, 0, ACCESS
251C  337D     RRCF _PFNf_set_aleg, F, BANKED
251E  0E03     MOVLW 0x3
2520  EC8B     CALL 0xBF16, 0
2522  F05F     NOP
2524  6F7E     MOVWF _PFNf_set_eco, BANKED
2526  517D     MOVF _PFNf_set_aleg, W, BANKED
2528  5D7E     SUBWF _PFNf_set_eco, W, BANKED
252A  E30C     BNC 0x2544
252C  0E03     MOVLW 0x3
252E  EC8B     CALL 0xBF16, 0
2530  F05F     NOP
2532  6F7D     MOVWF _PFNf_set_aleg, BANKED
2534  90D8     BCF STATUS, 0, ACCESS
2536  3183     RRCF _PFNf_str_ncw, W, BANKED
2538  5D7D     SUBWF _PFNf_set_aleg, W, BANKED
253A  E204     BC 0x2544
934:                       {
935:                           PFNf_prn_cs=0;
253C  9A0E     BCF PFNf_popFN, 5, ACCESS
936:                           PFNf_prn_in=1;
253E  8C0E     BSF PFNf_popFN, 6, ACCESS
937:                           PFNf_prn_pp=0;
2540  900F     BCF PFNf_set_fnserw, 0, ACCESS
2542  D013     BRA 0x256A
938:                           PFNf_prn_pg=0;
939:                       }
940:                       else
941:                       if((RTdS(_RTPCS)>=(tm/2))&&(RTdS(_RTPCS)<((3*tm)/4)))
2544  D8DC     RCALL PL704
2546  0E03     MOVLW 0x3
2548  EC8B     CALL 0xBF16, 0
254A  F05F     NOP
254C  6F7E     MOVWF _PFNf_set_eco, BANKED
254E  517D     MOVF _PFNf_set_aleg, W, BANKED
2550  5D7E     SUBWF _PFNf_set_eco, W, BANKED
2552  E30D     BNC 0x256E
2554  0E03     MOVLW 0x3
2556  EC8B     CALL 0xBF16, 0
2558  F05F     NOP
255A  D885     RCALL PL270
255C  ECC3     CALL 0x9D86, 0
255E  F04E     NOP
2560  D8A1     RCALL PL374
2562  E205     BC 0x256E
942:                       {
943:                           PFNf_prn_cs=0;
2564  9A0E     BCF PFNf_popFN, 5, ACCESS
944:                           PFNf_prn_in=0;
2566  9C0E     BCF PFNf_popFN, 6, ACCESS
945:                           PFNf_prn_pp=1;
2568  800F     BSF PFNf_set_fnserw, 0, ACCESS
946:                           PFNf_prn_pg=0;
256A  9E0E     BCF PFNf_popFN, 7, ACCESS
947:                       }
256C  D00C     BRA 0x2586
948:                       else
949:                       if((RTdS(_RTPCS)>=((3*tm)/4)))
256E  0E03     MOVLW 0x3
2570  EC8B     CALL 0xBF16, 0
2572  F05F     NOP
2574  D878     RCALL PL270
2576  ECC3     CALL 0x9D86, 0
2578  F04E     NOP
257A  D894     RCALL PL374
257C  E304     BNC 0x2586
950:                       {
951:                           PFNf_prn_cs=0;
257E  9A0E     BCF PFNf_popFN, 5, ACCESS
952:                           PFNf_prn_in=0;
2580  9C0E     BCF PFNf_popFN, 6, ACCESS
953:                           PFNf_prn_pp=0;
2582  900F     BCF PFNf_set_fnserw, 0, ACCESS
954:                           PFNf_prn_pg=1;
2584  8E0E     BSF PFNf_popFN, 7, ACCESS
955:                       }				
956:                   }      
957:           //---------------------
958:                   if(!PFNf_off&&(PFNf_fnserw||PFNf_ofnserw))					//aktywna funkcja serwisowa?
2586  BA0C     BTFSC PFNf_off, 5, ACCESS
2588  D020     BRA 0x25CA
258A  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
258C  D002     BRA 0x2592
258E  AE0C     BTFSS PFNf_off, 7, ACCESS
2590  D01C     BRA 0x25CA
959:                   {
960:                       if(PresKeyEX(RdPrt(S_KUP_CO),&ky[SS_KUP_CO])>0)	//nacisnieto przycisk +?
2592  D891     RCALL PL382
2594  EC02     CALL 0xBA04, 0
2596  F05D     NOP
2598  0E01     MOVLW 0x1
259A  A0D8     BTFSS STATUS, 0, ACCESS
259C  0E00     MOVLW 0x0
259E  EC20     CALL 0x6C40, 0
25A0  F036     NOP
25A2  0900     IORLW 0x0
25A4  E004     BZ 0x25AE
25A6  D870     RCALL PL338
961:                       {
962:                           ResBufKeyEx(&ky[SS_KUP_CO]);		//resetuj podtrzymanie
25A8  EC77     CALL 0xBAEE, 0
25AA  F05D     NOP
963:                           PFNf_fns_max=1;
25AC  8A0A     BSF PFNf_firstEdge, 5, ACCESS
964:                       }
965:                       if(PresKeyEX(RdPrt(S_KDW_CO),&ky[SS_KDW_CO])>0)	//nacisnieto przycisk -?
25AE  D88D     RCALL PL560
25B0  EC02     CALL 0xBA04, 0
25B2  F05D     NOP
25B4  0E01     MOVLW 0x1
25B6  A0D8     BTFSS STATUS, 0, ACCESS
25B8  0E00     MOVLW 0x0
25BA  EC20     CALL 0x6C40, 0
25BC  F036     NOP
25BE  0900     IORLW 0x0
25C0  E004     BZ 0x25CA
25C2  D85D     RCALL PL336
966:                       {
967:                           ResBufKeyEx(&ky[SS_KDW_CO]);		//resetuj podtrzymanie
25C4  EC77     CALL 0xBAEE, 0
25C6  F05D     NOP
968:                           PFNf_fns_max=0;
25C8  9A0A     BCF PFNf_firstEdge, 5, ACCESS
969:                       }
970:                   }
971:           //--------------------------RESET------------------------------
972:                   //nacisnieto przycisk RESET
973:                   key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
25CA  ECF7     CALL 0x11EE, 0
25CC  F008     NOP
25CE  EC02     CALL 0xBA04, 0
25D0  F05D     NOP
25D2  0E01     MOVLW 0x1
25D4  A0D8     BTFSS STATUS, 0, ACCESS
25D6  0E00     MOVLW 0x0
25D8  EC20     CALL 0x6C40, 0
25DA  F036     NOP
25DC  6F84     MOVWF _PFNf_tdzCO, BANKED
974:                   if(key==_KDFST)
25DE  0E64     MOVLW 0x64
25E0  1984     XORWF _PFNf_tdzCO, W, BANKED
25E2  E133     BNZ 0x264A
975:                   {
976:                       if(PFNf_set_nco||PFNf_set_ncw||PFNf_set_eco||PFNf_str_nco||PFNf_str_ncw||PFNf_prn_res||PFNf_set_fnserw||PFNf_fnserw||PFNf_set_aleg||PFNf_aleg||PFNf_prODP)
25E4  A010     BTFSS PFNf_str_nco, 0, ACCESS
25E6  B210     BTFSC PFNf_str_nco, 1, ACCESS
25E8  D00E     BRA 0x2606
25EA  AC0F     BTFSS PFNf_set_fnserw, 6, ACCESS
25EC  B410     BTFSC PFNf_str_nco, 2, ACCESS
25EE  D00B     BRA 0x2606
25F0  A610     BTFSS PFNf_str_nco, 3, ACCESS
25F2  B20F     BTFSC PFNf_set_fnserw, 1, ACCESS
25F4  D008     BRA 0x2606
25F6  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
25F8  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
25FA  D005     BRA 0x2606
25FC  AA0F     BTFSS PFNf_set_fnserw, 5, ACCESS
25FE  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
2600  D002     BRA 0x2606
2602  A80E     BTFSS PFNf_popFN, 4, ACCESS
2604  D008     BRA 0x2616
977:                       {
978:                           WaitToLowEx(&ky[SS_OFF]);
2606  ECF2     CALL 0x11E4, 0
2608  F008     NOP
260A  EC65     CALL 0xBCCA, 0
260C  F05E     NOP
979:                           PFNf_set_nco=0;
260E  9010     BCF PFNf_str_nco, 0, ACCESS
980:                           PFNf_set_ncw=0;
2610  EC5A     CALL 0x44B4, 0
2612  F022     NOP
981:                           PFNf_str_nco=0;
982:                           PFNf_str_ncw=0;
983:                           PFNf_mod_ncw=0;
984:                           PFNf_set_eco=0;
985:                           PFNf_mod_eco=0;
2614  D019     BRA 0x2648
986:                           PFNf_prn_res=0;
987:                           PFNf_set_fnserw=0;
988:                           PFNf_fnserw=0;
989:                           PFNf_set_aleg=0;
990:                           PFNf_aleg=0;
991:                       }
992:                       else
993:                       if(!PFNf_off&&!PFNf_ferr&&!PFNf_fmsg&&!PFNf_prODP)
2616  AA0C     BTFSS PFNf_off, 5, ACCESS
2618  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
261A  D017     BRA 0x264A
261C  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
261E  B80E     BTFSC PFNf_popFN, 4, ACCESS
2620  D014     BRA 0x264A
2622  ECF2     CALL 0x11E4, 0
2624  F008     NOP
994:                       {
995:                           WaitToLowEx(&ky[SS_OFF]);
2626  EC65     CALL 0xBCCA, 0
2628  F05E     NOP
996:                           if(!PFNf_errCS||(PFNf_fnoCS&&!PFNf_errIN))
262A  AA09     BTFSS PFNf_b_str_nco, 5, ACCESS
262C  D003     BRA 0x2634
262E  B80A     BTFSC PFNf_firstEdge, 4, ACCESS
2630  BE09     BTFSC PFNf_b_str_nco, 7, ACCESS
2632  D001     BRA 0x2636
997:                           {
998:                               PFNf_prn_res=1;
2634  820F     BSF PFNf_set_fnserw, 1, ACCESS
999:                           }
1000:                          StartRTdS(_RTPCS);
2636  0E03     MOVLW 0x3
2638  EC55     CALL 0xBCAA, 0
263A  F05E     NOP
263C  D006     BRA 0x264A
1001:                      }
1002:                  }
1003:          	}
1004:          	else
1005:          	{
1006:          		PFNf_set_nco=0;
263E  9010     BCF PFNf_str_nco, 0, ACCESS
1007:          		PFNf_set_ncw=0;
2640  9210     BCF PFNf_str_nco, 1, ACCESS
1008:          		PFNf_str_nco=0;
2642  9410     BCF PFNf_str_nco, 2, ACCESS
1009:          		PFNf_str_ncw=0;
2644  9610     BCF PFNf_str_nco, 3, ACCESS
1010:          		PFNf_set_eco=0;
2646  9C0F     BCF PFNf_set_fnserw, 6, ACCESS
2648  D84A     RCALL PL578
1011:          		PFNf_prn_res=0;
1012:          		PFNf_set_fnserw=0;
1013:          		PFNf_fnserw=0;
1014:          		PFNf_set_aleg=0;
1015:          		PFNf_aleg=0;
1016:          	}
1017:              
1018:              if(!PFNf_opgres) PFNf_LINres=0;
264A  A80D     BTFSS PFNf_plmCO, 4, ACCESS
264C  9607     BCF PFNf_OTTimeout, 3, ACCESS
1019:              if(!PFNf_fsetLaddr) //nieaktywny tryb przypisania adresu LIN?
264E  B00B     BTFSC PFNf_lato, 0, ACCESS
2650  0012     RETURN 0
1020:              {
1021:                  //stan przycisku RESET
1022:                  if(RdPrt(S_OFF)||PFNf_LINres)
2652  0E00     MOVLW 0x0
2654  EC02     CALL 0xBA04, 0
2656  F05D     NOP
2658  E202     BC 0x265E
265A  A607     BTFSS PFNf_OTTimeout, 3, ACCESS
265C  D002     BRA 0x2662
1023:                  {
1024:                          PFNf_res=1;
265E  840F     BSF PFNf_set_fnserw, 2, ACCESS
1025:                  }
2660  0012     RETURN 0
1026:                  else PFNf_res=0;
2662  940F     BCF PFNf_set_fnserw, 2, ACCESS
1027:              }
1028:          }
2664  0012     RETURN 0
1029:          #endif
1030:          
1031:          
1032:          
1033:          
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/konfig3.c  ------------------
1:             /*konfig3.c*/
2:             //Procedury zwiazane z wyborem typu gazu i poziomow
3:             //mocy startowej oraz majksymalnej dla CO i CW
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             //#include <htc.h>
7:             #include <xc.h>
8:             #include "global.h"					//parametry globalne
9:             #include "konfig3.h"					//parametry lokalne
10:            #include "eeprom.h"
11:            #include "pomiar.h"
12:            #include "wsw.h"
13:            #include "main.tp.h"
14:            #include "keypad.tp.h"
15:            #include "print.h"
16:            
17:            #if (_EXT_BOARD>=2)
18:                #include "amgs_rs9b.tp.h"
19:            #else
20:                #include "mgs_rs9b.tp.h"
21:            #endif
22:            
23:            volatile DtKONF DtKNF;
24:            volatile unsigned int nrp=0;
25:            unsigned char zm,zp;
26:            
27:            
28:            extern volatile unsigned char x,y;
29:            
30:            extern volatile MGSRSData MGSD;
31:            extern tpMAIN M;
32:            extern volatile DataPFN PFN;
33:            extern volatile tpRSDTA1 RSDT1;
34:            extern volatile StPin ky[];
35:            extern volatile StPin xxky[];
36:            /*---------------------------------------------------------------------------------*/
37:            //Podstawowe cechy kolejnych parametrow
38:            //MIN,MAX,(RLD,NO_MSG,HIGH,T,B,SHW,x,x)
39:            const CDtPZK CPZK[_KNPAR]=
40:            {
41:            	0 ,99,0b00001100,			//0 moc startowa
42:            	0 ,99,0b00001100,           //1 moc maksymalna CW
43:            	0 ,99,0b00001100,           //2 moc maksymalna CO
44:            	12,20,0b01100100,			//3 dolna granica predkosci obrotowej wentylatora
45:            	25,95,0b01100100,			//4 gorna granica predkosci obrotowej wentylatora
46:            
47:            	1 , 2,0b01000000,			//5 kod kotla
48:            
49:            	0 , 1,0b01000100,			//6 rodzaj obiegu
50:            	0 , 1,0b01000100,			//7 ogrzewanie podlogowe
51:            	0 , 1,0b01000100,			//8 wybor rodzaju czujnika cisnienia
52:            	0 , 1,0b01000100,			//9 aktywacja zegara antylegionella
53:            
54:            	1 , 4,0b01000100,			//10 tachometr - liczba okresow na sek.
55:            	0 , 1,0b01000100,			//11 rodzaj pompy
56:            	5 ,25,0b01010100,			//12 delta T dla pompy
57:            	15,99,0b01001100,           //13 minimalny wydatek pompy
58:            	0 , 1,0b01000100,			//14 aktywacja/deaktywacja trybu pracy ECO
59:            
60:            	0 , 5,0b01000100,			//15 czas pracy przy obnizonej mocy w trybie CO/deaktywacja dla wartosci 0
61:            	0 ,25,0b01001100,			//16 wartosc obnizonej mocy w trybie CO
62:            	25,99,0b01001100,			//17 maksymalny wydatek pompy
63:            	25,99,0b01001100,			//18 maksymalny wydatek pompy dla obiegu CW     
64:            
65:            	0 ,10,0b01010100,			//19 histereza wylaczenia grzania CO (ponad nastawe)
66:            	70,89,0b01010100,			//20 temp CO przy grzaniu CW zasobnika
67:            	0 ,20,0b01010100,			//21 poprawka dla regulagtora pogodowego  
68:                0 , 1,0b01000100,			//22 wybor rodzaju wentylatora
69:                2 ,30,0b01000100,			//23 czas wybiegu na mocy startowej dla obiegu CO   
70:                1 ,60,0b01000100,			//24 czas blokady L3 dla obiegu CO     
71:                
72:                0 , 2,0b01000100,			//25 rodzaj regulatora pogodowego
73:                10,21,0b01010100,			//26 wartosc graniczna pobudzenia od regulatora pogodowego
74:                0 ,20,0b01010100,			//27 obnizenie nocne dla regulatora pogodowego  
75:                _MIN_PDCO ,_MAX_PCO,0b01010100,	//28 maksymalna wartosc graniczna CO dla regulatora pogodowego    
76:            };
77:            /*---------------------------------------------------------------------------------*/
78:            //Podstawowe cechy kolejnych parametrow
79:            //MIN,MAX,DTA,DYN_DTA,(RLD,NO_MSG,HIGH,T,B,SHW)
80:            volatile static DtPZK PZK[_KNPAR];
81:            /*---------------------------------------------------------------------------------*/
82:            //Inicjalizacja danych zwiazanych z kolejnymi parametrami konfiguracyjnymi
83:            void InitPZK(void)
84:            {
85:                volatile unsigned char i;
86:                for(i=0;i<_KNPAR;i++)
9BA0  0100     MOVLB 0x0
9BA2  6B74     CLRF _PFNf_prODP, BANKED
9BA4  0E1C     MOVLW 0x1C
9BA6  6574     CPFSGT _PFNf_prODP, BANKED
9BA8  D001     BRA 0x9BAC
9BAA  0C1C     RETLW 0x1C
9BF6  2B74     INCF _PFNf_prODP, F, BANKED
87:                {
88:                    PZK[i].dta=0;
9BAC  5174     MOVF _PFNf_prODP, W, BANKED
9BAE  ECD6     CALL 0x11AC, 0
9BB0  F008     NOP
9BB2  6ADE     CLRF POSTINC2, ACCESS
9BB4  6ADD     CLRF POSTDEC2, ACCESS
89:                    PZK[i].bfdta=0;        
9BB6  5174     MOVF _PFNf_prODP, W, BANKED
9BB8  ECBE     CALL 0x117C, 0
9BBA  F008     NOP
9BBC  6ADE     CLRF POSTINC2, ACCESS
9BBE  6ADD     CLRF POSTDEC2, ACCESS
90:                    PZK[i].min=CPZK[i].min;
9BC0  5174     MOVF _PFNf_prODP, W, BANKED
9BC2  0D05     MULLW 0x5
9BC4  ECE5     CALL 0x31CA, 0
9BC6  F018     NOP
9BC8  5174     MOVF _PFNf_prODP, W, BANKED
9BCA  ECDE     CALL 0x11BC, 0
9BCC  F008     NOP
9BCE  D815     RCALL PL140
91:                    PZK[i].max=CPZK[i].max;    
9BD0  5174     MOVF _PFNf_prODP, W, BANKED
9BD2  0D05     MULLW 0x5
9BD4  ECD0     CALL 0x31A0, 0
9BD6  F018     NOP
9BD8  5174     MOVF _PFNf_prODP, W, BANKED
9BDA  ECCE     CALL 0x119C, 0
9BDC  F008     NOP
9BDE  D816     RCALL PL210
92:                    PZK[i].fl.war=CPZK[i].flwar;        
9BE0  5174     MOVF _PFNf_prODP, W, BANKED
9BE2  0D05     MULLW 0x5
9BE4  0E04     MOVLW 0x4
9BE6  ECDB     CALL 0x31B6, 0
9BE8  F018     NOP
9BEA  5174     MOVF _PFNf_prODP, W, BANKED
9BEC  ECC6     CALL 0x118C, 0
9BEE  F008     NOP
9BF0  0008     TBLRD*
9BF2  CFF5     MOVFF TABLAT, INDF2
9BF4  FFDF     NOP
9BF6  2B74     INCF _PFNf_prODP, F, BANKED
9BF8  D7D5     BRA 0x9BA4
93:                }
94:            }
95:            /*---------------------------------------------------------------------------------*/
96:            //Odblokowanie procedury wejsciowej konfiguracji
97:            //po uruchomieniu sterownika na pozycji OFF
98:            //UEAGA: umiescic przed petla glowna
99:            void InitKonf(void)
100:           {
101:           		DtKNF.KRK=0;
C20E  6BD4     CLRF 0xD4, BANKED
102:           		DtKNF.PRM=0;
C210  6BD3     CLRF 0xD3, BANKED
103:                   InitPZK();                                                          //Inicjalizacja danych charakterystycznych kolejnych parametrow
C212  EFD0     GOTO 0x9BA0
C214  F04D     NOP
104:           }
105:           /*---------------------------------------------------------------------------------*/
106:           //wyjscie z procedury konfiguracji po modyfikacji parametrow
107:           void ExitKonf(void)
108:           {
109:           	PFNf_aktywne_KNF=0;
BBA0  9008     BCF PFNf_b_set_nco, 0, ACCESS
110:           	EndPR();								//wygas wskaz parametru
BBA2  ECE1     CALL 0xBBC2, 0
BBA4  F05D     NOP
111:           	ClrAllMarks();							//wygas znaki konfiguracji
BBA6  ECC5     CALL 0xB78A, 0
BBA8  F05B     NOP
112:           	DtKNF.PRM=0;
BBAA  6BD3     CLRF 0xD3, BANKED
113:           	DtKNF.KRK=0;
BBAC  6BD4     CLRF 0xD4, BANKED
BBAE  ECF2     CALL 0x11E4, 0
BBB0  F008     NOP
114:           #if _KEY_BBOARD==0    
115:           	WaitToLowEx(&ky[SS_OFF]);
116:           	WaitToLowEx(&ky[SS_SET]);
117:           #endif
118:           #if _KEY_BBOARD==1    
119:           	WaitToLowEx(&ky[SS_OFF]);
BBB2  EC65     CALL 0xBCCA, 0
BBB4  F05E     NOP
120:           	WaitToLowEx(&ky[SS_KOM]);
BBB6  EC06     CALL 0x120C, 0
BBB8  F009     NOP
BBBA  EC65     CALL 0xBCCA, 0
BBBC  F05E     NOP
121:           #endif    
122:           	PFNf_KnfDisErr=0;
BBBE  9E05     BCF PFNf_KnfDisErr, 7, ACCESS
123:           }
BBC0  0012     RETURN 0
124:           /*---------------------------------------------------------------------------------*/
125:           //Aktualizacja wartosci parametru (po akceptacji zmiany)
126:           void UpdateKnfPar(unsigned char par)
696A  6F76     MOVWF _PFNf_prn_in, BANKED
127:           {
128:               if(par<_KNPAR)
696C  0E1D     MOVLW 0x1D
696E  0100     MOVLB 0x0
6970  6176     CPFSLT _PFNf_prn_in, BANKED
6972  0C1D     RETLW 0x1D
6974  D075     BRA 0x6A60
129:               {
130:                   switch(par)
6A60  5176     MOVF _PFNf_prn_in, W, BANKED
6A62  E089     BZ 0x6976
6A64  0A01     XORLW 0x1
6A66  E08A     BZ 0x697C
6A68  0A03     XORLW 0x3
6A6A  E08B     BZ 0x6982
6A6C  0A01     XORLW 0x1
6A6E  E08C     BZ 0x6988
6A70  0A07     XORLW 0x7
6A72  E08D     BZ 0x698E
6A74  0A01     XORLW 0x1
6A76  E08E     BZ 0x6994
6A78  0A03     XORLW 0x3
6A7A  E08F     BZ 0x699A
6A7C  0A01     XORLW 0x1
6A7E  E090     BZ 0x69A0
6A80  0A0F     XORLW 0xF
6A82  E091     BZ 0x69A6
6A84  0A01     XORLW 0x1
6A86  E092     BZ 0x69AC
6A88  0A03     XORLW 0x3
6A8A  E093     BZ 0x69B2
6A8C  0A01     XORLW 0x1
6A8E  E094     BZ 0x69B8
6A90  0A07     XORLW 0x7
6A92  E095     BZ 0x69BE
6A94  0A01     XORLW 0x1
6A96  E096     BZ 0x69C4
6A98  0A03     XORLW 0x3
6A9A  E0A6     BZ 0x69E8
6A9C  0A01     XORLW 0x1
6A9E  E0A7     BZ 0x69EE
6AA0  0A1F     XORLW 0x1F
6AA2  E0A8     BZ 0x69F4
6AA4  0A01     XORLW 0x1
6AA6  E0A9     BZ 0x69FA
6AA8  0A03     XORLW 0x3
6AAA  E0B9     BZ 0x6A1E
6AAC  0A01     XORLW 0x1
6AAE  E0BA     BZ 0x6A24
6AB0  0A07     XORLW 0x7
6AB2  E0BB     BZ 0x6A2A
6AB4  0A01     XORLW 0x1
6AB6  E0BC     BZ 0x6A30
6AB8  0A03     XORLW 0x3
6ABA  E0BD     BZ 0x6A36
6ABC  0A01     XORLW 0x1
6ABE  E0BE     BZ 0x6A3C
6AC0  0A0F     XORLW 0xF
6AC2  E0BF     BZ 0x6A42
6AC4  0A01     XORLW 0x1
6AC6  E0C0     BZ 0x6A48
6AC8  0A03     XORLW 0x3
6ACA  E0C1     BZ 0x6A4E
6ACC  0A01     XORLW 0x1
6ACE  E0C2     BZ 0x6A54
6AD0  0A07     XORLW 0x7
6AD2  E0C3     BZ 0x6A5A
131:                   {
132:                       case 0:
133:                           RSDT1.inMSTR=PZK[0].dta;		//0 moc startowa
6976  C68B     MOVFF 0x68B, 0x283
6978  F283     NOP
134:                       break;
697A  0012     RETURN 0
135:                       case 1:
136:                           RSDT1.inMMAXU=PZK[1].dta;		//1 moc maksymalna CW
697C  C694     MOVFF 0x694, 0x284
697E  F284     NOP
137:                       break;
6980  0012     RETURN 0
138:                       case 2:
139:                           RSDT1.inMMAXG=PZK[2].dta;		//2 moc maksymalna CO
6982  C69D     MOVFF 0x69D, 0x285
6984  F285     NOP
140:                       break;
6986  0012     RETURN 0
141:                       case 3:
142:                           RSDT1.inMMIN=PZK[3].dta;		//3 dolna granica predkosci obrotowej wentylatora
6988  C6A6     MOVFF 0x6A6, 0x28C
698A  F28C     NOP
143:                       break;
698C  0012     RETURN 0
144:                       case 4:
145:                           RSDT1.inMMAX=PZK[4].dta;		//4 gorna granica predkosci obrotowej wentylatora
698E  C6AF     MOVFF 0x6AF, 0x28D
6990  F28D     NOP
146:                       break;
6992  0012     RETURN 0
147:                       case 5:
148:                           RSDT1.inKODKT=PZK[5].dta;		//5 kod kotla
6994  C6B8     MOVFF 0x6B8, 0x287
6996  F287     NOP
149:                       break;
6998  0012     RETURN 0
150:                       case 6:
151:                           RSDT1.inWOBG=PZK[6].dta;		//6 rodzaj obiegu
699A  C6C1     MOVFF 0x6C1, 0x288
699C  F288     NOP
152:                       break;
699E  0012     RETURN 0
153:                       case 7:
154:                           RSDT1.inOPDG=PZK[7].dta;		//7 ogrzewanie podlogowe
69A0  C6CA     MOVFF 0x6CA, 0x28A
69A2  F28A     NOP
155:                       break;
69A4  0012     RETURN 0
156:                       case 8:
157:                           RSDT1.inTPCS=PZK[8].dta;		//8 wybor rodzaju czujnika cisnienia
69A6  C6D3     MOVFF 0x6D3, 0x28B
69A8  F28B     NOP
158:                       break;
69AA  0012     RETURN 0
159:                       case 9:
160:                           RSDT1.inWANL=PZK[9].dta;		//9 aktywacja zegara antylegionella		
69AC  C6DC     MOVFF 0x6DC, 0x286
69AE  F286     NOP
161:                       break;
69B0  0012     RETURN 0
162:                       case 10:
163:                           RSDT1.inNOKR=PZK[10].dta;		//10 tachometr - liczba okresow na sek.
69B2  C6E5     MOVFF 0x6E5, 0x289
69B4  F289     NOP
164:                       break;
69B6  0012     RETURN 0
165:                       case 11:
166:                           RSDT1.inRDPM=PZK[11].dta;		//11 rodzaj pompy
69B8  C6EE     MOVFF 0x6EE, 0x28E
69BA  F28E     NOP
167:                       break;
69BC  0012     RETURN 0
168:                       case 12:
169:                           RSDT1.inDTPM=PZK[12].dta;		//12 delta T dla pompy
69BE  C6F7     MOVFF 0x6F7, 0x28F
69C0  F28F     NOP
170:                       break;
69C2  0012     RETURN 0
171:                       case 13:
172:                                       RSDT1.inMDPM=PZK[13].dta;                   //13 minimalny wydatek pompy
69C4  C700     MOVFF 0x700, 0x290
69C6  F290     NOP
173:                                       if(RSDT1.inMDPM>RSDT1.inMGPM)
69C8  0102     MOVLB 0x2
69CA  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
69CC  5D94     SUBWF _RSDT1f_RRD_KNF, W, BANKED
69CE  B0D8     BTFSC STATUS, 0, ACCESS
69D0  0012     RETURN 0
174:                                       {
175:                                           PZK[17].dta=RSDT1.inMDPM;
69D2  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
69D4  0100     MOVLB 0x0
69D6  6F74     MOVWF _PFNf_prODP, BANKED
69D8  6B75     CLRF _PFNf_prn_cs, BANKED
69DA  C074     MOVFF _PFNf_prODP, 0x724
69DC  F724     NOP
69DE  C075     MOVFF _PFNf_prn_cs, 0x725
69E0  F725     NOP
176:                                           RSDT1.inMGPM=PZK[17].dta;
69E2  C724     MOVFF 0x724, 0x294
69E4  F294     NOP
69E6  0012     RETURN 0
177:                                       }
178:                       break;
179:                       case 14:
180:                           RSDT1.inTECO=PZK[14].dta;		//14 aktywacja/deaktywacja trybu pracy ECO
69E8  C709     MOVFF 0x709, 0x291
69EA  F291     NOP
181:                       break;
69EC  0012     RETURN 0
182:                       case 15:
183:                           RSDT1.inTMMAXG2=PZK[15].dta;            //15 czas pracy przy obnizonej mocy w trybie CO/deaktywacja dla wartosci 0
69EE  C712     MOVFF 0x712, 0x292
69F0  F292     NOP
184:                       break;
69F2  0012     RETURN 0
185:                       case 16:
186:                           RSDT1.inMMAXG2=PZK[16].dta;		//16 wartosc obnizonej mocy w trybie CO
69F4  C71B     MOVFF 0x71B, 0x293
69F6  F293     NOP
187:                       break;
69F8  0012     RETURN 0
188:                       case 17:
189:                                       RSDT1.inMGPM=PZK[17].dta;		//17 maksymalny wydatek pompy
69FA  C724     MOVFF 0x724, 0x294
69FC  F294     NOP
190:                                       if(RSDT1.inMGPM<RSDT1.inMDPM)
69FE  0102     MOVLB 0x2
6A00  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
6A02  5D94     SUBWF _RSDT1f_RRD_KNF, W, BANKED
6A04  B0D8     BTFSC STATUS, 0, ACCESS
6A06  0012     RETURN 0
191:                                       {
192:                                           PZK[13].dta=RSDT1.inMGPM;
6A08  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
6A0A  0100     MOVLB 0x0
6A0C  6F74     MOVWF _PFNf_prODP, BANKED
6A0E  6B75     CLRF _PFNf_prn_cs, BANKED
6A10  C074     MOVFF _PFNf_prODP, 0x700
6A12  F700     NOP
6A14  C075     MOVFF _PFNf_prn_cs, 0x701
6A16  F701     NOP
193:                                           RSDT1.inMDPM=PZK[13].dta;
6A18  C700     MOVFF 0x700, 0x290
6A1A  F290     NOP
6A1C  0012     RETURN 0
194:                                       }
195:                       break;
196:                       case 18:
197:                           RSDT1.inMGPM2=PZK[18].dta;		//18 maksymalny wydatek pompy dla obiegu CW
6A1E  C72D     MOVFF 0x72D, 0x295
6A20  F295     NOP
198:                       break;
6A22  0012     RETURN 0
199:                       case 19:
200:                           RSDT1.inHSCO=PZK[19].dta;		//19 histereza wylaczenia grzania CO (ponad nastawe)  
6A24  C736     MOVFF 0x736, 0x296
6A26  F296     NOP
201:                       break;
6A28  0012     RETURN 0
202:                       case 20:
203:                           RSDT1.inCONW=PZK[20].dta;		//20 temp CO przy grzaniu CW zasobnika
6A2A  C73F     MOVFF 0x73F, 0x297
6A2C  F297     NOP
204:                       break;
6A2E  0012     RETURN 0
205:                       case 21:
206:                           RSDT1.inPROP=PZK[21].dta;		//21 poprawka dla regulagtora pogodowego   
6A30  C748     MOVFF 0x748, 0x298
6A32  F298     NOP
207:                       break;
6A34  0012     RETURN 0
208:                       case 22:
209:                           RSDT1.inRFAN=PZK[22].dta;		//22 wybor rodzaju wentylatora   
6A36  C751     MOVFF 0x751, 0x299
6A38  F299     NOP
210:                       break; 
6A3A  0012     RETURN 0
211:                       case 23:
212:                           RSDT1.inTSTR=PZK[23].dta;		//23 czas wybiegu na mocy startowej dla obiegu CO   
6A3C  C75A     MOVFF 0x75A, 0x29A
6A3E  F29A     NOP
213:                       break;
6A40  0012     RETURN 0
214:                       case 24:
215:                           RSDT1.inTL3=PZK[24].dta;		//24 czas blokady L3 dla obiegu CO   
6A42  C763     MOVFF 0x763, 0x29B
6A44  F29B     NOP
216:                       break;           
6A46  0012     RETURN 0
217:                       case 25:
218:                           RSDT1.inPGDR=PZK[25].dta;		//25 rodzaj regulatora pogodowego   
6A48  C76C     MOVFF 0x76C, 0x29C
6A4A  F29C     NOP
219:                       break; 
6A4C  0012     RETURN 0
220:                       case 26:
221:                           RSDT1.inPGDG=PZK[26].dta;		//26 wartosc graniczna pobudzenia od regulatora pogodowego   
6A4E  C775     MOVFF 0x775, 0x29D
6A50  F29D     NOP
222:                       break;
6A52  0012     RETURN 0
223:                       case 27:
224:                           RSDT1.inPGDO=PZK[27].dta;		//27 obnizenie nocne dla regulatora pogodowego   
6A54  C77E     MOVFF 0x77E, 0x29E
6A56  F29E     NOP
225:                       break; 
6A58  0012     RETURN 0
226:                       case 28:
227:                           RSDT1.inPGMX=PZK[28].dta;		//28 maksymalna wartosc graniczna CO dla regulatora pogodowego   
6A5A  C787     MOVFF 0x787, 0x29F
6A5C  F29F     NOP
228:                       break;        
6A5E  0012     RETURN 0
229:                   }
230:               }
231:           }
6AD4  0012     RETURN 0
232:           /*---------------------------------------------------------------------------------*/
233:           //Aktualizuj wartosci graniczne wskazanego parametru
234:           void UpdateMinMax(const unsigned char par)
7FBA  6F78     MOVWF _PFNf_prn_pp, BANKED
235:           {
236:               if(par<_KNPAR)
7FBC  0E1D     MOVLW 0x1D
7FBE  0100     MOVLB 0x0
7FC0  6178     CPFSLT _PFNf_prn_pp, BANKED
7FC2  0C1D     RETLW 0x1D
7FC4  D04D     BRA 0x8060
237:               {
238:                   //wartosci graniczne
239:                   switch(par)
8060  5178     MOVF _PFNf_prn_pp, W, BANKED
240:                   {
241:                       case 28:        //granica (min,max) dla maksymalnej wartosci granicznej CO regulatora pogodowego
242:                       {
243:                           if((RSDT1.vKNF>=8)&&PZK[28].fl.shw) //wersja paczki konfiguracyjnej>=8 i parametr widoczny?
7FC6  0E07     MOVLW 0x7
7FC8  0102     MOVLB 0x2
7FCA  6550     CPFSGT 0x50, BANKED
7FCC  0C07     RETLW 0x7
7FCE  EE27     LFSR 2, 0x78B
7FD0  F08B     NOP
7FD2  A4DF     BTFSS INDF2, 2, ACCESS
7FD4  0C07     RETLW 0x7
244:                           {
245:                               if(RSDT1.inOPDG)    //ogrzewanie podlogowe?
7FD6  518A     MOVF _PFNf_vnt, W, BANKED
7FD8  E004     BZ 0x7FE2
246:                               {
247:                                   PZK[28].min=_MIN_PDCO;
7FDA  0E19     MOVLW 0x19
7FDC  D84A     RCALL PL594
248:                                   PZK[28].max=_MAX_PDCO;
7FDE  0E37     MOVLW 0x37
7FE0  D003     BRA 0x7FE8
249:                               }
250:                               else                //ogrzewanie tradycyjne
251:                               {
252:                                   PZK[28].min=_MIN_PCO;
7FE2  0E28     MOVLW 0x28
7FE4  D846     RCALL PL594
253:                                   PZK[28].max=_MAX_PCO;
7FE6  0E50     MOVLW 0x50
7FE8  CFE8     MOVFF WREG, 0x785
7FEA  F785     NOP
7FEC  0E00     MOVLW 0x0
7FEE  CFE8     MOVFF WREG, 0x786
7FF0  F786     NOP
254:                               }            
255:                               if(PZK[28].bfdta<PZK[28].min) PZK[28].bfdta=PZK[28].min;
7FF2  EE27     LFSR 2, 0x783
7FF4  F083     NOP
7FF6  EE17     LFSR 1, 0x789
7FF8  F089     NOP
7FFA  D836     RCALL PL284
7FFC  E203     BC 0x8004
7FFE  EE27     LFSR 2, 0x783
8000  F083     NOP
8002  D83D     RCALL PL660
256:                               if(PZK[28].bfdta>PZK[28].max) PZK[28].bfdta=PZK[28].max; 
8004  EE27     LFSR 2, 0x789
8006  F089     NOP
8008  EE17     LFSR 1, 0x785
800A  F085     NOP
800C  D82D     RCALL PL284
800E  E203     BC 0x8016
8010  EE27     LFSR 2, 0x785
8012  F085     NOP
8014  D834     RCALL PL660
257:                               if(PZK[28].dta<PZK[28].min) PZK[28].dta=PZK[28].min;
8016  EE27     LFSR 2, 0x783
8018  F083     NOP
801A  EE17     LFSR 1, 0x787
801C  F087     NOP
801E  D824     RCALL PL284
8020  E203     BC 0x8028
8022  EE27     LFSR 2, 0x783
8024  F083     NOP
8026  D830     RCALL PL678
258:                               if(PZK[28].dta>PZK[28].max) PZK[28].dta=PZK[28].max;    
8028  EE27     LFSR 2, 0x787
802A  F087     NOP
802C  EE17     LFSR 1, 0x785
802E  F085     NOP
8030  D81B     RCALL PL284
8032  B0D8     BTFSC STATUS, 0, ACCESS
8034  0012     RETURN 0
8036  EE27     LFSR 2, 0x785
8038  F085     NOP
803A  D026     BRA PL678
259:                           }        
260:                           break;
261:                       }
262:                       default:      //pozostale parametry
263:                       {
264:                           PZK[par].min=CPZK[par].min;
803C  5178     MOVF _PFNf_prn_pp, W, BANKED
803E  0D05     MULLW 0x5
8040  ECE5     CALL 0x31CA, 0
8042  F018     NOP
8044  5178     MOVF _PFNf_prn_pp, W, BANKED
8046  ECDE     CALL 0x11BC, 0
8048  F008     NOP
804A  ECFD     CALL 0x9BFA, 0
804C  F04D     NOP
265:                           PZK[par].max=CPZK[par].max;            
804E  5178     MOVF _PFNf_prn_pp, W, BANKED
8050  0D05     MULLW 0x5
8052  ECD0     CALL 0x31A0, 0
8054  F018     NOP
8056  5178     MOVF _PFNf_prn_pp, W, BANKED
8058  ECCE     CALL 0x119C, 0
805A  F008     NOP
805C  EF06     GOTO 0x9C0C
805E  F04E     NOP
8060  5178     MOVF _PFNf_prn_pp, W, BANKED
8062  0A1C     XORLW 0x1C
8064  E0B0     BZ 0x7FC6
8066  D7EA     BRA 0x803C
266:                       }
267:                   }
268:               } 
269:           }
270:           //------------------------------------------------------------------------------------
271:           //Decyzja o ukryciu wybranych parametrow
272:           void DecShowHide(void)
273:           {
274:               volatile unsigned char i;
275:               //-----------------------------------------------
276:               //Zaladuj znaczniki domyslne wszystkim parametrom
277:               for(i=0;i<_KNPAR;i++)
7054  0100     MOVLB 0x0
7056  6B78     CLRF _PFNf_prn_pp, BANKED
7058  0E1C     MOVLW 0x1C
705A  6578     CPFSGT _PFNf_prn_pp, BANKED
705C  D001     BRA 0x7060
705E  D00D     BRA 0x707A
7076  2B78     INCF _PFNf_prn_pp, F, BANKED
7078  D7EF     BRA 0x7058
278:               {   
279:                   PZK[i].fl.war=CPZK[i].flwar;        
7060  5178     MOVF _PFNf_prn_pp, W, BANKED
7062  0D05     MULLW 0x5
7064  0E04     MOVLW 0x4
7066  ECDB     CALL 0x31B6, 0
7068  F018     NOP
706A  5178     MOVF _PFNf_prn_pp, W, BANKED
706C  ECC6     CALL 0x118C, 0
706E  F008     NOP
7070  0008     TBLRD*
7072  CFF5     MOVFF TABLAT, INDF2
7074  FFDF     NOP
280:               }
281:               //-----------------------------------------------
282:               //Zaktualizuj znaczniki zwiazane z ukrywaniem parametrow
283:               
284:           	//3 dolna granica predkosci obrotowej wentylatora
285:           	//4 gorna granica predkosci obrotowej wentylatora
286:               PZK[3].fl.shw=1;				//RSDT1.inMMIN
707A  EE26     LFSR 2, 0x6AA
707C  F0AA     NOP
707E  84DF     BSF INDF2, 2, ACCESS
287:           	PZK[4].fl.shw=1;				//RSDT1.inMMAX
7080  EE26     LFSR 2, 0x6B3
7082  F0B3     NOP
7084  84DF     BSF INDF2, 2, ACCESS
288:           
289:           	//5 kod kotla
290:           	PZK[5].fl.shw=GetBit2(RSDT1.outKSTAT0,_ZCFM);//pokaz/ukryj parametry powiazane
7086  6B74     CLRF _PFNf_prODP, BANKED
7088  0102     MOVLB 0x2
708A  5151     MOVF 0x51, W, BANKED
708C  ECC6     CALL 0xB98C, 0
708E  F05C     NOP
7090  EE26     LFSR 2, 0x6BC
7092  F0BC     NOP
7094  B0D8     BTFSC STATUS, 0, ACCESS
7096  D002     BRA 0x709C
7098  94DF     BCF INDF2, 2, ACCESS
709A  D001     BRA 0x709E
709C  84DF     BSF INDF2, 2, ACCESS
291:           
292:           	//9 aktywacja zegara antylegionella
293:           	PZK[9].fl.shw=GetBit2(RSDT1.outKSTAT0,_KC1F);//pokaz/ukryj parametry powiazane
709E  ECF5     CALL 0x1FEA, 0
70A0  F00F     NOP
70A2  5151     MOVF 0x51, W, BANKED
70A4  ECC6     CALL 0xB98C, 0
70A6  F05C     NOP
70A8  EE26     LFSR 2, 0x6E0
70AA  F0E0     NOP
70AC  B0D8     BTFSC STATUS, 0, ACCESS
70AE  D002     BRA 0x70B4
70B0  94DF     BCF INDF2, 2, ACCESS
70B2  D001     BRA 0x70B6
70B4  84DF     BSF INDF2, 2, ACCESS
294:           
295:           	//12 delta T dla pompy
296:           	//13 minimalny wydatek pompy
297:           	//14 aktywacja/deaktywacja trybu pracy ECO
298:               //17 maksymalny wydatek pompy dla CO
299:               //18 maksymalny wydatek pompy dla CW
300:           	if(RSDT1.inRDPM==0)				//pokaz/ukryj parametry powiazane
70B6  0102     MOVLB 0x2
70B8  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
70BA  E105     BNZ 0x70C6
301:           	{
302:           		PZK[12].fl.shw=0;				//RSDT1.inDTPM
70BC  D861     RCALL PL312
303:           		PZK[13].fl.shw=0;				//RSDT1.inMDPM
304:           		PZK[14].fl.shw=0;				//RSDT1.inTECO
305:           		PZK[17].fl.shw=0;				//RSDT1.inMGPM
70BE  EE27     LFSR 2, 0x728
70C0  F028     NOP
70C2  94DF     BCF INDF2, 2, ACCESS
70C4  D01A     BRA 0x70FA
306:           		PZK[18].fl.shw=0;				//RSDT1.inMGPM2        
307:           	}
308:           	else
309:           	{
310:                   if(RSDT1.inWOBG)            //obieg zamkniety?
70C6  5188     MOVF _PFNf_toInit, W, BANKED
70C8  E01C     BZ 0x7102
311:                   {
312:                       if(RSDT1.inTECO)        //tryb ECO?
70CA  5191     MOVF _RSDT1f_RD_KNF, W, BANKED
70CC  E004     BZ 0x70D6
313:                       {
314:                           PZK[12].fl.shw=0;				//RSDT1.inDTPM    
70CE  EE26     LFSR 2, 0x6FB
70D0  F0FB     NOP
70D2  94DF     BCF INDF2, 2, ACCESS
315:                       }
70D4  D003     BRA 0x70DC
316:                       else
317:                       {
318:                           PZK[12].fl.shw=1;				//RSDT1.inDTPM        
70D6  EE26     LFSR 2, 0x6FB
70D8  F0FB     NOP
70DA  84DF     BSF INDF2, 2, ACCESS
319:                       }
320:                       PZK[13].fl.shw=1;                  //RSDT1.inMDPM
70DC  EE27     LFSR 2, 0x704
70DE  F004     NOP
70E0  84DF     BSF INDF2, 2, ACCESS
321:                       PZK[14].fl.shw=1;                  //RSDT1.inTECO
70E2  EE27     LFSR 2, 0x70D
70E4  F00D     NOP
70E6  84DF     BSF INDF2, 2, ACCESS
322:                       PZK[17].fl.shw=1;                  //RSDT1.inMGPM
70E8  EE27     LFSR 2, 0x728
70EA  F028     NOP
70EC  84DF     BSF INDF2, 2, ACCESS
323:                       if(RSDT1.inKODKT==_KODKT_1F)    //jednofunkcyjny?
70EE  0587     DECF _PFNf_tmpZW, W, BANKED
70F0  E104     BNZ 0x70FA
324:                       {
325:                           PZK[18].fl.shw=1;				//RSDT1.inMGPM2
70F2  EE27     LFSR 2, 0x731
70F4  F031     NOP
70F6  84DF     BSF INDF2, 2, ACCESS
326:                       }
70F8  D006     BRA 0x7106
327:                       else
328:                       {
329:                           PZK[18].fl.shw=0;				//RSDT1.inMGPM2            
70FA  EE27     LFSR 2, 0x731
70FC  F031     NOP
70FE  94DF     BCF INDF2, 2, ACCESS
7100  D002     BRA 0x7106
330:                       }
331:                   }
332:                   else
333:                   {
334:                       PZK[12].fl.shw=0;				//RSDT1.inDTPM
7102  D83E     RCALL PL312
335:                       PZK[13].fl.shw=0;				//RSDT1.inMDPM
336:                       PZK[14].fl.shw=0;				//RSDT1.inTECO 
7104  D7F1     BRA 0x70E8
337:                       PZK[17].fl.shw=1;				//RSDT1.inMGPM
338:                       if(RSDT1.inKODKT==_KODKT_1F)    //jednofunkcyjny?
339:                       {
340:                           PZK[18].fl.shw=1;				//RSDT1.inMGPM2
341:                       }
342:                       else
343:                       {
344:                           PZK[18].fl.shw=0;				//RSDT1.inMGPM2            
345:                       }            
346:                   }
347:           	}
348:           
349:           	//16 wartosc obnizonej mocy w trybie CO
350:           	if(RSDT1.inTMMAXG2==0)				//pokaz/ukryj parametry powiazane
7106  5192     MOVF _RSDT1f_RD_LIN, W, BANKED
7108  E104     BNZ 0x7112
351:           	{
352:           		PZK[16].fl.shw=0;				//RSDT1.inMMAXG2
710A  EE27     LFSR 2, 0x71F
710C  F01F     NOP
710E  94DF     BCF INDF2, 2, ACCESS
353:           	}
7110  D003     BRA 0x7118
354:           	else
355:           	{
356:           		PZK[16].fl.shw=1;				//RSDT1.inMMAXG2
7112  EE27     LFSR 2, 0x71F
7114  F01F     NOP
7116  84DF     BSF INDF2, 2, ACCESS
357:           	}
358:               //20 temp CO przy grzaniu CW zasobnika
359:               if(RSDT1.inKODKT==_KODKT_1F)    //jednofunkcyjny?
7118  0587     DECF _PFNf_tmpZW, W, BANKED
711A  E104     BNZ 0x7124
360:               {
361:                   PZK[20].fl.shw=1;				//RSDT1.inCONW
711C  EE27     LFSR 2, 0x743
711E  F043     NOP
7120  84DF     BSF INDF2, 2, ACCESS
362:               }
7122  D003     BRA 0x712A
363:               else
364:               {
365:                   PZK[20].fl.shw=0;				//RSDT1.inCONW            
7124  EE27     LFSR 2, 0x743
7126  F043     NOP
7128  94DF     BCF INDF2, 2, ACCESS
366:               }
367:               //25 rodzaj regulatora pogodowego
368:               if(RSDT1.inPGDR)
712A  519C     MOVF _UAD1tf_TFEnd, W, BANKED
712C  E01D     BZ 0x7168
369:               {
370:                   if(RSDT1.vKNF>=7) PZK[21].fl.shw=1;                  //RSDT1.inPROP
712E  0E06     MOVLW 0x6
7130  6550     CPFSGT 0x50, BANKED
7132  D004     BRA 0x713C
7134  EE27     LFSR 2, 0x74C
7136  F04C     NOP
7138  84DF     BSF INDF2, 2, ACCESS
713A  D001     BRA 0x713E
371:                   else PZK[21].fl.shw=0;                  
713C  D832     RCALL PL802
372:                   if(RSDT1.vKNF>=8) PZK[28].fl.shw=1;                  //RSDT1.inPGMX 
713E  0E07     MOVLW 0x7
7140  6550     CPFSGT 0x50, BANKED
7142  D004     BRA 0x714C
7144  EE27     LFSR 2, 0x78B
7146  F08B     NOP
7148  84DF     BSF INDF2, 2, ACCESS
714A  D003     BRA 0x7152
373:                   else PZK[28].fl.shw=0;
714C  EE27     LFSR 2, 0x78B
714E  F08B     NOP
7150  94DF     BCF INDF2, 2, ACCESS
374:                   if(RSDT1.inPGDR==2)             //pobudzenie RT generowane przez regulator pogodowy?
7152  0E02     MOVLW 0x2
7154  199C     XORWF _UAD1tf_TFEnd, W, BANKED
7156  E11E     BNZ PL444
375:                   {
376:                       PZK[26].fl.shw=1;				//RSDT1.inPGDG
7158  EE27     LFSR 2, 0x779
715A  F079     NOP
715C  84DF     BSF INDF2, 2, ACCESS
377:                       PZK[27].fl.shw=1;				//RSDT1.inPGDO          
715E  EE27     LFSR 2, 0x782
7160  F082     NOP
7162  84DF     BSF INDF2, 2, ACCESS
378:                   }
7164  0012     RETURN 0
379:                   else
380:                   {
381:                       PZK[26].fl.shw=0;				//RSDT1.inPGDG 
7166  D016     BRA PL444
382:                       PZK[27].fl.shw=0;				//RSDT1.inPGDO        
383:                   } 
384:               }
385:               else
386:               {
387:                   if(RSDT1.vKNF>=7) PZK[21].fl.shw=0;              //RSDT1.inPROP
7168  0E06     MOVLW 0x6
716A  6550     CPFSGT 0x50, BANKED
716C  D001     BRA 0x7170
716E  D819     RCALL PL802
7170  D811     RCALL PL444
388:                   PZK[26].fl.shw=0;				//RSDT1.inPGDG 
389:                   PZK[27].fl.shw=0;				//RSDT1.inPGDO 
390:                   if(RSDT1.vKNF>=8) PZK[28].fl.shw=0;				//RSDT1.inPGMX        
7172  0E07     MOVLW 0x7
7174  6550     CPFSGT 0x50, BANKED
7176  0C07     RETLW 0x7
7178  EE27     LFSR 2, 0x78B
717A  F08B     NOP
717C  94DF     BCF INDF2, 2, ACCESS
391:               }
392:           }
717E  0C07     RETLW 0x7
393:           /*---------------------------------------------------------------------------------*/
394:           unsigned char SetKNPAR(void)
395:           {
396:               switch(RSDT1.vKNF)
ABA6  D012     BRA 0xABCC
ABCC  0102     MOVLB 0x2
ABCE  5150     MOVF 0x50, W, BANKED
ABD0  0A01     XORLW 0x1
ABD2  E0EA     BZ 0xABA8
ABD4  0A03     XORLW 0x3
ABD6  E0EA     BZ 0xABAC
ABD8  0A01     XORLW 0x1
ABDA  E0EA     BZ 0xABB0
ABDC  0A07     XORLW 0x7
ABDE  E0EA     BZ 0xABB4
ABE0  0A01     XORLW 0x1
ABE2  E0EA     BZ 0xABB8
ABE4  0A03     XORLW 0x3
ABE6  E0EA     BZ 0xABBC
ABE8  0A01     XORLW 0x1
ABEA  E0EA     BZ 0xABC0
ABEC  0A0F     XORLW 0xF
ABEE  D7EC     BRA 0xABC8
397:               {
398:                   case 1:												//pierwsza wersja paczki danych plyty UNI-02
399:                       DtKNF.KNPAR=_KNPAR1;
ABA8  0E0F     MOVLW 0xF
ABAA  D00B     BRA 0xABC2
400:                       break;						
401:                   case 2:												//druga wersja paczki danych plyty UNI-02
402:                       DtKNF.KNPAR=_KNPAR2;
ABAC  0E11     MOVLW 0x11
ABAE  D009     BRA 0xABC2
403:                       break;
404:                   case 3:
405:                       DtKNF.KNPAR=_KNPAR3;
ABB0  0E12     MOVLW 0x12
ABB2  D007     BRA 0xABC2
406:                       break;                        
407:                   case 4:
408:                       DtKNF.KNPAR=_KNPAR4;
ABB4  0E13     MOVLW 0x13
ABB6  D005     BRA 0xABC2
409:                       break;
410:                   case 5:
411:                       DtKNF.KNPAR=_KNPAR5;
ABB8  0E16     MOVLW 0x16
ABBA  D003     BRA 0xABC2
412:                       break;  
413:                   case 6:
414:                       DtKNF.KNPAR=_KNPAR6;
ABBC  0E17     MOVLW 0x17
ABBE  D001     BRA 0xABC2
415:                       break; 
416:                   case 7:
417:                       DtKNF.KNPAR=_KNPAR7;
ABC0  0E1C     MOVLW 0x1C
418:                       break;     
419:                   case 8:
420:                       DtKNF.KNPAR=_KNPAR8;
ABC2  0100     MOVLB 0x0
ABC4  6FD2     MOVWF DtKNF, BANKED
421:                       break;            
ABC6  D014     BRA 0xABF0
422:                   default:
423:                       DtKNF.KNPAR=_KNPAR;
ABC8  0E1D     MOVLW 0x1D
ABCA  D7FB     BRA 0xABC2
424:                       break;
425:               }  
426:               return DtKNF.KNPAR;
ABF0  51D2     MOVF DtKNF, W, BANKED
427:           }
ABF2  0012     RETURN 0
428:           //Glowna procedura konfiguracji (wykonywana w petli glownej)
429:           void MKonfiguracja(void)
430:           {
431:           	volatile unsigned char key,fst;
432:               static unsigned int bnrp,bfdta;
433:               
434:           	if(PFNf_aktywne_KNF&&(DtKNF.KRK>=2)&&!PFNf_opKNF) 					//procedura z jakiegos powodu nieaktywna w uk³adzie UNI-02?
0A50  A008     BTFSS PFNf_b_set_nco, 0, ACCESS
0A52  D007     BRA 0xA62
0A54  0E01     MOVLW 0x1
0A56  0100     MOVLB 0x0
0A58  65D4     CPFSGT 0xD4, BANKED
0A5A  D003     BRA 0xA62
0A5C  A40D     BTFSS PFNf_plmCO, 2, ACCESS
435:           	{
436:           		ExitKonf();
0A5E  EFD0     GOTO 0xBBA0
0A60  F05D     NOP
437:           		return;
438:           	}
439:           
440:           	if(PFNf_aktywne_KNF&&((RTM(_RTKONF3)>=_TKNFEXT)||PFNf_opgres))		//uplynol maksymalny dozwolony czas aktywnosci procedury lub wylaczenie awaryjne z blokada w ukladzie UNI-02?
0A62  A008     BTFSS PFNf_b_set_nco, 0, ACCESS
0A64  D36B     BRA 0x113C
0A66  0E00     MOVLW 0x0
0A68  EC43     CALL 0xBE86, 0
0A6A  F05F     NOP
0A6C  6FA4     MOVWF _UADtf_TEnd, BANKED
0A6E  0E0A     MOVLW 0xA
0A70  61A4     CPFSLT _UADtf_TEnd, BANKED
0A72  EFD0     GOTO 0xBBA0
0A74  F05D     NOP
0A76  A80D     BTFSS PFNf_plmCO, 4, ACCESS
0A78  D361     BRA 0x113C
0A7A  EFD0     GOTO 0xBBA0
0A7C  F05D     NOP
441:           	{
442:           		ExitKonf();
443:           		return;
444:           	}
445:           
446:           	switch(DtKNF.KRK)
113C  0100     MOVLB 0x0
113E  51D4     MOVF 0xD4, W, BANKED
1140  E101     BNZ 0x1144
1142  D49D     BRA 0xA7E
1144  0A01     XORLW 0x1
1146  E101     BNZ 0x114A
1148  D4DB     BRA 0xB00
114A  0A03     XORLW 0x3
114C  E101     BNZ 0x1150
114E  D649     BRA 0xDE2
1150  0A01     XORLW 0x1
1152  E101     BNZ 0x1156
1154  D705     BRA 0xF60
1156  0A07     XORLW 0x7
1158  E0E8     BZ 0x112A
447:           	{
448:           		//warunek wejscia do procedury modyfikacji parametrow
449:           		case 0:
450:           		{
451:           			RSDT1.inPRM=0;
0A7E  DBCB     RCALL PL348
452:           			RSDT1.inKRK=DtKNF.KRK;
453:           			if(!PFNf_off) return;					//aktywny tryb OFF?
0A80  AA0C     BTFSS PFNf_off, 5, ACCESS
0A82  0012     RETURN 0
454:           			if(MGSDf_NO_ODB||PFNf_toInit) return;	//problem z komunikacja?
0A84  AE03     BTFSS LIN1f_NDTA, 7, ACCESS
0A86  B011     BTFSC PFNf_zima, 0, ACCESS
0A88  0012     RETURN 0
455:           
456:           			//przytrzymano przycisk wejscia do procedury konfiguracji 
457:           #if _KEY_BBOARD==0             
458:           			key=PresKeyEX(RdPrt(S_OFF)&&RdPrt(S_SET),&ky[SS_OFF_SET]);
459:           #endif
460:           #if _KEY_BBOARD==1             
461:           			key=PresKeyEX(RdPrt(S_OFF)&&RdPrt(S_KOM),&ky[SS_OFF_SET]);
0A8A  0100     MOVLB 0x0
0A8C  6BA8     CLRF sign, BANKED
0A8E  0E00     MOVLW 0x0
0A90  EC02     CALL 0xBA04, 0
0A92  F05D     NOP
0A94  E306     BNC 0xAA2
0A96  0E02     MOVLW 0x2
0A98  EC02     CALL 0xBA04, 0
0A9A  F05D     NOP
0A9C  E302     BNC 0xAA2
0A9E  0E01     MOVLW 0x1
0AA0  6FA8     MOVWF sign, BANKED
0AA2  0ED3     MOVLW 0xD3
0AA4  6F76     MOVWF _PFNf_prn_in, BANKED
0AA6  0E03     MOVLW 0x3
0AA8  6F77     MOVWF _PFNf_prn_pg, BANKED
0AAA  51A8     MOVF sign, W, BANKED
0AAC  EC20     CALL 0x6C40, 0
0AAE  F036     NOP
0AB0  6FAA     MOVWF f, BANKED
462:           #endif			
463:           			if(PFNf_enKNF&&key!=100&&key>=50) //przytrzymano przycisk wejscia do procedury konfiguracji?
0AB2  A609     BTFSS PFNf_b_str_nco, 3, ACCESS
0AB4  D022     BRA 0xAFA
0AB6  0E64     MOVLW 0x64
0AB8  19AA     XORWF f, W, BANKED
0ABA  E01F     BZ 0xAFA
0ABC  0E31     MOVLW 0x31
0ABE  65AA     CPFSGT f, BANKED
0AC0  D01C     BRA 0xAFA
464:           			{
465:           #if _KEY_BBOARD==0                
466:           				WaitToLowEx(&ky[SS_OFF_SET]);			
467:           				WaitToLowEx(&ky[SS_OFF]);
468:           				WaitToLowEx(&ky[SS_SET]);
469:           #endif  
470:           #if _KEY_BBOARD==1                
471:           				WaitToLowEx(&ky[SS_OFF_SET]);			
0AC2  0ED3     MOVLW 0xD3
0AC4  6F74     MOVWF _PFNf_prODP, BANKED
0AC6  0E03     MOVLW 0x3
0AC8  6F75     MOVWF _PFNf_prn_cs, BANKED
0ACA  EC65     CALL 0xBCCA, 0
0ACC  F05E     NOP
0ACE  DB8A     RCALL PL214
472:           				WaitToLowEx(&ky[SS_OFF]);
0AD0  EC65     CALL 0xBCCA, 0
0AD2  F05E     NOP
0AD4  DB9B     RCALL PL340
473:           				WaitToLowEx(&ky[SS_KOM]);
0AD6  EC65     CALL 0xBCCA, 0
0AD8  F05E     NOP
474:           #endif                
475:           				PFNf_aktywne_KNF=1;
0ADA  8008     BSF PFNf_b_set_nco, 0, ACCESS
476:           				StartRTM(_RTKONF3);					//start timera aktywnosci proc. konfig
0ADC  0E00     MOVLW 0x0
0ADE  EC25     CALL 0xBC4A, 0
0AE0  F05E     NOP
477:           				DtKNF.KNPAR=_KNPAR;					//domyslna maksymalna liczba parametrow (obs.kompatybilnosci w dol)
0AE2  0E1D     MOVLW 0x1D
0AE4  6FD2     MOVWF DtKNF, BANKED
478:           				DtKNF.PRM=0; 						//aktywacja pierwszego parametru
0AE6  6BD3     CLRF 0xD3, BANKED
479:           				DtKNF.KRK=1; 						//aktywacja proc. konfiguracji
0AE8  0E01     MOVLW 0x1
0AEA  6FD4     MOVWF 0xD4, BANKED
480:           				RSDT1.inPRM=0;
0AEC  0102     MOVLB 0x2
0AEE  6B81     CLRF _PFNf_set_ncw, BANKED
481:           				ClrAllMarks();						//wygas znaki nie zwiazane z konfiguracja
0AF0  ECC5     CALL 0xB78A, 0
0AF2  F05B     NOP
482:           				StartRTS(_RTKONF1);					//start timera oczekiwania na wejsciowe dane konfiguracyjne
0AF4  0E00     MOVLW 0x0
0AF6  EF45     GOTO 0xBC8A
0AF8  F05E     NOP
483:           			}
484:           			else 
485:           			{
486:           				DtKNF.PRM=0;
0AFA  6BD3     CLRF 0xD3, BANKED
487:           				DtKNF.KRK=0;
0AFC  6BD4     CLRF 0xD4, BANKED
0AFE  D38B     BRA PL348
488:           				RSDT1.inPRM=0;
489:           				RSDT1.inKRK=DtKNF.KRK;
490:           				return;
491:           			}
492:           			break;
493:           		}
494:           		//oczekiwanie na na wejsciowe dane konfiguracyjne
495:           		case 1:
0B00  DB8A     RCALL PL348
496:           		{
497:           			RSDT1.inPRM=0;
498:           			RSDT1.inKRK=DtKNF.KRK;
499:                       InitPZK();                                                          //Inicjalizacja danych charakterystycznych kolejnych parametrow
0B02  ECD0     CALL 0x9BA0, 0
0B04  F04D     NOP
500:           			if((RTS(_RTKONF1)>=_TKNFINI))                                       //przekroczony limit czasu?
0B06  0E00     MOVLW 0x0
0B08  EC73     CALL 0xBEE6, 0
0B0A  F05F     NOP
0B0C  6FA4     MOVWF _UADtf_TEnd, BANKED
0B0E  0E04     MOVLW 0x4
0B10  65A4     CPFSGT _UADtf_TEnd, BANKED
0B12  D002     BRA 0xB18
0B14  EFD0     GOTO 0xBBA0
0B16  F05D     NOP
501:           			{
502:           				ExitKonf();
503:           				return;
504:           			}
505:                       if(PFN.vUNI02&&RSDT1.vSTD&&RSDT1.vKNF)                              //mamy komplet danych koniecznych do porawnej pracy procedury?
0B18  0101     MOVLB 0x1
0B1A  51EC     MOVF 0xEC, W, BANKED
0B1C  B4D8     BTFSC STATUS, 2, ACCESS
0B1E  0012     RETURN 0
0B20  0102     MOVLB 0x2
0B22  512F     MOVF _PFNf_KnfDisErr, W, BANKED
0B24  B4D8     BTFSC STATUS, 2, ACCESS
0B26  0012     RETURN 0
0B28  5150     MOVF 0x50, W, BANKED
0B2A  A4D8     BTFSS STATUS, 2, ACCESS
506:                       {
507:                           if(RSDT1f_RD_KNF&&PFNf_opKNF)                                   //odczytaj dane wejsciowe parametrów ktore maja byc modyfikowane
0B2C  A212     BTFSS RSDT1f_RD_STD, 1, ACCESS
0B2E  0012     RETURN 0
0B30  A40D     BTFSS PFNf_plmCO, 2, ACCESS
0B32  0012     RETURN 0
508:                           {
509:                               RSDT1f_RRD_KNF=1;
0B34  8812     BSF RSDT1f_RD_STD, 4, ACCESS
510:                               RSDT1.inMSTR=PZK[0].dta=PZK[0].bfdta=RSDT1.outMSTR;			//0 moc startowa
0B36  5154     MOVF 0x54, W, BANKED
0B38  0100     MOVLB 0x0
0B3A  6FA4     MOVWF _UADtf_TEnd, BANKED
0B3C  6BA5     CLRF f3, BANKED
0B3E  EE26     LFSR 2, 0x68D
0B40  F08D     NOP
0B42  DB17     RCALL __end_ofPL4
0B44  EE16     LFSR 1, 0x68B
0B46  F08B     NOP
0B48  DB09     RCALL PL4
0B4A  6F83     MOVWF _PFNf_str_ncw, BANKED
511:                               RSDT1.inMMAXU=PZK[1].dta=PZK[1].bfdta=RSDT1.outMMAXU;		//1 moc maksymalna CW
0B4C  5155     MOVF 0x55, W, BANKED
0B4E  0100     MOVLB 0x0
0B50  6FA4     MOVWF _UADtf_TEnd, BANKED
0B52  6BA5     CLRF f3, BANKED
0B54  EE26     LFSR 2, 0x696
0B56  F096     NOP
0B58  DB0C     RCALL __end_ofPL4
0B5A  EE16     LFSR 1, 0x694
0B5C  F094     NOP
0B5E  DAFE     RCALL PL4
0B60  6F84     MOVWF _PFNf_tdzCO, BANKED
512:                               RSDT1.inMMAXG=PZK[2].dta=PZK[2].bfdta=RSDT1.outMMAXG;		//2 moc maksymalna CO
0B62  5156     MOVF 0x56, W, BANKED
0B64  0100     MOVLB 0x0
0B66  6FA4     MOVWF _UADtf_TEnd, BANKED
0B68  6BA5     CLRF f3, BANKED
0B6A  EE26     LFSR 2, 0x69F
0B6C  F09F     NOP
0B6E  DB01     RCALL __end_ofPL4
0B70  EE16     LFSR 1, 0x69D
0B72  F09D     NOP
0B74  DAF3     RCALL PL4
0B76  6F85     MOVWF _PFNf_tdzCW, BANKED
513:                               RSDT1.inMMIN=PZK[3].dta=PZK[3].bfdta=RSDT1.outMMIN;			//3 dolna granica predkosci obrotowej wentylatora
0B78  515D     MOVF 0x5D, W, BANKED
0B7A  0100     MOVLB 0x0
0B7C  6FA4     MOVWF _UADtf_TEnd, BANKED
0B7E  6BA5     CLRF f3, BANKED
0B80  EE26     LFSR 2, 0x6A8
0B82  F0A8     NOP
0B84  DAF6     RCALL __end_ofPL4
0B86  EE16     LFSR 1, 0x6A6
0B88  F0A6     NOP
0B8A  DAE8     RCALL PL4
0B8C  6F8C     MOVWF _PFNf_zima, BANKED
514:                               RSDT1.inMMAX=PZK[4].dta=PZK[4].bfdta=RSDT1.outMMAX;			//4 gorna granica predkosci obrotowej wentylatora
0B8E  515E     MOVF 0x5E, W, BANKED
0B90  0100     MOVLB 0x0
0B92  6FA4     MOVWF _UADtf_TEnd, BANKED
0B94  6BA5     CLRF f3, BANKED
0B96  EE26     LFSR 2, 0x6B1
0B98  F0B1     NOP
0B9A  DAEB     RCALL __end_ofPL4
0B9C  EE16     LFSR 1, 0x6AF
0B9E  F0AF     NOP
0BA0  DADD     RCALL PL4
0BA2  6F8D     MOVWF _PWMf_ENPWM2, BANKED
515:                               RSDT1.inKODKT=PZK[5].dta=PZK[5].bfdta=RSDT1.outKODKT;		//5 kod kotla
0BA4  5158     MOVF 0x58, W, BANKED
0BA6  0100     MOVLB 0x0
0BA8  6FA4     MOVWF _UADtf_TEnd, BANKED
0BAA  6BA5     CLRF f3, BANKED
0BAC  EE26     LFSR 2, 0x6BA
0BAE  F0BA     NOP
0BB0  DAE0     RCALL __end_ofPL4
0BB2  EE16     LFSR 1, 0x6B8
0BB4  F0B8     NOP
0BB6  DAD2     RCALL PL4
0BB8  6F87     MOVWF _PFNf_tmpZW, BANKED
516:                               RSDT1.inWOBG=PZK[6].dta=PZK[6].bfdta=RSDT1.outWOBG;			//6 rodzaj obiegu
0BBA  5159     MOVF 0x59, W, BANKED
0BBC  0100     MOVLB 0x0
0BBE  6FA4     MOVWF _UADtf_TEnd, BANKED
0BC0  6BA5     CLRF f3, BANKED
0BC2  EE26     LFSR 2, 0x6C3
0BC4  F0C3     NOP
0BC6  DAD5     RCALL __end_ofPL4
0BC8  EE16     LFSR 1, 0x6C1
0BCA  F0C1     NOP
0BCC  DAC7     RCALL PL4
0BCE  6F88     MOVWF _PFNf_toInit, BANKED
517:                               RSDT1.inOPDG=PZK[7].dta=PZK[7].bfdta=RSDT1.outOPDG;			//7 ogrzewanie podlogowe
0BD0  515B     MOVF 0x5B, W, BANKED
0BD2  0100     MOVLB 0x0
0BD4  6FA4     MOVWF _UADtf_TEnd, BANKED
0BD6  6BA5     CLRF f3, BANKED
0BD8  EE26     LFSR 2, 0x6CC
0BDA  F0CC     NOP
0BDC  DACA     RCALL __end_ofPL4
0BDE  EE16     LFSR 1, 0x6CA
0BE0  F0CA     NOP
0BE2  DABC     RCALL PL4
0BE4  6F8A     MOVWF _PFNf_vnt, BANKED
518:                               RSDT1.inTPCS=PZK[8].dta=PZK[8].bfdta=RSDT1.outTPCS;			//8 wybor rodzaju czujnika cisnienia
0BE6  515C     MOVF 0x5C, W, BANKED
0BE8  0100     MOVLB 0x0
0BEA  6FA4     MOVWF _UADtf_TEnd, BANKED
0BEC  6BA5     CLRF f3, BANKED
0BEE  EE26     LFSR 2, 0x6D5
0BF0  F0D5     NOP
0BF2  DABF     RCALL __end_ofPL4
0BF4  EE16     LFSR 1, 0x6D3
0BF6  F0D3     NOP
0BF8  DAB1     RCALL PL4
0BFA  6F8B     MOVWF _PFNf_zcfm, BANKED
519:                               RSDT1.inWANL=PZK[9].dta=PZK[9].bfdta=RSDT1.outWANL;			//9 aktywacja zegara antylegionella
0BFC  5157     MOVF 0x57, W, BANKED
0BFE  0100     MOVLB 0x0
0C00  6FA4     MOVWF _UADtf_TEnd, BANKED
0C02  6BA5     CLRF f3, BANKED
0C04  EE26     LFSR 2, 0x6DE
0C06  F0DE     NOP
0C08  DAB4     RCALL __end_ofPL4
0C0A  EE16     LFSR 1, 0x6DC
0C0C  F0DC     NOP
0C0E  DAA6     RCALL PL4
0C10  6F86     MOVWF _PFNf_timZAS, BANKED
520:                               RSDT1.inNOKR=PZK[10].dta=PZK[10].bfdta=RSDT1.outNOKR;		//10 tachometr - liczba okresow na sek.
0C12  515A     MOVF 0x5A, W, BANKED
0C14  0100     MOVLB 0x0
0C16  6FA4     MOVWF _UADtf_TEnd, BANKED
0C18  6BA5     CLRF f3, BANKED
0C1A  EE26     LFSR 2, 0x6E7
0C1C  F0E7     NOP
0C1E  DAA9     RCALL __end_ofPL4
0C20  EE16     LFSR 1, 0x6E5
0C22  F0E5     NOP
0C24  DA9B     RCALL PL4
0C26  6F89     MOVWF _PFNf_trbECO, BANKED
521:                               RSDT1.inRDPM=PZK[11].dta=PZK[11].bfdta=RSDT1.outRDPM;		//11 rodzaj pompy
0C28  515F     MOVF 0x5F, W, BANKED
0C2A  0100     MOVLB 0x0
0C2C  6FA4     MOVWF _UADtf_TEnd, BANKED
0C2E  6BA5     CLRF f3, BANKED
0C30  EE26     LFSR 2, 0x6F0
0C32  F0F0     NOP
0C34  DA9E     RCALL __end_ofPL4
0C36  EE16     LFSR 1, 0x6EE
0C38  F0EE     NOP
0C3A  DA90     RCALL PL4
0C3C  6F8E     MOVWF _RSDT1f_NewLIDN, BANKED
522:                               RSDT1.inDTPM=PZK[12].dta=PZK[12].bfdta=RSDT1.outDTPM;		//12 delta T dla pompy
0C3E  5160     MOVF __pcstackBANK0, W, BANKED
0C40  0100     MOVLB 0x0
0C42  6FA4     MOVWF _UADtf_TEnd, BANKED
0C44  6BA5     CLRF f3, BANKED
0C46  EE26     LFSR 2, 0x6F9
0C48  F0F9     NOP
0C4A  DA93     RCALL __end_ofPL4
0C4C  EE16     LFSR 1, 0x6F7
0C4E  F0F7     NOP
0C50  DA85     RCALL PL4
0C52  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
523:                               RSDT1.inMDPM=PZK[13].dta=PZK[13].bfdta=RSDT1.outMDPM;		//13 minimalny wydatek pompy
0C54  5161     MOVF 0x61, W, BANKED
0C56  0100     MOVLB 0x0
0C58  6FA4     MOVWF _UADtf_TEnd, BANKED
0C5A  6BA5     CLRF f3, BANKED
0C5C  EE27     LFSR 2, 0x702
0C5E  F002     NOP
0C60  DA88     RCALL __end_ofPL4
0C62  EE17     LFSR 1, 0x700
0C64  F000     NOP
0C66  DA7A     RCALL PL4
0C68  6F90     MOVWF _RSDT1f_OdpLIDN, BANKED
524:                               RSDT1.inTECO=PZK[14].dta=PZK[14].bfdta=RSDT1.outTECO;		//14 aktywacja/deaktywacja trybu ECO
0C6A  5162     MOVF msk, W, BANKED
0C6C  0100     MOVLB 0x0
0C6E  6FA4     MOVWF _UADtf_TEnd, BANKED
0C70  6BA5     CLRF f3, BANKED
0C72  EE27     LFSR 2, 0x70B
0C74  F00B     NOP
0C76  DA7D     RCALL __end_ofPL4
0C78  EE17     LFSR 1, 0x709
0C7A  F009     NOP
0C7C  DA6F     RCALL PL4
0C7E  6F91     MOVWF _RSDT1f_RD_KNF, BANKED
525:                               RSDT1.inTMMAXG2=PZK[15].dta=PZK[15].bfdta=RSDT1.outTMMAXG2;	//15 czas pracy przy obnizonej mocy w trybie CO/deaktywacja dla wartosci 0
0C80  5163     MOVF 0x63, W, BANKED
0C82  0100     MOVLB 0x0
0C84  6FA4     MOVWF _UADtf_TEnd, BANKED
0C86  6BA5     CLRF f3, BANKED
0C88  EE27     LFSR 2, 0x714
0C8A  F014     NOP
0C8C  DA72     RCALL __end_ofPL4
0C8E  EE17     LFSR 1, 0x712
0C90  F012     NOP
0C92  DA64     RCALL PL4
0C94  6F92     MOVWF _RSDT1f_RD_LIN, BANKED
526:                               RSDT1.inMMAXG2=PZK[16].dta=PZK[16].bfdta=RSDT1.outMMAXG2;	//16 wartosc obnizonej mocy w trybie CO
0C96  5164     MOVF i, W, BANKED
0C98  0100     MOVLB 0x0
0C9A  6FA4     MOVWF _UADtf_TEnd, BANKED
0C9C  6BA5     CLRF f3, BANKED
0C9E  EE27     LFSR 2, 0x71D
0CA0  F01D     NOP
0CA2  DA67     RCALL __end_ofPL4
0CA4  EE17     LFSR 1, 0x71B
0CA6  F01B     NOP
0CA8  DA59     RCALL PL4
0CAA  6F93     MOVWF _RSDT1f_RD_STD, BANKED
527:                               RSDT1.inMGPM=PZK[17].dta=PZK[17].bfdta=RSDT1.outMGPM;		//17 maksymalny wydatek pompy
0CAC  5165     MOVF 0x65, W, BANKED
0CAE  0100     MOVLB 0x0
0CB0  6FA4     MOVWF _UADtf_TEnd, BANKED
0CB2  6BA5     CLRF f3, BANKED
0CB4  EE27     LFSR 2, 0x726
0CB6  F026     NOP
0CB8  DA5C     RCALL __end_ofPL4
0CBA  EE17     LFSR 1, 0x724
0CBC  F024     NOP
0CBE  DA4E     RCALL PL4
0CC0  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
528:                               RSDT1.inMGPM2=PZK[18].dta=PZK[18].bfdta=RSDT1.outMGPM2;		//18 maksymalny wydatek pompy dla obiegu CW                      
0CC2  5166     MOVF 0x66, W, BANKED
0CC4  0100     MOVLB 0x0
0CC6  6FA4     MOVWF _UADtf_TEnd, BANKED
0CC8  6BA5     CLRF f3, BANKED
0CCA  EE27     LFSR 2, 0x72F
0CCC  F02F     NOP
0CCE  DA51     RCALL __end_ofPL4
0CD0  EE17     LFSR 1, 0x72D
0CD2  F02D     NOP
0CD4  DA43     RCALL PL4
0CD6  6F95     MOVWF _RSDT1f_RRD_STD, BANKED
529:                               RSDT1.inHSCO=PZK[19].dta=PZK[19].bfdta=RSDT1.outHSCO;		//19 histereza wylaczenia grzania CO (ponad nastawe) 
0CD8  5167     MOVF _PFNf_ofnserw, W, BANKED
0CDA  0100     MOVLB 0x0
0CDC  6FA4     MOVWF _UADtf_TEnd, BANKED
0CDE  6BA5     CLRF f3, BANKED
0CE0  EE27     LFSR 2, 0x738
0CE2  F038     NOP
0CE4  DA46     RCALL __end_ofPL4
0CE6  EE17     LFSR 1, 0x736
0CE8  F036     NOP
0CEA  DA38     RCALL PL4
0CEC  6F96     MOVWF _RSDT1f_RespLIDN, BANKED
530:                               RSDT1.inCONW=PZK[20].dta=PZK[20].bfdta=RSDT1.outCONW;		//20 temp CO przy grzaniu CW zasobnika                 
0CEE  5168     MOVF _PFNf_ofoff, W, BANKED
0CF0  0100     MOVLB 0x0
0CF2  6FA4     MOVWF _UADtf_TEnd, BANKED
0CF4  6BA5     CLRF f3, BANKED
0CF6  EE27     LFSR 2, 0x741
0CF8  F041     NOP
0CFA  DA3B     RCALL __end_ofPL4
0CFC  EE17     LFSR 1, 0x73F
0CFE  F03F     NOP
0D00  DA2D     RCALL PL4
0D02  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
531:                               RSDT1.inPROP=PZK[21].dta=PZK[21].bfdta=RSDT1.outPROP;		//21 poprawka dla regulagtora pogodowego
0D04  5169     MOVF _PFNf_ofzima, W, BANKED
0D06  0100     MOVLB 0x0
0D08  6FA4     MOVWF _UADtf_TEnd, BANKED
0D0A  6BA5     CLRF f3, BANKED
0D0C  EE27     LFSR 2, 0x74A
0D0E  F04A     NOP
0D10  DA30     RCALL __end_ofPL4
0D12  EE17     LFSR 1, 0x748
0D14  F048     NOP
0D16  DA22     RCALL PL4
0D18  6F98     MOVWF _UAD1tf_RFData, BANKED
532:                               RSDT1.inRFAN=PZK[22].dta=PZK[22].bfdta=RSDT1.outRFAN;		//22 wybor rodzaju wentylatora
0D1A  516A     MOVF _PFNf_opKNF, W, BANKED
0D1C  0100     MOVLB 0x0
0D1E  6FA4     MOVWF _UADtf_TEnd, BANKED
0D20  6BA5     CLRF f3, BANKED
0D22  EE27     LFSR 2, 0x753
0D24  F053     NOP
0D26  DA25     RCALL __end_ofPL4
0D28  EE17     LFSR 1, 0x751
0D2A  F051     NOP
0D2C  DA17     RCALL PL4
0D2E  6F99     MOVWF _UAD1tf_RFEnd, BANKED
533:                               RSDT1.inTSTR=PZK[23].dta=PZK[23].bfdta=RSDT1.outTSTR;		//23 czas wybiegu na mocy startowej dla obiegu CO 
0D30  516B     MOVF _PFNf_opgprg, W, BANKED
0D32  0100     MOVLB 0x0
0D34  6FA4     MOVWF _UADtf_TEnd, BANKED
0D36  6BA5     CLRF f3, BANKED
0D38  EE27     LFSR 2, 0x75C
0D3A  F05C     NOP
0D3C  DA1A     RCALL __end_ofPL4
0D3E  EE17     LFSR 1, 0x75A
0D40  F05A     NOP
0D42  DA0C     RCALL PL4
0D44  6F9A     MOVWF _UAD1tf_RFExt, BANKED
534:                               RSDT1.inTL3=PZK[24].dta=PZK[24].bfdta=RSDT1.outTL3;         //24 czas blokady L3 dla obiegu CO  
0D46  516C     MOVF _PFNf_opgres, W, BANKED
0D48  0100     MOVLB 0x0
0D4A  6FA4     MOVWF _UADtf_TEnd, BANKED
0D4C  6BA5     CLRF f3, BANKED
0D4E  EE27     LFSR 2, 0x765
0D50  F065     NOP
0D52  DA0F     RCALL __end_ofPL4
0D54  EE17     LFSR 1, 0x763
0D56  F063     NOP
0D58  DA01     RCALL PL4
0D5A  6F9B     MOVWF _UAD1tf_TFData, BANKED
535:           
536:                               RSDT1.inPGDR=PZK[25].dta=PZK[25].bfdta=RSDT1.outPGDR;       //25 rodzaj regulatora pogodowego
0D5C  516D     MOVF _PFNf_pgd, W, BANKED
0D5E  0100     MOVLB 0x0
0D60  6FA4     MOVWF _UADtf_TEnd, BANKED
0D62  6BA5     CLRF f3, BANKED
0D64  EE27     LFSR 2, 0x76E
0D66  F06E     NOP
0D68  DA04     RCALL __end_ofPL4
0D6A  EE17     LFSR 1, 0x76C
0D6C  F06C     NOP
0D6E  D9F6     RCALL PL4
0D70  6F9C     MOVWF _UAD1tf_TFEnd, BANKED
537:                               RSDT1.inPGDG=PZK[26].dta=PZK[26].bfdta=RSDT1.outPGDG;       //26 wartosc graniczna pobudzenia od regulatora pogodowego
0D72  516E     MOVF _PFNf_pgdTP, W, BANKED
0D74  0100     MOVLB 0x0
0D76  6FA4     MOVWF _UADtf_TEnd, BANKED
0D78  6BA5     CLRF f3, BANKED
0D7A  EE27     LFSR 2, 0x777
0D7C  F077     NOP
0D7E  D9F9     RCALL __end_ofPL4
0D80  EE17     LFSR 1, 0x775
0D82  F075     NOP
0D84  D9EB     RCALL PL4
0D86  6F9D     MOVWF _UADtf_RData, BANKED
538:                               RSDT1.inPGDO=PZK[27].dta=PZK[27].bfdta=RSDT1.outPGDO;       //27 obnizenie nocne dla regulatora pogodowego                
0D88  516F     MOVF _PFNf_plmCO, W, BANKED
0D8A  0100     MOVLB 0x0
0D8C  6FA4     MOVWF _UADtf_TEnd, BANKED
0D8E  6BA5     CLRF f3, BANKED
0D90  EE27     LFSR 2, 0x780
0D92  F080     NOP
0D94  D9EE     RCALL __end_ofPL4
0D96  EE17     LFSR 1, 0x77E
0D98  F07E     NOP
0D9A  D9E0     RCALL PL4
0D9C  6F9E     MOVWF _UADtf_REXT, BANKED
539:                               RSDT1.inPGMX=PZK[28].dta=PZK[28].bfdta=RSDT1.outPGMX;       //28 maksymalna wartosc graniczna CO dla regulatora pogodowego
0D9E  5170     MOVF _PFNf_plmCW, W, BANKED
0DA0  0100     MOVLB 0x0
0DA2  6FA4     MOVWF _UADtf_TEnd, BANKED
0DA4  6BA5     CLRF f3, BANKED
0DA6  EE27     LFSR 2, 0x789
0DA8  F089     NOP
0DAA  D9E3     RCALL __end_ofPL4
0DAC  EE17     LFSR 1, 0x787
0DAE  F087     NOP
0DB0  D9D5     RCALL PL4
0DB2  6F9F     MOVWF _UADtf_REnd, BANKED
540:           
541:                               DecShowHide();												//pokaz/ukryj parametry
0DB4  EC2A     CALL 0x7054, 0
0DB6  F038     NOP
542:                               if(PZK[5].fl.shw) DtKNF.PRM=nrp=5;								//domyslnie zaznaczony parametr nr 5 - wybor typu kotla
0DB8  EE26     LFSR 2, 0x6BC
0DBA  F0BC     NOP
0DBC  A4DF     BTFSS INDF2, 2, ACCESS
0DBE  D005     BRA 0xDCA
0DC0  0100     MOVLB 0x0
0DC2  6BDA     CLRF 0xDA, BANKED
0DC4  0E05     MOVLW 0x5
0DC6  6FD9     MOVWF nrp, BANKED
0DC8  D003     BRA 0xDD0
543:                               else DtKNF.PRM=nrp=0;										//domyslnie zaznaczony parametr nr 0 - moc startowa
0DCA  0100     MOVLB 0x0
0DCC  6BDA     CLRF 0xDA, BANKED
0DCE  6BD9     CLRF nrp, BANKED
0DD0  C0D9     MOVFF nrp, 0xD3
0DD2  F0D3     NOP
544:                               //kompatybilnosc wsteczna 
545:                               SetKNPAR();                                                 //okresl liczbe parametrow w zaleznosci od wersji oprogramowania
0DD4  ECD3     CALL 0xABA6, 0
0DD6  F055     NOP
546:                               RSDT1f_RRD_KNF=0;                
0DD8  9812     BCF RSDT1f_RD_STD, 4, ACCESS
547:                               DtKNF.KRK=2;
0DDA  0E02     MOVLW 0x2
0DDC  0100     MOVLB 0x0
0DDE  6FD4     MOVWF 0xD4, BANKED
0DE0  0C02     RETLW 0x2
548:                           }
549:                       }
550:           			break;
551:           		}
552:           		//wybor parametru
553:           		case 2:
0DE2  DA19     RCALL PL348
554:           		{
555:           			RSDT1.inPRM=0;
556:           			RSDT1.inKRK=DtKNF.KRK;
557:           			RSDT1.inDDTA=0;
0DE4  6B82     CLRF _PFNf_str_nco, BANKED
558:           			PFNf_off=1;
0DE6  8A0C     BSF PFNf_off, 5, ACCESS
559:           			PFNf_lato=0;
0DE8  980B     BCF PFNf_lato, 4, ACCESS
560:           			PFNf_zima=0;
0DEA  9811     BCF PFNf_zima, 4, ACCESS
561:           			PFNf_KnfDisErr=1;
0DEC  8E05     BSF PFNf_KnfDisErr, 7, ACCESS
562:           			Mark(_GZ_BAR,0);											
0DEE  0100     MOVLB 0x0
0DF0  6B7A     CLRF _PFNf_res, BANKED
0DF2  0E06     MOVLW 0x6
0DF4  EC1F     CALL 0xB83E, 0
0DF6  F05C     NOP
563:           			Mark(_GZ_TCO,0);
0DF8  6B7A     CLRF _PFNf_res, BANKED
0DFA  0E04     MOVLW 0x4
0DFC  EC1F     CALL 0xB83E, 0
0DFE  F05C     NOP
564:           			Mark(_GZ_MXCW,0);											
0E00  6B7A     CLRF _PFNf_res, BANKED
0E02  0E0B     MOVLW 0xB
0E04  EC1F     CALL 0xB83E, 0
0E06  F05C     NOP
565:           			Mark(_GZ_MNCO,0);
0E08  6B7A     CLRF _PFNf_res, BANKED
0E0A  0E0E     MOVLW 0xE
0E0C  EC1F     CALL 0xB83E, 0
0E0E  F05C     NOP
566:           			DecShowHide();
0E10  EC2A     CALL 0x7054, 0
0E12  F038     NOP
567:           			if((nrp<_KNPAR)&&(PZK[nrp].fl.shw))							//parametr mo¿e byc wyswietlony?
0E14  0100     MOVLB 0x0
0E16  51DA     MOVF 0xDA, W, BANKED
0E18  E130     BNZ 0xE7A
0E1A  0E1D     MOVLW 0x1D
0E1C  5DD9     SUBWF nrp, W, BANKED
0E1E  E22D     BC 0xE7A
0E20  C0D9     MOVFF nrp, _PFNf_prODP
0E22  F074     NOP
0E24  C0DA     MOVFF 0xDA, _PFNf_prn_cs
0E26  F075     NOP
0E28  6B77     CLRF _PFNf_prn_pg, BANKED
0E2A  0E09     MOVLW 0x9
0E2C  6F76     MOVWF _PFNf_prn_in, BANKED
0E2E  EC3E     CALL 0xBA7C, 0
0E30  F05D     NOP
0E32  0E8F     MOVLW 0x8F
0E34  2574     ADDWF _PFNf_prODP, W, BANKED
0E36  6ED9     MOVWF FSR2, ACCESS
0E38  0E06     MOVLW 0x6
0E3A  2175     ADDWFC _PFNf_prn_cs, W, BANKED
0E3C  6EDA     MOVWF FSR2H, ACCESS
0E3E  A4DF     BTFSS INDF2, 2, ACCESS
0E40  D01C     BRA 0xE7A
568:           			{
569:           #if _KEY_BBOARD==0  
570:                           bnrp=nrp;
571:           				//ReadParam(&nrp,&zm,&zp,0,DtKNF.KNPAR-1,1,0);
572:           				ReadParam(&bnrp,&zm,&zp,0,DtKNF.KNPAR-1,1,0);                
573:                           nrp=bnrp;
574:           #endif
575:           #if _KEY_BBOARD==1  
576:                           bnrp=nrp;
0E42  C0D9     MOVFF nrp, bnrp
0E44  F2F8     NOP
0E46  C0DA     MOVFF 0xDA, 0x2F9
0E48  F2F9     NOP
577:           				//ReadParamCO(&nrp,&zm,&zp,0,DtKNF.KNPAR-1,1,0);
578:           				ReadParamCO(&bnrp,&zm,&zp,0,DtKNF.KNPAR-1,1,0);                
0E4A  0EF8     MOVLW 0xF8
0E4C  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
0E4E  0E02     MOVLW 0x2
0E50  D9D3     RCALL PL320
0E52  6B96     CLRF _RSDT1f_RespLIDN, BANKED
0E54  6B95     CLRF _RSDT1f_RRD_STD, BANKED
0E56  0EFF     MOVLW 0xFF
0E58  25D2     ADDWF DtKNF, W, BANKED
0E5A  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
0E5C  6B98     CLRF _UAD1tf_RFData, BANKED
0E5E  0EFF     MOVLW 0xFF
0E60  2398     ADDWFC _UAD1tf_RFData, F, BANKED
0E62  0E01     MOVLW 0x1
0E64  6F99     MOVWF _UAD1tf_RFEnd, BANKED
0E66  6B9A     CLRF _UAD1tf_RFExt, BANKED
0E68  EC42     CALL 0x6084, 0
0E6A  F030     NOP
579:                           nrp=bnrp;
0E6C  C2F8     MOVFF bnrp, nrp
0E6E  F0D9     NOP
0E70  C2F9     MOVFF 0x2F9, 0xDA
0E72  F0DA     NOP
580:           #endif                
581:           				DtKNF.PRM=nrp;
0E74  C0D9     MOVFF nrp, 0xD3
0E76  F0D3     NOP
582:           			}
0E78  D02B     BRA 0xED0
583:           			else
584:           			{
585:           				if(zm==3)						//zmiana w gore?
0E7A  0E03     MOVLW 0x3
0E7C  0101     MOVLB 0x1
0E7E  19FD     XORWF 0xFD, W, BANKED
0E80  E115     BNZ 0xEAC
586:           				{
587:           					if(nrp<(DtKNF.KNPAR-1)) nrp++;
0E82  0100     MOVLB 0x0
0E84  69A4     SETF _UADtf_TEnd, BANKED
0E86  69A5     SETF f3, BANKED
0E88  51D2     MOVF DtKNF, W, BANKED
0E8A  6FA6     MOVWF sign, BANKED
0E8C  6BA7     CLRF x, BANKED
0E8E  51A4     MOVF _UADtf_TEnd, W, BANKED
0E90  27A6     ADDWF sign, F, BANKED
0E92  51A5     MOVF f3, W, BANKED
0E94  23A7     ADDWFC x, F, BANKED
0E96  51A6     MOVF sign, W, BANKED
0E98  5DD9     SUBWF nrp, W, BANKED
0E9A  51A7     MOVF x, W, BANKED
0E9C  59DA     SUBWFB 0xDA, W, BANKED
0E9E  E203     BC 0xEA6
0EA0  4BD9     INFSNZ nrp, F, BANKED
0EA2  2BDA     INCF 0xDA, F, BANKED
0EA4  0012     RETURN 0
588:           					else nrp=0;
0EA6  6BD9     CLRF nrp, BANKED
0EA8  6BDA     CLRF 0xDA, BANKED
0EAA  0012     RETURN 0
589:           				}
590:           				else
591:           				if(zm==2)						//zmiana w dol?
0EAC  0E02     MOVLW 0x2
0EAE  19FD     XORWF 0xFD, W, BANKED
0EB0  E1E8     BNZ 0xE82
592:           				{
593:           					if(nrp>0) nrp--;
0EB2  0100     MOVLB 0x0
0EB4  51D9     MOVF nrp, W, BANKED
0EB6  11DA     IORWF 0xDA, W, BANKED
0EB8  E004     BZ 0xEC2
0EBA  07D9     DECF nrp, F, BANKED
0EBC  A0D8     BTFSS STATUS, 0, ACCESS
0EBE  07DA     DECF 0xDA, F, BANKED
0EC0  0012     RETURN 0
594:           					else nrp=DtKNF.KNPAR-1;
0EC2  0EFF     MOVLW 0xFF
0EC4  25D2     ADDWF DtKNF, W, BANKED
0EC6  6FD9     MOVWF nrp, BANKED
0EC8  6BDA     CLRF 0xDA, BANKED
0ECA  0EFF     MOVLW 0xFF
0ECC  23DA     ADDWFC 0xDA, F, BANKED
0ECE  0CFF     RETLW 0xFF
595:           					}
596:           				else							//gdy pierwsze parametr ukryty						
597:           				{
598:           					if(nrp<(DtKNF.KNPAR-1)) nrp++;
599:           					else nrp=0;
600:           				}
601:           				break;	
602:           			}
603:           			PrintPR(led_P,DtKNF.PRM+1,0);								//kod rx
0ED0  29D3     INCF 0xD3, W, BANKED
0ED2  6F7E     MOVWF _PFNf_set_eco, BANKED
0ED4  0E00     MOVLW 0x0
0ED6  6F7F     MOVWF _PFNf_set_fnserw, BANKED
0ED8  0E73     MOVLW 0x73
0EDA  EC3B     CALL 0x9E76, 0
0EDC  F04F     NOP
0EDE  D9A0     RCALL PL386
604:           #if _KEY_BBOARD==0             
605:           			key=PresKeyEX(RdPrt(S_SET),&ky[SS_SET]);
606:           #endif
607:           #if _KEY_BBOARD==1             
608:           			key=PresKeyEX(RdPrt(S_KOM),&ky[SS_KOM]);
0EE0  EC02     CALL 0xBA04, 0
0EE2  F05D     NOP
0EE4  0E01     MOVLW 0x1
0EE6  A0D8     BTFSS STATUS, 0, ACCESS
0EE8  0E00     MOVLW 0x0
0EEA  EC20     CALL 0x6C40, 0
0EEC  F036     NOP
0EEE  6FAA     MOVWF f, BANKED
609:           #endif            
610:           			if(key>0)													//wybrano parametr
0EF0  51AA     MOVF f, W, BANKED
0EF2  E01D     BZ 0xF2E
0EF4  D98B     RCALL PL340
611:           			{
612:           #if _KEY_BBOARD==0                
613:           				WaitToLowEx(&ky[SS_SET]);		
614:           				WaitToLowEx(&ky[SS_OFF]);
615:           #endif
616:           #if _KEY_BBOARD==1                
617:           				WaitToLowEx(&ky[SS_KOM]);		
0EF6  EC65     CALL 0xBCCA, 0
0EF8  F05E     NOP
0EFA  D974     RCALL PL214
618:           				WaitToLowEx(&ky[SS_OFF]);
0EFC  EC65     CALL 0xBCCA, 0
0EFE  F05E     NOP
619:           #endif                
620:                           if(DtKNF.PRM<_KNPAR)
0F00  0E1D     MOVLW 0x1D
0F02  61D3     CPFSLT 0xD3, BANKED
0F04  D014     BRA 0xF2E
621:                           {
622:                               RSDT1.inDDTA=PZK[DtKNF.PRM].bfdta=PZK[DtKNF.PRM].dta;
0F06  51D3     MOVF 0xD3, W, BANKED
0F08  D951     RCALL PL108
0F0A  D964     RCALL PL206
0F0C  D95D     RCALL PL176
0F0E  CFE6     MOVFF POSTINC1, _UADtf_TEnd
0F10  F0A4     NOP
0F12  CFE5     MOVFF POSTDEC1, f3
0F14  F0A5     NOP
0F16  51A4     MOVF _UADtf_TEnd, W, BANKED
0F18  0102     MOVLB 0x2
0F1A  6F82     MOVWF _PFNf_str_nco, BANKED
623:                               RSDT1.inPRM=DtKNF.PRM;
0F1C  C0D3     MOVFF 0xD3, 0x281
0F1E  F281     NOP
624:                               UpdateMinMax(DtKNF.PRM);                                //aktualizuj wartosci graniczne parametru                
0F20  0100     MOVLB 0x0
0F22  51D3     MOVF 0xD3, W, BANKED
0F24  ECDD     CALL 0x7FBA, 0
0F26  F03F     NOP
625:                               DtKNF.KRK=3;											//wejscie w edycje parametru
0F28  0E03     MOVLW 0x3
0F2A  0100     MOVLB 0x0
0F2C  6FD4     MOVWF 0xD4, BANKED
626:                           }
627:           			}
628:           			key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
0F2E  D95F     RCALL PL274
0F30  EC02     CALL 0xBA04, 0
0F32  F05D     NOP
0F34  0E01     MOVLW 0x1
0F36  A0D8     BTFSS STATUS, 0, ACCESS
0F38  0E00     MOVLW 0x0
0F3A  EC20     CALL 0x6C40, 0
0F3C  F036     NOP
0F3E  6FAA     MOVWF f, BANKED
629:           			if(key!=100&&key>=20)
0F40  0E64     MOVLW 0x64
0F42  19AA     XORWF f, W, BANKED
0F44  B4D8     BTFSC STATUS, 2, ACCESS
0F46  0012     RETURN 0
0F48  0E13     MOVLW 0x13
0F4A  65AA     CPFSGT f, BANKED
0F4C  0C13     RETLW 0x13
0F4E  D94A     RCALL PL214
630:           			{
631:           				WaitToLowEx(&ky[SS_OFF]);		
0F50  EC65     CALL 0xBCCA, 0
0F52  F05E     NOP
632:           				StartRTS(_RTKONF1);										//start timera zapisu
0F54  0E00     MOVLW 0x0
0F56  EC45     CALL 0xBC8A, 0
0F58  F05E     NOP
633:           				DtKNF.KRK=4;											//wyjscie z procedury
0F5A  0E04     MOVLW 0x4
0F5C  6FD4     MOVWF 0xD4, BANKED
0F5E  0C04     RETLW 0x4
634:           			}
635:           			break;
636:           		}
637:           		//modyfikacji wartosci parametru
638:           		case 3:
639:           		{
640:           			RSDT1.inPRM=DtKNF.PRM;
0F60  C0D3     MOVFF 0xD3, 0x281
0F62  F281     NOP
641:           			RSDT1.inKRK=DtKNF.KRK;
0F64  C0D4     MOVFF 0xD4, 0x280
0F66  F280     NOP
642:           			PFNf_off=0;
0F68  9A0C     BCF PFNf_off, 5, ACCESS
643:           			PFNf_lato=1;
0F6A  880B     BSF PFNf_lato, 4, ACCESS
644:           			PFNf_zima=0;
0F6C  9811     BCF PFNf_zima, 4, ACCESS
645:           			PFNf_KnfDisErr=PZK[DtKNF.PRM].fl.no_msg;
0F6E  51D3     MOVF 0xD3, W, BANKED
0F70  D90D     RCALL PL86
0F72  ACDF     BTFSS INDF2, 6, ACCESS
0F74  D003     BRA 0xF7C
0F76  6BA4     CLRF _UADtf_TEnd, BANKED
0F78  2BA4     INCF _UADtf_TEnd, F, BANKED
0F7A  D002     BRA 0xF80
0F7C  0100     MOVLB 0x0
0F7E  6BA4     CLRF _UADtf_TEnd, BANKED
0F80  31A4     RRCF _UADtf_TEnd, W, BANKED
0F82  E302     BNC 0xF88
0F84  8E05     BSF PFNf_KnfDisErr, 7, ACCESS
0F86  D001     BRA 0xF8A
0F88  9E05     BCF PFNf_KnfDisErr, 7, ACCESS
646:           			if((PZK[DtKNF.PRM].max-PZK[DtKNF.PRM].min)>10) fst=1;			//decyzja o zmiennej szybkosci inkrementacji/dekrementacji
0F8A  0100     MOVLB 0x0
0F8C  51D3     MOVF 0xD3, W, BANKED
0F8E  D916     RCALL PL164
0F90  20F4     ADDWFC PRODH, W, ACCESS
0F92  6EDA     MOVWF FSR2H, ACCESS
0F94  CFDE     MOVFF POSTINC2, _UADtf_TEnd
0F96  F0A4     NOP
0F98  CFDD     MOVFF POSTDEC2, f3
0F9A  F0A5     NOP
0F9C  51D3     MOVF 0xD3, W, BANKED
0F9E  D8FE     RCALL PL106
0FA0  CFDE     MOVFF POSTINC2, sign
0FA2  F0A6     NOP
0FA4  CFDD     MOVFF POSTDEC2, x
0FA6  F0A7     NOP
0FA8  51A4     MOVF _UADtf_TEnd, W, BANKED
0FAA  5FA6     SUBWF sign, F, BANKED
0FAC  51A5     MOVF f3, W, BANKED
0FAE  5BA7     SUBWFB x, F, BANKED
0FB0  51A7     MOVF x, W, BANKED
0FB2  E103     BNZ 0xFBA
0FB4  0E0B     MOVLW 0xB
0FB6  5DA6     SUBWF sign, W, BANKED
0FB8  E303     BNC 0xFC0
0FBA  0E01     MOVLW 0x1
0FBC  6FA9     MOVWF dt, BANKED
0FBE  D001     BRA 0xFC2
647:           			else fst=0;
0FC0  6BA9     CLRF dt, BANKED
648:           #if _KEY_BBOARD==0 
649:                       bfdta=PZK[DtKNF.PRM].bfdta;
650:           			//ReadParam(&(PZK[DtKNF.PRM].bfdta),&zm,&zp,PZK[DtKNF.PRM].min,PZK[DtKNF.PRM].max,PZK[DtKNF.PRM].rld,fst);
651:           			ReadParam(&bfdta,&zm,&zp,PZK[DtKNF.PRM].min,PZK[DtKNF.PRM].max,PZK[DtKNF.PRM].fl.rld,fst);            
652:                       PZK[DtKNF.PRM].bfdta=bfdta;
653:           #endif            
654:           #if _KEY_BBOARD==1         
655:                       bfdta=PZK[DtKNF.PRM].bfdta;
0FC2  51D3     MOVF 0xD3, W, BANKED
0FC4  D8DB     RCALL PL52
0FC6  CFDE     MOVFF POSTINC2, bfdta
0FC8  F2F6     NOP
0FCA  CFDD     MOVFF POSTDEC2, 0x2F7
0FCC  F2F7     NOP
656:           			//ReadParamCO(&(PZK[DtKNF.PRM].bfdta),&zm,&zp,PZK[DtKNF.PRM].min,PZK[DtKNF.PRM].max,PZK[DtKNF.PRM].rld,fst);
657:                       ReadParamCO(&bfdta,&zm,&zp,PZK[DtKNF.PRM].min,PZK[DtKNF.PRM].max,PZK[DtKNF.PRM].fl.rld,fst);
0FCE  0EF6     MOVLW 0xF6
0FD0  6F8F     MOVWF _RSDT1f_NoRespToLIN, BANKED
0FD2  0E02     MOVLW 0x2
0FD4  D911     RCALL PL320
0FD6  51D3     MOVF 0xD3, W, BANKED
0FD8  D8F1     RCALL PL164
0FDA  20F4     ADDWFC PRODH, W, ACCESS
0FDC  6EDA     MOVWF FSR2H, ACCESS
0FDE  CFDE     MOVFF POSTINC2, _RSDT1f_RRD_STD
0FE0  F095     NOP
0FE2  CFDD     MOVFF POSTDEC2, _RSDT1f_RespLIDN
0FE4  F096     NOP
0FE6  51D3     MOVF 0xD3, W, BANKED
0FE8  D8D9     RCALL PL106
0FEA  CFDE     MOVFF POSTINC2, _UAD1tf_RFBrSn
0FEC  F097     NOP
0FEE  CFDD     MOVFF POSTDEC2, _UAD1tf_RFData
0FF0  F098     NOP
0FF2  51D3     MOVF 0xD3, W, BANKED
0FF4  D8CB     RCALL PL86
0FF6  0E00     MOVLW 0x0
0FF8  BEDF     BTFSC INDF2, 7, ACCESS
0FFA  0E01     MOVLW 0x1
0FFC  6F99     MOVWF _UAD1tf_RFEnd, BANKED
0FFE  C0A9     MOVFF dt, _UAD1tf_RFExt
1000  F09A     NOP
1002  EC42     CALL 0x6084, 0
1004  F030     NOP
658:                       PZK[DtKNF.PRM].bfdta=bfdta;
1006  51D3     MOVF 0xD3, W, BANKED
1008  D8B9     RCALL PL52
100A  C2F6     MOVFF bfdta, POSTINC2
100C  FFDE     NOP
100E  C2F7     MOVFF 0x2F7, POSTDEC2
1010  FFDD     NOP
659:           #endif			
660:           			RSDT1.inDDTA=(char)PZK[DtKNF.PRM].bfdta;
1012  51D3     MOVF 0xD3, W, BANKED
1014  D8B3     RCALL PL52
1016  50DF     MOVF INDF2, W, ACCESS
1018  0102     MOVLB 0x2
101A  6F82     MOVWF _PFNf_str_nco, BANKED
661:           			//Formatuj wyswietlanie
662:           			if(!(!PFNf_KnfDisErr&&(PFNf_ferr||PFNf_fmsg)))					//nie jest wyswietlany kod awaryjny?
101C  BE05     BTFSC PFNf_KnfDisErr, 7, ACCESS
101E  D003     BRA 0x1026
1020  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
1022  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
1024  D037     BRA 0x1094
663:           			{
664:           				if(!PZK[DtKNF.PRM].fl.high) PrintWPR(0,PZK[DtKNF.PRM].bfdta);
1026  0100     MOVLB 0x0
1028  51D3     MOVF 0xD3, W, BANKED
102A  D8B0     RCALL PL86
102C  BADF     BTFSC INDF2, 5, ACCESS
102E  D008     BRA 0x1040
1030  51D3     MOVF 0xD3, W, BANKED
1032  D8A4     RCALL PL52
1034  50DF     MOVF INDF2, W, ACCESS
1036  6F7E     MOVWF _PFNf_set_eco, BANKED
1038  0E00     MOVLW 0x0
103A  ECB3     CALL 0xB566, 0
103C  F05A     NOP
103E  D006     BRA 0x104C
665:           				else PrintWPR(PZK[DtKNF.PRM].bfdta,0);
1040  6B7E     CLRF _PFNf_set_eco, BANKED
1042  51D3     MOVF 0xD3, W, BANKED
1044  D89B     RCALL PL52
1046  50DF     MOVF INDF2, W, ACCESS
1048  ECB3     CALL 0xB566, 0
104A  F05A     NOP
666:           				Mark(_GZ_MXCW,PZK[DtKNF.PRM].bfdta>=PZK[DtKNF.PRM].max);
104C  51D3     MOVF 0xD3, W, BANKED
104E  D8A6     RCALL PL106
1050  D8C1     RCALL PL206
1052  6EE2     MOVWF FSR1H, ACCESS
1054  EC34     CALL 0x8068, 0
1056  F040     NOP
1058  D8EE     RCALL PL664
105A  0E0B     MOVLW 0xB
105C  EC1F     CALL 0xB83E, 0
105E  F05C     NOP
667:           				Mark(_GZ_MNCO,PZK[DtKNF.PRM].bfdta<=PZK[DtKNF.PRM].min);
1060  51D3     MOVF 0xD3, W, BANKED
1062  D88C     RCALL PL52
1064  51D3     MOVF 0xD3, W, BANKED
1066  0D09     MULLW 0x9
1068  0E87     MOVLW 0x87
106A  24F3     ADDWF PROD, W, ACCESS
106C  6EE1     MOVWF FSR1, ACCESS
106E  0E06     MOVLW 0x6
1070  20F4     ADDWFC PRODH, W, ACCESS
1072  6EE2     MOVWF FSR1H, ACCESS
1074  EC34     CALL 0x8068, 0
1076  F040     NOP
1078  D8DE     RCALL PL664
107A  0E0E     MOVLW 0xE
107C  EC1F     CALL 0xB83E, 0
107E  F05C     NOP
668:           				Mark(_GZ_TCO,PZK[DtKNF.PRM].fl.T);
1080  51D3     MOVF 0xD3, W, BANKED
1082  D884     RCALL PL86
1084  0E00     MOVLW 0x0
1086  B8DF     BTFSC INDF2, 4, ACCESS
1088  0E01     MOVLW 0x1
108A  6F7A     MOVWF _PFNf_res, BANKED
108C  0E04     MOVLW 0x4
108E  EC1F     CALL 0xB83E, 0
1090  F05C     NOP
669:           				//Mark(_GZ_BAR,PZK[DtKNF.PRM].B);
670:           			}
1092  D012     BRA 0x10B8
671:           			else
672:           			{
673:            				EndPR();
1094  ECE1     CALL 0xBBC2, 0
1096  F05D     NOP
674:           				Mark(_GZ_MXCW,0);											
1098  6B7A     CLRF _PFNf_res, BANKED
109A  0E0B     MOVLW 0xB
109C  EC1F     CALL 0xB83E, 0
109E  F05C     NOP
675:           				Mark(_GZ_MNCO,0);
10A0  6B7A     CLRF _PFNf_res, BANKED
10A2  0E0E     MOVLW 0xE
10A4  EC1F     CALL 0xB83E, 0
10A6  F05C     NOP
676:           				Mark(_GZ_TCO,0);
10A8  6B7A     CLRF _PFNf_res, BANKED
10AA  0E04     MOVLW 0x4
10AC  EC1F     CALL 0xB83E, 0
10AE  F05C     NOP
677:           				Mark(_GZ_BAR,0);
10B0  6B7A     CLRF _PFNf_res, BANKED
10B2  0E06     MOVLW 0x6
10B4  EC1F     CALL 0xB83E, 0
10B6  F05C     NOP
678:           			}
679:           #if _KEY_BBOARD==0             
680:           			key=PresKeyEX(RdPrt(S_SET),&ky[SS_SET]);
681:           #endif
682:           #if _KEY_BBOARD==1             
683:           			key=PresKeyEX(RdPrt(S_KOM),&ky[SS_KOM]);
10B8  D8B3     RCALL PL386
10BA  EC02     CALL 0xBA04, 0
10BC  F05D     NOP
10BE  0E01     MOVLW 0x1
10C0  A0D8     BTFSS STATUS, 0, ACCESS
10C2  0E00     MOVLW 0x0
10C4  EC20     CALL 0x6C40, 0
10C6  F036     NOP
10C8  6FAA     MOVWF f, BANKED
684:           #endif            
685:           			if(key>0)						//akceptacja zmian
10CA  51AA     MOVF f, W, BANKED
10CC  E015     BZ 0x10F8
10CE  D89E     RCALL PL340
686:           			{
687:           #if _KEY_BBOARD==0                
688:           				WaitToLowEx(&ky[SS_SET]);
689:           #endif
690:           #if _KEY_BBOARD==1                
691:           				WaitToLowEx(&ky[SS_KOM]);
10D0  EC65     CALL 0xBCCA, 0
10D2  F05E     NOP
692:           #endif                
693:           				PZK[DtKNF.PRM].dta=PZK[DtKNF.PRM].bfdta;
10D4  51D3     MOVF 0xD3, W, BANKED
10D6  D852     RCALL PL52
10D8  51D3     MOVF 0xD3, W, BANKED
10DA  0D09     MULLW 0x9
10DC  0E8B     MOVLW 0x8B
10DE  24F3     ADDWF PROD, W, ACCESS
10E0  6EE1     MOVWF FSR1, ACCESS
10E2  0E06     MOVLW 0x6
10E4  20F4     ADDWFC PRODH, W, ACCESS
10E6  D870     RCALL PL176
694:           				RSDT1.inDDTA=PZK[DtKNF.PRM].dta;
10E8  51D3     MOVF 0xD3, W, BANKED
10EA  D860     RCALL PL108
10EC  D89E     RCALL PL556
695:           				UpdateKnfPar(DtKNF.PRM);
10EE  ECB5     CALL 0x696A, 0
10F0  F034     NOP
696:           				DtKNF.KRK=2;
10F2  0E02     MOVLW 0x2
10F4  0100     MOVLB 0x0
10F6  6FD4     MOVWF 0xD4, BANKED
697:           			}
698:           			key=PresKeyEX(RdPrt(S_OFF),&ky[SS_OFF]);
10F8  D87A     RCALL PL274
10FA  EC02     CALL 0xBA04, 0
10FC  F05D     NOP
10FE  0E01     MOVLW 0x1
1100  A0D8     BTFSS STATUS, 0, ACCESS
1102  0E00     MOVLW 0x0
1104  EC20     CALL 0x6C40, 0
1106  F036     NOP
1108  6FAA     MOVWF f, BANKED
699:           			if(key>0)						//rezygnacja
110A  51AA     MOVF f, W, BANKED
110C  B4D8     BTFSC STATUS, 2, ACCESS
110E  0012     RETURN 0
1110  D869     RCALL PL214
700:           			{
701:           				WaitToLowEx(&ky[SS_OFF]);
1112  EC65     CALL 0xBCCA, 0
1114  F05E     NOP
702:           				PZK[DtKNF.PRM].bfdta=PZK[DtKNF.PRM].dta;
1116  51D3     MOVF 0xD3, W, BANKED
1118  D849     RCALL PL108
111A  D85C     RCALL PL206
111C  D855     RCALL PL176
703:           				RSDT1.inDDTA=PZK[DtKNF.PRM].dta;
111E  51D3     MOVF 0xD3, W, BANKED
1120  D845     RCALL PL108
1122  D883     RCALL PL556
704:           				UpdateKnfPar(DtKNF.PRM);
1124  ECB5     CALL 0x696A, 0
1126  F034     NOP
1128  D658     BRA 0xDDA
705:           				DtKNF.KRK=2;
706:           			}
707:           			break;
708:           		}
709:           		//daj czas na zapis parametrow i wyjdz z proc. konfiguracji
710:           		case 4:
112A  D875     RCALL PL348
711:           		{
712:           			RSDT1.inPRM=0;
713:           			RSDT1.inKRK=DtKNF.KRK;            
714:           			if((RTS(_RTKONF1)>=_TKNFSAV)) 
112C  0E00     MOVLW 0x0
112E  EC73     CALL 0xBEE6, 0
1130  F05F     NOP
1132  0900     IORLW 0x0
1134  E002     BZ 0x113A
1136  EFD0     GOTO 0xBBA0
1138  F05D     NOP
113A  0012     RETURN 0
715:           			{
716:           				ExitKonf();
717:           				return;
718:           			}
719:           		}
720:           	}
721:           }
115A  0012     RETURN 0
722:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/kolejka.c  ------------------
1:             /*komendy.c*/
2:             /*Procedury zwiazane z obsluga automatu*/
3:             //#include <pic18.h>
4:             #include <xc.h>
5:             #include "global.h"			//parametry globalne
6:             #include "main.tp.h"
7:             #include "kolejka.h"
8:             #include "amgs_rs9b.h"		
9:             
10:            extern DataPFN PFN;
11:            static volatile unsigned char timRing;
12:            static unsigned char ZTN,KZTN;
13:            extern volatile unsigned char xxy,zzz,vvv;
14:            extern tpRSDTA1 RSDT1;
15:            extern volatile MGSRSData MGSD;
16:            //----------------------------------------------------------
17:            #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?
18:            #define _NPOZ_KOL 10 //9liczba pozycji kolejki liczac od 1
19:            #else
20:            #define _NPOZ_KOL 8  //liczba pozycji kolejki liczac od 1
21:            #endif
22:            
23:            //----------------------------------------------------------
24:            //-------------------------------------------------------------------------------
25:            //Timer na potrzeby kroku czasowego kolejkowania (umiescic w przerwaniu od zegara TMR1)
26:            void IncRingTimer(void)
27:            {
28:            	if(timRing<255) timRing++;
C1E0  0101     MOVLB 0x1
C1E2  29CF     INCF 0xCF, W, BANKED
C1E4  A4D8     BTFSS STATUS, 2, ACCESS
C1E6  2BCF     INCF 0xCF, F, BANKED
29:            }
C1E8  0012     RETURN 0
30:            //-------------------------------------------------------------------------------
31:            //Restart zegara 
32:            void StartRingTim(void)
33:            {
34:            	timRing=0;
C24E  0101     MOVLB 0x1
C250  6BCF     CLRF 0xCF, BANKED
35:            }
C252  0012     RETURN 0
36:            //-------------------------------------------------------------------------------
37:            //Odczyt stanu zegara 
38:            unsigned char RingTim(void)
39:            {
40:            	return timRing;
C254  0101     MOVLB 0x1
C256  51CF     MOVF 0xCF, W, BANKED
41:            }
C258  0012     RETURN 0
42:            //-------------------------------------------------------------------------------
43:            //Adresowanie kolejnych pozycji kolejki
44:            void ZtnToNext(unsigned char delay)
AF9E  0100     MOVLB 0x0
AFA0  6F75     MOVWF _PFNf_prn_cs, BANKED
45:            {
46:            	if(delay)
AFA2  5175     MOVF _PFNf_prn_cs, W, BANKED
AFA4  E110     BNZ 0xAFC6
AFA6  D016     BRA 0xAFD4
47:            	{
48:            		switch(KZTN)
AFC6  0101     MOVLB 0x1
AFC8  51C5     MOVF 0xC5, W, BANKED
AFCA  E0EE     BZ 0xAFA8
AFCC  0A01     XORLW 0x1
AFCE  A4D8     BTFSS STATUS, 2, ACCESS
AFD0  0012     RETURN 0
AFD2  D7EE     BRA 0xAFB0
49:            		{
50:            			case 0:	
51:            				StartRingTim();
AFA8  EC27     CALL 0xC24E, 0
AFAA  F061     NOP
52:            				KZTN=1;
AFAC  0E01     MOVLW 0x1
AFAE  6FC5     MOVWF 0xC5, BANKED
53:            			case 1:	
54:            				if(RingTim()>5)
AFB0  EC2A     CALL 0xC254, 0
AFB2  F061     NOP
AFB4  0100     MOVLB 0x0
AFB6  6F74     MOVWF _PFNf_prODP, BANKED
AFB8  0E05     MOVLW 0x5
AFBA  6574     CPFSGT _PFNf_prODP, BANKED
AFBC  0C05     RETLW 0x5
55:            				{
56:            					ZTN++;
AFBE  D00A     BRA 0xAFD4
57:            					if(ZTN>=_NPOZ_KOL) ZTN=0;
AFC0  6BCB     CLRF 0xCB, BANKED
58:            					KZTN=0;
AFC2  6BC5     CLRF 0xC5, BANKED
AFC4  0012     RETURN 0
59:            					//zzz=ZTN;
60:            
61:            				}
62:            		}
63:            	}
64:            	else
65:            	{
66:            		ZTN++;
AFD4  0101     MOVLB 0x1
AFD6  2BCB     INCF 0xCB, F, BANKED
67:            		if(ZTN>=_NPOZ_KOL) ZTN=0;
AFD8  0E09     MOVLW 0x9
AFDA  65CB     CPFSGT 0xCB, BANKED
AFDC  D7F2     BRA 0xAFC2
AFDE  D7F0     BRA 0xAFC0
68:            		KZTN=0;
69:            	}
70:            }
71:            //----------------------------------------------------------
72:            //Kolejka procedur
73:            
74:            #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?
75:            void RingProc(void)
76:            {
77:                volatile unsigned char rk,rs;
78:            
79:                if(PFN.vUNI02<9)
7EE0  0E09     MOVLW 0x9
7EE2  0101     MOVLB 0x1
7EE4  61EC     CPFSLT 0xEC, BANKED
7EE6  D005     BRA 0x7EF2
80:                {
81:                    rk=_RD_KNF;     //ramka podstawowa
7EE8  0E02     MOVLW 0x2
7EEA  0100     MOVLB 0x0
7EEC  6F81     MOVWF _PFNf_set_ncw, BANKED
82:                    rs=_RD_STD;
7EEE  0E01     MOVLW 0x1
7EF0  D004     BRA 0x7EFA
83:                }
84:                else
85:                {
86:                    rk=_RD_KNF2;    //ramka rozszerzona
7EF2  0E05     MOVLW 0x5
7EF4  0100     MOVLB 0x0
7EF6  6F81     MOVWF _PFNf_set_ncw, BANKED
87:                    rs=_RD_STD2;        
7EF8  0E04     MOVLW 0x4
7EFA  6F82     MOVWF _PFNf_str_nco, BANKED
7EFC  D048     BRA 0x7F8E
88:                }
89:                
90:                switch(ZTN)
7F8E  0101     MOVLB 0x1
7F90  51CB     MOVF 0xCB, W, BANKED
7F92  E0B5     BZ 0x7EFE
7F94  0A01     XORLW 0x1
7F96  E0BB     BZ 0x7F0E
7F98  0A03     XORLW 0x3
7F9A  E0BF     BZ 0x7F1A
7F9C  0A01     XORLW 0x1
7F9E  E0C2     BZ 0x7F24
7FA0  0A07     XORLW 0x7
7FA2  E0C6     BZ 0x7F30
7FA4  0A01     XORLW 0x1
7FA6  E0C9     BZ 0x7F3A
7FA8  0A03     XORLW 0x3
7FAA  E0CD     BZ 0x7F46
7FAC  0A01     XORLW 0x1
7FAE  E0D8     BZ 0x7F60
7FB0  0A0F     XORLW 0xF
7FB2  E0DB     BZ 0x7F6A
7FB4  0A01     XORLW 0x1
7FB6  E0E7     BZ 0x7F86
91:                {
92:                    case 0:		//pozycja 1
93:                    {
94:                            if(TrToUNI01(rs)) ZtnToNext(0);     //paczka standardowa
7EFE  0100     MOVLB 0x0
7F00  5182     MOVF _PFNf_str_nco, W, BANKED
7F02  EC82     CALL 0x8304, 0
7F04  F041     NOP
7F06  0900     IORLW 0x0
7F08  B4D8     BTFSC STATUS, 2, ACCESS
7F0A  0012     RETURN 0
7F0C  D039     BRA 0x7F80
95:                            return;
96:                    }
97:                    case 1:
98:                    {
99:                            if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
7F0E  AC11     BTFSS PFNf_zima, 6, ACCESS
7F10  D03B     BRA 0x7F88
100:                           {
101:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
7F12  0E03     MOVLW 0x3
7F14  EC82     CALL 0x8304, 0
7F16  F041     NOP
7F18  D02D     BRA 0x7F74
102:                               {
103:                                   RSDT1f_NewLIDN=0;
104:                                   ZtnToNext(0);
105:                               }
106:                           }else ZtnToNext(1);          //przerwa
107:                           return;
108:                   }
109:                   case 2:		//pozycja 2
110:                   {
111:                           if(TrToUNI01(rk)) ZtnToNext(0);     //paczka konfiguracyjna
7F1A  0100     MOVLB 0x0
7F1C  5181     MOVF _PFNf_set_ncw, W, BANKED
7F1E  EC82     CALL 0x8304, 0
7F20  F041     NOP
7F22  D7F1     BRA 0x7F06
112:                           return;
113:                   }
114:                   case 3:
115:                   {
116:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
7F24  AC11     BTFSS PFNf_zima, 6, ACCESS
7F26  D030     BRA 0x7F88
117:                           {
118:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
7F28  0E03     MOVLW 0x3
7F2A  EC82     CALL 0x8304, 0
7F2C  F041     NOP
7F2E  D022     BRA 0x7F74
119:                               {
120:                                   RSDT1f_NewLIDN=0;
121:                                   ZtnToNext(0);
122:                               }
123:                           }else ZtnToNext(1);          //przerwa
124:                           return;
125:                   }
126:                   case 4:		//pozycja 3
127:                   {
128:                           if(TrToUNI01(rs)) ZtnToNext(0);
7F30  0100     MOVLB 0x0
7F32  5182     MOVF _PFNf_str_nco, W, BANKED
7F34  EC82     CALL 0x8304, 0
7F36  F041     NOP
7F38  D7E6     BRA 0x7F06
129:                           return;
130:                   }
131:                   case 5:
132:                   {
133:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
7F3A  AC11     BTFSS PFNf_zima, 6, ACCESS
7F3C  D025     BRA 0x7F88
134:                           {
135:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
7F3E  0E03     MOVLW 0x3
7F40  EC82     CALL 0x8304, 0
7F42  F041     NOP
7F44  D017     BRA 0x7F74
136:                               {
137:                                   RSDT1f_NewLIDN=0;
138:                                   ZtnToNext(0);
139:                               }
140:                           }else ZtnToNext(1);          //przerwa
141:                           return;
142:                   }
143:                   case 6:		//pozycja 4
144:                   {
145:                           if(PFNf_aktywne_KNF)
7F46  A008     BTFSS PFNf_b_set_nco, 0, ACCESS
7F48  D01B     BRA 0x7F80
146:                           {
147:                               if(TrToUNI01(rk))
7F4A  0100     MOVLB 0x0
7F4C  5181     MOVF _PFNf_set_ncw, W, BANKED
7F4E  EC82     CALL 0x8304, 0
7F50  F041     NOP
7F52  0900     IORLW 0x0
7F54  B4D8     BTFSC STATUS, 2, ACCESS
7F56  0012     RETURN 0
148:                               {
149:                                   ZtnToNext(0);
7F58  0E00     MOVLW 0x0
7F5A  ECCF     CALL 0xAF9E, 0
7F5C  F057     NOP
150:                                   ZtnToNext(0);
151:                               }
152:                           }
153:                           else ZtnToNext(0);
7F5E  D010     BRA 0x7F80
154:                           return;
155:                   }
156:                   case 7:		//lub pozycja 4
157:                   {
158:                           if(TrToUNI01(rs)) ZtnToNext(0);
7F60  0100     MOVLB 0x0
7F62  5182     MOVF _PFNf_str_nco, W, BANKED
7F64  EC82     CALL 0x8304, 0
7F66  F041     NOP
7F68  D7CE     BRA 0x7F06
159:                           return;
160:                   }
161:                   case 8:
162:                   {
163:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
7F6A  AC11     BTFSS PFNf_zima, 6, ACCESS
7F6C  D009     BRA 0x7F80
164:                           {
165:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
7F6E  0E03     MOVLW 0x3
7F70  EC82     CALL 0x8304, 0
7F72  F041     NOP
7F74  0102     MOVLB 0x2
7F76  6FA5     MOVWF f3, BANKED
7F78  51A5     MOVF f3, W, BANKED
7F7A  B4D8     BTFSC STATUS, 2, ACCESS
7F7C  0012     RETURN 0
166:                               {
167:                                   RSDT1f_NewLIDN=0;
7F7E  9C11     BCF PFNf_zima, 6, ACCESS
168:                                   ZtnToNext(0);
169:                               }
170:                           }else ZtnToNext(0);          
7F80  0E00     MOVLW 0x0
7F82  EFCF     GOTO 0xAF9E
7F84  F057     NOP
171:                           return;
172:                   }
173:                   case 9:		//przerwa
174:                   {
175:                           Nop();
7F86  F000     NOP
176:                           ZtnToNext(1);                 //przerwa
7F88  0E01     MOVLW 0x1
7F8A  EFCF     GOTO 0xAF9E
7F8C  F057     NOP
177:                           return;
178:                   }        
179:               }
180:           }
7FB8  0012     RETURN 0
181:           
182:           /*void RingProc(void)
183:           {
184:               volatile unsigned char rk,rs;
185:           
186:               if(PFN.vUNI02<9)
187:               {
188:                   rk=_RD_KNF;     //ramka podstawowa
189:                   rs=_RD_STD;
190:               }
191:               else
192:               {
193:                   rk=_RD_KNF2;    //ramka rozszerzona
194:                   rs=_RD_STD2;        
195:               }
196:               
197:               switch(ZTN)
198:               {
199:                   case 0:		//pozycja 1
200:                   {
201:                           if(TrToUNI01(rs)) ZtnToNext(0);
202:                           return;
203:                   }
204:                   case 1:
205:                   {
206:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
207:                           {
208:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
209:                               {
210:                                   RSDT1f_NewLIDN=0;
211:                                   ZtnToNext(0);
212:                               }
213:                           }else ZtnToNext(1);          //przerwa
214:                           return;
215:                   }
216:                   case 2:		//pozycja 2
217:                   {
218:                           if(PFNf_aktywne_KNF)
219:                           {
220:                               if(TrToUNI01(rk))
221:                               {
222:                                   ZtnToNext(0);
223:                                   ZtnToNext(0);
224:                               }
225:                           }
226:                           else ZtnToNext(0);
227:                           return;
228:                   }
229:                   case 3:         //lub pozycja 2
230:                   {
231:                           if(TrToUNI01(rs)) ZtnToNext(0);
232:                           return;
233:                   }
234:                   case 4:
235:                   {
236:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
237:                           {
238:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
239:                               {
240:                                   RSDT1f_NewLIDN=0;
241:                                   ZtnToNext(0);
242:                               }
243:                           }else ZtnToNext(1);          //przerwa
244:                           return;
245:                   }
246:                   case 5:		//pozycja 3
247:                   {
248:                           if(TrToUNI01(rs)) ZtnToNext(0);
249:                           return;
250:                   }
251:                   case 6:
252:                   {
253:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
254:                           {
255:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
256:                               {
257:                                   RSDT1f_NewLIDN=0;
258:                                   ZtnToNext(0);
259:                               }
260:                           }else ZtnToNext(1);          //przerwa
261:                           return;
262:                   }
263:                   case 7:		//pozycja 4
264:                   {
265:                           if(PFNf_aktywne_KNF)
266:                           {
267:                               if(TrToUNI01(rk))
268:                               {
269:                                   ZtnToNext(0);
270:                                   ZtnToNext(0);
271:                               }
272:                           }
273:                           else ZtnToNext(0);
274:                           return;
275:                   }
276:                   case 8:		//lub pozycja 4
277:                   {
278:                           if(TrToUNI01(rs)) ZtnToNext(0);
279:                           return;
280:                   }
281:                   case 9:
282:                   {
283:                           if(RSDT1f_NewLIDN)            //ndac komunikat LIN do UNI-02?
284:                           {
285:                               if(RSDT1.ACKUNI=TrToUNI01(_RD_LIN))
286:                               {
287:                                   RSDT1f_NewLIDN=0;
288:                                   ZtnToNext(0);
289:                               }
290:                           }else ZtnToNext(1);          //przerwa
291:                           return;
292:                   }
293:               }
294:           }*/
295:           #else
296:           void RingProc(void)
297:           {
298:               volatile unsigned char rk,rs;
299:               
300:               //vvv=PFN.vUNI02;
301:               if(PFN.vUNI02<9)
302:               {      
303:                   rk=_RD_KNF;     //ramka podstawowa
304:                   rs=_RD_STD;
305:               }
306:               else
307:               {
308:                   rk=_RD_KNF2;    //ramka rozszerzona
309:                   rs=_RD_STD2;        
310:               }
311:           	switch(ZTN)
312:               {
313:                   case 0:		//pozycja 1
314:                       TrToUNI01(rs);
315:                       return;
316:                   case 1:		//pozycja 2
317:                       if(PFNf_aktywne_KNF) TrToUNI01(rk);
318:                       else ZtnToNext(1);
319:                       return;
320:                   case 2:		//pozycja 3
321:                       if(PFNf_aktywne_KNF) TrToUNI01(rk);
322:                       else TrToUNI01(rs);
323:                       return;
324:                   case 3:		//pozycja 4
325:                       if(PFNf_aktywne_KNF) TrToUNI01(rk);
326:                       else ZtnToNext(1);
327:                       return;
328:                   case 4:		//pozycja 5
329:                       TrToUNI01(rs);
330:                       return;
331:                   case 5:		//pozycja 6
332:                       if(PFNf_aktywne_KNF) TrToUNI01(rk);
333:                       else ZtnToNext(1);
334:                       return;
335:                   case 6:		//pozycja 7
336:                       if(PFNf_aktywne_KNF) TrToUNI01(rk);
337:                       else TrToUNI01(rs);
338:                   case 7:		//pozycja 8
339:                       if(PFNf_aktywne_KNF) TrToUNI01(rs);
340:                       else ZtnToNext(1);
341:                       return;
342:               }
343:           	/*switch(ZTN)
344:               {
345:                   case 0:		//pozycja 1
346:                       TrToUNI01(_RD_STD);
347:                       return;
348:                   case 1:		//pozycja 2
349:                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_KNF);
350:                       else ZtnToNext(1);
351:                       return;
352:                   case 2:		//pozycja 3
353:                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_KNF);
354:                       else TrToUNI01(_RD_STD);
355:                       return;
356:                   case 3:		//pozycja 4
357:                                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_KNF);
358:                       else ZtnToNext(1);
359:                       return;
360:                   case 4:		//pozycja 5
361:                       TrToUNI01(_RD_STD);
362:                       return;
363:                   case 5:		//pozycja 6
364:                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_KNF);
365:                       else ZtnToNext(1);
366:                       return;
367:                   case 6:		//pozycja 7
368:                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_KNF);
369:                       else TrToUNI01(_RD_STD);
370:                   case 7:		//pozycja 8
371:                       if(PFNf_aktywne_KNF) TrToUNI01(_RD_STD);
372:                       else ZtnToNext(1);
373:                       return;
374:               }*/    
375:           }
376:           #endif //(_EXT_BOARD>=2)
377:           //----------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/keypad.c  -------------------
1:             /*keypad.c*/
2:             //Funkcje obslugi przycisku RESET dla celow konfiguracji
3:             // (!) Bazuje na funkcjach z plikow: rtimer.c
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "keypad.h"			//parametry lokalne
9:             /*---------------------------------------------------------------------------------*/
10:            /*---------------------------------------------------------------------------------*/
11:            #if _EN_PK!=0
12:            volatile StPin ky[_EN_PK];
13:            #endif
14:            #if _EN_DPK!=0
15:            volatile StPin dky[_EN_DPK];
16:            #endif
17:            #if _EN_EXPK!=0
18:            volatile StPin xky[_EN_EXPK];
19:            #endif
20:            #if _EN_EXXPK!=0
21:            volatile StPin xxky[_EN_EXXPK];
22:            #endif
23:            
24:            //-------------------------------------------------------------------------------
25:            //-------------------------------------------------------------------------------
26:            //Timer na potrzeby obslugi przyciskow (umiescic w przerwaniu od zegara TMR1)
27:            void IncKeyTimer(void)
28:            {
29:            	unsigned char i;
30:            #if _EN_PK!=0
31:            	for(i=0;i<_EN_PK;i++)
9192  6A29     CLRF _PFNf_10V_nPCO, ACCESS
91AE  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
91B0  0E09     MOVLW 0x9
91B2  6429     CPFSGT _PFNf_10V_nPCO, ACCESS
91B4  D7EF     BRA 0x9194
32:            	{
33:            		ky[i].cS++;
9194  D823     RCALL PL192
9196  2ADF     INCF INDF2, F, ACCESS
9198  D821     RCALL PL192
34:            		if(ky[i].cS>9)
919A  0E09     MOVLW 0x9
919C  64DF     CPFSGT INDF2, ACCESS
919E  D007     BRA 0x91AE
91A0  D81D     RCALL PL192
35:            		{
36:            			ky[i].cS=0;
91A2  6ADF     CLRF INDF2, ACCESS
37:            			if(ky[i].dS<255) ky[i].dS++;
91A4  D82D     RCALL PL354
91A6  28DE     INCF POSTINC2, W, ACCESS
91A8  E002     BZ 0x91AE
91AA  D82A     RCALL PL354
91AC  2ADF     INCF INDF2, F, ACCESS
38:            		}
39:            	}
40:            #endif
41:            #if _EN_DPK!=0
42:            	for(i=0;i<_EN_DPK;i++)
43:            	{
44:            		dky[i].cS++;
45:            		if(dky[i].cS>9)
46:            		{
47:            			dky[i].cS=0;
48:            			if(dky[i].dS<255) dky[i].dS++;
49:            		}
50:            	}
51:            #endif
52:            #if _EN_EXPK!=0
53:            	for(i=0;i<_EN_EXPK;i++)
54:            	{
55:            		xky[i].cS++;
56:            		if(xky[i].cS>9)
57:            		{
58:            			xky[i].cS=0;
59:            			if(xky[i].dS<255) xky[i].dS++;
60:            		}
61:            	}
62:            #endif
63:            #if _EN_EXXPK!=0
64:            	for(i=0;i<_EN_EXXPK;i++)
91B6  6A29     CLRF _PFNf_10V_nPCO, ACCESS
91D2  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
65:            	{
66:            		xxky[i].cS++;
91B8  D81A     RCALL PL200
91BA  2ADF     INCF INDF2, F, ACCESS
91BC  D818     RCALL PL200
67:            		if(xxky[i].cS>9)
91BE  0E09     MOVLW 0x9
91C0  64DF     CPFSGT INDF2, ACCESS
91C2  D007     BRA 0x91D2
91C4  D814     RCALL PL200
68:            		{
69:            			xxky[i].cS=0;
91C6  6ADF     CLRF INDF2, ACCESS
70:            			if(xxky[i].dS<255) xxky[i].dS++;
91C8  D824     RCALL PL366
91CA  28DE     INCF POSTINC2, W, ACCESS
91CC  E002     BZ 0x91D2
91CE  D821     RCALL PL366
91D0  2ADF     INCF INDF2, F, ACCESS
91D2  2A29     INCF _PFNf_10V_nPCO, F, ACCESS
91D4  0E09     MOVLW 0x9
91D6  6429     CPFSGT _PFNf_10V_nPCO, ACCESS
91D8  D7EF     BRA 0x91B8
91DA  0C09     RETLW 0x9
71:            		}
72:            	}
73:            #endif
74:            }
75:            //-------------------------------------------------------------------------------
76:            //Restart zegara przycisku
77:            void StartKeyTim(volatile StPin *ky)
78:            {
79:            	(*ky).cS=0;
BDEA  EE20     LFSR 2, 0x1
BDEC  F001     NOP
BDEE  D804     RCALL PL546
80:            	(*ky).dS=0;
BDF0  EE20     LFSR 2, 0x2
BDF2  F002     NOP
BDF4  D801     RCALL PL546
81:            }
BDF6  0C00     RETLW 0x0
82:            //-------------------------------------------------------------------------------
83:            //Odczyt stanu zegara przycisku
84:            unsigned char KeyTim(volatile StPin *ky)
85:            {
86:            	return (*ky).dS;
C116  0100     MOVLB 0x0
C118  EE20     LFSR 2, 0x2
C11A  F002     NOP
C11C  5174     MOVF _PFNf_prODP, W, BANKED
C11E  26D9     ADDWF FSR2, F, ACCESS
C120  5175     MOVF _PFNf_prn_cs, W, BANKED
C122  EFAB     GOTO 0xBF56
C124  F05F     NOP
87:            }
88:            /*---------------------------------------------------------------------------------*/
89:            //-----------------------------------------------------------
90:            //Funkcja detekcji nacisniecia przycisku (wersja podstawowa)
91:            //k-fizyczne wejscie procesora dla przycisku
92:            //ky - pamiec stanu przycisku
93:            //ng - typ reakcji: dla 0 zwraca 1 przy nacisnieciu przycisku, dla 1 przy puszczeniu przycisku 
94:            //np. PresKey(RdPrt(S_SET),&ky[S_SET])
95:            /*
96:            #if _EN_PK!=0
97:            unsigned char PresKey(unsigned char k,StPin *ky,unsigned char ng)
98:            {
99:            	(*ky).bk=(k)?1:0;
100:           	if ((!ng&&(!(*ky).sbk&&(*ky).bk))||(ng&&((*ky).sbk&&!(*ky).bk)))	//nacisnieto przycisk?
101:           	{
102:           		(*ky).sbk=((*ky).bk)?1:0;
103:           		return 1;
104:           	}
105:           	(*ky).sbk=((*ky).bk)?1:0;
106:           	return 0;
107:           }
108:           void SetBufKey(StPin *ky)
109:           {
110:           	(*ky).sbk=1;
111:           }
112:           void ResBufKey(StPin *ky)
113:           {
114:           	(*ky).sbk=0;
115:           }
116:           
117:           #endif
118:           */
119:           //-----------------------------------------------------------
120:           //Funkcja detekcji nacisniecia przycisku (I wersja rozszerzona)
121:           //k-fizyczne wejscie procesora dla przycisku
122:           //ky - pamiec stanu przycisku
123:           //ng - typ reakcji: dla 0 zwraca 1 przy nacisnieciu przycisku, dla 1 przy puszczeniu przycisku 
124:           //np. PresKey(RdPrt(S_SET),&ky[S_SET])
125:           //funkcja zwraca:
126:           //0 - przycisk w stanie spoczynku
127:           //1...99 - przycisk wcisniety lub podtrzymanie stanu przycisku, wartosc rowna czasowi przytrzymania przycisku
128:           //100 - dla szybkiego nacisniecia przycisku
129:           #if _EN_PK!=0
130:           unsigned char PresKeyEX(unsigned char k,volatile StPin *ky)
6C40  6F7C     MOVWF _PFNf_setKey, BANKED
131:           {
132:           
133:           	(*ky).bk=(k)?1:0;
6C42  0100     MOVLB 0x0
6C44  517C     MOVF _PFNf_setKey, W, BANKED
6C46  E003     BZ 0x6C4E
6C48  6B78     CLRF _PFNf_prn_pp, BANKED
6C4A  2B78     INCF _PFNf_prn_pp, F, BANKED
6C4C  D002     BRA 0x6C52
6C4E  0100     MOVLB 0x0
6C50  6B78     CLRF _PFNf_prn_pp, BANKED
6C52  D897     RCALL PL138
6C54  50DF     MOVF INDF2, W, ACCESS
6C56  1978     XORWF _PFNf_prn_pp, W, BANKED
6C58  0BFE     ANDLW 0xFE
6C5A  1978     XORWF _PFNf_prn_pp, W, BANKED
6C5C  6EDF     MOVWF INDF2, ACCESS
134:           	switch ((*ky).krk)
6C5E  D078     BRA 0x6D50
6D50  EE20     LFSR 2, 0x3
135:           	{
136:           		//oczekiwanie na nacisniecie przycisku
137:           		case 0:
138:           		{
139:           			if(!(*ky).sbk&&(*ky).bk) //nacisnieto przycisk?
6C60  D890     RCALL PL138
6C62  B2DF     BTFSC INDF2, 1, ACCESS
6C64  D00E     BRA 0x6C82
6C66  D88D     RCALL PL138
6C68  A0DF     BTFSS INDF2, 0, ACCESS
6C6A  D00B     BRA 0x6C82
6C6C  D88A     RCALL PL138
140:           			{
141:           				(*ky).sbk=1;//((*ky).bk)?1:0;
6C6E  82DF     BSF INDF2, 1, ACCESS
142:           				StartKeyTim(ky);		
6C70  D892     RCALL PL716
6C72  ECF5     CALL 0xBDEA, 0
6C74  F05E     NOP
143:           				(*ky).krk=1;
6C76  EE20     LFSR 2, 0x3
6C78  F003     NOP
6C7A  D87E     RCALL PL136
6C7C  0E01     MOVLW 0x1
6C7E  6EDF     MOVWF INDF2, ACCESS
144:           			}
6C80  0C00     RETLW 0x0
145:           			else (*ky).sbk=((*ky).bk)?1:0;
6C82  D87F     RCALL PL138
6C84  C076     MOVFF _PFNf_prn_in, FSR1
6C86  FFE1     NOP
6C88  C077     MOVFF _PFNf_prn_pg, FSR1H
6C8A  FFE2     NOP
6C8C  B0DF     BTFSC INDF2, 0, ACCESS
6C8E  D002     BRA 0x6C94
6C90  92E7     BCF INDF1, 1, ACCESS
6C92  D002     BRA 0x6C98
6C94  0100     MOVLB 0x0
6C96  82E7     BSF INDF1, 1, ACCESS
146:           			return 0;
6C98  0C00     RETLW 0x0
147:           		}
148:           		//oczekiwanie na puszczenie przycisku
149:           		case 1:
150:           		{
151:           			(*ky).val=KeyTim(ky)+1;	//kod przytrzymania przycisku
6C9A  D878     RCALL PL538
6C9C  EC8B     CALL 0xC116, 0
6C9E  F060     NOP
6CA0  6F78     MOVWF _PFNf_prn_pp, BANKED
6CA2  2B78     INCF _PFNf_prn_pp, F, BANKED
6CA4  D862     RCALL PL76
6CA6  C078     MOVFF _PFNf_prn_pp, INDF2
6CA8  FFDF     NOP
6CAA  D85F     RCALL PL76
152:           			if((*ky).val>99) (*ky).val=99;
6CAC  0E63     MOVLW 0x63
6CAE  64DF     CPFSGT INDF2, ACCESS
6CB0  D003     BRA 0x6CB8
6CB2  D85B     RCALL PL76
6CB4  0E63     MOVLW 0x63
6CB6  6EDF     MOVWF INDF2, ACCESS
153:           			if((*ky).sbk&&!(*ky).bk) 	//puszczono przycisk?
6CB8  D864     RCALL PL138
6CBA  A2DF     BTFSS INDF2, 1, ACCESS
6CBC  D024     BRA 0x6D06
6CBE  D861     RCALL PL138
6CC0  B0DF     BTFSC INDF2, 0, ACCESS
6CC2  D021     BRA 0x6D06
6CC4  D85E     RCALL PL138
154:           			{
155:           				(*ky).sbk=0;//((*ky).bk)?1:0;
6CC6  92DF     BCF INDF2, 1, ACCESS
156:           				if(((*ky).val-1)<_TFASTK)
6CC8  6978     SETF _PFNf_prn_pp, BANKED
6CCA  6979     SETF _PFNf_prn_res, BANKED
6CCC  D84E     RCALL PL76
6CCE  50DF     MOVF INDF2, W, ACCESS
6CD0  6F7A     MOVWF _PFNf_res, BANKED
6CD2  6B7B     CLRF _PFNf_rozruch, BANKED
6CD4  5178     MOVF _PFNf_prn_pp, W, BANKED
6CD6  277A     ADDWF _PFNf_res, F, BANKED
6CD8  5179     MOVF _PFNf_prn_res, W, BANKED
6CDA  237B     ADDWFC _PFNf_rozruch, F, BANKED
6CDC  BF7B     BTFSC _PFNf_rozruch, 7, BANKED
6CDE  D005     BRA 0x6CEA
6CE0  517B     MOVF _PFNf_rozruch, W, BANKED
6CE2  E106     BNZ 0x6CF0
6CE4  0E08     MOVLW 0x8
6CE6  5D7A     SUBWF _PFNf_res, W, BANKED
6CE8  E203     BC 0x6CF0
157:           				{
158:           					(*ky).val=100;			//kod szybkiego klikniecia
6CEA  D83F     RCALL PL76
6CEC  0E64     MOVLW 0x64
6CEE  6EDF     MOVWF INDF2, ACCESS
159:           				}
160:           				StartKeyTim(ky);		
6CF0  D852     RCALL PL716
6CF2  ECF5     CALL 0xBDEA, 0
6CF4  F05E     NOP
161:           				(*ky).krk=2;
6CF6  EE20     LFSR 2, 0x3
6CF8  F003     NOP
6CFA  D83E     RCALL PL136
6CFC  0E02     MOVLW 0x2
6CFE  6EDF     MOVWF INDF2, ACCESS
6D00  D834     RCALL PL76
162:           				return (*ky).val;
6D02  50DF     MOVF INDF2, W, ACCESS
6D04  0012     RETURN 0
163:           			}
164:           			return (*ky).val;
6D06  D831     RCALL PL76
6D08  50DF     MOVF INDF2, W, ACCESS
6D0A  0012     RETURN 0
165:           		}
166:           		//podtrzymanie stanu przycisku
167:           		case 2:
168:           		{
169:           			if((KeyTim(ky)>1&&!(*ky).sbk&&(*ky).bk)||KeyTim(ky)>=_TMEMK)	//ponownie nacisnieto przycisk lub minal czas podtrzymania?
6D0C  D83F     RCALL PL538
6D0E  EC8B     CALL 0xC116, 0
6D10  F060     NOP
6D12  6F78     MOVWF _PFNf_prn_pp, BANKED
6D14  0E01     MOVLW 0x1
6D16  6578     CPFSGT _PFNf_prn_pp, BANKED
6D18  D006     BRA 0x6D26
6D1A  D833     RCALL PL138
6D1C  B2DF     BTFSC INDF2, 1, ACCESS
6D1E  D003     BRA 0x6D26
6D20  D830     RCALL PL138
6D22  B0DF     BTFSC INDF2, 0, ACCESS
6D24  D010     BRA 0x6D46
6D26  D832     RCALL PL538
6D28  EC8B     CALL 0xC116, 0
6D2A  F060     NOP
6D2C  6F78     MOVWF _PFNf_prn_pp, BANKED
6D2E  0E09     MOVLW 0x9
6D30  6578     CPFSGT _PFNf_prn_pp, BANKED
6D32  D001     BRA 0x6D36
6D34  D008     BRA 0x6D46
170:           			{
171:           				(*ky).krk=0;
172:            				return 0;
173:           			}
174:           			return (*ky).val;					//przez 1 sek podtrzymaj kod stanu przycisku	
6D36  D819     RCALL PL76
6D38  50DF     MOVF INDF2, W, ACCESS
6D3A  0012     RETURN 0
175:           		}
176:           		case 3:									//oczekiwanie na puszczenie przycisku
177:           		{
178:           			if(!(*ky).bk) 			//puszczono przycisk?
6D3C  D822     RCALL PL138
6D3E  B0DF     BTFSC INDF2, 0, ACCESS
6D40  0C00     RETLW 0x0
6D42  D81F     RCALL PL138
179:           			{
180:           				(*ky).sbk=0;
6D44  92DF     BCF INDF2, 1, ACCESS
181:           				(*ky).krk=0;
6D46  EE20     LFSR 2, 0x3
6D48  F003     NOP
6D4A  D816     RCALL PL136
6D4C  6ADF     CLRF INDF2, ACCESS
6D4E  0C00     RETLW 0x0
6D50  EE20     LFSR 2, 0x3
6D52  F003     NOP
6D54  D811     RCALL PL136
6D56  50DF     MOVF INDF2, W, ACCESS
6D58  E083     BZ 0x6C60
6D5A  0A01     XORLW 0x1
6D5C  E09E     BZ 0x6C9A
6D5E  0A03     XORLW 0x3
6D60  E0D5     BZ 0x6D0C
6D62  0A01     XORLW 0x1
6D64  A4D8     BTFSS STATUS, 2, ACCESS
6D66  0C00     RETLW 0x0
6D68  D7E9     BRA 0x6D3C
182:            			}
183:           			return 0;
184:           		}			
185:           	}
186:           	return 0;
187:           }
188:           //Resetuje czas podtrzymania
189:           void ResBufKeyEx(volatile StPin *ky)						//resetuj podtrzymanie kodu stanu przycisku
190:           {
191:           	(*ky).sbk=0;
BAEE  C074     MOVFF _PFNf_prODP, FSR2
BAF0  FFD9     NOP
BAF2  C075     MOVFF _PFNf_prn_cs, FSR2H
BAF4  FFDA     NOP
BAF6  92DF     BCF INDF2, 1, ACCESS
192:           	(*ky).krk=0;
BAF8  EE20     LFSR 2, 0x3
BAFA  F003     NOP
BAFC  D804     RCALL PL586
193:           	(*ky).val=0;
BAFE  EE20     LFSR 2, 0x4
BB00  F004     NOP
BB02  D801     RCALL PL586
194:           }
BB04  0C00     RETLW 0x0
195:           //Wymusza oczekiwanie na zwolnienie przyciskow (na czas oczekiwania funkcja zwraca 0)
196:           void WaitToLowEx(volatile StPin *ky)						//wymus oczekiwanie na puszczenie przycisku
197:           {
198:           	(*ky).krk=3;
BCCA  EE20     LFSR 2, 0x3
BCCC  F003     NOP
BCCE  D807     RCALL PL706
BCD0  0E03     MOVLW 0x3
BCD2  6EDF     MOVWF INDF2, ACCESS
199:           	(*ky).val=0;
BCD4  EE20     LFSR 2, 0x4
BCD6  F004     NOP
BCD8  D802     RCALL PL706
BCDA  6ADF     CLRF INDF2, ACCESS
200:           }
BCDC  0C00     RETLW 0x0
201:           #endif
202:           /*---------------------------------------------------------------------------------*/
203:           #if _EN_DPK!=0
204:           //Funkcja detekcji podwojnego nacisniecia przycisku
205:           //k-fizyczne wejscie procesora dla przycisku
206:           //np. DoublePresKey(RdPrt(S_SET),&ky[S_SET])
207:           unsigned char DoublePresKey(unsigned char k,volatile StPin *ky)
208:           {
209:           	(*ky).c=PresKey(k,ky); 
210:           	if(!(*ky).dk&&(*ky).c) 			//pierwsze nacisniecie przycisku?
211:           	{
212:           		(*ky).dk=1;
213:           		StartKeyTim(ky);
214:           		return 0;
215:           	}
216:           	(*ky).t=(KeyTim(ky)<=5);
217:           	if((*ky).dk&&(*ky).t) 						
218:           	{
219:           		if((*ky).c)					//drugie nacisniecie przycisku?
220:           		{	
221:           			(*ky).dk=0;
222:           			return 1;
223:           		}
224:           	}
225:           	if(!(*ky).t) (*ky).dk=0;		//czas uplynol?
226:           	return 0;	
227:           }
228:           #endif
229:           /*---------------------------------------------------------------------------------*/
230:           #if _EN_EXPK!=0
231:           //Funkcja detekcji nacisniecia przycisku (wersja zaawansowana)
232:           //dla danych liczbowych (<2.5 cyfry)
233:           //k-fizyczne wejscie procesora dla przycisku,
234:           //dTim-czas po jakim przy nacisnietym przycisku nastapi wygenerowanie ciagu impulsów [*0.1sek],
235:           //pTim-czas miedzy kolejnymi impulsami przy spelnieniu warunku dTim [*0.1sek]
236:           //zwraca 0 dla przycisku w stanie spoczynku
237:           //zwraca 1 dla pojedynczego nacisniecia przycisku
238:           //zwraca 2 dla impulsu w trakcie podtrzymania pzrycisku
239:           //np. ExPresKey(RdPrt(S_OFF),&xxky[S_OFF],50,1)
240:           unsigned char ExPresKey(unsigned char k,volatile StPin *ky,unsigned char dTim,unsigned char pTim)
241:           {
242:           	(*ky).bk=(k)?1:0;
243:           	
244:           	if (!(*ky).sbk&&(*ky).bk)
245:           	{
246:           		(*ky).sbk=((*ky).bk)?1:0;
247:           		StartKeyTim(ky);
248:           		return 1;						//nacisnieto przycisk
249:           	}
250:           	(*ky).sbk=((*ky).bk)?1:0;
251:           	if((*ky).sbk&&(*ky).bk)
252:           	{
253:           		if(!(*ky).ap&&KeyTim(ky)>=dTim) //przytrzymano przycisk
254:           		{
255:           			(*ky).ap=1;
256:           			StartKeyTim(ky);
257:           			return 2;				//pierwszy impuls
258:           		}
259:           		if((*ky).ap&&KeyTim(ky)>=pTim)
260:           		{
261:           			StartKeyTim(ky);		//kolejne impulsy co pTim
262:           			return 2;
263:           		}
264:           	}else (*ky).ap=0;
265:           	return 0;	
266:           }
267:           void ExResKey(volatile StPin *ky)
268:           {
269:           	(*ky).bk=0;
270:           	(*ky).sbk=0;
271:           	(*ky).ap=0;
272:           	StartKeyTim(ky);
273:           }
274:           #endif
275:           /*---------------------------------------------------------------------------------*/
276:           #if _EN_EXXPK!=0
277:           //Funkcja detekcji nacisniecia przycisku (wersja b.zaawansowana)
278:           //dla duzych danych liczbowych (>2.5 cyfry)
279:           //k-fizyczne wejscie procesora dla przycisku,
280:           //dTim-czas po jakim przy nacisnietym przycisku nastapi wygenerowanie ciagu impulsów [*0.1sek],
281:           //pTim-czas miedzy kolejnymi impulsami przy spelnieniu warunku dTim [*0.1sek]
282:           //zwraca 0 dla przycisku w stanie spoczynku
283:           //zwraca 1 dla pojedynczego nacisniecia przycisku
284:           //zwraca 2 dla impulsu w trakcie podtrzymania pzrycisku
285:           //zwraca 3 miedzy impulsami w trakcie podtrzymania pzrycisku 
286:           //np. ExxPresKey(RdPrt(S_OFF),&xxky[S_OFF],50,1)
287:           unsigned char ExxPresKey(unsigned char k,volatile StPin *ky,unsigned char dTim,unsigned char pTim)
78EC  6F7B     MOVWF _PFNf_rozruch, BANKED
288:           {
289:           	(*ky).bk=(k)?1:0;
78EE  0100     MOVLB 0x0
78F0  517B     MOVF _PFNf_rozruch, W, BANKED
78F2  E003     BZ 0x78FA
78F4  6B7A     CLRF _PFNf_res, BANKED
78F6  2B7A     INCF _PFNf_res, F, BANKED
78F8  D002     BRA 0x78FE
78FA  0100     MOVLB 0x0
78FC  6B7A     CLRF _PFNf_res, BANKED
78FE  D871     RCALL __end_of_ExxPresKey
7900  50DF     MOVF INDF2, W, ACCESS
7902  197A     XORWF _PFNf_res, W, BANKED
7904  0BFE     ANDLW 0xFE
7906  197A     XORWF _PFNf_res, W, BANKED
7908  6EDF     MOVWF INDF2, ACCESS
790A  D86B     RCALL __end_of_ExxPresKey
290:           	
291:           	if((*ky).fl&&(*ky).sbk&&!(*ky).bk)
790C  A8DF     BTFSS INDF2, 4, ACCESS
790E  D013     BRA 0x7936
7910  D868     RCALL __end_of_ExxPresKey
7912  A2DF     BTFSS INDF2, 1, ACCESS
7914  D010     BRA 0x7936
7916  D865     RCALL __end_of_ExxPresKey
7918  B0DF     BTFSC INDF2, 0, ACCESS
791A  D00D     BRA 0x7936
791C  D862     RCALL __end_of_ExxPresKey
292:           	{
293:           		(*ky).fl=0;
791E  98DF     BCF INDF2, 4, ACCESS
7920  D860     RCALL __end_of_ExxPresKey
294:           		(*ky).sbk=((*ky).bk)?1:0;
7922  D869     RCALL PL428
7924  B0DF     BTFSC INDF2, 0, ACCESS
7926  D002     BRA 0x792C
7928  92E7     BCF INDF1, 1, ACCESS
792A  D002     BRA 0x7930
792C  0100     MOVLB 0x0
792E  82E7     BSF INDF1, 1, ACCESS
295:           		StartKeyTim(ky);
7930  D85D     RCALL PL420
7932  ECF5     CALL 0xBDEA, 0
7934  F05E     NOP
296:           	}
297:           	if (!(*ky).sbk&&(*ky).bk)
7936  D855     RCALL __end_of_ExxPresKey
7938  B2DF     BTFSC INDF2, 1, ACCESS
793A  D00F     BRA 0x795A
793C  D852     RCALL __end_of_ExxPresKey
793E  A0DF     BTFSS INDF2, 0, ACCESS
7940  D00C     BRA 0x795A
7942  D84F     RCALL __end_of_ExxPresKey
7944  D858     RCALL PL428
298:           	{
299:           		(*ky).sbk=((*ky).bk)?1:0;
7946  B0DF     BTFSC INDF2, 0, ACCESS
7948  D002     BRA 0x794E
794A  92E7     BCF INDF1, 1, ACCESS
794C  D002     BRA 0x7952
794E  0100     MOVLB 0x0
7950  82E7     BSF INDF1, 1, ACCESS
7952  D84C     RCALL PL420
300:            		StartKeyTim(ky);
7954  ECF5     CALL 0xBDEA, 0
7956  F05E     NOP
301:           		return 1;
7958  0C01     RETLW 0x1
302:           	}			
303:           	if (!(*ky).fl&&(*ky).sbk&&!(*ky).bk)		
795A  D843     RCALL __end_of_ExxPresKey
795C  B8DF     BTFSC INDF2, 4, ACCESS
795E  D011     BRA 0x7982
7960  D840     RCALL __end_of_ExxPresKey
7962  A2DF     BTFSS INDF2, 1, ACCESS
7964  D00E     BRA 0x7982
7966  D83D     RCALL __end_of_ExxPresKey
7968  B0DF     BTFSC INDF2, 0, ACCESS
796A  D00B     BRA 0x7982
796C  D83A     RCALL __end_of_ExxPresKey
796E  D843     RCALL PL428
304:           	{
305:           		(*ky).sbk=((*ky).bk)?1:0;	
7970  B0DF     BTFSC INDF2, 0, ACCESS
7972  D002     BRA 0x7978
7974  92E7     BCF INDF1, 1, ACCESS
7976  D002     BRA 0x797C
7978  0100     MOVLB 0x0
797A  82E7     BSF INDF1, 1, ACCESS
797C  D837     RCALL PL420
306:           		StartKeyTim(ky);			
797E  ECF5     CALL 0xBDEA, 0
7980  F05E     NOP
307:           	}
308:           	if((*ky).sbk&&(*ky).bk)				
7982  D82F     RCALL __end_of_ExxPresKey
7984  A2DF     BTFSS INDF2, 1, ACCESS
7986  D01F     BRA 0x79C6
7988  D82C     RCALL __end_of_ExxPresKey
798A  A0DF     BTFSS INDF2, 0, ACCESS
798C  D01C     BRA 0x79C6
798E  D829     RCALL __end_of_ExxPresKey
309:           	{
310:           		
311:           		if(!(*ky).ap&&KeyTim(ky)>=dTim) 
7990  B4DF     BTFSC INDF2, 2, ACCESS
7992  D00B     BRA 0x79AA
7994  D835     RCALL PL724
7996  EC8B     CALL 0xC116, 0
7998  F060     NOP
799A  6F7A     MOVWF _PFNf_res, BANKED
799C  5178     MOVF _PFNf_prn_pp, W, BANKED
799E  5D7A     SUBWF _PFNf_res, W, BANKED
79A0  E304     BNC 0x79AA
79A2  D81F     RCALL __end_of_ExxPresKey
312:           		{
313:           			(*ky).fl=1;
79A4  88DF     BSF INDF2, 4, ACCESS
79A6  D81D     RCALL __end_of_ExxPresKey
314:           			(*ky).ap=1;
79A8  84DF     BSF INDF2, 2, ACCESS
315:           		}
79AA  D81B     RCALL __end_of_ExxPresKey
316:           		if((*ky).ap&&KeyTim(ky)>=pTim)
79AC  A4DF     BTFSS INDF2, 2, ACCESS
79AE  D00D     BRA 0x79CA
79B0  D827     RCALL PL724
79B2  EC8B     CALL 0xC116, 0
79B4  F060     NOP
79B6  6F7A     MOVWF _PFNf_res, BANKED
79B8  5179     MOVF _PFNf_prn_res, W, BANKED
79BA  5D7A     SUBWF _PFNf_res, W, BANKED
79BC  E306     BNC 0x79CA
79BE  D816     RCALL PL420
317:           		{
318:           			StartKeyTim(ky);
79C0  ECF5     CALL 0xBDEA, 0
79C2  F05E     NOP
319:           			return 2;
79C4  0C02     RETLW 0x2
320:           		}
321:           	}else (*ky).ap=0;	
79C6  D80D     RCALL __end_of_ExxPresKey
79C8  94DF     BCF INDF2, 2, ACCESS
322:           	(*ky).sbk=((*ky).bk)?1:0;	
79CA  D80B     RCALL __end_of_ExxPresKey
79CC  D814     RCALL PL428
79CE  B0DF     BTFSC INDF2, 0, ACCESS
79D0  D002     BRA 0x79D6
79D2  92E7     BCF INDF1, 1, ACCESS
79D4  D002     BRA 0x79DA
79D6  0100     MOVLB 0x0
79D8  82E7     BSF INDF1, 1, ACCESS
79DA  D803     RCALL __end_of_ExxPresKey
323:           	if ((*ky).ap) return 3;
79DC  B4DF     BTFSC INDF2, 2, ACCESS
79DE  0C03     RETLW 0x3
324:           	return 0;	
325:           }
79E0  0C00     RETLW 0x0
326:           void ExxResKey(volatile StPin *ky)
327:           {
328:           	(*ky).bk=0;
329:           	(*ky).sbk=0;
330:           	(*ky).ap=0;
331:           	StartKeyTim(ky);
332:           }
333:           #endif
334:           /*---------------------------------------------------------------------------------*/
335:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/isr.c  ----------------------
1:             /*--------------------------------------------------------------*/
2:             /*isr.c*/
3:             /*obsluga przerwan*/
4:             /*--------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"				//parametry globalne
8:             #include "isr.h"				//parametry lokalne
9:             #include "ot.tp.h"				//parametry lokalne
10:            volatile unsigned char x,y;
11:            extern volatile unsigned char xxy,zzz,vvv;
12:            extern volatile tpOTDta OT;
13:            //-------------------------------------------------------------------------
14:            //HIHG priority interrupt
15:            void interrupt H_ISR(void)
0008  824B     BSF 0x4B, 1, ACCESS
000A  CFD9     MOVFF FSR2, _MGSDf_TransDataTR
000C  F026     NOP
000E  CFDA     MOVFF FSR2H, _MGSDf_TransOK
0010  F027     NOP
0012  EF12     GOTO 0x9224
0014  F049     NOP
16:            {
17:                //komunikacja OT - timer0
18:                if((TMR0IF)&&(TMR0IE))
9224  B4F2     BTFSC INTCON, 2, ACCESS
9226  AAF2     BTFSS INTCON, 5, ACCESS
9228  D010     BRA 0x924A
19:                {
20:            #if (_EXT_BOARD>=3)        
21:                    ReloadTMR0(OT.prelTMR0+OT.pop);             //gdzie OT.pop dla odbioru danych stanowi poprawke dla pkt pomiaru
922A  0101     MOVLB 0x1
922C  512C     MOVF _PFNf_EnLIN, W, BANKED
922E  2517     ADDWF _LIN1f_ERRR, W, BANKED
9230  6E15     MOVWF _LIN1f_Busy, ACCESS
9232  512D     MOVF _PFNf_FLIN, W, BANKED
9234  2118     ADDWFC _LIN1f_FAdta, W, BANKED
9236  6E16     MOVWF _LIN1f_CHK, ACCESS
9238  EC91     CALL 0xB122, 0
923A  F058     NOP
22:            #endif
23:                    OT.pop=0;
923C  0101     MOVLB 0x1
923E  6B2C     CLRF _PFNf_EnLIN, BANKED
9240  6B2D     CLRF _PFNf_FLIN, BANKED
24:                    TMR0IF=0;
9242  94F2     BCF INTCON, 2, ACCESS
25:            #if (_EXT_BOARD>=3)    
26:                    IntOTDeamon();                              //synchronizacja, odbior i transmisja ramki OT            
9244  EC1B     CALL 0x8236, 0
9246  F041     NOP
9248  D030     BRA 0x92AA
27:            #endif
28:                    return;
29:                }    
30:                //komunikacja OT - INT0
31:                if((INT0IF) && (INT0IE))          //transmisja OT - zbocze opadajace
924A  B2F2     BTFSC INTCON, 1, ACCESS
924C  A8F2     BTFSS INTCON, 4, ACCESS
924E  D004     BRA 0x9258
32:                {
33:                    INT0IF=0;
9250  92F2     BCF INTCON, 1, ACCESS
34:                    //if(_OUTX) _OUTX=0;
35:                    //else _OUTX=1;            
36:            #if (_EXT_BOARD>=3)            
37:                    IntINT0();
9252  EC0E     CALL 0x981C, 0
9254  F04C     NOP
9256  D029     BRA 0x92AA
38:            #endif            
39:                    return;
40:                }
41:                //komunikacja OT - INT1
42:                if((INT1IF) && (INT1IE))          //transmisja OT - zbocze narastajace
9258  B0F0     BTFSC INTCON3, 0, ACCESS
925A  A6F0     BTFSS INTCON3, 3, ACCESS
925C  D004     BRA 0x9266
43:                {
44:                    INT1IF=0; 
925E  90F0     BCF INTCON3, 0, ACCESS
45:            #if (_EXT_BOARD>=3)            
46:                    IntINT1();
9260  ECAD     CALL 0xBB5A, 0
9262  F05D     NOP
9264  D022     BRA 0x92AA
47:            #endif
48:                    return;
49:                }
50:                /*
51:                //komunikacja OT - timer0
52:                if((TMR0IF)&&(TMR0IE))
53:                {
54:                    TMR0IF=0;
55:            #if (_EXT_BOARD>=3)    
56:                    ReloadTMR0(OT.prelTMR0);
57:                    IntOTDeamon();         //synchronizacja, odbior i transmisja ramki OT            
58:            #endif
59:                    return;
60:                } */         
61:                    
62:                //Timer zwiazany z protokolami transmisji danych
63:                if((TMR3IF)&&(TMR3IE))
9266  B2A1     BTFSC PIR2, 1, ACCESS
9268  A2A0     BTFSS PIE2, 1, ACCESS
926A  D008     BRA 0x927C
64:                {
65:                        TMR3IF=0;
926C  92A1     BCF PIR2, 1, ACCESS
66:                        ReloadTimer3();         //obsluga zegara Timer3
926E  EC3C     CALL 0xC278, 0
9270  F061     NOP
67:                        IncRSTimer();           //obsluga timerow modulu MGS_RS
9272  EC23     CALL 0xC246, 0
9274  F061     NOP
68:                        #if (_EXT_BOARD>=2)
69:                            IntLIN1Tim();           //obsluga zegarow transmitera LIN1
9276  EC98     CALL 0xB530, 0
9278  F05A     NOP
927A  D017     BRA 0x92AA
70:                        #endif
71:                        return;
72:                }
73:                
74:            #if (_EXT_BOARD!=0)
75:                    //Komunikacja z plyta UNI-02
76:                    //UART2
77:                    if((RC2IF)&&(RC2IE))		//odbior RS232 (RCIF jest zerowane sprzetowo)
927C  BAA4     BTFSC PIR3, 5, ACCESS
927E  AAA3     BTFSS PIE3, 5, ACCESS
9280  D003     BRA 0x9288
78:                    {
79:                            IntUSARTRC();
9282  ECED     CALL 0x8BDA, 0
9284  F045     NOP
9286  D011     BRA 0x92AA
80:                            return;
81:                    }
82:                    //UART2
83:                    if((TX2IF)&&(TX2IE))		//transmisja RS232 (TXIF jest zerowane sprzetowo)
9288  B8A4     BTFSC PIR3, 4, ACCESS
928A  A8A3     BTFSS PIE3, 4, ACCESS
928C  D003     BRA 0x9294
84:                    {
85:                            IntUSARTTR();
928E  EC8C     CALL 0xAF18, 0
9290  F057     NOP
9292  D00B     BRA 0x92AA
86:                            return;
87:                    }
88:            #if (_EXT_BOARD>=2)
89:                    //Komunikacja poprzez magistrale LIN z managerem kaskady lub regulatorem RT
90:                    //UART1 (LIN SLAVE)
91:                    if((RC1IF) && (RC1IE))          //odbior RS232 (RCIF jest zerowane sprzetowo)
9294  BA9E     BTFSC PIR1, 5, ACCESS
9296  AA9D     BTFSS PIE1, 5, ACCESS
9298  D003     BRA 0x92A0
92:                    {
93:                            IntUSART1SRC();             //slave
929A  EC60     CALL 0xA0C0, 0
929C  F050     NOP
929E  D005     BRA 0x92AA
94:                            return;
95:                    }
96:                   //UART1 (LIN SLAVE)
97:                    if((TX1IF) && (TX1IE))          //transmisja RS232 (TXIF jest zerowane sprzetowo)
92A0  B89E     BTFSC PIR1, 4, ACCESS
92A2  A89D     BTFSS PIE1, 4, ACCESS
92A4  D002     BRA 0x92AA
98:                    {
99:                            IntUSART1STR();             //slave
92A6  EC64     CALL 0xBAC8, 0
92A8  F05D     NOP
100:                           return;
101:                   }
102:           #endif
103:             
104:           #else
105:               //Komunikacja z plyta UNI-02
106:               //UART1
107:               if((RCIF)&&(RCIE))		//odbior RS232 (RCIF jest zerowane sprzetowo)
108:               {
109:                       IntUSARTRC();
110:                       return;
111:               }
112:               //UART1
113:               if((TXIF)&&(TXIE))		//transmisja RS232 (TXIF jest zerowane sprzetowo)
114:               {
115:                       IntUSARTTR();
116:                       return;
117:               }
118:           #endif      
119:           }
92AA  C027     MOVFF _MGSDf_TransOK, FSR2H
92AC  FFDA     NOP
92AE  C026     MOVFF _MGSDf_TransDataTR, FSR2
92B0  FFD9     NOP
92B2  924B     BCF 0x4B, 1, ACCESS
92B4  0011     RETFIE 1
120:           //-------------------------------------------------------------------------
121:           //LOW priority interrupt
122:           void interrupt low_priority L_ISR(void)
0018  804B     BSF 0x4B, 0, ACCESS
123:           {
124:               if((LCDIF)&&(LCDIE))	//obsluga przerwania od LCD
0056  BCA4     BTFSC PIR3, 6, ACCESS
0058  ACA3     BTFSS PIE3, 6, ACCESS
005A  D002     BRA 0x60
125:               {
126:                       LCDIF=0;
005C  9CA4     BCF PIR3, 6, ACCESS
127:                       return;
005E  D027     BRA 0xAE
128:               }
129:               if((TMR1IF)&&(TMR1IE))
0060  B09E     BTFSC PIR1, 0, ACCESS
0062  A09D     BTFSS PIE1, 0, ACCESS
0064  D00E     BRA 0x82
130:               {
131:                       TMR1IF=0;
0066  909E     BCF PIR1, 0, ACCESS
132:                       ReloadTimer1();		//obsluga zegara Timer1
0068  EC39     CALL 0xC272, 0
006A  F061     NOP
133:                       IncRTimer();		//obsluga zegarow RT
006C  EC53     CALL 0x76A6, 0
006E  F03B     NOP
134:                       IncKeyTimer();		//obsluga zegarow klawiszy
0070  ECC9     CALL 0x9192, 0
0072  F048     NOP
135:                       //IncRSTimer();		//obsluga timerow modulu MGS_RS
136:                       IncRingTimer();		//obsluga timerow kolejkowania procedur
0074  ECF0     CALL 0xC1E0, 0
0076  F060     NOP
137:                       RefreshWSW();		//obsluga wyswietlacza
0078  EC0D     CALL 0xC01A, 0
007A  F060     NOP
138:                       StabPort();			//stabilizacja stanu okreslonych sygnalow
007C  EC00     CALL 0x7E00, 0
007E  F03F     NOP
0080  D016     BRA 0xAE
139:                       return;
140:               }
141:               if((TMR2IF)&&(TMR2IE))      //przerwanie co 1/4 msek
0082  B29E     BTFSC PIR1, 1, ACCESS
0084  A29D     BTFSS PIE1, 1, ACCESS
0086  D008     BRA 0x98
142:               {
143:                       TMR2IF=0;
0088  929E     BCF PIR1, 1, ACCESS
144:                       IntPWM2();                  //pwm2 - podswietlenie
008A  EC2A     CALL 0xBA54, 0
008C  F05D     NOP
145:           #if (_EXT_BOARD>=3)            
146:                       IntMillis();        //zliczanie milisekund poczawszy od zalaczenia zasilania (przeladowanie po 50 dniach)  
008E  EC1C     CALL 0xBE38, 0
0090  F05F     NOP
147:                       IntOTTimeout();     //restart procedury OT do stanu oczekiwania na ramke po zadanym czasie (1=1ms, 0xFFFF=65,5 sek))
0092  ECAB     CALL 0xAB56, 0
0094  F055     NOP
0096  D00B     BRA 0xAE
148:           #endif            
149:                       return;
150:               }
151:               if((CCP2IF)&&(CCP2IE))
0098  B4A4     BTFSC PIR3, 2, ACCESS
009A  A4A3     BTFSS PIE3, 2, ACCESS
009C  D002     BRA 0xA2
152:               {
153:                       CCP2IF=0;
009E  94A4     BCF PIR3, 2, ACCESS
154:                       return;
00A0  D006     BRA 0xAE
155:               }
156:               if((SSPIF)&&(SSPIE))	//obsluga przerwania od I2C
00A2  B69E     BTFSC PIR1, 3, ACCESS
00A4  A69D     BTFSS PIE1, 3, ACCESS
00A6  D003     BRA 0xAE
157:               {
158:                       SSPIF=0;
00A8  969E     BCF PIR1, 3, ACCESS
159:                       I2CSlaveTR();
00AA  ECD2     CALL 0xA1A4, 0
00AC  F050     NOP
160:                       return;
161:               }
162:           }
00AE  C073     MOVFF _PFNf_popFN, TABLAT
00B0  FFF5     NOP
00B2  C072     MOVFF _PFNf_pobRT, TBLPTRU
00B4  FFF8     NOP
00B6  C071     MOVFF _PFNf_pmpPWM, TBLPTRH
00B8  FFF7     NOP
00BA  C070     MOVFF _PFNf_plmCW, TBLPTR
00BC  FFF6     NOP
00BE  C06F     MOVFF _PFNf_plmCO, PRODH
00C0  FFF4     NOP
00C2  C06E     MOVFF _PFNf_pgdTP, PROD
00C4  FFF3     NOP
00C6  C06D     MOVFF _PFNf_pgd, FSR2H
00C8  FFDA     NOP
00CA  C06C     MOVFF _PFNf_opgres, FSR2
00CC  FFD9     NOP
00CE  C06B     MOVFF _PFNf_opgprg, FSR1H
00D0  FFE2     NOP
00D2  C06A     MOVFF _PFNf_opKNF, FSR1
00D4  FFE1     NOP
00D6  C069     MOVFF _PFNf_ofzima, FSR0H
00D8  FFEA     NOP
00DA  C068     MOVFF _PFNf_ofoff, FSR0
00DC  FFE9     NOP
00DE  C067     MOVFF _PFNf_ofnserw, BSR
00E0  FFE0     NOP
00E2  C066     MOVFF 0x66, WREG
00E4  FFE8     NOP
00E6  C065     MOVFF 0x65, STATUS
00E8  FFD8     NOP
00EA  904B     BCF 0x4B, 0, ACCESS
00EC  0010     RETFIE 0
163:           //-------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/i2c_s.c  --------------------
1:             /*i2c_s.c*/
2:             /*I2C Slave Mode*/
3:             //-------------------------------------------------------------------------------
4:             //#include <pic18.h>
5:             #include <xc.h>
6:             #include "global.h"			//parametry globalne
7:             #include "i2c_s.h"			//parametry lokalne
8:             #include "main.tp.h"
9:             //#include "uart9b.h"			//parametry lokalne
10:            
11:            volatile static DataI2C	DtI2C;
12:            volatile static bfI2C	BufI2C;
13:            
14:            //extern volatile UARTData UADt;
15:            extern volatile unsigned char x,y;
16:            extern volatile unsigned char xxy,zzz,vvv;
17:            extern DataPFN PFN;
18:            extern tpRSDTA1 RSDT1;
19:            
20:            extern unsigned char ccc;
21:            //-------------------------------------------------------------------------------
22:            //Inicjalizacja modulu I2C
23:            void InitI2C(void)
24:            {
25:            	//TRISC
26:            	TRISC3=1;				//SDA i SCA konfiguracja jako wejscia
B8BE  8694     BSF TRISC, 3, ACCESS
27:            	TRISC4=1;
B8C0  8894     BSF TRISC, 4, ACCESS
28:            
29:            	//SSPADD
30:            	SSPADD=_I2CSPADD;		
B8C2  0ECC     MOVLW 0xCC
B8C4  6EC8     MOVWF SSP1ADD, ACCESS
31:            	
32:            	//SSPCON1
33:            	SSPM0=0;
B8C6  90C6     BCF SSP1CON1, 0, ACCESS
34:            	SSPM1=1;
B8C8  82C6     BSF SSP1CON1, 1, ACCESS
35:            	SSPM2=1;
B8CA  84C6     BSF SSP1CON1, 2, ACCESS
36:            	SSPM3=0;				//I2C Slave Mode, 7 bit address
B8CC  96C6     BCF SSP1CON1, 3, ACCESS
37:            
38:            	CKP=1;					//Release clock	
B8CE  88C6     BSF SSP1CON1, 4, ACCESS
39:                SEN = 1;                //Stretch enable bit
B8D0  80C5     BSF SSP1CON2, 0, ACCESS
40:            
41:            	//SSPSTAT
42:            	SMP=1;					//standart speed mode
B8D2  8EC7     BSF SSP1STAT, 7, ACCESS
43:            	CKE=0;					//data transmited on rising edge
B8D4  9CC7     BCF SSP1STAT, 6, ACCESS
44:            
45:            	//PIE
46:            	SSPIE=1;				//serial interrupt enable bit
B8D6  869D     BSF PIE1, 3, ACCESS
47:            	//BCLIE=1;				//bus collision interrupt enable bit
48:            	
49:            	//IPR
50:            	//low prioriy interrupt
51:            	SSPIP=0;
B8D8  969F     BCF IPR1, 3, ACCESS
52:            	
53:            	BufI2C.indeks=0;
B8DA  0103     MOVLB 0x3
B8DC  6B20     CLRF _MGSDf_RERR_REC, BANKED
54:            	DtI2C.error=0;
B8DE  0104     MOVLB 0x4
B8E0  6B00     CLRF 0x0, BANKED
55:            	DtI2Cf_krok=0;
B8E2  9601     BCF DtCOf_err_CO, 3, ACCESS
56:                SSPEN=1;				//enables the serial port
B8E4  8AC6     BSF SSP1CON1, 5, ACCESS
57:            }
B8E6  0012     RETURN 0
58:            //-------------------------------------------------------------------------------
59:            //Procedura transferu/odbioru danych
60:            //UWAGA: umiescic w przerwaniu od SSPIF.
61:            //UWAGA: dla SEN=1 nastepuje autozatrzymanie zegara.Przy wyjsciu z procedury nalezy uwolnic zegar poleceniem CKP=1
62:            volatile static unsigned char dt;
63:            void I2CSlaveTR(void)
64:            {
65:            	if(WCOL)							//nadpisanie danej przy zapisie?
A1A4  AEC6     BTFSS SSP1CON1, 7, ACCESS
A1A6  D005     BRA 0xA1B2
66:            	{ 
67:            		WCOL=0;
A1A8  9EC6     BCF SSP1CON1, 7, ACCESS
68:            		DtI2C.error=_ErWCOL;
A1AA  0E07     MOVLW 0x7
A1AC  0104     MOVLB 0x4
A1AE  6F00     MOVWF 0x0, BANKED
69:            	}
A1B0  D02A     BRA 0xA206
70:            	else
71:            	if(SSPOV) 							//nadpisanie danej przy odbiorze?
A1B2  ACC6     BTFSS SSP1CON1, 6, ACCESS
A1B4  D007     BRA 0xA1C4
72:            	{
73:            		SSPOV=0;
A1B6  9CC6     BCF SSP1CON1, 6, ACCESS
74:            		DtI2C.error=_ErSSPOV;
A1B8  0E08     MOVLW 0x8
A1BA  0104     MOVLB 0x4
A1BC  6F00     MOVWF 0x0, BANKED
75:                    dt = SSPBUF;
A1BE  CFC9     MOVFF SSP1BUF, dt
A1C0  F1CE     NOP
76:            	}
A1C2  D021     BRA 0xA206
77:            	else
78:            	{ 
79:            		if(!DA)							//adres czy dane?
A1C4  BAC7     BTFSC SSP1STAT, 5, ACCESS
A1C6  D015     BRA 0xA1F2
80:            		{	
81:            			//ADRES
82:            			if(RW)  //transmisja danych
A1C8  A4C7     BTFSS SSP1STAT, 2, ACCESS
A1CA  D00C     BRA 0xA1E4
83:            			{
84:            				//Przygotowanie do transmisji danych
85:            				DtI2Cf_krok=1;
A1CC  8601     BSF DtCOf_err_CO, 3, ACCESS
86:                            dt = SSPBUF;
A1CE  CFC9     MOVFF SSP1BUF, dt
A1D0  F1CE     NOP
87:            				SetTData();
A1D2  EC7D     CALL 0xB4FA, 0
A1D4  F05A     NOP
88:            				BufI2C.Bf[_NBDATA-1]=LiczCHK(_NBDATA);
A1D6  0E16     MOVLW 0x16
A1D8  ECA4     CALL 0xA748, 0
A1DA  F053     NOP
A1DC  0103     MOVLB 0x3
A1DE  6F36     MOVWF _PFNf_LIN_KSK, BANKED
89:            				BufI2C.indeks=0;
A1E0  6B20     CLRF _MGSDf_RERR_REC, BANKED
90:            			}
A1E2  D007     BRA 0xA1F2
91:            			else 
92:            			{
93:            				//Przygotowanie do odbioru danych
94:            				DtI2Cf_krok=0;
A1E4  9601     BCF DtCOf_err_CO, 3, ACCESS
95:            				SetRData();
A1E6  EC17     CALL 0xC22E, 0
A1E8  F061     NOP
96:            				dt=SSPBUF;
A1EA  CFC9     MOVFF SSP1BUF, dt
A1EC  F1CE     NOP
97:                            CKP = 1;    //uwolnij zegar
A1EE  88C6     BSF SSP1CON1, 4, ACCESS
A1F0  0012     RETURN 0
98:            				return;
99:            			}
100:           		}
101:           		//DATA
102:           		//Odbior danych
103:           		if(DtI2Cf_krok==0) 
A1F2  B601     BTFSC DtCOf_err_CO, 3, ACCESS
A1F4  D003     BRA 0xA1FC
104:           		{
105:           			ReceptData();
A1F6  EC2B     CALL 0xB256, 0
A1F8  F059     NOP
A1FA  D7F9     BRA 0xA1EE
106:                       CKP = 1;    //uwolnij zegar
107:           			return;
108:           		}
109:           		//Transmisja danych
110:           		if(DtI2Cf_krok==1) 
A1FC  A601     BTFSS DtCOf_err_CO, 3, ACCESS
A1FE  D003     BRA 0xA206
111:           		{
112:           			TransmitData();
A200  EC89     CALL 0xB912, 0
A202  F05C     NOP
A204  D7F4     BRA 0xA1EE
113:                       CKP = 1;    //uwolnij zegar
114:           			return;
115:           		}
116:           	}
117:           	//Koniec transmisji/odbioru
118:               dt = SSPBUF;
A206  CFC9     MOVFF SSP1BUF, dt
A208  F1CE     NOP
119:           	DtI2Cf_krok=0;
A20A  9601     BCF DtCOf_err_CO, 3, ACCESS
120:           	BufI2C.indeks=0;
A20C  0103     MOVLB 0x3
A20E  6B20     CLRF _MGSDf_RERR_REC, BANKED
121:               CKP = 1;    //uwolnij zegar
A210  88C6     BSF SSP1CON1, 4, ACCESS
122:           }
A212  0012     RETURN 0
123:           //-------------------------------------------------------------------------------
124:           //Oblicza CHK i umieszcza go w ostatnim bajcie bufora danych
125:           //NBTI2C - liczba danych bez adresu z CHK
126:           unsigned char LiczCHK(const unsigned char NBTI2C)
A748  6E30     MOVWF _PFNf_LIN_CK, ACCESS
127:           {
128:           	unsigned char i;
129:           	unsigned char chk=0;
A74A  6A2F     CLRF _PFNf_KnfDisErr, ACCESS
130:           	
131:           	for(i=0;i<NBTI2C-1;i++) chk+=(BufI2C.Bf[i]+i)^0xAA;
A74C  6A31     CLRF _PFNf_LIN_CW, ACCESS
A74E  D820     RCALL PL324
A750  BE2B     BTFSC _PFNf_EnF10V, 7, ACCESS
A752  D01C     BRA 0xA78C
A754  502B     MOVF _PFNf_EnF10V, W, ACCESS
A756  E102     BNZ 0xA75C
A758  042A     DECF _PFNf_EnAleg, W, ACCESS
A75A  E318     BNC 0xA78C
A75C  0E21     MOVLW 0x21
A75E  2431     ADDWF _PFNf_LIN_CW, W, ACCESS
A760  6ED9     MOVWF FSR2, ACCESS
A762  6ADA     CLRF FSR2H, ACCESS
A764  0E03     MOVLW 0x3
A766  22DA     ADDWFC FSR2H, F, ACCESS
A768  50DF     MOVF INDF2, W, ACCESS
A76A  2431     ADDWF _PFNf_LIN_CW, W, ACCESS
A76C  0AAA     XORLW 0xAA
A76E  262F     ADDWF _PFNf_KnfDisErr, F, ACCESS
A770  2A31     INCF _PFNf_LIN_CW, F, ACCESS
A772  D80E     RCALL PL324
A774  5031     MOVF _PFNf_LIN_CW, W, ACCESS
A776  6E2C     MOVWF _PFNf_EnLIN, ACCESS
A778  6A2D     CLRF _PFNf_FLIN, ACCESS
A77A  502A     MOVF _PFNf_EnAleg, W, ACCESS
A77C  5C2C     SUBWF _PFNf_EnLIN, W, ACCESS
A77E  502D     MOVF _PFNf_FLIN, W, ACCESS
A780  0A80     XORLW 0x80
A782  6E2E     MOVWF _PFNf_FOT, ACCESS
A784  502B     MOVF _PFNf_EnF10V, W, ACCESS
A786  0A80     XORLW 0x80
A788  582E     SUBWFB _PFNf_FOT, W, ACCESS
A78A  E3E8     BNC 0xA75C
132:           	return chk;		
A78C  502F     MOVF _PFNf_KnfDisErr, W, ACCESS
133:           }
0008  824B     BSF 0x4B, 1, ACCESS
A78E  0012     RETURN 0
134:           //-------------------------------------------------------------------------------
135:           //Wysyla dane do odbiornika
136:           void TransmitData(void)
137:           {
138:           	if(RW)				//ACK lub bit STOP?
B912  A4C7     BTFSS SSP1STAT, 2, ACCESS
B914  EF18     GOTO 0xC230
B916  F061     NOP
139:           	{
140:           		if(BufI2C.indeks < _NBSIZE) SSPBUF=BufI2C.Bf[BufI2C.indeks];
B918  0E18     MOVLW 0x18
B91A  0103     MOVLB 0x3
B91C  6120     CPFSLT _MGSDf_RERR_REC, BANKED
B91E  D005     BRA 0xB92A
B920  EC42     CALL 0xB284, 0
B922  F059     NOP
B924  50DF     MOVF INDF2, W, ACCESS
B926  6EC9     MOVWF SSP1BUF, ACCESS
B928  D002     BRA 0xB92E
141:                           else SSPBUF = BufI2C.Bf[_NBSIZE - 1];
B92A  C338     MOVFF 0x338, SSP1BUF
B92C  FFC9     NOP
142:           		//CKP=1;
143:           		if(BufI2C.indeks<_NBDATA-1) BufI2C.indeks++;	
B92E  0E15     MOVLW 0x15
B930  6120     CPFSLT _MGSDf_RERR_REC, BANKED
B932  0C15     RETLW 0x15
B934  2B20     INCF _MGSDf_RERR_REC, F, BANKED
B936  0C15     RETLW 0x15
144:           	}
145:           	else
146:           	{
147:           		//CKP=1;
148:           		BufI2C.indeks=0;		
B938  EF18     GOTO 0xC230
B93A  F061     NOP
149:           	}
150:           }
151:           //-------------------------------------------------------------------------------
152:           //Odbiera nadeslane dane
153:           void ReceptData(void)
154:           {
155:               dt = SSPBUF;
B256  CFC9     MOVFF SSP1BUF, dt
B258  F1CE     NOP
156:           	if(BufI2C.indeks<_NRCDT)
B25A  0E03     MOVLW 0x3
B25C  0103     MOVLB 0x3
B25E  6120     CPFSLT _MGSDf_RERR_REC, BANKED
B260  0C03     RETLW 0x3
B262  D810     RCALL PL456
157:           	{
158:           		BufI2C.Bf[BufI2C.indeks]=dt;
B264  C1CE     MOVFF dt, INDF2
B266  FFDF     NOP
159:           		BufI2C.indeks++;
B268  2B20     INCF _MGSDf_RERR_REC, F, BANKED
160:           		if(BufI2C.indeks==_NRCDT-1)
B26A  0E02     MOVLW 0x2
B26C  1920     XORWF _MGSDf_RERR_REC, W, BANKED
B26E  A4D8     BTFSS STATUS, 2, ACCESS
B270  0012     RETURN 0
161:                   {
162:                       if(LiczCHK(_NRCDT)==BufI2C.Bf[_NRCDT-1]) ToWork();
B272  0E03     MOVLW 0x3
B274  ECA4     CALL 0xA748, 0
B276  F053     NOP
B278  0103     MOVLB 0x3
B27A  1923     XORWF _MGSDf_TransACK, W, BANKED
B27C  B4D8     BTFSC STATUS, 2, ACCESS
B27E  EC4E     CALL 0xC29C, 0
B280  F061     NOP
163:                   }
164:           	}
165:           }
B282  0012     RETURN 0
166:           //-------------------------------------------------------------------------------
167:           //Operacje wykonywane po odebraniu danych
168:           void ToWork(void)
169:           {
170:           
171:           }
C29C  0012     RETURN 0
172:           
173:           //-------------------------------------------------------------------------------
174:           //Zapis danych przeznaczonych do wysylki do bufora
175:           void SetTData(void)
176:           {
177:           	//static unsigned char d;
178:           
179:           	//d=(d>=99)?0:d+1;
180:           	BufI2C.Bf[0]=0xD1;
B4FA  0ED1     MOVLW 0xD1
B4FC  0103     MOVLB 0x3
B4FE  6F21     MOVWF _MGSDf_RERR_TIM, BANKED
181:           	BufI2C.Bf[1]=xxy;
B500  C1D2     MOVFF xxy, 0x322
B502  F322     NOP
182:           	BufI2C.Bf[2]=zzz;//0;//y;
B504  C1D4     MOVFF zzz, 0x323
B506  F323     NOP
183:           	BufI2C.Bf[3]=vvv;//zzz;
B508  C1D0     MOVFF vvv, 0x324
B50A  F324     NOP
184:           	BufI2C.Bf[4]=0;
B50C  6B25     CLRF _MGSDf_TransDataRC, BANKED
185:           	BufI2C.Bf[5]=0;//x;
B50E  6B26     CLRF _MGSDf_TransDataTR, BANKED
186:           	BufI2C.Bf[6]=0;
B510  6B27     CLRF _MGSDf_TransOK, BANKED
187:           	BufI2C.Bf[7]=0;
B512  6B28     CLRF _PFNf_10V_RT, BANKED
188:           	BufI2C.Bf[8]=0;
B514  6B29     CLRF _PFNf_10V_nPCO, BANKED
189:           	BufI2C.Bf[9]=0;
B516  6B2A     CLRF _PFNf_EnAleg, BANKED
190:           	BufI2C.Bf[10]=0;
B518  6B2B     CLRF _PFNf_EnF10V, BANKED
191:           	BufI2C.Bf[11]=0;
B51A  6B2C     CLRF _PFNf_EnLIN, BANKED
192:           	BufI2C.Bf[12]=0;
B51C  6B2D     CLRF _PFNf_FLIN, BANKED
193:           	BufI2C.Bf[13]=0;
B51E  6B2E     CLRF _PFNf_FOT, BANKED
194:           	BufI2C.Bf[14]=0;
B520  6B2F     CLRF _PFNf_KnfDisErr, BANKED
195:           	BufI2C.Bf[15]=0;
B522  6B30     CLRF _PFNf_LIN_CK, BANKED
196:           	BufI2C.Bf[16]=0;
B524  6B31     CLRF _PFNf_LIN_CW, BANKED
197:           	BufI2C.Bf[17]=0;
B526  6B32     CLRF _PFNf_LIN_DPGD, BANKED
198:           	BufI2C.Bf[18]=0;
B528  6B33     CLRF _PFNf_LIN_ENDO, BANKED
199:           	BufI2C.Bf[19]=0;
B52A  6B34     CLRF _PFNf_LIN_EPBCO, BANKED
200:           	BufI2C.Bf[20]=0;
B52C  6B35     CLRF _PFNf_LIN_EPBCW, BANKED
201:           }
B52E  0012     RETURN 0
202:           //-------------------------------------------------------------------------------
203:           //Przygotowanie na odbior danych
204:           void SetRData(void)
C22E  D000     BRA PL838
205:           {
206:           	BufI2C.indeks=0;
207:           }
208:           //-------------------------------------------------------------------------------
209:           //Formatowanie danych na potrzeby modulu IMY-02
210:           void FormatDataIMY(void)
211:           {
212:           
213:           }
214:           //-------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/bit.c  ----------------------
1:             /*bit.c*/
2:             /*Procedury zwiazane operacjami na bitach*/
3:             
4:             //#include <pic18.h>
5:             #include <xc.h>
6:             #include "global.h"			//parametry globalne
7:             //-------------------------------------------------------------------------------
8:             //-------------------------------------------------------------------------------
9:             //odczyt stanu wybranego bitu dowolnej danej typu char
10:            bit GetBit(const unsigned char data,const unsigned char nbit)
11:            {
12:            	if(data&(1<<nbit)) return 1;
13:            	return 0;
14:            }
15:            //do wywolania w petli glownej
16:            bit GetBit2(const unsigned char data,const unsigned char nbit)
B98C  0100     MOVLB 0x0
B98E  6F77     MOVWF _PFNf_prn_pg, BANKED
17:            {
18:            	if(data&(1<<nbit)) return 1;
B990  C074     MOVFF _PFNf_prODP, _PFNf_prn_cs
B992  F075     NOP
B994  0E01     MOVLW 0x1
B996  6F76     MOVWF _PFNf_prn_in, BANKED
B998  2B75     INCF _PFNf_prn_cs, F, BANKED
B99A  D002     BRA 0xB9A0
B99C  90D8     BCF STATUS, 0, ACCESS
B99E  3776     RLCF _PFNf_prn_in, F, BANKED
B9A0  2F75     DECFSZ _PFNf_prn_cs, F, BANKED
B9A2  D7FC     BRA 0xB99C
B9A4  0100     MOVLB 0x0
B9A6  5176     MOVF _PFNf_prn_in, W, BANKED
B9A8  1577     ANDWF _PFNf_prn_pg, W, BANKED
B9AA  E002     BZ 0xB9B0
B9AC  80D8     BSF STATUS, 0, ACCESS
B9AE  0012     RETURN 0
19:            	return 0;
B9B0  90D8     BCF STATUS, 0, ACCESS
20:            }
B9B2  0012     RETURN 0
21:            //ustawia/kasuje wybrany bit dowolnej danej typu char (zapalenie/wygaszenie diody)
22:            void BitSet(unsigned char *data, const unsigned char nbit,const unsigned char bt)
23:            {
24:            	if(bt) *data|=1<<nbit;
25:            	else *data&=~(1<<nbit);
26:            }
27:            //do wywolania w petli glownej
28:            void BitSet2(unsigned char *data, const unsigned char nbit,const unsigned char bt)
29:            {
30:            	if(bt) *data|=1<<nbit;
ACDA  5177     MOVF _PFNf_prn_pg, W, BANKED
ACDC  E00B     BZ 0xACF4
ACDE  D817     RCALL PL604
ACE0  D002     BRA 0xACE6
ACE2  90D8     BCF STATUS, 0, ACCESS
ACE4  3779     RLCF _PFNf_prn_res, F, BANKED
ACE6  2F78     DECFSZ _PFNf_prn_pp, F, BANKED
ACE8  D7FC     BRA 0xACE2
ACEA  D817     RCALL PL702
ACEC  0100     MOVLB 0x0
ACEE  5179     MOVF _PFNf_prn_res, W, BANKED
ACF0  12DF     IORWF INDF2, F, ACCESS
ACF2  0012     RETURN 0
31:            	else *data&=~(1<<nbit);
ACF4  D80C     RCALL PL604
ACF6  D002     BRA 0xACFC
ACF8  90D8     BCF STATUS, 0, ACCESS
ACFA  3779     RLCF _PFNf_prn_res, F, BANKED
ACFC  2F78     DECFSZ _PFNf_prn_pp, F, BANKED
ACFE  D7FC     BRA 0xACF8
AD00  0100     MOVLB 0x0
AD02  1D79     COMF _PFNf_prn_res, W, BANKED
AD04  6F7A     MOVWF _PFNf_res, BANKED
AD06  D809     RCALL PL702
AD08  517A     MOVF _PFNf_res, W, BANKED
AD0A  16DF     ANDWF INDF2, F, ACCESS
32:            }
AD0C  0012     RETURN 0
33:            
34:            //do wywolania w petli glownej
35:            void BitSet3(volatile unsigned char *data, const unsigned char nbit,const unsigned char bt)
36:            {
37:            	if(bt) *data|=1<<nbit;
AC90  5179     MOVF _PFNf_prn_res, W, BANKED
AC92  E00B     BZ 0xACAA
AC94  D817     RCALL PL548
AC96  D002     BRA 0xAC9C
AC98  90D8     BCF STATUS, 0, ACCESS
AC9A  377B     RLCF _PFNf_rozruch, F, BANKED
AC9C  2F7A     DECFSZ _PFNf_res, F, BANKED
AC9E  D7FC     BRA 0xAC98
ACA0  D817     RCALL PL640
ACA2  0100     MOVLB 0x0
ACA4  517B     MOVF _PFNf_rozruch, W, BANKED
ACA6  12DF     IORWF INDF2, F, ACCESS
ACA8  0012     RETURN 0
38:            	else *data&=~(1<<nbit);
ACAA  D80C     RCALL PL548
ACAC  D002     BRA 0xACB2
ACAE  90D8     BCF STATUS, 0, ACCESS
ACB0  377B     RLCF _PFNf_rozruch, F, BANKED
ACB2  2F7A     DECFSZ _PFNf_res, F, BANKED
ACB4  D7FC     BRA 0xACAE
ACB6  0100     MOVLB 0x0
ACB8  1D7B     COMF _PFNf_rozruch, W, BANKED
ACBA  6F7C     MOVWF _PFNf_setKey, BANKED
ACBC  D809     RCALL PL640
ACBE  517C     MOVF _PFNf_setKey, W, BANKED
ACC0  16DF     ANDWF INDF2, F, ACCESS
39:            }
ACC2  0012     RETURN 0
40:            //-------------------------------------------------------------------------------
41:            //-------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/auart9b.c  ------------------
1:             /*auart9b.c*/
2:             //Funkcje obslugi RS232 w trybie 9 bit z adresowaniem dla AUART2.
3:             //Interfejs oparty na ukladzie MAX487
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #include "main.tp.h"
9:             #if (_EXT_BOARD!=0)
10:            #include "auart9b.h"			//parametry lokalne
11:            #include "amgs_rs9b.h"
12:            #include "rtimer.tp.h"
13:            extern volatile unsigned char xxy,zzz,vvv;
14:            extern volatile near RTsekundy	Sk[];//**************************
15:            
16:            volatile UARTData UADt;
17:            volatile unsigned char bufTUART[_NRS_TBF];	//bufor roboczy modulu UART
18:            volatile unsigned char bufRUART[_NRS_RBF];	//bufor roboczy modulu UART
19:            volatile near unsigned char RSerial;
20:            
21:            extern tpRSDTA1 RSDT1;
22:            /*---------------------------------------------------------------------------------*/
23:            /*---------------------------------------------------------------------------------*/
24:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
25:            void StartUSARTRC(const unsigned char nData);
26:            unsigned char VerifyNDatCHK(const unsigned char Data);
27:            void InitAUart2(void)
28:            {
29:            	//1 wyjscie portu G ustawic jako wyjscie (0)
30:            	//2 wyjscie portu C ustawic jako wejscie (1)
31:            
32:            	TXSTA2bits.CSRC=0;			//asynch mode
B21A  9E61     BCF TXSTA2, 7, ACCESS
33:            	RCSTA2bits.RX9=1;			//odbior 9 bitowy
B21C  8C60     BSF RCSTA2, 6, ACCESS
34:            	SPBRG2=_SPBRG;	//baud rate
B21E  0ECF     MOVLW 0xCF
B220  6E64     MOVWF SPBRG2, ACCESS
35:            	TXSTA2bits.SYNC=_SYNC;		//tryb asynchroniczny/synchroniczny
B222  9861     BCF TXSTA2, 4, ACCESS
36:            	TXSTA2bits.BRGH=_BRGH;		//predkosc generatora Baud Rate
B224  9461     BCF TXSTA2, 2, ACCESS
37:            	RCSTA2bits.ADDEN=1;		//z adresowaniem
B226  8660     BSF RCSTA2, 3, ACCESS
38:            	TXSTA2bits.TX9=1;			//nadawanie 9 bitowe
B228  8C61     BSF TXSTA2, 6, ACCESS
39:            	IPR3bits.RC2IP=1;			//wysoki priorytet przerwania
B22A  8AA5     BSF IPR3, 5, ACCESS
40:            	PIE3bits.RC2IE=1;			//aktywne przerwanie dla odbioru
B22C  8AA3     BSF PIE3, 5, ACCESS
41:            	IPR3bits.TX2IP=1;			//wysoki priorytet przerwania
B22E  88A5     BSF IPR3, 4, ACCESS
42:            	TXSTA2bits.TXEN=1;			//aktywacja modulu transmisji
B230  8A61     BSF TXSTA2, 5, ACCESS
43:            	RCSTA2bits.SPEN=1;			//aktywacja portu szeregowego
B232  8E60     BSF RCSTA2, 7, ACCESS
44:            	RCSTA2bits.CREN=1;			//aktywacja odbioru
B234  8860     BSF RCSTA2, 4, ACCESS
45:            	U2OD=0;
B236  9E8F     BCF LATG, 7, ACCESS
46:            
47:            	//UWAGA: GIEL=1 oraz GIEH=1
48:            	UADtf_RData=0;
B238  9A13     BCF UAD1tf_RFData, 5, ACCESS
49:            	UADtf_RErrREC=0;
B23A  9214     BCF UADtf_RErrREC, 1, ACCESS
50:            	UADtf_RErrBUF=0;
B23C  9014     BCF UADtf_RErrREC, 0, ACCESS
51:            	
52:            	UADtf_TData=0;
B23E  9414     BCF UADtf_RErrREC, 2, ACCESS
53:            	UADt.RNData=0;
B240  6A42     CLRF 0x42, ACCESS
54:            	UADt.TNData=0;
B242  6A43     CLRF 0x43, ACCESS
55:            
56:            	UADtf_REnd=0;
B244  9E13     BCF UAD1tf_RFData, 7, ACCESS
57:            	UADtf_TEnd=0;
B246  9814     BCF UADtf_RErrREC, 4, ACCESS
58:                
59:                UADtf_REXT=0;                //znacznik rozszerzonej liczby danych
B248  9C13     BCF UAD1tf_RFData, 6, ACCESS
60:                UADtf_TEXT=0;                //znacznik rozszerzonej liczby danych    
B24A  9614     BCF UADtf_RErrREC, 3, ACCESS
61:            	UADt.indeks=0;
B24C  6A41     CLRF UADt, ACCESS
62:                    
63:            	RSerial=RCREG2;
B24E  CF63     MOVFF RCREG2, RSerial
B250  F049     NOP
64:            	PIE3bits.TX2IE=0;
B252  98A3     BCF PIE3, 4, ACCESS
65:            }
B254  0012     RETURN 0
66:            /*---------------------------------------------------------------------------------*/
67:            /*---------------------------------------------------------------------------------*/
68:            //Odbior danych /procedura wykonywana w przerwaniu/
69:            /*void IntUSARTRC(void)
70:            {
71:            	if(RCSTA2bits.ADDEN&&RCSTA2bits.RX9D)							//RX9D - ustawiony 9 ty bit? (znacznik adresu)
72:            	{
73:            		RSerial=RCREG2;
74:            		if(RSerial==_MY_ADDR)				//parawidlowy adres?
75:            		{
76:            			//if(zzz++>99) zzz=0;
77:            			RCSTA2bits.ADDEN=0;						//wylacz detekcje adresu
78:            			UADt.indeks=0;					//wyzeruj indeks
79:            			bufRUART[UADt.indeks++]=RSerial;//zapisz adres w buforze pod 0 indeksem
80:            			UADtf_RData=1;					//sygnalizuj aktywny odbior danych
81:            		}
82:            		return;								//wyjdz z przerwania
83:            	}
84:            	RSerial=RCREG2;
85:            	if (UADt.indeks<_NRS_RBF)				//mozliwe przepelnienienie bufora odbioru?
86:            	{
87:            		bufRUART[UADt.indeks++]=RSerial;
88:            		UADt.RNData=bufRUART[1];
89:            		if(VerifyNDatCHK(UADt.RNData))		//kontroluj poprawnosc danej
90:            		{
91:            			UADt.RNData=UADt.RNData&0b00011111;
92:            			if (UADt.indeks>=UADt.RNData)		//ostatni bajt?
93:            			{	
94:            				RCSTA2bits.ADDEN=1;						//zalacz detekcje adresu
95:            		 		UADtf_RData=0;					//sygnalizuj deaktywacje odbioru danych
96:            				UADtf_REnd=1;					//ustaw znacznik odbioru kompletnej paczki danych
97:            				//if(xxy++>99) xxy=0;
98:            			}
99:            		}
100:           		else
101:           		{
102:           			RCSTA2bits.ADDEN=1;							//uaktywnij detekcje adresu
103:           		 	UADtf_RData=0;						//sygnalizuj deaktywacje odbioru danych
104:           			UADtf_REnd=0;						//usun znacznik odbioru kompletnej paczki danych
105:           			UADtf_RErrBUF=1;						//sygnalizuj blad zbyt duzej ilosci danych
106:           		}
107:           	}
108:           	else									//w przypadku bledu przeplnienia przerwij odbior
109:           	{
110:           		//CREN=0;							//przerwij odbior
111:           
112:           		RCSTA2bits.ADDEN=1;							//uaktywnij detekcje adresu
113:           	 	UADtf_RData=0;						//sygnalizuj deaktywacje odbioru danych
114:           		UADtf_REnd=0;						//usun znacznik odbioru kompletnej paczki danych
115:           		UADtf_RErrBUF=1;						//sygnalizuj blad zbyt duzej ilosci danych
116:           
117:           	}
118:           }*/
119:           
120:           void IntUSARTRC(void)
121:           {
122:           	if(RCSTA2bits.ADDEN&&RCSTA2bits.RX9D)							//RX9D - ustawiony 9 ty bit? (znacznik adresu)
8BDA  B660     BTFSC RCSTA2, 3, ACCESS
8BDC  A060     BTFSS RCSTA2, 0, ACCESS
8BDE  D00B     BRA 0x8BF6
123:           	{
124:           		RSerial=RCREG2;
8BE0  CF63     MOVFF RCREG2, RSerial
8BE2  F049     NOP
125:           		if(RSerial==_MY_ADDR)				//parawidlowy adres?
8BE4  0E11     MOVLW 0x11
8BE6  1849     XORWF RSerial, W, ACCESS
8BE8  A4D8     BTFSS STATUS, 2, ACCESS
8BEA  0012     RETURN 0
126:           		{
127:           			//if(zzz++>99) zzz=0;
128:           			RCSTA2bits.ADDEN=0;						//wylacz detekcje adresu
8BEC  9660     BCF RCSTA2, 3, ACCESS
129:           			UADt.indeks=0;					//wyzeruj indeks
8BEE  6A41     CLRF UADt, ACCESS
130:           			bufRUART[UADt.indeks++]=RSerial;//zapisz adres w buforze pod 0 indeksem
8BF0  D841     RCALL PL318
131:           			UADtf_RData=1;					//sygnalizuj aktywny odbior danych
8BF2  8A13     BSF UAD1tf_RFData, 5, ACCESS
8BF4  0012     RETURN 0
132:           		}
133:           		return;								//wyjdz z przerwania
134:           	}
135:           	RSerial=RCREG2;
8BF6  CF63     MOVFF RCREG2, RSerial
8BF8  F049     NOP
136:           	if (UADt.indeks<_NRS_RBF)				//mozliwe przepelnienienie bufora odbioru?
8BFA  0E4B     MOVLW 0x4B
8BFC  6041     CPFSLT UADt, ACCESS
8BFE  D034     BRA PL304
8C00  D839     RCALL PL318
137:           	{
138:           		bufRUART[UADt.indeks++]=RSerial;
139:                   switch(UADt.indeks)
8C02  D023     BRA 0x8C4A
8C4A  5041     MOVF UADt, W, ACCESS
8C4C  0A02     XORLW 0x2
8C4E  E0DA     BZ 0x8C04
8C50  0A06     XORLW 0x6
8C52  E0E8     BZ 0x8C24
140:                   {
141:                       case 2: //odebrany drugi bajt (liczba danych)
142:                       {
143:                           UADt.RNData=bufRUART[1];
8C04  C567     MOVFF 0x567, 0x42
8C06  F042     NOP
144:                           if(VerifyNDatCHK(UADt.RNData))		//kontroluj poprawnosc danej
8C08  5042     MOVF 0x42, W, ACCESS
8C0A  EC93     CALL 0xC126, 0
8C0C  F060     NOP
8C0E  0900     IORLW 0x0
8C10  E02B     BZ PL304
145:                           {
146:                               UADt.RNData=UADt.RNData&0b00011111;                
8C12  5042     MOVF 0x42, W, ACCESS
8C14  0B1F     ANDLW 0x1F
8C16  6E42     MOVWF 0x42, ACCESS
147:                               if(UADt.RNData>_NRS_RBF) UADt.RNData=_NRS_RBF;                
8C18  0E4B     MOVLW 0x4B
8C1A  6442     CPFSGT 0x42, ACCESS
8C1C  D01B     BRA 0x8C54
8C1E  6E42     MOVWF 0x42, ACCESS
8C20  D019     BRA 0x8C54
148:                           }
149:                           else
150:                           {
151:                               //if(vvv<99) vvv++;
152:                               //else vvv=0;
153:                               RCSTA2bits.ADDEN=1;							//uaktywnij detekcje adresu
8C22  D022     BRA PL304
154:                               UADtf_REXT=0;
155:                               UADtf_RData=0;						//sygnalizuj deaktywacje odbioru danych
156:                               UADtf_REnd=0;						//usun znacznik odbioru kompletnej paczki danych
157:                               UADtf_RErrBUF=1;						//sygnalizuj blad zbyt duzej ilosci danych  
158:                               return;
159:                           }    
160:                           break;
161:                       }
162:                       case 4: //odebrany czwarty bajt (mozliwa korekta liczby danych)
163:                       {
164:                           if((bufRUART[2]==_RD_KNF2)||(bufRUART[2]==_RD_STD2))    //odebrana paczka konfiguracyjna 
8C24  0E05     MOVLW 0x5
8C26  0105     MOVLB 0x5
8C28  1968     XORWF _PFNf_ofoff, W, BANKED
8C2A  E003     BZ 0x8C32
8C2C  0E04     MOVLW 0x4
8C2E  1968     XORWF _PFNf_ofoff, W, BANKED
8C30  E111     BNZ 0x8C54
165:                           {
166:                               if(VerifyNDatCHK(bufRUART[3]))		//kontroluj poprawnosc danej
8C32  5169     MOVF _PFNf_ofzima, W, BANKED
8C34  EC93     CALL 0xC126, 0
8C36  F060     NOP
8C38  0900     IORLW 0x0
8C3A  E016     BZ PL304
167:                               {
168:                                   UADtf_REXT=1;
8C3C  8C13     BSF UAD1tf_RFData, 6, ACCESS
169:                                   UADt.RNData=UADt.RNData+(bufRUART[3]&0b00011111);                
8C3E  0105     MOVLB 0x5
8C40  5169     MOVF _PFNf_ofzima, W, BANKED
8C42  0B1F     ANDLW 0x1F
8C44  2642     ADDWF 0x42, F, ACCESS
8C46  D7E8     BRA 0x8C18
170:                                   if(UADt.RNData>_NRS_RBF) UADt.RNData=_NRS_RBF;                
171:                               }
172:                               else
8C48  D00F     BRA PL304
173:                               {
174:                                   //if(vvv<99) vvv++;
175:                                   //else vvv=0;
176:                                   RCSTA2bits.ADDEN=1;							//uaktywnij detekcje adresu
177:                                   UADtf_REXT=0;
178:                                   UADtf_RData=0;						//sygnalizuj deaktywacje odbioru danych
179:                                   UADtf_REnd=0;						//usun znacznik odbioru kompletnej paczki danych
180:                                   UADtf_RErrBUF=1;						//sygnalizuj blad zbyt duzej ilosci danych  
181:                                   return;
182:                               }    
183:                           }
184:                           break;
185:                       }      
186:                   }
187:                   if (UADt.indeks>=UADt.RNData)		//ostatni bajt?
8C54  5042     MOVF 0x42, W, ACCESS
8C56  5C41     SUBWF UADt, W, ACCESS
8C58  A0D8     BTFSS STATUS, 0, ACCESS
8C5A  0012     RETURN 0
188:                   {	       
189:                       RCSTA2bits.ADDEN=1;						//zalacz detekcje adresu
8C5C  8660     BSF RCSTA2, 3, ACCESS
190:                       UADtf_REXT=0;
8C5E  9C13     BCF UAD1tf_RFData, 6, ACCESS
191:                       UADtf_RData=0;					//sygnalizuj deaktywacje odbioru danych
8C60  9A13     BCF UAD1tf_RFData, 5, ACCESS
192:                       UADtf_REnd=1;					//ustaw znacznik odbioru kompletnej paczki danych
8C62  8E13     BSF UAD1tf_RFData, 7, ACCESS
8C64  0012     RETURN 0
193:                   }
194:           	}
195:           	else									//w przypadku bledu przeplnienia przerwij odbior
8C66  D000     BRA PL304
196:           	{
197:           		RCSTA2bits.ADDEN=1;							//uaktywnij detekcje adresu
198:                   UADtf_REXT=0;
199:           	 	UADtf_RData=0;						//sygnalizuj deaktywacje odbioru danych
200:           		UADtf_REnd=0;						//usun znacznik odbioru kompletnej paczki danych
201:           		UADtf_RErrBUF=1;						//sygnalizuj blad zbyt duzej ilosci danych
202:           	}   
203:           }
204:           //------------------------------------------------------------------------------------
205:           //Aktywacja modulu odbioru danych
206:           //Gdzie: nData - ogolna liczba odbieranych bajtow (wlaczywszy adres)
207:           void StartUSARTRC(const unsigned char nData)
208:           {
209:           	UADtf_REnd=0;				//wyzeruj znacznik konca odbioru
210:               UADtf_REXT=0;    
211:           	RCSTA2bits.ADDEN=1;
212:           	RCSTA2bits.CREN=1;
213:           }
214:           
215:           //------------------------------------------------------------------------------------
216:           //------------------------------------------------------------------------------------
217:           //Transmisja danych /procedura wykonywana w przerwaniu/
218:           //Wysylane sa wszystkie bajty poczawszy od adresu odbiornika
219:           void IntUSARTTR(void)
220:           {
221:           	if(!UADt.indeks) TXSTA2bits.TX9D=1;		//dla zerowego indeksu ustaw znacznik adresu
AF18  5041     MOVF UADt, W, ACCESS
AF1A  E102     BNZ 0xAF20
AF1C  8061     BSF TXSTA2, 0, ACCESS
AF1E  D001     BRA 0xAF22
222:           	else TXSTA2bits.TX9D=0;					//dla pozostalych danych usun znacznik adresu
AF20  9061     BCF TXSTA2, 0, ACCESS
223:           	if(UADt.TNData>_NRS_TBF) UADt.TNData=_NRS_TBF;
AF22  0E4B     MOVLW 0x4B
AF24  6443     CPFSGT 0x43, ACCESS
AF26  D001     BRA 0xAF2A
AF28  6E43     MOVWF 0x43, ACCESS
224:           	if(UADt.indeks>_NRS_TBF-1) UADt.indeks=_NRS_TBF-1;    
AF2A  0E4A     MOVLW 0x4A
AF2C  6441     CPFSGT UADt, ACCESS
AF2E  D001     BRA 0xAF32
AF30  6E41     MOVWF UADt, ACCESS
225:           	TXREG2=bufTUART[UADt.indeks++];	//rozpoczyna transmisje
AF32  0EB1     MOVLW 0xB1
AF34  2441     ADDWF UADt, W, ACCESS
AF36  D80D     RCALL PL696
AF38  50DF     MOVF INDF2, W, ACCESS
AF3A  6E62     MOVWF TXREG2, ACCESS
AF3C  2A41     INCF UADt, F, ACCESS
226:           	if(UADt.indeks<UADt.TNData)	UADtf_TData=1; //ustaw znacznik transmisji danych
AF3E  5043     MOVF 0x43, W, ACCESS
AF40  5C41     SUBWF UADt, W, ACCESS
AF42  E202     BC 0xAF48
AF44  8414     BSF UADtf_RErrREC, 2, ACCESS
AF46  0012     RETURN 0
227:           	else
228:           	{
229:                   UADtf_TEXT=0;
AF48  9614     BCF UADtf_RErrREC, 3, ACCESS
230:           		UADtf_TData=0;				//usun znacznik transmisji danych
AF4A  9414     BCF UADtf_RErrREC, 2, ACCESS
231:           		UADtf_TEnd=1;				//ustaw znacznik zakonczenia transmisji danych
AF4C  8814     BSF UADtf_RErrREC, 4, ACCESS
232:           		PIE3bits.TX2IE=0;						//deaktywacja transmisji
AF4E  98A3     BCF PIE3, 4, ACCESS
233:           	}
234:           }	
AF50  0012     RETURN 0
235:           //------------------------------------------------------------------------------------
236:           //Aktywacja modulu odbioru danych
237:           //Gdzie: nData - ogolna liczba wysylanych bajtow (wlaczywszy adres)
238:           void StartUSARTTR(void)//const unsigned char nData)
239:           {
240:           	if(PIE3bits.TX2IE) return;				//trwa transmisja danych?
B6CC  B8A3     BTFSC PIE3, 4, ACCESS
B6CE  0012     RETURN 0
241:           	UADt.TNData=(bufTUART[1]&0b00011111);//liczba wysylanych bajtow
B6D0  0105     MOVLB 0x5
B6D2  51B2     MOVF 0xB2, W, BANKED
B6D4  0B1F     ANDLW 0x1F
B6D6  6E43     MOVWF 0x43, ACCESS
242:               if((bufTUART[2]==_RD_KNF2)||(bufTUART[2]==_RD_STD2))            //ramka konfiguracyjna
B6D8  0E05     MOVLW 0x5
B6DA  19B3     XORWF 0xB3, W, BANKED
B6DC  E003     BZ 0xB6E4
B6DE  0E04     MOVLW 0x4
B6E0  19B3     XORWF 0xB3, W, BANKED
B6E2  E104     BNZ 0xB6EC
243:               {
244:                   UADtf_TEXT=1;
B6E4  8614     BSF UADtf_RErrREC, 3, ACCESS
245:                   UADt.TNData=UADt.TNData+(bufTUART[3]&0b00011111);  //zwieksz liczbe danych o wartosc korekty
B6E6  51B4     MOVF 0xB4, W, BANKED
B6E8  0B1F     ANDLW 0x1F
B6EA  2643     ADDWF 0x43, F, ACCESS
246:               }  
247:           	if(UADt.TNData>_NRS_TBF) UADt.TNData=_NRS_TBF;    
B6EC  0E4B     MOVLW 0x4B
B6EE  6443     CPFSGT 0x43, ACCESS
B6F0  D001     BRA 0xB6F4
B6F2  6E43     MOVWF 0x43, ACCESS
248:           	UADt.indeks=0;					//indeks = 0 - pierwszy bajt oznaczony jako adres
B6F4  6A41     CLRF UADt, ACCESS
249:           	UADtf_TEnd=0;					//wyzeruj znacznik konca odbioru
B6F6  9814     BCF UADtf_RErrREC, 4, ACCESS
250:           	PIE3bits.TX2IE=1;							//aktywacja transmisji
B6F8  88A3     BSF PIE3, 4, ACCESS
251:           }
B6FA  0012     RETURN 0
252:           //Deaktywacja modulu odbioru danych
253:           void StopUSARTTR(void)
254:           {
255:           	PIE3bits.TX2IE=0;							//deaktywacja transmisji
C19A  98A3     BCF PIE3, 4, ACCESS
256:           	UADtf_TData=0;					//usun znacznik transmisji danych
C19C  9414     BCF UADtf_RErrREC, 2, ACCESS
257:           	UADtf_TEnd=0;					//wyzeruj znacznik konca odbioru
C19E  9814     BCF UADtf_RErrREC, 4, ACCESS
258:               UADtf_TEXT=0;	
C1A0  9614     BCF UADtf_RErrREC, 3, ACCESS
259:           }
C1A2  0012     RETURN 0
260:           //------------------------------------------------------------------------------------
261:           //------------------------------------------------------------------------------------
262:           //Wyzerowanie bufora odbiornika
263:           void ClrRSRBuf(void)
264:           {
265:           	unsigned char i;
266:           	for(i=0;i<_NRS_RBF;i++) bufRUART[i]=0;
267:           }
268:           //------------------------------------------------------------------------------------
269:           //Wyzerowanie bufora nadajnika
270:           void ClrRSTBuf(void)
271:           {
272:           	unsigned char i;
273:           	for(i=0;i<_NRS_TBF;i++) bufTUART[i]=0;
274:           }
275:           //------------------------------------------------------------------------------------
276:           //Zapis danych do bufora nadajnika
277:           void SetRSTBuf(const unsigned char indeks,const unsigned char data)
C02E  6F75     MOVWF _PFNf_prn_cs, BANKED
278:           {
279:           	bufTUART[indeks]=data;	
C030  0EB1     MOVLW 0xB1
C032  0100     MOVLB 0x0
C034  2575     ADDWF _PFNf_prn_cs, W, BANKED
C036  ECA9     CALL 0xAF52, 0
C038  F057     NOP
C03A  C074     MOVFF _PFNf_prODP, INDF2
C03C  FFDF     NOP
280:           }
C03E  0012     RETURN 0
281:           //------------------------------------------------------------------------------------
282:           //Odczyt danych z bufora odbiornika
283:           unsigned char GetRSRBuf(const unsigned char indeks)
BF46  0100     MOVLB 0x0
BF48  6F74     MOVWF _PFNf_prODP, BANKED
284:           {
285:           	return bufRUART[indeks];	
BF4A  0E66     MOVLW 0x66
BF4C  2574     ADDWF _PFNf_prODP, W, BANKED
BF4E  6ED9     MOVWF FSR2, ACCESS
BF50  6ADA     CLRF FSR2H, ACCESS
BF52  0E05     MOVLW 0x5
BF54  D000     BRA PL610
286:           }
287:           //------------------------------------------------------------------------------------
288:           //Oblicza CHK z nData bajtow bufora bf (bufor danych musi zawierac przynajmniej 2 elementy)
289:           //Gdzie bf - adres pierwszego bajtu, nData - liczba bajtow z ktorych liczone bedzie CHK 
290:           unsigned char LiczRSCHK(volatile unsigned char *bf,const unsigned char nData)
291:           {
292:           	unsigned char i,chk;
293:           	chk=0;
B964  6B77     CLRF _PFNf_prn_pg, BANKED
294:           	for(i=0;i<nData;i++) chk+=(*(bf+i)+i)^0xAA;
B966  6B78     CLRF _PFNf_prn_pp, BANKED
B968  5176     MOVF _PFNf_prn_in, W, BANKED
B96A  E00E     BZ 0xB988
B96C  5178     MOVF _PFNf_prn_pp, W, BANKED
B96E  2574     ADDWF _PFNf_prODP, W, BANKED
B970  6ED9     MOVWF FSR2, ACCESS
B972  0E00     MOVLW 0x0
B974  2175     ADDWFC _PFNf_prn_cs, W, BANKED
B976  6EDA     MOVWF FSR2H, ACCESS
B978  50DF     MOVF INDF2, W, ACCESS
B97A  2578     ADDWF _PFNf_prn_pp, W, BANKED
B97C  0AAA     XORLW 0xAA
B97E  2777     ADDWF _PFNf_prn_pg, F, BANKED
B980  2B78     INCF _PFNf_prn_pp, F, BANKED
B982  5176     MOVF _PFNf_prn_in, W, BANKED
B984  5D78     SUBWF _PFNf_prn_pp, W, BANKED
B986  E3F2     BNC 0xB96C
295:           	return chk;
B988  5177     MOVF _PFNf_prn_pg, W, BANKED
296:           }
B98A  0012     RETURN 0
297:           //------------------------------------------------------------------------------------
298:           //Oblicza CHK i zapisuje na ostatniej pozycji bufora danych do wysylki
299:           //nData - ogolna liczba wysylanych bajtow (lacznie z adresem i bajtem CHK)
300:           void SetRSCHK(const unsigned char nData)
B93C  6F79     MOVWF _PFNf_prn_res, BANKED
301:           {
302:           	UADt.CHK=LiczRSCHK(bufTUART,nData-1); 	//liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
B93E  0EB1     MOVLW 0xB1
B940  0100     MOVLB 0x0
B942  6F74     MOVWF _PFNf_prODP, BANKED
B944  0E05     MOVLW 0x5
B946  6F75     MOVWF _PFNf_prn_cs, BANKED
B948  0579     DECF _PFNf_prn_res, W, BANKED
B94A  6F76     MOVWF _PFNf_prn_in, BANKED
B94C  ECB2     CALL 0xB964, 0
B94E  F05C     NOP
B950  6E44     MOVWF 0x44, ACCESS
303:           	bufTUART[nData-1]=UADt.CHK;				//zapisz w buforze danych do wysylki (na ostatniej pozycji) obliczona wartosc CHK
B952  0EB0     MOVLW 0xB0
B954  2579     ADDWF _PFNf_prn_res, W, BANKED
B956  6ED9     MOVWF FSR2, ACCESS
B958  6ADA     CLRF FSR2H, ACCESS
B95A  0E05     MOVLW 0x5
B95C  22DA     ADDWFC FSR2H, F, ACCESS
B95E  C044     MOVFF 0x44, INDF2
B960  FFDF     NOP
304:           }
B962  0012     RETURN 0
305:           //------------------------------------------------------------------------------------
306:           //Funkcja przeznaczona dla sytuacji gdy po wyslaniu paczki danych spodziewamu sie otrzymac odpowiedz w postaci dwoch bajtow:
307:           //adresu i bajtu potwierdzenia. 
308:           //Funkcja zwraca wartosc 1 gdy bajt potwierdzenia = 0xff wynik pozytywny.
309:           unsigned char VerifyRSACK(void)
310:           {
311:           	if(bufRUART[2]!=_RD_ERR) return 1; 	//porownuje drugi odebrany bajt z obliczonym wczesniej CHK dla paczki wysylanych danych
C190  0105     MOVLB 0x5
C192  5168     MOVF _PFNf_ofoff, W, BANKED
C194  E001     BZ 0xC198
C196  0C01     RETLW 0x1
312:           	return 0;									
313:           }
C198  0C00     RETLW 0x0
314:           /*unsigned char VerifyRSACK(void)
315:           {
316:           	if(bufRUART[2]==0xff) return 1; 	//porownuje drugi odebrany bajt z obliczonym wczesniej CHK dla paczki wysylanych danych
317:           	return 0;									
318:           }*/
319:           //------------------------------------------------------------------------------------
320:           //Oblicza CHK z odebranych danych (pominawszy ostani bajt) i porownuje otrzymany wynik z ostatnim odebranym bajtem
321:           //nData - ogolna liczba odebranych bajtow (lacznie z adresem i bajtem CHK)
322:           //Funkcja zwraca wartosc 1 gdy porownanie ma wynik pozytywny.
323:           unsigned char VerifyRSCHK(const unsigned char nData)
B7E6  0100     MOVLB 0x0
B7E8  6F7B     MOVWF _PFNf_rozruch, BANKED
324:           {
325:           	if(bufRUART[nData-1]==LiczRSCHK(bufRUART,nData-1)) return 1; 	//liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
B7EA  0E66     MOVLW 0x66
B7EC  6F74     MOVWF _PFNf_prODP, BANKED
B7EE  0E05     MOVLW 0x5
B7F0  6F75     MOVWF _PFNf_prn_cs, BANKED
B7F2  057B     DECF _PFNf_rozruch, W, BANKED
B7F4  6F76     MOVWF _PFNf_prn_in, BANKED
B7F6  ECB2     CALL 0xB964, 0
B7F8  F05C     NOP
B7FA  6F79     MOVWF _PFNf_prn_res, BANKED
B7FC  0E65     MOVLW 0x65
B7FE  257B     ADDWF _PFNf_rozruch, W, BANKED
B800  6ED9     MOVWF FSR2, ACCESS
B802  6ADA     CLRF FSR2H, ACCESS
B804  0E05     MOVLW 0x5
B806  22DA     ADDWFC FSR2H, F, ACCESS
B808  50DE     MOVF POSTINC2, W, ACCESS
B80A  1979     XORWF _PFNf_prn_res, W, BANKED
B80C  E101     BNZ 0xB810
B80E  0C01     RETLW 0x1
326:           	return 0;														//i porownuje z ostatnim odebranym bajtem.
327:           }
B810  0C00     RETLW 0x0
328:           //------------------------------------------------------------------------------------
329:           //Odczyt obliczonej wartosci CHK (rejestracja CHK odbywa sie za pomoca procedury SetRSCHK(nData)
330:           unsigned char GetRSCHK(void)
331:           {
332:           	return UADt.CHK;	
333:           }
334:           //------------------------------------------------------------------------------------
335:           //Oblicza CHK dla liczby danych i zapisuje na trzech najstarszych bitach
336:           unsigned char SetNDatCHK(const unsigned char Data)
B6FC  0100     MOVLB 0x0
B6FE  6F76     MOVWF _PFNf_prn_in, BANKED
B7B8  6E17     MOVWF _LIN1f_ERRR, ACCESS
337:           {
338:           	unsigned char a,b,d;
339:           	d=Data&0b00011111;
B700  5176     MOVF _PFNf_prn_in, W, BANKED
B702  0B1F     ANDLW 0x1F
B704  6F79     MOVWF _PFNf_prn_res, BANKED
B7BA  5017     MOVF _LIN1f_ERRR, W, ACCESS
B7BC  0B1F     ANDLW 0x1F
B7BE  6E1A     MOVWF _LIN1f_FResp, ACCESS
340:           	a=d&0b00000111;
B706  5179     MOVF _PFNf_prn_res, W, BANKED
B708  0B07     ANDLW 0x7
B70A  6F77     MOVWF _PFNf_prn_pg, BANKED
B7C0  501A     MOVF _LIN1f_FResp, W, ACCESS
B7C2  0B07     ANDLW 0x7
B7C4  6E18     MOVWF _LIN1f_FAdta, ACCESS
341:           	b=0b00000100|(d>>3);
B70C  3979     SWAPF _PFNf_prn_res, W, BANKED
B70E  46E8     RLNCF WREG, F, ACCESS
B710  0B1F     ANDLW 0x1F
B712  0904     IORLW 0x4
B714  6F78     MOVWF _PFNf_prn_pp, BANKED
B7C6  381A     SWAPF _LIN1f_FResp, W, ACCESS
B7C8  46E8     RLNCF WREG, F, ACCESS
B7CA  0B1F     ANDLW 0x1F
B7CC  0904     IORLW 0x4
B7CE  6E19     MOVWF _LIN1f_FIN, ACCESS
342:           	return d|((a^b)<<5);
B716  1977     XORWF _PFNf_prn_pg, W, BANKED
B718  6F74     MOVWF _PFNf_prODP, BANKED
B71A  0E05     MOVLW 0x5
B71C  6F75     MOVWF _PFNf_prn_cs, BANKED
B71E  90D8     BCF STATUS, 0, ACCESS
B720  3774     RLCF _PFNf_prODP, F, BANKED
B722  2F75     DECFSZ _PFNf_prn_cs, F, BANKED
B724  D7FC     BRA 0xB71E
B726  5174     MOVF _PFNf_prODP, W, BANKED
B728  1179     IORWF _PFNf_prn_res, W, BANKED
B7D0  1818     XORWF _LIN1f_FAdta, W, ACCESS
B7D2  6E15     MOVWF _LIN1f_Busy, ACCESS
B7D4  0E05     MOVLW 0x5
B7D6  6E16     MOVWF _LIN1f_CHK, ACCESS
B7D8  90D8     BCF STATUS, 0, ACCESS
B7DA  3615     RLCF _LIN1f_Busy, F, ACCESS
B7DC  2E16     DECFSZ _LIN1f_CHK, F, ACCESS
B7DE  D7FC     BRA 0xB7D8
B7E0  5015     MOVF _LIN1f_Busy, W, ACCESS
B7E2  101A     IORWF _LIN1f_FResp, W, ACCESS
343:           }
B72A  0012     RETURN 0
B7E4  0012     RETURN 0
344:           //Weryfikacja wartosci CHK dla liczby danych
345:           unsigned char VerifyNDatCHK(const unsigned char Data)
C126  6E1B     MOVWF _LIN1f_FTrans, ACCESS
346:           {
347:           	if(SetNDatCHK(Data)==Data) return 1; 	//liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
C128  501B     MOVF _LIN1f_FTrans, W, ACCESS
C12A  ECDC     CALL 0xB7B8, 0
C12C  F05B     NOP
C12E  181B     XORWF _LIN1f_FTrans, W, ACCESS
C130  E101     BNZ 0xC134
C132  0C01     RETLW 0x1
348:           	return 0;														//i porownuje z ostatnim odebranym bajtem.
349:           }
C134  0C00     RETLW 0x0
350:           //------------------------------------------------------------------------------------
351:           //Oblicza CHK dla liczby bajtow w rozszerzonej ramce danych
352:           void SetExNDatCHK(const unsigned char ndt)
AE48  0100     MOVLB 0x0
AE4A  6F7A     MOVWF _PFNf_res, BANKED
353:           {
354:               volatile unsigned char chkndat;
355:               if(ndt<=31)
AE4C  0E20     MOVLW 0x20
AE4E  617A     CPFSLT _PFNf_res, BANKED
AE50  D004     BRA 0xAE5A
356:               {
357:                   chkndat=SetNDatCHK(ndt);       //oblicz CHK dla liczby danych    
AE52  517A     MOVF _PFNf_res, W, BANKED
AE54  EC7E     CALL 0xB6FC, 0
AE56  F05B     NOP
AE58  D003     BRA 0xAE60
358:               }
359:               else chkndat=SetNDatCHK(31);        //oblicz CHK dla liczby danych            
AE5A  0E1F     MOVLW 0x1F
AE5C  EC7E     CALL 0xB6FC, 0
AE5E  F05B     NOP
AE60  6F7B     MOVWF _PFNf_rozruch, BANKED
360:               SetRSTBuf(1,chkndat);				//1 - liczba przesy³anych danych (ndat)
AE62  C07B     MOVFF _PFNf_rozruch, _PFNf_prODP
AE64  F074     NOP
AE66  0E01     MOVLW 0x1
AE68  EC17     CALL 0xC02E, 0
AE6A  F060     NOP
361:               if(ndt>31)
AE6C  0E1F     MOVLW 0x1F
AE6E  657A     CPFSGT _PFNf_res, BANKED
AE70  D005     BRA 0xAE7C
362:               {
363:                   chkndat=SetNDatCHK(ndt-31);    //oblicz CHK dla liczby danych    
AE72  517A     MOVF _PFNf_res, W, BANKED
AE74  0FE1     ADDLW 0xE1
AE76  EC7E     CALL 0xB6FC, 0
AE78  F05B     NOP
AE7A  D003     BRA 0xAE82
364:               }
365:               else chkndat=SetNDatCHK(0);			//oblicz CHK dla liczby danych
AE7C  0E00     MOVLW 0x0
AE7E  EC7E     CALL 0xB6FC, 0
AE80  F05B     NOP
AE82  6F7B     MOVWF _PFNf_rozruch, BANKED
366:               SetRSTBuf(3,chkndat);               //1 - liczba przesy³anych danych (ndat) 
AE84  C07B     MOVFF _PFNf_rozruch, _PFNf_prODP
AE86  F074     NOP
AE88  0E03     MOVLW 0x3
AE8A  EF17     GOTO 0xC02E
AE8C  F060     NOP
367:           }
368:           //------------------------------------------------------------------------------------
369:           //Zwraca liczbe bajtow dla rozszerzonej ramki danych
370:           unsigned char GetNDat(void)
371:           {
372:               return (GetRSRBuf(1)&0b00011111);
C1A4  0E01     MOVLW 0x1
C1A6  ECA3     CALL 0xBF46, 0
C1A8  F05F     NOP
C1AA  0B1F     ANDLW 0x1F
373:           }
C1AC  0012     RETURN 0
374:           //------------------------------------------------------------------------------------
375:           //Zwraca liczbe bajtow dla rozszerzonej ramki danych
376:           unsigned char GetExNDat(void)
377:           {
378:               return (GetRSRBuf(1)&0b00011111)+(GetRSRBuf(3)&0b00011111);
BE9E  0E03     MOVLW 0x3
BEA0  ECA3     CALL 0xBF46, 0
BEA2  F05F     NOP
BEA4  6F75     MOVWF _PFNf_prn_cs, BANKED
BEA6  0E1F     MOVLW 0x1F
BEA8  1775     ANDWF _PFNf_prn_cs, F, BANKED
BEAA  0E01     MOVLW 0x1
BEAC  ECA3     CALL 0xBF46, 0
BEAE  F05F     NOP
BEB0  0B1F     ANDLW 0x1F
BEB2  2575     ADDWF _PFNf_prn_cs, W, BANKED
379:           }
BEB4  0012     RETURN 0
380:           //------------------------------------------------------------------------------------
381:           //------------------------------------------------------------------------------------
382:           #endif //(_EXT_BOARD!=0)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/amgs_rs9b.c  ----------------
1:             /*amgs_rs9b.c*/
2:             //Funkcje obslugi magistrali RS232 dla AUART2
3:             
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             #include <xc.h>
7:             #include "global.h"			//parametry globalne
8:             #if (_EXT_BOARD!=0)
9:             
10:            #include "main.tp.h"
11:            #include "ammy1.h"
12:            #include "auart9b.tp.h"
13:            #include "amgs_rs9b.h"			//parametry lokalne
14:            #include "LIN1SInterpreter.h"
15:            #include "wersja.h"
16:            #include "ot.tp.h"
17:            
18:            volatile MGSRSData MGSD;
19:            volatile unsigned char stbf[32]={0};
20:            extern volatile UARTData UADt;
21:            extern tpRSDTA1 RSDT1;
22:            extern FRAME_LIN1 FRL1,FTL1;
23:            extern volatile tpOTMaster OTMaster;
24:            extern volatile DataPFN PFN;
25:            volatile unsigned char xxy,zzz,vvv;
26:            //-------------------------------------------------------------------------------
27:            //Timer na potrzeby transmisji (umiescic w przerwaniu od zegara TMR1)
28:            void IncRSTimer(void)
29:            {
30:            	if(MGSD.timRS<255) MGSD.timRS++;
C246  283C     INCF MGSD, W, ACCESS
C248  A4D8     BTFSS STATUS, 2, ACCESS
C24A  2A3C     INCF MGSD, F, ACCESS
31:            }
C24C  0012     RETURN 0
32:            //-------------------------------------------------------------------------------
33:            //Restart zegara 
34:            void StartRSTim(void)
35:            {
36:            	MGSD.timRS=0;
C27E  6A3C     CLRF MGSD, ACCESS
37:            }
C280  0012     RETURN 0
38:            //-------------------------------------------------------------------------------
39:            //Odczyt stanu zegara 
40:            unsigned char RSTim(void)
41:            {
42:            	return MGSD.timRS;
C282  503C     MOVF MGSD, W, ACCESS
43:            }
C284  0012     RETURN 0
44:            //-------------------------------------------------------------------------------
45:            //Inicjalizacja danych zwiazanych z transmisj¹ UART
46:            void InitTransProc(void)
47:            {
48:            	MGSDf_TransData=0;
BD06  9804     BCF MGSDf_TransData, 4, ACCESS
49:            	MGSDf_TransDataTR=0;
BD08  9C04     BCF MGSDf_TransData, 6, ACCESS
50:            	MGSDf_TransDataRC=0;
BD0A  9A04     BCF MGSDf_TransData, 5, ACCESS
51:            	MGSDf_TransOK=0;
BD0C  9E04     BCF MGSDf_TransData, 7, ACCESS
52:            	MGSDf_TransACK=0;
BD0E  9604     BCF MGSDf_TransData, 3, ACCESS
53:            	MGSDf_TERR_TIM=0;
BD10  9404     BCF MGSDf_TransData, 2, ACCESS
54:            	MGSDf_RERR_TIM=0;
BD12  9204     BCF MGSDf_TransData, 1, ACCESS
55:            	MGSDf_RERR_REC=0;
BD14  9004     BCF MGSDf_TransData, 0, ACCESS
56:            	MGSDf_ERRt=0;
BD16  9C03     BCF LIN1f_NDTA, 6, ACCESS
57:            	MGSD.timRS=0;
BD18  6A3C     CLRF MGSD, ACCESS
58:            	MGSD.MTRS=0;
BD1A  6A3D     CLRF _PFNf_LINresSR, ACCESS
59:            	MGSD.MTRS2=0;
BD1C  6A3E     CLRF _PFNf_OTTimeout, ACCESS
60:            	MGSD.KTR=0;
BD1E  6A3F     CLRF 0x3F, ACCESS
61:            	MGSD.LCN=0;
BD20  6A40     CLRF 0x40, ACCESS
62:            }
BD22  0012     RETURN 0
63:            //-------------------------------------------------------------------------------
64:            //Uruchomienie transmisji danych
65:            void StartTransData(void)
66:            {
67:            	MGSDf_TransData=1;		//ustaw bit aktywacji proc. TransData
C25A  8804     BSF MGSDf_TransData, 4, ACCESS
68:            	MGSD.MTRS=0;
C25C  6A3D     CLRF _PFNf_LINresSR, ACCESS
69:            }
C25E  0012     RETURN 0
70:            /*---------------------------------------------------------------------------------*/
71:            //Realizacja transmisji danych do/z odbiornika
72:            //gdzie:
73:            // tnDat - liczba bajtow wysylanych do odbiornika (razem z CHK jesli wystepuje),
74:            // rnDat - liczba bajtow odpowiedzi odbiornika (razem z CHK jesli wystepuje).
75:            void TransData(const unsigned char tnDat)//,const unsigned char rnDat)
855E  0100     MOVLB 0x0
8560  6F75     MOVWF _PFNf_prn_cs, BANKED
76:            {
77:            	switch(MGSD.MTRS)
8562  D04D     BRA 0x85FE
85FE  503D     MOVF _PFNf_LINresSR, W, ACCESS
8600  E0B1     BZ 0x8564
8602  0A01     XORLW 0x1
8604  E0B8     BZ 0x8576
8606  0A03     XORLW 0x3
8608  E0D5     BZ 0x85B4
860A  0A06     XORLW 0x6
860C  E0EE     BZ 0x85EA
860E  0A01     XORLW 0x1
8610  E0F1     BZ 0x85F4
8612  0A03     XORLW 0x3
8614  E0F1     BZ 0x85F8
78:            	{
79:            		case 0:		
80:            			if(tnDat) StartUSARTTR();//tnDat);			//uaktywnij nadawanie
8564  0100     MOVLB 0x0
8566  5175     MOVF _PFNf_prn_cs, W, BANKED
8568  E002     BZ 0x856E
856A  EC66     CALL 0xB6CC, 0
856C  F05B     NOP
81:            			StartRSTim();
856E  EC3F     CALL 0xC27E, 0
8570  F061     NOP
82:            			MGSD.MTRS=1;
8572  0E01     MOVLW 0x1
8574  6E3D     MOVWF _PFNf_LINresSR, ACCESS
83:            		case 1:
84:            			if(tnDat)
8576  0100     MOVLB 0x0
8578  5175     MOVF _PFNf_prn_cs, W, BANKED
857A  E013     BZ 0x85A2
85:            			{
86:            				if(TX2IE)							//trwa nadawanie?
857C  A8A3     BTFSS PIE3, 4, ACCESS
857E  D011     BRA 0x85A2
87:            				{
88:            					if(((RSTim()>1)&&!UADtf_TData)||(RSTim()>_TS_TOUT))			//uplynol maksymalny czas oczekiwania na zak. nadawania?	
8580  EC41     CALL 0xC282, 0
8582  F061     NOP
8584  0100     MOVLB 0x0
8586  6F74     MOVWF _PFNf_prODP, BANKED
8588  0E01     MOVLW 0x1
858A  6574     CPFSGT _PFNf_prODP, BANKED
858C  D002     BRA 0x8592
858E  A414     BTFSS UADtf_RErrREC, 2, ACCESS
8590  D005     BRA 0x859C
8592  EC41     CALL 0xC282, 0
8594  F061     NOP
8596  D840     RCALL PL776
8598  6574     CPFSGT _PFNf_prODP, BANKED
859A  0C14     RETLW 0x14
89:            					{
90:            						MGSD.MTRS=4;
859C  0E04     MOVLW 0x4
859E  6E3D     MOVWF _PFNf_LINresSR, ACCESS
91:            						break;
85A0  0C04     RETLW 0x4
92:            					}
93:            					break;
94:            				}
95:            			}
96:            			MGSDf_TERR_TIM=0;
85A2  9404     BCF MGSDf_TransData, 2, ACCESS
97:            			if(!TXSTA2bits.TRMT) break;						//odczekaj na fizyczne zakonczenie transmisji
85A4  A261     BTFSS TXSTA2, 1, ACCESS
85A6  0012     RETURN 0
98:            			StopUSARTTR();
85A8  ECCD     CALL 0xC19A, 0
85AA  F060     NOP
99:             			StartRSTim();
85AC  EC3F     CALL 0xC27E, 0
85AE  F061     NOP
100:           			MGSD.MTRS=2;
85B0  0E02     MOVLW 0x2
85B2  6E3D     MOVWF _PFNf_LINresSR, ACCESS
101:           		case 2:
102:           			if(!UADtf_REnd&&(RSTim()<_RS_TOUT)) break;
85B4  BE13     BTFSC UAD1tf_RFData, 7, ACCESS
85B6  D006     BRA 0x85C4
85B8  EC41     CALL 0xC282, 0
85BA  F061     NOP
85BC  D82D     RCALL PL776
85BE  6174     CPFSLT _PFNf_prODP, BANKED
85C0  D001     BRA 0x85C4
85C2  0C14     RETLW 0x14
103:           			if(!UADtf_REnd)
85C4  BE13     BTFSC UAD1tf_RFData, 7, ACCESS
85C6  D003     BRA 0x85CE
104:           			{
105:           				MGSD.MTRS=5;
85C8  0E05     MOVLW 0x5
85CA  6E3D     MOVWF _PFNf_LINresSR, ACCESS
106:           				break;
85CC  0C05     RETLW 0x5
107:           			}
108:           			MGSDf_RERR_TIM=0;
85CE  9204     BCF MGSDf_TransData, 1, ACCESS
109:           			if(UADtf_REnd)							//odbior bez problemu?
85D0  AE13     BTFSS UAD1tf_RFData, 7, ACCESS
85D2  D004     BRA 0x85DC
110:           			{
111:           				
112:           				UADtf_REnd=0;
85D4  9E13     BCF UAD1tf_RFData, 7, ACCESS
113:           				MGSDf_TransOK=1;						//znacznik potwierdzenia odebrania paczki danych/zakonczenie trans.
85D6  8E04     BSF MGSDf_TransData, 7, ACCESS
114:           				MGSDf_RERR_REC=0;			
85D8  9004     BCF MGSDf_TransData, 0, ACCESS
115:           			}
85DA  D002     BRA 0x85E0
116:           			else
117:           			{ 
118:           				MGSDf_TransOK=0;
85DC  9E04     BCF MGSDf_TransData, 7, ACCESS
119:           				MGSDf_RERR_REC=1;
85DE  8004     BSF MGSDf_TransData, 0, ACCESS
120:           			}
121:           			MGSDf_TERR_TIM=0;						//przekroczony limit czasu dla transmisji
85E0  9404     BCF MGSDf_TransData, 2, ACCESS
122:           			MGSDf_RERR_TIM=0;						//przekroczony limit czasu dla odbioru
85E2  9204     BCF MGSDf_TransData, 1, ACCESS
123:           			MGSD.MTRS=6;
85E4  0E06     MOVLW 0x6
85E6  6E3D     MOVWF _PFNf_LINresSR, ACCESS
124:           			break;
85E8  0C06     RETLW 0x6
125:           		case 4:
126:           			MGSDf_TERR_TIM=1;						//przekroczony limit czasu dla transmisji
85EA  8404     BSF MGSDf_TransData, 2, ACCESS
127:           			MGSDf_TransOK=0;
85EC  9E04     BCF MGSDf_TransData, 7, ACCESS
128:           			StopUSARTTR();
85EE  ECCD     CALL 0xC19A, 0
85F0  F060     NOP
85F2  D7F8     BRA 0x85E4
129:           			MGSD.MTRS=6;
130:           			break;
131:           		case 5:
132:           			MGSDf_RERR_TIM=1;						//przekroczony limit czasu dla odbioru
85F4  8204     BSF MGSDf_TransData, 1, ACCESS
133:           			MGSDf_TransOK=0;
85F6  9E04     BCF MGSDf_TransData, 7, ACCESS
134:           		case 6:
135:           			MGSDf_TransData=0;
85F8  9804     BCF MGSDf_TransData, 4, ACCESS
136:           			MGSD.MTRS=0;
85FA  6A3D     CLRF _PFNf_LINresSR, ACCESS
137:           			break;
85FC  0012     RETURN 0
138:           	}
139:           }
8616  0012     RETURN 0
140:           /*---------------------------------------------------------------------------------*/
141:           /*---------------------------------------------------------------------------------*/
142:           /*---------------------------------------------------------------------------------*/
143:           /*---------------------------------------------------------------------------------*/
144:           //------------------Procedury zwiazane z obsluga transmisji z ukladem UNI-01
145:           /*---------------------------------------------------------------------------------*/
146:           //Zapisuje dane z modulu UNI-02
147:           void SaveRSToData(void)
148:           {
149:               volatile unsigned char i;
150:           	//unsigned char idn;
151:           	//0 - adres master
152:           	//1 - liczba przesylanych bajtow (ndat)
153:           	//2 - identyfikator paczki danych
154:           	RSDT1.outID=GetRSRBuf(2);
1240  0E02     MOVLW 0x2
1242  ECA3     CALL 0xBF46, 0
1244  F05F     NOP
1246  0102     MOVLB 0x2
1248  6F2E     MOVWF _PFNf_FOT, BANKED
155:           
156:           	switch(RSDT1.outID)
124A  D36C     BRA 0x1924
1924  512E     MOVF _PFNf_FOT, W, BANKED
1926  0A01     XORLW 0x1
1928  E101     BNZ 0x192C
192A  D490     BRA 0x124C
192C  0A03     XORLW 0x3
192E  E101     BNZ 0x1932
1930  D5EE     BRA 0x150E
1932  0A01     XORLW 0x1
1934  E101     BNZ 0x1938
1936  D748     BRA 0x17C8
1938  0A07     XORLW 0x7
193A  E101     BNZ 0x193E
193C  D537     BRA 0x13AC
193E  0A01     XORLW 0x1
1940  E101     BNZ 0x1944
1942  D68D     BRA 0x165E
157:           	{
158:           		case _RD_STD:				//identyfikator paczki danych
159:           		{
160:                       //(RAMKA DLA WERSJI OPROGRAMOWANIA<=8)
161:           			if(!RSDT1f_RRD_STD)		//aktywna blokada na czas interpretacji danych?
124C  BA12     BTFSC RSDT1f_RD_STD, 5, ACCESS
124E  0012     RETURN 0
162:           			{
163:           				RSDT1f_RD_STD=0;
1250  9612     BCF RSDT1f_RD_STD, 3, ACCESS
164:           				switch(GetNDat())	//liczba przeslanych bajtow
1252  D00B     BRA 0x126A
126A  ECD2     CALL 0xC1A4, 0
126C  F060     NOP
126E  0A1C     XORLW 0x1C
1270  E0F1     BZ 0x1254
1272  0A02     XORLW 0x2
1274  E0F1     BZ 0x1258
1276  0A01     XORLW 0x1
1278  E0F1     BZ 0x125C
127A  D7F4     BRA 0x1264
165:           				{
166:           					case 28:
167:           						RSDT1.vSTD=1;
1254  0E01     MOVLW 0x1
1256  D003     BRA 0x125E
168:           						break;
169:           					case 30:
170:           						RSDT1.vSTD=2;
1258  0E02     MOVLW 0x2
125A  D001     BRA 0x125E
171:           						break; 
172:           					case 31:
173:           						RSDT1.vSTD=3;
125C  0E03     MOVLW 0x3
125E  0102     MOVLB 0x2
1260  6F2F     MOVWF _PFNf_KnfDisErr, BANKED
174:           						break;                        
1262  D00C     BRA 0x127C
175:                               default:
176:           						if(GetNDat()>31) RSDT1.vSTD=3;
1264  ECD2     CALL 0xC1A4, 0
1266  F060     NOP
1268  D7F9     BRA 0x125C
177:                                   else RSDT1.vSTD=3;
178:           						break;                        
179:                           }                
180:           				RSDT1.outRDZ0=GetRSRBuf(3);
127C  0E03     MOVLW 0x3
127E  ECA3     CALL 0xBF46, 0
1280  F05F     NOP
1282  0102     MOVLB 0x2
1284  6F30     MOVWF _PFNf_LIN_CK, BANKED
181:           				RSDT1.outRDZ1=GetRSRBuf(4);
1286  0E04     MOVLW 0x4
1288  ECA3     CALL 0xBF46, 0
128A  F05F     NOP
128C  0102     MOVLB 0x2
128E  6F31     MOVWF _PFNf_LIN_CW, BANKED
182:                           RSDT1.outRDZ2=0;
1290  6B32     CLRF _PFNf_LIN_DPGD, BANKED
183:           				RSDT1.outSTAT0=GetRSRBuf(5);
1292  0E05     MOVLW 0x5
1294  ECA3     CALL 0xBF46, 0
1296  F05F     NOP
1298  0102     MOVLB 0x2
129A  6F45     MOVWF CommRT, BANKED
184:           				RSDT1.outSTAT1=GetRSRBuf(6);
129C  0E06     MOVLW 0x6
129E  ECA3     CALL 0xBF46, 0
12A0  F05F     NOP
12A2  0102     MOVLB 0x2
12A4  6F46     MOVWF 0x46, BANKED
185:           				RSDT1.outSTAT2=GetRSRBuf(7);
12A6  0E07     MOVLW 0x7
12A8  ECA3     CALL 0xBF46, 0
12AA  F05F     NOP
12AC  0102     MOVLB 0x2
12AE  6F47     MOVWF 0x47, BANKED
186:           				RSDT1.outSTAT3=GetRSRBuf(8);
12B0  0E08     MOVLW 0x8
12B2  ECA3     CALL 0xBF46, 0
12B4  F05F     NOP
12B6  0102     MOVLB 0x2
12B8  6F48     MOVWF sample, BANKED
187:           				RSDT1.outCO=GetRSRBuf(9);
12BA  0E09     MOVLW 0x9
12BC  ECA3     CALL 0xBF46, 0
12BE  F05F     NOP
12C0  0102     MOVLB 0x2
12C2  6F33     MOVWF _PFNf_LIN_ENDO, BANKED
188:           				RSDT1.outCW=GetRSRBuf(10);
12C4  0E0A     MOVLW 0xA
12C6  ECA3     CALL 0xBF46, 0
12C8  F05F     NOP
12CA  0102     MOVLB 0x2
12CC  6F34     MOVWF _PFNf_LIN_EPBCO, BANKED
189:           				RSDT1.outCS=GetRSRBuf(11);
12CE  0E0B     MOVLW 0xB
12D0  ECA3     CALL 0xBF46, 0
12D2  F05F     NOP
12D4  0102     MOVLB 0x2
12D6  6F35     MOVWF _PFNf_LIN_EPBCW, BANKED
190:           				RSDT1.outIN=GetRSRBuf(12);
12D8  0E0C     MOVLW 0xC
12DA  ECA3     CALL 0xBF46, 0
12DC  F05F     NOP
12DE  0102     MOVLB 0x2
12E0  6F36     MOVWF _PFNf_LIN_KSK, BANKED
191:           				RSDT1.outVNT=GetRSRBuf(13);
12E2  0E0D     MOVLW 0xD
12E4  ECA3     CALL 0xBF46, 0
12E6  F05F     NOP
12E8  0102     MOVLB 0x2
12EA  6F37     MOVWF _PFNf_LIN_PBCO, BANKED
192:           				RSDT1.outPCO=GetRSRBuf(14);
12EC  0E0E     MOVLW 0xE
12EE  ECA3     CALL 0xBF46, 0
12F0  F05F     NOP
12F2  0102     MOVLB 0x2
12F4  6F38     MOVWF _PFNf_LIN_PBCW, BANKED
193:           				RSDT1.outPCOmn=GetRSRBuf(15);
12F6  0E0F     MOVLW 0xF
12F8  ECA3     CALL 0xBF46, 0
12FA  F05F     NOP
12FC  0102     MOVLB 0x2
12FE  6F3A     MOVWF _PFNf_LIN_STR, BANKED
194:           				RSDT1.outPCOmx=GetRSRBuf(16);
1300  0E10     MOVLW 0x10
1302  ECA3     CALL 0xBF46, 0
1304  F05F     NOP
1306  0102     MOVLB 0x2
1308  6F3B     MOVWF _PFNf_LINres, BANKED
195:           				RSDT1.outPCW=GetRSRBuf(17);
130A  0E11     MOVLW 0x11
130C  ECA3     CALL 0xBF46, 0
130E  F05F     NOP
1310  0102     MOVLB 0x2
1312  6F39     MOVWF _PFNf_LIN_RT, BANKED
196:           				RSDT1.outPCWmn=GetRSRBuf(18);
1314  0E12     MOVLW 0x12
1316  ECA3     CALL 0xBF46, 0
1318  F05F     NOP
131A  0102     MOVLB 0x2
131C  6F3C     MOVWF MGSD, BANKED
197:           				RSDT1.outPCWmx=GetRSRBuf(19);
131E  0E13     MOVLW 0x13
1320  ECA3     CALL 0xBF46, 0
1322  F05F     NOP
1324  0102     MOVLB 0x2
1326  6F3D     MOVWF _PFNf_LINresSR, BANKED
198:           				RSDT1.outPPCO=GetRSRBuf(20);
1328  0E14     MOVLW 0x14
132A  ECA3     CALL 0xBF46, 0
132C  F05F     NOP
132E  0102     MOVLB 0x2
1330  6F3E     MOVWF _PFNf_OTTimeout, BANKED
199:           				RSDT1.outPPCW=GetRSRBuf(21);
1332  0E15     MOVLW 0x15
1334  ECA3     CALL 0xBF46, 0
1336  F05F     NOP
1338  0102     MOVLB 0x2
133A  6F3F     MOVWF 0x3F, BANKED
200:           				RSDT1.outERR=GetRSRBuf(22);
133C  0E16     MOVLW 0x16
133E  ECA3     CALL 0xBF46, 0
1340  F05F     NOP
1342  0102     MOVLB 0x2
1344  6F40     MOVWF 0x40, BANKED
201:           				RSDT1.outAWR=GetRSRBuf(23);
1346  0E17     MOVLW 0x17
1348  ECA3     CALL 0xBF46, 0
134A  F05F     NOP
134C  0102     MOVLB 0x2
134E  6F41     MOVWF UADt, BANKED
202:           				RSDT1.outECO=GetRSRBuf(24);
1350  0E18     MOVLW 0x18
1352  ECA3     CALL 0xBF46, 0
1354  F05F     NOP
1356  0102     MOVLB 0x2
1358  6F42     MOVWF 0x42, BANKED
203:           				RSDT1.outPP=GetRSRBuf(25);
135A  0E19     MOVLW 0x19
135C  ECA3     CALL 0xBF46, 0
135E  F05F     NOP
1360  0102     MOVLB 0x2
1362  6F43     MOVWF 0x43, BANKED
204:           				RSDT1.outPG=GetRSRBuf(26);    
1364  0E1A     MOVLW 0x1A
1366  ECA3     CALL 0xBF46, 0
1368  F05F     NOP
136A  0102     MOVLB 0x2
136C  6F44     MOVWF 0x44, BANKED
205:                           if(RSDT1.vSTD>1)
136E  0E01     MOVLW 0x1
1370  652F     CPFSGT _PFNf_KnfDisErr, BANKED
1372  D00B     BRA 0x138A
206:                           {                
207:                               RSDT1.outrCO=GetRSRBuf(27);
1374  0E1B     MOVLW 0x1B
1376  ECA3     CALL 0xBF46, 0
1378  F05F     NOP
137A  0102     MOVLB 0x2
137C  6F4B     MOVWF 0x4B, BANKED
208:                               RSDT1.outrCW=GetRSRBuf(28);
137E  0E1C     MOVLW 0x1C
1380  ECA3     CALL 0xBF46, 0
1382  F05F     NOP
1384  0102     MOVLB 0x2
1386  6F4C     MOVWF 0x4C, BANKED
209:                           }
1388  D004     BRA 0x1392
210:                           else
211:                           {
212:                               RSDT1.outrCO=RSDT1.outCO;
138A  C233     MOVFF 0x233, 0x24B
138C  F24B     NOP
213:                               RSDT1.outrCW=RSDT1.outCW;                    
138E  C234     MOVFF 0x234, 0x24C
1390  F24C     NOP
214:                           }
215:                           if(RSDT1.vSTD>2)
1392  0E02     MOVLW 0x2
1394  652F     CPFSGT _PFNf_KnfDisErr, BANKED
1396  D006     BRA 0x13A4
216:                           {
217:                               RSDT1.outSTAT4=GetRSRBuf(29);  
1398  0E1D     MOVLW 0x1D
139A  ECA3     CALL 0xBF46, 0
139C  F05F     NOP
139E  0102     MOVLB 0x2
13A0  6F49     MOVWF RSerial, BANKED
218:                               RSDT1.outSTAT5=0;                    
13A2  D001     BRA 0x13A6
219:                           }
220:                           else
221:                           {
222:                               RSDT1.outSTAT4=0;
13A4  6B49     CLRF RSerial, BANKED
223:                               RSDT1.outSTAT5=0;                    
13A6  6B4A     CLRF cSk, BANKED
224:                           }                               
225:           				RSDT1f_RD_STD=1;
13A8  8612     BSF RSDT1f_RD_STD, 3, ACCESS
13AA  0012     RETURN 0
226:           			}
227:           			break;
228:           		}
229:           		case _RD_STD2:				//identyfikator paczki danych
230:           		{
231:                       //(RAMKA DLA WERSJI OPROGRAMOWANIA>=9)
232:           			if(!RSDT1f_RRD_STD)		//aktywna blokada na czas interpretacji danych?
13AC  BA12     BTFSC RSDT1f_RD_STD, 5, ACCESS
13AE  0012     RETURN 0
233:           			{
234:           				RSDT1f_RD_STD=0;
13B0  9612     BCF RSDT1f_RD_STD, 3, ACCESS
235:           				switch(GetExNDat())	//liczba przeslanych bajtow
13B2  D007     BRA 0x13C2
13C2  EC4F     CALL 0xBE9E, 0
13C4  F05F     NOP
13C6  0A25     XORLW 0x25
13C8  E0F5     BZ 0x13B4
13CA  D7F8     BRA 0x13BC
236:           				{
237:           					case 37:
238:           						RSDT1.vSTD=4;
13B4  0E04     MOVLW 0x4
13B6  0102     MOVLB 0x2
13B8  6F2F     MOVWF _PFNf_KnfDisErr, BANKED
239:           						break;                        
13BA  D008     BRA 0x13CC
240:                               default:
241:           						if(GetExNDat()>37) RSDT1.vSTD=4;
13BC  EC4F     CALL 0xBE9E, 0
13BE  F05F     NOP
13C0  D7F9     BRA 0x13B4
242:                                   else RSDT1.vSTD=4;
243:           						break;                        
244:                           }                
245:           				RSDT1.outRDZ0=GetRSRBuf(4);
13CC  0E04     MOVLW 0x4
13CE  ECA3     CALL 0xBF46, 0
13D0  F05F     NOP
13D2  0102     MOVLB 0x2
13D4  6F30     MOVWF _PFNf_LIN_CK, BANKED
246:           				RSDT1.outRDZ1=GetRSRBuf(5);
13D6  0E05     MOVLW 0x5
13D8  ECA3     CALL 0xBF46, 0
13DA  F05F     NOP
13DC  0102     MOVLB 0x2
13DE  6F31     MOVWF _PFNf_LIN_CW, BANKED
247:           				RSDT1.outRDZ2=GetRSRBuf(6);                
13E0  0E06     MOVLW 0x6
13E2  ECA3     CALL 0xBF46, 0
13E4  F05F     NOP
13E6  0102     MOVLB 0x2
13E8  6F32     MOVWF _PFNf_LIN_DPGD, BANKED
248:           				RSDT1.outSTAT0=GetRSRBuf(7);
13EA  0E07     MOVLW 0x7
13EC  ECA3     CALL 0xBF46, 0
13EE  F05F     NOP
13F0  0102     MOVLB 0x2
13F2  6F45     MOVWF CommRT, BANKED
249:           				RSDT1.outSTAT1=GetRSRBuf(8);
13F4  0E08     MOVLW 0x8
13F6  ECA3     CALL 0xBF46, 0
13F8  F05F     NOP
13FA  0102     MOVLB 0x2
13FC  6F46     MOVWF 0x46, BANKED
250:           				RSDT1.outSTAT2=GetRSRBuf(9);
13FE  0E09     MOVLW 0x9
1400  ECA3     CALL 0xBF46, 0
1402  F05F     NOP
1404  0102     MOVLB 0x2
1406  6F47     MOVWF 0x47, BANKED
251:           				RSDT1.outSTAT3=GetRSRBuf(10);
1408  0E0A     MOVLW 0xA
140A  ECA3     CALL 0xBF46, 0
140C  F05F     NOP
140E  0102     MOVLB 0x2
1410  6F48     MOVWF sample, BANKED
252:           				RSDT1.outSTAT4=GetRSRBuf(11);      
1412  0E0B     MOVLW 0xB
1414  ECA3     CALL 0xBF46, 0
1416  F05F     NOP
1418  0102     MOVLB 0x2
141A  6F49     MOVWF RSerial, BANKED
253:           				RSDT1.outSTAT5=GetRSRBuf(12);                
141C  0E0C     MOVLW 0xC
141E  ECA3     CALL 0xBF46, 0
1420  F05F     NOP
1422  0102     MOVLB 0x2
1424  6F4A     MOVWF cSk, BANKED
254:           				RSDT1.outCO=GetRSRBuf(13);
1426  0E0D     MOVLW 0xD
1428  ECA3     CALL 0xBF46, 0
142A  F05F     NOP
142C  0102     MOVLB 0x2
142E  6F33     MOVWF _PFNf_LIN_ENDO, BANKED
255:           				RSDT1.outCW=GetRSRBuf(14);
1430  0E0E     MOVLW 0xE
1432  ECA3     CALL 0xBF46, 0
1434  F05F     NOP
1436  0102     MOVLB 0x2
1438  6F34     MOVWF _PFNf_LIN_EPBCO, BANKED
256:           				RSDT1.outCS=GetRSRBuf(15);
143A  0E0F     MOVLW 0xF
143C  ECA3     CALL 0xBF46, 0
143E  F05F     NOP
1440  0102     MOVLB 0x2
1442  6F35     MOVWF _PFNf_LIN_EPBCW, BANKED
257:           				RSDT1.outIN=GetRSRBuf(16);
1444  0E10     MOVLW 0x10
1446  ECA3     CALL 0xBF46, 0
1448  F05F     NOP
144A  0102     MOVLB 0x2
144C  6F36     MOVWF _PFNf_LIN_KSK, BANKED
258:           				RSDT1.outVNT=GetRSRBuf(17);
144E  0E11     MOVLW 0x11
1450  ECA3     CALL 0xBF46, 0
1452  F05F     NOP
1454  0102     MOVLB 0x2
1456  6F37     MOVWF _PFNf_LIN_PBCO, BANKED
259:           				RSDT1.outPCO=GetRSRBuf(18);
1458  0E12     MOVLW 0x12
145A  ECA3     CALL 0xBF46, 0
145C  F05F     NOP
145E  0102     MOVLB 0x2
1460  6F38     MOVWF _PFNf_LIN_PBCW, BANKED
260:           				RSDT1.outPCOmn=GetRSRBuf(19);
1462  0E13     MOVLW 0x13
1464  ECA3     CALL 0xBF46, 0
1466  F05F     NOP
1468  0102     MOVLB 0x2
146A  6F3A     MOVWF _PFNf_LIN_STR, BANKED
261:           				RSDT1.outPCOmx=GetRSRBuf(20);
146C  0E14     MOVLW 0x14
146E  ECA3     CALL 0xBF46, 0
1470  F05F     NOP
1472  0102     MOVLB 0x2
1474  6F3B     MOVWF _PFNf_LINres, BANKED
262:           				RSDT1.outPCW=GetRSRBuf(21);
1476  0E15     MOVLW 0x15
1478  ECA3     CALL 0xBF46, 0
147A  F05F     NOP
147C  0102     MOVLB 0x2
147E  6F39     MOVWF _PFNf_LIN_RT, BANKED
263:           				RSDT1.outPCWmn=GetRSRBuf(22);
1480  0E16     MOVLW 0x16
1482  ECA3     CALL 0xBF46, 0
1484  F05F     NOP
1486  0102     MOVLB 0x2
1488  6F3C     MOVWF MGSD, BANKED
264:           				RSDT1.outPCWmx=GetRSRBuf(23);
148A  0E17     MOVLW 0x17
148C  ECA3     CALL 0xBF46, 0
148E  F05F     NOP
1490  0102     MOVLB 0x2
1492  6F3D     MOVWF _PFNf_LINresSR, BANKED
265:           				RSDT1.outPPCO=GetRSRBuf(24);
1494  0E18     MOVLW 0x18
1496  ECA3     CALL 0xBF46, 0
1498  F05F     NOP
149A  0102     MOVLB 0x2
149C  6F3E     MOVWF _PFNf_OTTimeout, BANKED
266:           				RSDT1.outPPCW=GetRSRBuf(25);
149E  0E19     MOVLW 0x19
14A0  ECA3     CALL 0xBF46, 0
14A2  F05F     NOP
14A4  0102     MOVLB 0x2
14A6  6F3F     MOVWF 0x3F, BANKED
267:           				RSDT1.outERR=GetRSRBuf(26);
14A8  0E1A     MOVLW 0x1A
14AA  ECA3     CALL 0xBF46, 0
14AC  F05F     NOP
14AE  0102     MOVLB 0x2
14B0  6F40     MOVWF 0x40, BANKED
268:           				RSDT1.outAWR=GetRSRBuf(27);
14B2  0E1B     MOVLW 0x1B
14B4  ECA3     CALL 0xBF46, 0
14B6  F05F     NOP
14B8  0102     MOVLB 0x2
14BA  6F41     MOVWF UADt, BANKED
269:           				RSDT1.outECO=GetRSRBuf(28);
14BC  0E1C     MOVLW 0x1C
14BE  ECA3     CALL 0xBF46, 0
14C0  F05F     NOP
14C2  0102     MOVLB 0x2
14C4  6F42     MOVWF 0x42, BANKED
270:           				RSDT1.outPP=GetRSRBuf(29);
14C6  0E1D     MOVLW 0x1D
14C8  ECA3     CALL 0xBF46, 0
14CA  F05F     NOP
14CC  0102     MOVLB 0x2
14CE  6F43     MOVWF 0x43, BANKED
271:           				RSDT1.outPG=GetRSRBuf(30);                
14D0  0E1E     MOVLW 0x1E
14D2  ECA3     CALL 0xBF46, 0
14D4  F05F     NOP
14D6  0102     MOVLB 0x2
14D8  6F44     MOVWF 0x44, BANKED
272:                           RSDT1.outrCO=GetRSRBuf(31);
14DA  0E1F     MOVLW 0x1F
14DC  ECA3     CALL 0xBF46, 0
14DE  F05F     NOP
14E0  0102     MOVLB 0x2
14E2  6F4B     MOVWF 0x4B, BANKED
273:                           RSDT1.outrCW=GetRSRBuf(32);
14E4  0E20     MOVLW 0x20
14E6  ECA3     CALL 0xBF46, 0
14E8  F05F     NOP
14EA  0102     MOVLB 0x2
14EC  6F4C     MOVWF 0x4C, BANKED
274:                           RSDT1.outZW=GetRSRBuf(33);    
14EE  0E21     MOVLW 0x21
14F0  ECA3     CALL 0xBF46, 0
14F2  F05F     NOP
14F4  0102     MOVLB 0x2
14F6  6F4D     MOVWF 0x4D, BANKED
275:                           RSDT1.outSETPmin=GetRSRBuf(34);
14F8  0E22     MOVLW 0x22
14FA  ECA3     CALL 0xBF46, 0
14FC  F05F     NOP
14FE  0102     MOVLB 0x2
1500  6F4E     MOVWF 0x4E, BANKED
276:                           RSDT1.outSETPmax=GetRSRBuf(35);                
1502  0E23     MOVLW 0x23
1504  ECA3     CALL 0xBF46, 0
1506  F05F     NOP
1508  0102     MOVLB 0x2
150A  6F4F     MOVWF 0x4F, BANKED
150C  D74D     BRA 0x13A8
277:           				RSDT1f_RD_STD=1;
278:           			}
279:           			break;
280:           		}                 
281:           		case _RD_KNF:
282:           		{
283:                       //(RAMKA DLA WERSJI OPROGRAMOWANIA<=8)
284:           			if(!RSDT1f_RRD_KNF)		//aktywna blokada na czas interpretacji danych?
150E  B812     BTFSC RSDT1f_RD_STD, 4, ACCESS
1510  0012     RETURN 0
285:           			{
286:           				RSDT1f_RD_KNF=0;
1512  9212     BCF RSDT1f_RD_STD, 1, ACCESS
287:           				//okreslenie wersji paczki danych (na potrzeby proc.konf.- kompatybilnosc wsteczna)
288:           				switch(GetNDat())	//liczba przeslanych bajtow
1514  D011     BRA 0x1538
1538  ECD2     CALL 0xC1A4, 0
153A  F060     NOP
153C  0A16     XORLW 0x16
153E  E0EB     BZ 0x1516
1540  0A0E     XORLW 0xE
1542  E0EB     BZ 0x151A
1544  0A01     XORLW 0x1
1546  E0EB     BZ 0x151E
1548  0A03     XORLW 0x3
154A  E0EB     BZ 0x1522
154C  0A07     XORLW 0x7
154E  E0EB     BZ 0x1526
1550  0A03     XORLW 0x3
1552  E0EB     BZ 0x152A
1554  D7EE     BRA 0x1532
289:           				{
290:           					case 22:
291:           						RSDT1.vKNF=1;
1516  0E01     MOVLW 0x1
1518  D009     BRA 0x152C
292:           						break;
293:           					case 24:
294:           						RSDT1.vKNF=2;
151A  0E02     MOVLW 0x2
151C  D007     BRA 0x152C
295:           						break;
296:           					case 25:
297:           						RSDT1.vKNF=3;
151E  0E03     MOVLW 0x3
1520  D005     BRA 0x152C
298:           						break;
299:           					case 26:
300:           						RSDT1.vKNF=4;
1522  0E04     MOVLW 0x4
1524  D003     BRA 0x152C
301:           						break;    
302:           					case 29:
303:           						RSDT1.vKNF=5;
1526  0E05     MOVLW 0x5
1528  D001     BRA 0x152C
304:           						break;      
305:                               case 30:
306:                                   RSDT1.vKNF=6;
152A  0E06     MOVLW 0x6
152C  0102     MOVLB 0x2
152E  6F50     MOVWF 0x50, BANKED
307:                                   break;                        
1530  D012     BRA 0x1556
308:           					default:
309:                                   if(GetNDat()>30) RSDT1.vKNF=6;
1532  ECD2     CALL 0xC1A4, 0
1534  F060     NOP
1536  D7F9     BRA 0x152A
310:                                   else RSDT1.vKNF=6;
311:           						break;												
312:           				}
313:           				RSDT1.outKSTAT0=GetRSRBuf(3);
1556  0E03     MOVLW 0x3
1558  ECA3     CALL 0xBF46, 0
155A  F05F     NOP
155C  0102     MOVLB 0x2
155E  6F51     MOVWF 0x51, BANKED
314:           				RSDT1.outKRK=GetRSRBuf(4);
1560  0E04     MOVLW 0x4
1562  ECA3     CALL 0xBF46, 0
1564  F05F     NOP
1566  0102     MOVLB 0x2
1568  6F52     MOVWF 0x52, BANKED
315:           				RSDT1.outPRM=GetRSRBuf(5);
156A  0E05     MOVLW 0x5
156C  ECA3     CALL 0xBF46, 0
156E  F05F     NOP
1570  0102     MOVLB 0x2
1572  6F53     MOVWF 0x53, BANKED
316:           				RSDT1.outMSTR=GetRSRBuf(6);
1574  0E06     MOVLW 0x6
1576  ECA3     CALL 0xBF46, 0
1578  F05F     NOP
157A  0102     MOVLB 0x2
157C  6F54     MOVWF 0x54, BANKED
317:           				RSDT1.outMMAXU=GetRSRBuf(7);
157E  0E07     MOVLW 0x7
1580  ECA3     CALL 0xBF46, 0
1582  F05F     NOP
1584  0102     MOVLB 0x2
1586  6F55     MOVWF 0x55, BANKED
318:           				RSDT1.outMMAXG=GetRSRBuf(8);
1588  0E08     MOVLW 0x8
158A  ECA3     CALL 0xBF46, 0
158C  F05F     NOP
158E  0102     MOVLB 0x2
1590  6F56     MOVWF 0x56, BANKED
319:           				RSDT1.outOPDG=GetRSRBuf(9);
1592  0E09     MOVLW 0x9
1594  ECA3     CALL 0xBF46, 0
1596  F05F     NOP
1598  0102     MOVLB 0x2
159A  6F5B     MOVWF 0x5B, BANKED
320:           				RSDT1.outWANL=GetRSRBuf(10);
159C  0E0A     MOVLW 0xA
159E  ECA3     CALL 0xBF46, 0
15A0  F05F     NOP
15A2  0102     MOVLB 0x2
15A4  6F57     MOVWF 0x57, BANKED
321:           				RSDT1.outKODKT=GetRSRBuf(11);
15A6  0E0B     MOVLW 0xB
15A8  ECA3     CALL 0xBF46, 0
15AA  F05F     NOP
15AC  0102     MOVLB 0x2
15AE  6F58     MOVWF 0x58, BANKED
322:           				RSDT1.outWOBG=GetRSRBuf(12);
15B0  0E0C     MOVLW 0xC
15B2  ECA3     CALL 0xBF46, 0
15B4  F05F     NOP
15B6  0102     MOVLB 0x2
15B8  6F59     MOVWF 0x59, BANKED
323:           				RSDT1.outNOKR=GetRSRBuf(13);
15BA  0E0D     MOVLW 0xD
15BC  ECA3     CALL 0xBF46, 0
15BE  F05F     NOP
15C0  0102     MOVLB 0x2
15C2  6F5A     MOVWF 0x5A, BANKED
324:           				RSDT1.outTPCS=GetRSRBuf(14);
15C4  0E0E     MOVLW 0xE
15C6  ECA3     CALL 0xBF46, 0
15C8  F05F     NOP
15CA  0102     MOVLB 0x2
15CC  6F5C     MOVWF 0x5C, BANKED
325:           				RSDT1.outMMIN=GetRSRBuf(15);
15CE  0E0F     MOVLW 0xF
15D0  ECA3     CALL 0xBF46, 0
15D2  F05F     NOP
15D4  0102     MOVLB 0x2
15D6  6F5D     MOVWF 0x5D, BANKED
326:           				RSDT1.outMMAX=GetRSRBuf(16);
15D8  0E10     MOVLW 0x10
15DA  ECA3     CALL 0xBF46, 0
15DC  F05F     NOP
15DE  0102     MOVLB 0x2
15E0  6F5E     MOVWF 0x5E, BANKED
327:           				RSDT1.outRDPM=GetRSRBuf(17);
15E2  0E11     MOVLW 0x11
15E4  ECA3     CALL 0xBF46, 0
15E6  F05F     NOP
15E8  0102     MOVLB 0x2
15EA  6F5F     MOVWF 0x5F, BANKED
328:           				RSDT1.outDTPM=GetRSRBuf(18);
15EC  0E12     MOVLW 0x12
15EE  ECA3     CALL 0xBF46, 0
15F0  F05F     NOP
15F2  0102     MOVLB 0x2
15F4  6F60     MOVWF __pcstackBANK0, BANKED
329:           				RSDT1.outMDPM=GetRSRBuf(19);
15F6  0E13     MOVLW 0x13
15F8  ECA3     CALL 0xBF46, 0
15FA  F05F     NOP
15FC  0102     MOVLB 0x2
15FE  6F61     MOVWF 0x61, BANKED
330:           				RSDT1.outTECO=GetRSRBuf(20);
1600  0E14     MOVLW 0x14
1602  ECA3     CALL 0xBF46, 0
1604  F05F     NOP
1606  0102     MOVLB 0x2
1608  6F62     MOVWF msk, BANKED
331:           				RSDT1.outTMMAXG2=GetRSRBuf(21);
160A  0E15     MOVLW 0x15
160C  ECA3     CALL 0xBF46, 0
160E  F05F     NOP
1610  0102     MOVLB 0x2
1612  6F63     MOVWF 0x63, BANKED
332:           				RSDT1.outMMAXG2=GetRSRBuf(22);
1614  0E16     MOVLW 0x16
1616  ECA3     CALL 0xBF46, 0
1618  F05F     NOP
161A  0102     MOVLB 0x2
161C  6F64     MOVWF i, BANKED
333:           				RSDT1.outMGPM=GetRSRBuf(23);
161E  0E17     MOVLW 0x17
1620  ECA3     CALL 0xBF46, 0
1622  F05F     NOP
1624  0102     MOVLB 0x2
1626  6F65     MOVWF 0x65, BANKED
334:           				RSDT1.outMGPM2=GetRSRBuf(24);
1628  0E18     MOVLW 0x18
162A  ECA3     CALL 0xBF46, 0
162C  F05F     NOP
162E  0102     MOVLB 0x2
1630  6F66     MOVWF 0x66, BANKED
335:                           RSDT1.outHSCO=GetRSRBuf(25);
1632  0E19     MOVLW 0x19
1634  ECA3     CALL 0xBF46, 0
1636  F05F     NOP
1638  0102     MOVLB 0x2
163A  6F67     MOVWF _PFNf_ofnserw, BANKED
336:                           RSDT1.outCONW=GetRSRBuf(26);
163C  0E1A     MOVLW 0x1A
163E  ECA3     CALL 0xBF46, 0
1640  F05F     NOP
1642  0102     MOVLB 0x2
1644  6F68     MOVWF _PFNf_ofoff, BANKED
337:                           RSDT1.outPROP=GetRSRBuf(27);
1646  0E1B     MOVLW 0x1B
1648  ECA3     CALL 0xBF46, 0
164A  F05F     NOP
164C  0102     MOVLB 0x2
164E  6F69     MOVWF _PFNf_ofzima, BANKED
338:                           RSDT1.outRFAN=GetRSRBuf(28);                
1650  0E1C     MOVLW 0x1C
1652  ECA3     CALL 0xBF46, 0
1654  F05F     NOP
1656  0102     MOVLB 0x2
1658  6F6A     MOVWF _PFNf_opKNF, BANKED
339:           				RSDT1f_RD_KNF=1;
165A  8212     BSF RSDT1f_RD_STD, 1, ACCESS
165C  0012     RETURN 0
340:           			}
341:           			break;
342:           		}
343:           		case _RD_KNF2:
344:           		{
345:                       //(RAMKA DLA WERSJI OPROGRAMOWANIA>=9)
346:           			if(!RSDT1f_RRD_KNF)		//aktywna blokada na czas interpretacji danych?
165E  B812     BTFSC RSDT1f_RD_STD, 4, ACCESS
1660  0012     RETURN 0
347:           			{
348:           				RSDT1f_RD_KNF=0;
1662  9212     BCF RSDT1f_RD_STD, 1, ACCESS
349:           				//okreslenie wersji paczki danych (na potrzeby proc.konf.- kompatybilnosc wsteczna)
350:           				switch(GetExNDat())	//liczba przeslanych bajtow
1664  D009     BRA 0x1678
1678  EC4F     CALL 0xBE9E, 0
167A  F05F     NOP
167C  0A24     XORLW 0x24
167E  E0F5     BZ 0x166A
1680  0A01     XORLW 0x1
1682  E0F1     BZ 0x1666
1684  D7F6     BRA 0x1672
351:           				{        
352:                               case 37:
353:                                   RSDT1.vKNF=8;
1666  0E08     MOVLW 0x8
1668  D001     BRA 0x166C
354:                                   break;                    
355:                               case 36:
356:                                   RSDT1.vKNF=7;
166A  0E07     MOVLW 0x7
166C  0102     MOVLB 0x2
166E  6F50     MOVWF 0x50, BANKED
357:                                   break;                        
1670  D00A     BRA 0x1686
358:           					default:
359:           						if(GetExNDat()>37) RSDT1.vKNF=8;
1672  EC4F     CALL 0xBE9E, 0
1674  F05F     NOP
1676  D7F7     BRA 0x1666
360:                                   else RSDT1.vKNF=8;
361:           						break;
362:           				}
363:           				RSDT1.outKSTAT0=GetRSRBuf(4);
1686  0E04     MOVLW 0x4
1688  ECA3     CALL 0xBF46, 0
168A  F05F     NOP
168C  0102     MOVLB 0x2
168E  6F51     MOVWF 0x51, BANKED
364:           				RSDT1.outKRK=GetRSRBuf(5);
1690  0E05     MOVLW 0x5
1692  ECA3     CALL 0xBF46, 0
1694  F05F     NOP
1696  0102     MOVLB 0x2
1698  6F52     MOVWF 0x52, BANKED
365:           				RSDT1.outPRM=GetRSRBuf(6);
169A  0E06     MOVLW 0x6
169C  ECA3     CALL 0xBF46, 0
169E  F05F     NOP
16A0  0102     MOVLB 0x2
16A2  6F53     MOVWF 0x53, BANKED
366:           				RSDT1.outMSTR=GetRSRBuf(7);
16A4  0E07     MOVLW 0x7
16A6  ECA3     CALL 0xBF46, 0
16A8  F05F     NOP
16AA  0102     MOVLB 0x2
16AC  6F54     MOVWF 0x54, BANKED
367:           				RSDT1.outMMAXU=GetRSRBuf(8);
16AE  0E08     MOVLW 0x8
16B0  ECA3     CALL 0xBF46, 0
16B2  F05F     NOP
16B4  0102     MOVLB 0x2
16B6  6F55     MOVWF 0x55, BANKED
368:           				RSDT1.outMMAXG=GetRSRBuf(9);
16B8  0E09     MOVLW 0x9
16BA  ECA3     CALL 0xBF46, 0
16BC  F05F     NOP
16BE  0102     MOVLB 0x2
16C0  6F56     MOVWF 0x56, BANKED
369:           				RSDT1.outOPDG=GetRSRBuf(10);
16C2  0E0A     MOVLW 0xA
16C4  ECA3     CALL 0xBF46, 0
16C6  F05F     NOP
16C8  0102     MOVLB 0x2
16CA  6F5B     MOVWF 0x5B, BANKED
370:           				RSDT1.outWANL=GetRSRBuf(11);
16CC  0E0B     MOVLW 0xB
16CE  ECA3     CALL 0xBF46, 0
16D0  F05F     NOP
16D2  0102     MOVLB 0x2
16D4  6F57     MOVWF 0x57, BANKED
371:           				RSDT1.outKODKT=GetRSRBuf(12);
16D6  0E0C     MOVLW 0xC
16D8  ECA3     CALL 0xBF46, 0
16DA  F05F     NOP
16DC  0102     MOVLB 0x2
16DE  6F58     MOVWF 0x58, BANKED
372:           				RSDT1.outWOBG=GetRSRBuf(13);
16E0  0E0D     MOVLW 0xD
16E2  ECA3     CALL 0xBF46, 0
16E4  F05F     NOP
16E6  0102     MOVLB 0x2
16E8  6F59     MOVWF 0x59, BANKED
373:           				RSDT1.outNOKR=GetRSRBuf(14);
16EA  0E0E     MOVLW 0xE
16EC  ECA3     CALL 0xBF46, 0
16EE  F05F     NOP
16F0  0102     MOVLB 0x2
16F2  6F5A     MOVWF 0x5A, BANKED
374:           				RSDT1.outTPCS=GetRSRBuf(15);
16F4  0E0F     MOVLW 0xF
16F6  ECA3     CALL 0xBF46, 0
16F8  F05F     NOP
16FA  0102     MOVLB 0x2
16FC  6F5C     MOVWF 0x5C, BANKED
375:           				RSDT1.outMMIN=GetRSRBuf(16);
16FE  0E10     MOVLW 0x10
1700  ECA3     CALL 0xBF46, 0
1702  F05F     NOP
1704  0102     MOVLB 0x2
1706  6F5D     MOVWF 0x5D, BANKED
376:           				RSDT1.outMMAX=GetRSRBuf(17);
1708  0E11     MOVLW 0x11
170A  ECA3     CALL 0xBF46, 0
170C  F05F     NOP
170E  0102     MOVLB 0x2
1710  6F5E     MOVWF 0x5E, BANKED
377:           				RSDT1.outRDPM=GetRSRBuf(18);
1712  0E12     MOVLW 0x12
1714  ECA3     CALL 0xBF46, 0
1716  F05F     NOP
1718  0102     MOVLB 0x2
171A  6F5F     MOVWF 0x5F, BANKED
378:           				RSDT1.outDTPM=GetRSRBuf(19);
171C  0E13     MOVLW 0x13
171E  ECA3     CALL 0xBF46, 0
1720  F05F     NOP
1722  0102     MOVLB 0x2
1724  6F60     MOVWF __pcstackBANK0, BANKED
379:           				RSDT1.outMDPM=GetRSRBuf(20);
1726  0E14     MOVLW 0x14
1728  ECA3     CALL 0xBF46, 0
172A  F05F     NOP
172C  0102     MOVLB 0x2
172E  6F61     MOVWF 0x61, BANKED
380:           				RSDT1.outTECO=GetRSRBuf(21);
1730  0E15     MOVLW 0x15
1732  ECA3     CALL 0xBF46, 0
1734  F05F     NOP
1736  0102     MOVLB 0x2
1738  6F62     MOVWF msk, BANKED
381:           				RSDT1.outTMMAXG2=GetRSRBuf(22);
173A  0E16     MOVLW 0x16
173C  ECA3     CALL 0xBF46, 0
173E  F05F     NOP
1740  0102     MOVLB 0x2
1742  6F63     MOVWF 0x63, BANKED
382:           				RSDT1.outMMAXG2=GetRSRBuf(23);
1744  0E17     MOVLW 0x17
1746  ECA3     CALL 0xBF46, 0
1748  F05F     NOP
174A  0102     MOVLB 0x2
174C  6F64     MOVWF i, BANKED
383:           				RSDT1.outMGPM=GetRSRBuf(24);
174E  0E18     MOVLW 0x18
1750  ECA3     CALL 0xBF46, 0
1752  F05F     NOP
1754  0102     MOVLB 0x2
1756  6F65     MOVWF 0x65, BANKED
384:           				RSDT1.outMGPM2=GetRSRBuf(25);     
1758  0E19     MOVLW 0x19
175A  ECA3     CALL 0xBF46, 0
175C  F05F     NOP
175E  0102     MOVLB 0x2
1760  6F66     MOVWF 0x66, BANKED
385:                           RSDT1.outHSCO=GetRSRBuf(26);
1762  0E1A     MOVLW 0x1A
1764  ECA3     CALL 0xBF46, 0
1766  F05F     NOP
1768  0102     MOVLB 0x2
176A  6F67     MOVWF _PFNf_ofnserw, BANKED
386:                           RSDT1.outCONW=GetRSRBuf(27);
176C  0E1B     MOVLW 0x1B
176E  ECA3     CALL 0xBF46, 0
1770  F05F     NOP
1772  0102     MOVLB 0x2
1774  6F68     MOVWF _PFNf_ofoff, BANKED
387:                           RSDT1.outPROP=GetRSRBuf(28); 
1776  0E1C     MOVLW 0x1C
1778  ECA3     CALL 0xBF46, 0
177A  F05F     NOP
177C  0102     MOVLB 0x2
177E  6F69     MOVWF _PFNf_ofzima, BANKED
388:                           RSDT1.outRFAN=GetRSRBuf(29); 
1780  0E1D     MOVLW 0x1D
1782  ECA3     CALL 0xBF46, 0
1784  F05F     NOP
1786  0102     MOVLB 0x2
1788  6F6A     MOVWF _PFNf_opKNF, BANKED
389:                           RSDT1.outTSTR=GetRSRBuf(30);     
178A  0E1E     MOVLW 0x1E
178C  ECA3     CALL 0xBF46, 0
178E  F05F     NOP
1790  0102     MOVLB 0x2
1792  6F6B     MOVWF _PFNf_opgprg, BANKED
390:                           RSDT1.outTL3=GetRSRBuf(31);                 
1794  0E1F     MOVLW 0x1F
1796  ECA3     CALL 0xBF46, 0
1798  F05F     NOP
179A  0102     MOVLB 0x2
179C  6F6C     MOVWF _PFNf_opgres, BANKED
391:                           RSDT1.outPGDR=GetRSRBuf(32); 
179E  0E20     MOVLW 0x20
17A0  ECA3     CALL 0xBF46, 0
17A2  F05F     NOP
17A4  0102     MOVLB 0x2
17A6  6F6D     MOVWF _PFNf_pgd, BANKED
392:                           RSDT1.outPGDG=GetRSRBuf(33);     
17A8  0E21     MOVLW 0x21
17AA  ECA3     CALL 0xBF46, 0
17AC  F05F     NOP
17AE  0102     MOVLB 0x2
17B0  6F6E     MOVWF _PFNf_pgdTP, BANKED
393:                           RSDT1.outPGDO=GetRSRBuf(34);     
17B2  0E22     MOVLW 0x22
17B4  ECA3     CALL 0xBF46, 0
17B6  F05F     NOP
17B8  0102     MOVLB 0x2
17BA  6F6F     MOVWF _PFNf_plmCO, BANKED
394:                           RSDT1.outPGMX=GetRSRBuf(35);                
17BC  0E23     MOVLW 0x23
17BE  ECA3     CALL 0xBF46, 0
17C0  F05F     NOP
17C2  0102     MOVLB 0x2
17C4  6F70     MOVWF _PFNf_plmCW, BANKED
17C6  D749     BRA 0x165A
395:           				RSDT1f_RD_KNF=1;
396:           			}
397:           			break;
398:           		}         
399:           #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?
400:           		case _RD_LIN:
401:           		{
402:                       RSDT1f_RD_LIN=0;
17C8  9412     BCF RSDT1f_RD_STD, 2, ACCESS
403:                       RSDT1.outLIDN=GetRSRBuf(3);
17CA  0E03     MOVLW 0x3
17CC  ECA3     CALL 0xBF46, 0
17CE  F05F     NOP
17D0  0102     MOVLB 0x2
17D2  6F71     MOVWF _PFNf_pmpPWM, BANKED
404:                       switch(RSDT1.outLIDN)
17D4  D095     BRA 0x1900
1900  5171     MOVF _PFNf_pmpPWM, W, BANKED
1902  0A02     XORLW 0x2
1904  E101     BNZ 0x1908
1906  D76E     BRA 0x17E4
1908  0A01     XORLW 0x1
190A  E101     BNZ 0x190E
190C  D77B     BRA 0x1804
190E  0A07     XORLW 0x7
1910  E08C     BZ 0x182A
1912  0A01     XORLW 0x1
1914  E0AB     BZ 0x186C
1916  0A7A     XORLW 0x7A
1918  E101     BNZ 0x191C
191A  D75D     BRA 0x17D6
191C  0AFF     XORLW 0xFF
191E  A4D8     BTFSS STATUS, 2, ACCESS
1920  0012     RETURN 0
1922  D767     BRA 0x17F2
405:                       {
406:                           /*case _LIN_GKNF:
407:                           {
408:                               if(!RSDT1f_RRD_KNF)		//aktywna blokada na czas interpretacji danych?
409:                               {
410:                                   //okreslenie wersji paczki danych (na potrzeby proc.konf.- kompatybilnosc wsteczna)
411:                                   switch(GetRSRBuf(1)&0b00011111)
412:                                   {
413:                                           case 22:
414:                                                   RSDT1.vKNF=1;
415:                                                   break;
416:                                           case 24:
417:                                                   RSDT1.vKNF=2;
418:                                                   break;
419:                                           case 25:
420:                                                   RSDT1.vKNF=3;
421:                                                   break;
422:                                           case 26:
423:                                                   RSDT1.vKNF=4;
424:                                                   break;  
425:                                           case 29:
426:                                                   RSDT1.vKNF=5;
427:                                                   break; 
428:                                           case 30:
429:                                                   RSDT1.vKNF=6;
430:                                                   break;                                        
431:                                           default:
432:                                                   RSDT1.vKNF=2;
433:                                                   break;
434:                                   }
435:                                   RSDT1.outKSTAT0=GetRSRBuf(5);
436:                                   RSDT1.outMSTR=GetRSRBuf(6);
437:                                   RSDT1.outMMAXU=GetRSRBuf(7);
438:                                   RSDT1.outMMAXG=GetRSRBuf(8);
439:                                   RSDT1.outOPDG=GetRSRBuf(9);
440:                                   RSDT1.outWANL=GetRSRBuf(10);
441:                                   RSDT1.outKODKT=GetRSRBuf(11);
442:                                   RSDT1.outWOBG=GetRSRBuf(12);
443:                                   RSDT1.outNOKR=GetRSRBuf(13);
444:                                   RSDT1.outTPCS=GetRSRBuf(14);
445:                                   RSDT1.outMMIN=GetRSRBuf(15);
446:                                   RSDT1.outMMAX=GetRSRBuf(16);
447:                                   RSDT1.outRDPM=GetRSRBuf(17);
448:                                   RSDT1.outDTPM=GetRSRBuf(18);
449:                                   RSDT1.outMDPM=GetRSRBuf(19);
450:                                   RSDT1.outTECO=GetRSRBuf(20);
451:                                   RSDT1.outTMMAXG2=GetRSRBuf(21);
452:                                   RSDT1.outMMAXG2=GetRSRBuf(22);
453:                                   RSDT1.outMGPM=GetRSRBuf(23);
454:                                   RSDT1.outMGPM2=GetRSRBuf(24);   
455:                                   RSDT1.outHSCO=GetRSRBuf(25);
456:                                   RSDT1.outCONW=GetRSRBuf(26);
457:                                   RSDT1.outPROP=GetRSRBuf(27); 
458:                                   RSDT1.outRFAN=GetRSRBuf(28);                         
459:                                   RSDT1f_RD_LIN=1;                 //znacznik odpowiedzi
460:                               }
461:                               break;
462:                           }*/
463:                           case _LIN_SADR:
464:                           {
465:                               RSDT1.outLDTA1=GetRSRBuf(4);        //aktualny adres lin = parametr1 odpowiedzi
17D6  0E04     MOVLW 0x4
17D8  ECA3     CALL 0xBF46, 0
17DA  F05F     NOP
17DC  0102     MOVLB 0x2
17DE  6F72     MOVWF _PFNf_pobRT, BANKED
466:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
17E0  8412     BSF RSDT1f_RD_STD, 2, ACCESS
467:                               break;
17E2  0012     RETURN 0
468:                           }
469:                           case _LIN_RPKNF:                           
470:                           {
471:                               RSDT1.outLDTA1=GetRSRBuf(4);        //wartosc parametru wskazanego do odczytu
17E4  0E04     MOVLW 0x4
17E6  ECA3     CALL 0xBF46, 0
17E8  F05F     NOP
17EA  D8AD     RCALL PL744
472:                               RSDT1.outLDTA2=GetRSRBuf(5);        //statis operacji                     
17EC  ECA3     CALL 0xBF46, 0
17EE  F05F     NOP
17F0  D006     BRA 0x17FE
473:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
474:                               break;
475:                           } 
476:                           case _LIN_WPKNF:                           
477:                           {
478:                               RSDT1.outLDTA1=GetRSRBuf(4);        //wartosc parametru po operacji zapisu
17F2  0E04     MOVLW 0x4
17F4  ECA3     CALL 0xBF46, 0
17F6  F05F     NOP
17F8  D8A6     RCALL PL744
479:                               RSDT1.outLDTA2=GetRSRBuf(5);        //statis operacji                     
17FA  ECA3     CALL 0xBF46, 0
17FC  F05F     NOP
17FE  0102     MOVLB 0x2
1800  6F73     MOVWF _PFNf_popFN, BANKED
1802  D7EE     BRA 0x17E0
480:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
481:                               break;
482:                           } 
483:                           case _LIN_GSTAT:                           
484:                           {                
485:                               RSDT1.outLDTA1=GetRSRBuf(4);        //LO ogolna liczba zdarzen awaryjnych
1804  0E04     MOVLW 0x4
1806  ECA3     CALL 0xBF46, 0
1808  F05F     NOP
180A  D89D     RCALL PL744
486:                               RSDT1.outLDTA2=GetRSRBuf(5);        //HI ogolna liczba zdarzen awaryjnych   
180C  ECA3     CALL 0xBF46, 0
180E  F05F     NOP
1810  0102     MOVLB 0x2
1812  6F73     MOVWF _PFNf_popFN, BANKED
487:                               RSDT1.outLDTA3=GetRSRBuf(6);        //LO w tym liczba zdarzen awaryjnych z blokada
1814  0E06     MOVLW 0x6
1816  ECA3     CALL 0xBF46, 0
1818  F05F     NOP
181A  0102     MOVLB 0x2
181C  6F74     MOVWF _PFNf_prODP, BANKED
488:                               RSDT1.outLDTA4=GetRSRBuf(7);        //LO w tym liczba zdarzen awaryjnych z blokada                                     
181E  0E07     MOVLW 0x7
1820  ECA3     CALL 0xBF46, 0
1822  F05F     NOP
1824  0102     MOVLB 0x2
1826  6F75     MOVWF _PFNf_prn_cs, BANKED
1828  D7DB     BRA 0x17E0
489:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
490:                               break;
491:                           }                
492:                           case _LIN_GEEST:                           
493:                           {                
494:                               for(i=0;i<32;i++) stbf[i]=0; 
182A  0100     MOVLB 0x0
182C  6B78     CLRF _PFNf_prn_pp, BANKED
182E  0E1F     MOVLW 0x1F
1830  6578     CPFSGT _PFNf_prn_pp, BANKED
1832  D001     BRA 0x1836
1834  D007     BRA 0x1844
1836  0E00     MOVLW 0x0
1838  2578     ADDWF _PFNf_prn_pp, W, BANKED
183A  EC68     CALL 0x2CD0, 0
183C  F016     NOP
183E  6ADF     CLRF INDF2, ACCESS
1840  2B78     INCF _PFNf_prn_pp, F, BANKED
1842  D7F5     BRA 0x182E
495:                               for(i=0;i<_NDT_RRD_EEST;i++)
1844  6B78     CLRF _PFNf_prn_pp, BANKED
1846  0E16     MOVLW 0x16
1848  6578     CPFSGT _PFNf_prn_pp, BANKED
184A  D001     BRA 0x184E
184C  D7C9     BRA 0x17E0
186A  D7ED     BRA 0x1846
496:                               {
497:                                   if(i>=32) break;
184E  0E1F     MOVLW 0x1F
1850  6578     CPFSGT _PFNf_prn_pp, BANKED
1852  D001     BRA 0x1856
1854  D7C5     BRA 0x17E0
498:                                   stbf[i]=GetRSRBuf(4+i);        //wartosc parametru po operacji zapisu
1856  5178     MOVF _PFNf_prn_pp, W, BANKED
1858  0F04     ADDLW 0x4
185A  ECA3     CALL 0xBF46, 0
185C  F05F     NOP
185E  6F76     MOVWF _PFNf_prn_in, BANKED
1860  0E00     MOVLW 0x0
1862  2578     ADDWF _PFNf_prn_pp, W, BANKED
1864  EC68     CALL 0x2CD0, 0
1866  F016     NOP
1868  D871     RCALL PL822
499:                               }                    
500:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
501:                               break;
502:                           }  
503:                           case _LIN_GHIST:                           
504:                           {   
505:                               for(i=0;i<32;i++) stbf[i]=0;                    
186C  0100     MOVLB 0x0
186E  6B78     CLRF _PFNf_prn_pp, BANKED
1870  0E1F     MOVLW 0x1F
1872  6578     CPFSGT _PFNf_prn_pp, BANKED
1874  D001     BRA 0x1878
1876  D007     BRA 0x1886
1878  0E00     MOVLW 0x0
187A  2578     ADDWF _PFNf_prn_pp, W, BANKED
187C  EC68     CALL 0x2CD0, 0
187E  F016     NOP
1880  6ADF     CLRF INDF2, ACCESS
1882  2B78     INCF _PFNf_prn_pp, F, BANKED
1884  D7F5     BRA 0x1870
506:                               stbf[0]=GetRSRBuf(4);        //REFL
1886  0E04     MOVLW 0x4
1888  ECA3     CALL 0xBF46, 0
188A  F05F     NOP
188C  0103     MOVLB 0x3
188E  6F00     MOVWF 0x0, BANKED
507:                               stbf[1]=GetRSRBuf(5);        //REFH
1890  0E05     MOVLW 0x5
1892  ECA3     CALL 0xBF46, 0
1894  F05F     NOP
1896  0103     MOVLB 0x3
1898  6F01     MOVWF DtCOf_err_CO, BANKED
508:                               stbf[2]=GetRSRBuf(6);        //liczba danych                   
189A  0E06     MOVLW 0x6
189C  ECA3     CALL 0xBF46, 0
189E  F05F     NOP
18A0  0103     MOVLB 0x3
18A2  6F02     MOVWF LIN1f_Busy, BANKED
509:                               if((!stbf[0]&&!stbf[1])||!stbf[2])
18A4  5100     MOVF 0x0, W, BANKED
18A6  E102     BNZ 0x18AC
18A8  5101     MOVF DtCOf_err_CO, W, BANKED
18AA  E002     BZ 0x18B0
18AC  5102     MOVF LIN1f_Busy, W, BANKED
18AE  E102     BNZ 0x18B4
510:                               {
511:                                   stbf[2]=0;
18B0  6B02     CLRF LIN1f_Busy, BANKED
512:                               }
18B2  D796     BRA 0x17E0
513:                               else
514:                               {
515:                                   for(i=0;i<stbf[2];i++)
18B4  0100     MOVLB 0x0
18B6  6B78     CLRF _PFNf_prn_pp, BANKED
18B8  D01C     BRA 0x18F2
18F2  0103     MOVLB 0x3
18F4  5102     MOVF LIN1f_Busy, W, BANKED
18F6  0100     MOVLB 0x0
18F8  5D78     SUBWF _PFNf_prn_pp, W, BANKED
18FA  E301     BNC 0x18FE
18FC  D771     BRA 0x17E0
18FE  D7DD     BRA 0x18BA
516:                                   {
517:                                       if((3+i)>=32) break;
18BA  5178     MOVF _PFNf_prn_pp, W, BANKED
18BC  6F76     MOVWF _PFNf_prn_in, BANKED
18BE  6B77     CLRF _PFNf_prn_pg, BANKED
18C0  0E03     MOVLW 0x3
18C2  2776     ADDWF _PFNf_prn_in, F, BANKED
18C4  0E00     MOVLW 0x0
18C6  2377     ADDWFC _PFNf_prn_pg, F, BANKED
18C8  BF77     BTFSC _PFNf_prn_pg, 7, BANKED
18CA  D007     BRA 0x18DA
18CC  5177     MOVF _PFNf_prn_pg, W, BANKED
18CE  E188     BNZ 0x17E0
18D0  0E20     MOVLW 0x20
18D2  5D76     SUBWF _PFNf_prn_in, W, BANKED
18D4  E285     BC 0x17E0
18D6  D001     BRA 0x18DA
18D8  D783     BRA 0x17E0
518:                                       stbf[3+i]=GetRSRBuf(7+((stbf[2]-1)-i));   //dane bufora zdarzen
18DA  5178     MOVF _PFNf_prn_pp, W, BANKED
18DC  0103     MOVLB 0x3
18DE  5D02     SUBWF LIN1f_Busy, W, BANKED
18E0  0F06     ADDLW 0x6
18E2  ECA3     CALL 0xBF46, 0
18E4  F05F     NOP
18E6  6F76     MOVWF _PFNf_prn_in, BANKED
18E8  0E03     MOVLW 0x3
18EA  2578     ADDWF _PFNf_prn_pp, W, BANKED
18EC  EC7B     CALL 0x2CF6, 0
18EE  F016     NOP
18F0  D82D     RCALL PL822
519:                                   }
520:                               }                    
521:                               RSDT1f_RD_LIN=1;                    //znacznik odpowiedzi
522:                               break;  
523:                           }                
524:                       }
525:                       break;
526:                   }
527:           #endif
528:               }
529:               //ndat - CHK
530:           }
1944  0012     RETURN 0
531:           //Przygotowanie danych do wysylki do modulu UNI-02 (razem z obliczonym CHK)
532:           void SaveDataToRS(unsigned char tDTA)
374E  6F7C     MOVWF _PFNf_setKey, BANKED
533:           {
534:           	unsigned char ndat;		//liczba danych wysy³anych + CHK
535:           	unsigned char chkndat;
536:           
537:           	switch(tDTA)
3750  D23B     BRA 0x3BC8
3BC8  0100     MOVLB 0x0
3BCA  517C     MOVF _PFNf_setKey, W, BANKED
3BCC  0A01     XORLW 0x1
3BCE  E101     BNZ 0x3BD2
3BD0  D5C0     BRA 0x3752
3BD2  0A03     XORLW 0x3
3BD4  E101     BNZ 0x3BD8
3BD6  D630     BRA 0x3838
3BD8  0A01     XORLW 0x1
3BDA  E0E7     BZ 0x3BAA
3BDC  0A07     XORLW 0x7
3BDE  E101     BNZ 0x3BE2
3BE0  D5EB     BRA 0x37B8
3BE2  0A01     XORLW 0x1
3BE4  E101     BNZ 0x3BE8
3BE6  D6BF     BRA 0x3966
538:           	{
539:           		case _RD_STD:				//identyfikator paczki danych
540:           		{
541:           			ndat=11;                 //9
542:           			chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3752  0E0B     MOVLW 0xB
3754  EC7E     CALL 0xB6FC, 0
3756  F05B     NOP
3758  DA48     RCALL PL258
543:           		
544:           			SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
375A  EC17     CALL 0xC02E, 0
375C  F060     NOP
545:           			SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
375E  DA4C     RCALL PL540
3760  EC17     CALL 0xC02E, 0
3762  F060     NOP
546:           			SetRSTBuf(2,_RD_STD);			//2 - identyfikator paczki danych
3764  0E01     MOVLW 0x1
3766  6F74     MOVWF _PFNf_prODP, BANKED
3768  0E02     MOVLW 0x2
376A  EC17     CALL 0xC02E, 0
376C  F060     NOP
547:           			SetRSTBuf(3,RSDT1.inSTAT0);
376E  C279     MOVFF 0x279, _PFNf_prODP
3770  F074     NOP
3772  0E03     MOVLW 0x3
3774  EC17     CALL 0xC02E, 0
3776  F060     NOP
548:           			SetRSTBuf(4,RSDT1.inSTAT1);
3778  C27A     MOVFF 0x27A, _PFNf_prODP
377A  F074     NOP
377C  0E04     MOVLW 0x4
377E  EC17     CALL 0xC02E, 0
3780  F060     NOP
549:           			SetRSTBuf(5,RSDT1.inPCO);
3782  C276     MOVFF 0x276, _PFNf_prODP
3784  F074     NOP
3786  0E05     MOVLW 0x5
3788  EC17     CALL 0xC02E, 0
378A  F060     NOP
550:           			SetRSTBuf(6,RSDT1.inPCW);
378C  C277     MOVFF 0x277, _PFNf_prODP
378E  F074     NOP
3790  0E06     MOVLW 0x6
3792  EC17     CALL 0xC02E, 0
3794  F060     NOP
551:           			SetRSTBuf(7,RSDT1.inECO);
3796  C278     MOVFF 0x278, _PFNf_prODP
3798  F074     NOP
379A  0E07     MOVLW 0x7
379C  EC17     CALL 0xC02E, 0
379E  F060     NOP
552:           			SetRSTBuf(8,RSDT1.inLNSTAT);    //8 - (wystepowanie bez wzgledu na zawartosc wskazuje na wersje oprogramowania >=7 i zezwala na funkcje odpowietrzenia)
37A0  C27C     MOVFF 0x27C, _PFNf_prODP
37A2  F074     NOP
37A4  0E08     MOVLW 0x8
37A6  EC17     CALL 0xC02E, 0
37A8  F060     NOP
553:           			SetRSTBuf(9,0);                 //9 - (wystepowanie bez wzgledu na zawartosc wskazuje na wersje oprogramowania >=9)           
37AA  6B74     CLRF _PFNf_prODP, BANKED
37AC  0E09     MOVLW 0x9
37AE  EC17     CALL 0xC02E, 0
37B0  F060     NOP
554:           			SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
37B2  0E0B     MOVLW 0xB
37B4  EF9E     GOTO 0xB93C
37B6  F05C     NOP
555:           			//ndat - CHK
556:           			break;
557:           		}
558:           		case _RD_STD2:				//identyfikator paczki danych
559:           		{
560:           			ndat=15;                        //13
561:                       SetExNDatCHK(ndat);            
37B8  0E0F     MOVLW 0xF
37BA  EC24     CALL 0xAE48, 0
37BC  F057     NOP
562:           			SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
37BE  DA19     RCALL PL442
37C0  EC17     CALL 0xC02E, 0
37C2  F060     NOP
563:           			//SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
564:           			SetRSTBuf(2,_RD_STD2);			//2 - identyfikator paczki danych
37C4  0E04     MOVLW 0x4
37C6  6F74     MOVWF _PFNf_prODP, BANKED
37C8  0E02     MOVLW 0x2
37CA  EC17     CALL 0xC02E, 0
37CC  F060     NOP
565:           			//SetRSTBuf(3,chkndat);			//3 - liczba przesylanych bajtow (ndat) 
566:                       SetRSTBuf(4,_WERSJA);
37CE  0E0B     MOVLW 0xB
37D0  6F74     MOVWF _PFNf_prODP, BANKED
37D2  0E04     MOVLW 0x4
37D4  EC17     CALL 0xC02E, 0
37D6  F060     NOP
567:           			SetRSTBuf(5,RSDT1.inSTAT0);
37D8  C279     MOVFF 0x279, _PFNf_prODP
37DA  F074     NOP
37DC  0E05     MOVLW 0x5
37DE  EC17     CALL 0xC02E, 0
37E0  F060     NOP
568:           			SetRSTBuf(6,RSDT1.inSTAT1);
37E2  C27A     MOVFF 0x27A, _PFNf_prODP
37E4  F074     NOP
37E6  0E06     MOVLW 0x6
37E8  EC17     CALL 0xC02E, 0
37EA  F060     NOP
569:           			SetRSTBuf(7,RSDT1.inPCO);
37EC  C276     MOVFF 0x276, _PFNf_prODP
37EE  F074     NOP
37F0  0E07     MOVLW 0x7
37F2  EC17     CALL 0xC02E, 0
37F4  F060     NOP
570:           			SetRSTBuf(8,RSDT1.inPCW);
37F6  C277     MOVFF 0x277, _PFNf_prODP
37F8  F074     NOP
37FA  0E08     MOVLW 0x8
37FC  EC17     CALL 0xC02E, 0
37FE  F060     NOP
571:           			SetRSTBuf(9,RSDT1.inECO);
3800  C278     MOVFF 0x278, _PFNf_prODP
3802  F074     NOP
3804  0E09     MOVLW 0x9
3806  EC17     CALL 0xC02E, 0
3808  F060     NOP
572:           			SetRSTBuf(10,RSDT1.inINSTAT);                 
380A  C27B     MOVFF 0x27B, _PFNf_prODP
380C  F074     NOP
380E  0E0A     MOVLW 0xA
3810  EC17     CALL 0xC02E, 0
3812  F060     NOP
573:           			SetRSTBuf(11,RSDT1.inLNSTAT);  
3814  C27C     MOVFF 0x27C, _PFNf_prODP
3816  F074     NOP
3818  0E0B     MOVLW 0xB
381A  EC17     CALL 0xC02E, 0
381C  F060     NOP
574:                       SetRSTBuf(12,RSDT1.inCONTSETP); //obliczona docelowa wartosc punktu modulacji dla grzaniaobiegu WG  
381E  C27D     MOVFF 0x27D, _PFNf_prODP
3820  F074     NOP
3822  0E0C     MOVLW 0xC
3824  EC17     CALL 0xC02E, 0
3826  F060     NOP
575:           			SetRSTBuf(13,RSDT1.inSTAT2);              
3828  C27E     MOVFF 0x27E, _PFNf_prODP
382A  F074     NOP
382C  0E0D     MOVLW 0xD
382E  EC17     CALL 0xC02E, 0
3830  F060     NOP
576:           			SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3832  0E0F     MOVLW 0xF
3834  EF9E     GOTO 0xB93C
3836  F05C     NOP
577:           			//ndat - CHK
578:           			break;
579:           		}        
580:           		case _RD_KNF:				//identyfikator paczki danych
581:           		{
582:           			ndat=31;
583:           			chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3838  0E1F     MOVLW 0x1F
383A  EC7E     CALL 0xB6FC, 0
383C  F05B     NOP
383E  D9D5     RCALL PL258
584:           		
585:           			SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3840  EC17     CALL 0xC02E, 0
3842  F060     NOP
3844  D9D9     RCALL PL540
586:           			SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3846  EC17     CALL 0xC02E, 0
3848  F060     NOP
587:           			SetRSTBuf(2,_RD_KNF);			//2 - identyfikator paczki danych
384A  0E02     MOVLW 0x2
384C  6F74     MOVWF _PFNf_prODP, BANKED
384E  EC17     CALL 0xC02E, 0
3850  F060     NOP
588:           			SetRSTBuf(3,RSDT1.inKSTAT0);
3852  C27F     MOVFF 0x27F, _PFNf_prODP
3854  F074     NOP
3856  0E03     MOVLW 0x3
3858  EC17     CALL 0xC02E, 0
385A  F060     NOP
589:           			SetRSTBuf(4,RSDT1.inKRK);
385C  C280     MOVFF 0x280, _PFNf_prODP
385E  F074     NOP
3860  0E04     MOVLW 0x4
3862  EC17     CALL 0xC02E, 0
3864  F060     NOP
590:           			SetRSTBuf(5,RSDT1.inPRM);
3866  C281     MOVFF 0x281, _PFNf_prODP
3868  F074     NOP
386A  0E05     MOVLW 0x5
386C  EC17     CALL 0xC02E, 0
386E  F060     NOP
591:           			SetRSTBuf(6,RSDT1.inDDTA);
3870  C282     MOVFF 0x282, _PFNf_prODP
3872  F074     NOP
3874  0E06     MOVLW 0x6
3876  EC17     CALL 0xC02E, 0
3878  F060     NOP
592:           			SetRSTBuf(7,RSDT1.inMSTR);
387A  C283     MOVFF 0x283, _PFNf_prODP
387C  F074     NOP
387E  0E07     MOVLW 0x7
3880  EC17     CALL 0xC02E, 0
3882  F060     NOP
593:           			SetRSTBuf(8,RSDT1.inMMAXU);
3884  C284     MOVFF 0x284, _PFNf_prODP
3886  F074     NOP
3888  0E08     MOVLW 0x8
388A  EC17     CALL 0xC02E, 0
388C  F060     NOP
594:           			SetRSTBuf(9,RSDT1.inMMAXG);
388E  C285     MOVFF 0x285, _PFNf_prODP
3890  F074     NOP
3892  0E09     MOVLW 0x9
3894  EC17     CALL 0xC02E, 0
3896  F060     NOP
595:           			SetRSTBuf(10,RSDT1.inOPDG);
3898  C28A     MOVFF 0x28A, _PFNf_prODP
389A  F074     NOP
389C  0E0A     MOVLW 0xA
389E  EC17     CALL 0xC02E, 0
38A0  F060     NOP
596:           			SetRSTBuf(11,RSDT1.inWANL);
38A2  C286     MOVFF 0x286, _PFNf_prODP
38A4  F074     NOP
38A6  0E0B     MOVLW 0xB
38A8  EC17     CALL 0xC02E, 0
38AA  F060     NOP
597:           			SetRSTBuf(12,RSDT1.inKODKT);
38AC  C287     MOVFF 0x287, _PFNf_prODP
38AE  F074     NOP
38B0  0E0C     MOVLW 0xC
38B2  EC17     CALL 0xC02E, 0
38B4  F060     NOP
598:           			SetRSTBuf(13,RSDT1.inWOBG);
38B6  C288     MOVFF 0x288, _PFNf_prODP
38B8  F074     NOP
38BA  0E0D     MOVLW 0xD
38BC  EC17     CALL 0xC02E, 0
38BE  F060     NOP
599:           			SetRSTBuf(14,RSDT1.inNOKR);
38C0  C289     MOVFF 0x289, _PFNf_prODP
38C2  F074     NOP
38C4  0E0E     MOVLW 0xE
38C6  EC17     CALL 0xC02E, 0
38C8  F060     NOP
600:           			SetRSTBuf(15,RSDT1.inTPCS);
38CA  C28B     MOVFF 0x28B, _PFNf_prODP
38CC  F074     NOP
38CE  0E0F     MOVLW 0xF
38D0  EC17     CALL 0xC02E, 0
38D2  F060     NOP
601:           			SetRSTBuf(16,RSDT1.inMMIN);
38D4  C28C     MOVFF 0x28C, _PFNf_prODP
38D6  F074     NOP
38D8  0E10     MOVLW 0x10
38DA  EC17     CALL 0xC02E, 0
38DC  F060     NOP
602:           			SetRSTBuf(17,RSDT1.inMMAX);
38DE  C28D     MOVFF 0x28D, _PFNf_prODP
38E0  F074     NOP
38E2  0E11     MOVLW 0x11
38E4  EC17     CALL 0xC02E, 0
38E6  F060     NOP
603:           			SetRSTBuf(18,RSDT1.inRDPM);
38E8  C28E     MOVFF 0x28E, _PFNf_prODP
38EA  F074     NOP
38EC  0E12     MOVLW 0x12
38EE  EC17     CALL 0xC02E, 0
38F0  F060     NOP
604:           			SetRSTBuf(19,RSDT1.inDTPM);
38F2  C28F     MOVFF 0x28F, _PFNf_prODP
38F4  F074     NOP
38F6  0E13     MOVLW 0x13
38F8  EC17     CALL 0xC02E, 0
38FA  F060     NOP
605:           			SetRSTBuf(20,RSDT1.inMDPM);
38FC  C290     MOVFF 0x290, _PFNf_prODP
38FE  F074     NOP
3900  0E14     MOVLW 0x14
3902  EC17     CALL 0xC02E, 0
3904  F060     NOP
606:           			SetRSTBuf(21,RSDT1.inTECO);
3906  C291     MOVFF 0x291, _PFNf_prODP
3908  F074     NOP
390A  0E15     MOVLW 0x15
390C  EC17     CALL 0xC02E, 0
390E  F060     NOP
607:           			SetRSTBuf(22,RSDT1.inTMMAXG2);
3910  C292     MOVFF 0x292, _PFNf_prODP
3912  F074     NOP
3914  0E16     MOVLW 0x16
3916  EC17     CALL 0xC02E, 0
3918  F060     NOP
608:           			SetRSTBuf(23,RSDT1.inMMAXG2);
391A  C293     MOVFF 0x293, _PFNf_prODP
391C  F074     NOP
391E  0E17     MOVLW 0x17
3920  EC17     CALL 0xC02E, 0
3922  F060     NOP
609:                       SetRSTBuf(24,RSDT1.inMGPM);
3924  C294     MOVFF 0x294, _PFNf_prODP
3926  F074     NOP
3928  0E18     MOVLW 0x18
392A  EC17     CALL 0xC02E, 0
392C  F060     NOP
610:                       SetRSTBuf(25,RSDT1.inMGPM2);     
392E  C295     MOVFF 0x295, _PFNf_prODP
3930  F074     NOP
3932  0E19     MOVLW 0x19
3934  EC17     CALL 0xC02E, 0
3936  F060     NOP
611:           			SetRSTBuf(26,RSDT1.inHSCO);
3938  C296     MOVFF 0x296, _PFNf_prODP
393A  F074     NOP
393C  0E1A     MOVLW 0x1A
393E  EC17     CALL 0xC02E, 0
3940  F060     NOP
612:                       SetRSTBuf(27,RSDT1.inCONW);
3942  C297     MOVFF 0x297, _PFNf_prODP
3944  F074     NOP
3946  0E1B     MOVLW 0x1B
3948  EC17     CALL 0xC02E, 0
394A  F060     NOP
613:                       SetRSTBuf(28,RSDT1.inPROP);    
394C  C298     MOVFF 0x298, _PFNf_prODP
394E  F074     NOP
3950  0E1C     MOVLW 0x1C
3952  EC17     CALL 0xC02E, 0
3954  F060     NOP
614:                       SetRSTBuf(29,RSDT1.inRFAN);              
3956  C299     MOVFF 0x299, _PFNf_prODP
3958  F074     NOP
395A  0E1D     MOVLW 0x1D
395C  EC17     CALL 0xC02E, 0
395E  F060     NOP
615:           			SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3960  0E1F     MOVLW 0x1F
3962  EF9E     GOTO 0xB93C
3964  F05C     NOP
616:           			//ndat - CHK
617:           			break;
618:           		}
619:           		case _RD_KNF2:				//identyfikator paczki danych
620:           		{
621:           			ndat=38;
622:                       SetExNDatCHK(ndat);            
3966  0E26     MOVLW 0x26
3968  EC24     CALL 0xAE48, 0
396A  F057     NOP
396C  D942     RCALL PL442
623:           			SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
396E  EC17     CALL 0xC02E, 0
3970  F060     NOP
624:           			//SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
625:           			SetRSTBuf(2,_RD_KNF2);			//2 - identyfikator paczki danych
3972  0E05     MOVLW 0x5
3974  6F74     MOVWF _PFNf_prODP, BANKED
3976  0E02     MOVLW 0x2
3978  EC17     CALL 0xC02E, 0
397A  F060     NOP
626:           			//SetRSTBuf(3,chkndat);			//3 - liczba przesylanych bajtow (ndat)            
627:           			SetRSTBuf(4,RSDT1.inKSTAT0);
397C  C27F     MOVFF 0x27F, _PFNf_prODP
397E  F074     NOP
3980  0E04     MOVLW 0x4
3982  EC17     CALL 0xC02E, 0
3984  F060     NOP
628:           			SetRSTBuf(5,RSDT1.inKRK);
3986  C280     MOVFF 0x280, _PFNf_prODP
3988  F074     NOP
398A  0E05     MOVLW 0x5
398C  EC17     CALL 0xC02E, 0
398E  F060     NOP
629:           			SetRSTBuf(6,RSDT1.inPRM);
3990  C281     MOVFF 0x281, _PFNf_prODP
3992  F074     NOP
3994  0E06     MOVLW 0x6
3996  EC17     CALL 0xC02E, 0
3998  F060     NOP
630:           			SetRSTBuf(7,RSDT1.inDDTA);
399A  C282     MOVFF 0x282, _PFNf_prODP
399C  F074     NOP
399E  0E07     MOVLW 0x7
39A0  EC17     CALL 0xC02E, 0
39A2  F060     NOP
631:           			SetRSTBuf(8,RSDT1.inMSTR);
39A4  C283     MOVFF 0x283, _PFNf_prODP
39A6  F074     NOP
39A8  0E08     MOVLW 0x8
39AA  EC17     CALL 0xC02E, 0
39AC  F060     NOP
632:           			SetRSTBuf(9,RSDT1.inMMAXU);
39AE  C284     MOVFF 0x284, _PFNf_prODP
39B0  F074     NOP
39B2  0E09     MOVLW 0x9
39B4  EC17     CALL 0xC02E, 0
39B6  F060     NOP
633:           			SetRSTBuf(10,RSDT1.inMMAXG);
39B8  C285     MOVFF 0x285, _PFNf_prODP
39BA  F074     NOP
39BC  0E0A     MOVLW 0xA
39BE  EC17     CALL 0xC02E, 0
39C0  F060     NOP
634:           			SetRSTBuf(11,RSDT1.inOPDG);
39C2  C28A     MOVFF 0x28A, _PFNf_prODP
39C4  F074     NOP
39C6  0E0B     MOVLW 0xB
39C8  EC17     CALL 0xC02E, 0
39CA  F060     NOP
635:           			SetRSTBuf(12,RSDT1.inWANL);
39CC  C286     MOVFF 0x286, _PFNf_prODP
39CE  F074     NOP
39D0  0E0C     MOVLW 0xC
39D2  EC17     CALL 0xC02E, 0
39D4  F060     NOP
636:           			SetRSTBuf(13,RSDT1.inKODKT);
39D6  C287     MOVFF 0x287, _PFNf_prODP
39D8  F074     NOP
39DA  0E0D     MOVLW 0xD
39DC  EC17     CALL 0xC02E, 0
39DE  F060     NOP
637:           			SetRSTBuf(14,RSDT1.inWOBG);
39E0  C288     MOVFF 0x288, _PFNf_prODP
39E2  F074     NOP
39E4  0E0E     MOVLW 0xE
39E6  EC17     CALL 0xC02E, 0
39E8  F060     NOP
638:           			SetRSTBuf(15,RSDT1.inNOKR);
39EA  C289     MOVFF 0x289, _PFNf_prODP
39EC  F074     NOP
39EE  0E0F     MOVLW 0xF
39F0  EC17     CALL 0xC02E, 0
39F2  F060     NOP
639:           			SetRSTBuf(16,RSDT1.inTPCS);
39F4  C28B     MOVFF 0x28B, _PFNf_prODP
39F6  F074     NOP
39F8  0E10     MOVLW 0x10
39FA  EC17     CALL 0xC02E, 0
39FC  F060     NOP
640:           			SetRSTBuf(17,RSDT1.inMMIN);
39FE  C28C     MOVFF 0x28C, _PFNf_prODP
3A00  F074     NOP
3A02  0E11     MOVLW 0x11
3A04  EC17     CALL 0xC02E, 0
3A06  F060     NOP
641:           			SetRSTBuf(18,RSDT1.inMMAX);
3A08  C28D     MOVFF 0x28D, _PFNf_prODP
3A0A  F074     NOP
3A0C  0E12     MOVLW 0x12
3A0E  EC17     CALL 0xC02E, 0
3A10  F060     NOP
642:           			SetRSTBuf(19,RSDT1.inRDPM);
3A12  C28E     MOVFF 0x28E, _PFNf_prODP
3A14  F074     NOP
3A16  0E13     MOVLW 0x13
3A18  EC17     CALL 0xC02E, 0
3A1A  F060     NOP
643:           			SetRSTBuf(20,RSDT1.inDTPM);
3A1C  C28F     MOVFF 0x28F, _PFNf_prODP
3A1E  F074     NOP
3A20  0E14     MOVLW 0x14
3A22  EC17     CALL 0xC02E, 0
3A24  F060     NOP
644:           			SetRSTBuf(21,RSDT1.inMDPM);
3A26  C290     MOVFF 0x290, _PFNf_prODP
3A28  F074     NOP
3A2A  0E15     MOVLW 0x15
3A2C  EC17     CALL 0xC02E, 0
3A2E  F060     NOP
645:           			SetRSTBuf(22,RSDT1.inTECO);
3A30  C291     MOVFF 0x291, _PFNf_prODP
3A32  F074     NOP
3A34  0E16     MOVLW 0x16
3A36  EC17     CALL 0xC02E, 0
3A38  F060     NOP
646:           			SetRSTBuf(23,RSDT1.inTMMAXG2);
3A3A  C292     MOVFF 0x292, _PFNf_prODP
3A3C  F074     NOP
3A3E  0E17     MOVLW 0x17
3A40  EC17     CALL 0xC02E, 0
3A42  F060     NOP
647:           			SetRSTBuf(24,RSDT1.inMMAXG2);
3A44  C293     MOVFF 0x293, _PFNf_prODP
3A46  F074     NOP
3A48  0E18     MOVLW 0x18
3A4A  EC17     CALL 0xC02E, 0
3A4C  F060     NOP
648:                       SetRSTBuf(25,RSDT1.inMGPM);
3A4E  C294     MOVFF 0x294, _PFNf_prODP
3A50  F074     NOP
3A52  0E19     MOVLW 0x19
3A54  EC17     CALL 0xC02E, 0
3A56  F060     NOP
649:                       SetRSTBuf(26,RSDT1.inMGPM2);   
3A58  C295     MOVFF 0x295, _PFNf_prODP
3A5A  F074     NOP
3A5C  0E1A     MOVLW 0x1A
3A5E  EC17     CALL 0xC02E, 0
3A60  F060     NOP
650:           			SetRSTBuf(27,RSDT1.inHSCO);
3A62  C296     MOVFF 0x296, _PFNf_prODP
3A64  F074     NOP
3A66  0E1B     MOVLW 0x1B
3A68  EC17     CALL 0xC02E, 0
3A6A  F060     NOP
651:                       SetRSTBuf(28,RSDT1.inCONW);
3A6C  C297     MOVFF 0x297, _PFNf_prODP
3A6E  F074     NOP
3A70  0E1C     MOVLW 0x1C
3A72  EC17     CALL 0xC02E, 0
3A74  F060     NOP
652:                       SetRSTBuf(29,RSDT1.inPROP); 
3A76  C298     MOVFF 0x298, _PFNf_prODP
3A78  F074     NOP
3A7A  0E1D     MOVLW 0x1D
3A7C  EC17     CALL 0xC02E, 0
3A7E  F060     NOP
653:                       SetRSTBuf(30,RSDT1.inRFAN); 
3A80  C299     MOVFF 0x299, _PFNf_prODP
3A82  F074     NOP
3A84  0E1E     MOVLW 0x1E
3A86  EC17     CALL 0xC02E, 0
3A88  F060     NOP
654:                       SetRSTBuf(31,RSDT1.inTSTR); 
3A8A  C29A     MOVFF 0x29A, _PFNf_prODP
3A8C  F074     NOP
3A8E  0E1F     MOVLW 0x1F
3A90  EC17     CALL 0xC02E, 0
3A92  F060     NOP
655:                       SetRSTBuf(32,RSDT1.inTL3);
3A94  C29B     MOVFF 0x29B, _PFNf_prODP
3A96  F074     NOP
3A98  0E20     MOVLW 0x20
3A9A  EC17     CALL 0xC02E, 0
3A9C  F060     NOP
656:                       SetRSTBuf(33,RSDT1.inPGDR); 
3A9E  C29C     MOVFF 0x29C, _PFNf_prODP
3AA0  F074     NOP
3AA2  0E21     MOVLW 0x21
3AA4  EC17     CALL 0xC02E, 0
3AA6  F060     NOP
657:                       SetRSTBuf(34,RSDT1.inPGDG); 
3AA8  C29D     MOVFF 0x29D, _PFNf_prODP
3AAA  F074     NOP
3AAC  0E22     MOVLW 0x22
3AAE  EC17     CALL 0xC02E, 0
3AB0  F060     NOP
658:                       SetRSTBuf(35,RSDT1.inPGDO);    
3AB2  C29E     MOVFF 0x29E, _PFNf_prODP
3AB4  F074     NOP
3AB6  0E23     MOVLW 0x23
3AB8  EC17     CALL 0xC02E, 0
3ABA  F060     NOP
659:                       SetRSTBuf(36,RSDT1.inPGMX);            
3ABC  C29F     MOVFF 0x29F, _PFNf_prODP
3ABE  F074     NOP
3AC0  0E24     MOVLW 0x24
3AC2  EC17     CALL 0xC02E, 0
3AC4  F060     NOP
660:           			SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3AC6  0E26     MOVLW 0x26
3AC8  EF9E     GOTO 0xB93C
3ACA  F05C     NOP
661:           			//ndat - CHK
662:           			break;
663:           		}                
664:           #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?
665:           		case _RD_LIN:				//identyfikator paczki danych
666:           		{
667:                       switch(RSDT1.inLIDN)
3BAA  0102     MOVLB 0x2
3BAC  51A0     MOVF _UADtf_RErrBUF, W, BANKED
3BAE  0A02     XORLW 0x2
3BB0  E0A2     BZ 0x3AF6
3BB2  0A01     XORLW 0x1
3BB4  E0BC     BZ 0x3B2E
3BB6  0A07     XORLW 0x7
3BB8  E0CB     BZ 0x3B50
3BBA  0A01     XORLW 0x1
3BBC  E0E0     BZ 0x3B7E
3BBE  0A7A     XORLW 0x7A
3BC0  E085     BZ 0x3ACC
3BC2  0AFF     XORLW 0xFF
3BC4  E098     BZ 0x3AF6
3BC6  D7EF     BRA 0x3BA6
668:                       {
669:                           /*case _LIN_GKNF:
670:                           {
671:                               ndat=5;
672:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
673:           
674:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
675:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
676:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
677:                               SetRSTBuf(3,_LIN_GKNF);
678:                               //SetRSTBuf(4,RSDT1.inLDTA1);
679:                               //SetRSTBuf(5,RSDT1.inLDTA2);
680:                               //SetRSTBuf(6,RSDT1.inLDTA3);
681:                               //SetRSTBuf(7,RSDT1.inLDTA4);
682:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
683:                               //ndat - CHK
684:                               break;
685:                           }*/
686:                           case _LIN_SADR:
687:                           {
688:                               ndat=6;
689:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3ACC  0E06     MOVLW 0x6
3ACE  EC7E     CALL 0xB6FC, 0
3AD0  F05B     NOP
3AD2  D88B     RCALL PL258
690:           
691:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3AD4  EC17     CALL 0xC02E, 0
3AD6  F060     NOP
3AD8  D88F     RCALL PL540
692:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3ADA  EC17     CALL 0xC02E, 0
3ADC  F060     NOP
693:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
3ADE  D88F     RCALL PL614
3AE0  EC17     CALL 0xC02E, 0
3AE2  F060     NOP
694:                               SetRSTBuf(3,_LIN_SADR);         //3 - komenda LIN
3AE4  0E7F     MOVLW 0x7F
3AE6  6F74     MOVWF _PFNf_prODP, BANKED
3AE8  0E03     MOVLW 0x3
3AEA  EC17     CALL 0xC02E, 0
3AEC  F060     NOP
695:                               SetRSTBuf(4,RSDT1.inLDTA1);     //4 - parametr1 LIN
3AEE  D88A     RCALL PL748
3AF0  EC17     CALL 0xC02E, 0
3AF2  F060     NOP
696:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3AF4  D041     BRA 0x3B78
697:                               //ndat - CHK
698:                               break;
699:                           }
700:                           case _LIN_RPKNF:                        
701:                           case _LIN_WPKNF:
702:                           {
703:                               ndat=7;
704:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3AF6  0E07     MOVLW 0x7
3AF8  EC7E     CALL 0xB6FC, 0
3AFA  F05B     NOP
3AFC  D876     RCALL PL258
705:           
706:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3AFE  EC17     CALL 0xC02E, 0
3B00  F060     NOP
3B02  D87A     RCALL PL540
707:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3B04  EC17     CALL 0xC02E, 0
3B06  F060     NOP
3B08  D87A     RCALL PL614
708:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
3B0A  EC17     CALL 0xC02E, 0
3B0C  F060     NOP
709:                               SetRSTBuf(3,RSDT1.inLIDN);      //3 - komenda LIN
3B0E  C2A0     MOVFF 0x2A0, _PFNf_prODP
3B10  F074     NOP
3B12  0E03     MOVLW 0x3
3B14  EC17     CALL 0xC02E, 0
3B16  F060     NOP
3B18  D875     RCALL PL748
710:                               SetRSTBuf(4,RSDT1.inLDTA1);     //4 - parametr1 LIN (indeks)
3B1A  EC17     CALL 0xC02E, 0
3B1C  F060     NOP
711:                               SetRSTBuf(5,RSDT1.inLDTA2);     //5 - parametr1 LIN (wartosc dla _LIN_WPKNF)                            
3B1E  C2A2     MOVFF 0x2A2, _PFNf_prODP
3B20  F074     NOP
3B22  0E05     MOVLW 0x5
3B24  EC17     CALL 0xC02E, 0
3B26  F060     NOP
712:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3B28  0E07     MOVLW 0x7
3B2A  EF9E     GOTO 0xB93C
3B2C  F05C     NOP
713:                               //ndat - CHK
714:                               break;
715:                           } 
716:                           case _LIN_GSTAT:
717:                           {
718:                               ndat=5;
719:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3B2E  0E05     MOVLW 0x5
3B30  EC7E     CALL 0xB6FC, 0
3B32  F05B     NOP
3B34  D85A     RCALL PL258
720:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3B36  EC17     CALL 0xC02E, 0
3B38  F060     NOP
3B3A  D85E     RCALL PL540
721:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3B3C  EC17     CALL 0xC02E, 0
3B3E  F060     NOP
3B40  D85E     RCALL PL614
722:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
3B42  EC17     CALL 0xC02E, 0
3B44  F060     NOP
723:                               SetRSTBuf(3,_LIN_GSTAT);      //3 - komenda LIN                    
3B46  0E03     MOVLW 0x3
3B48  6F74     MOVWF _PFNf_prODP, BANKED
3B4A  EC17     CALL 0xC02E, 0
3B4C  F060     NOP
724:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat
3B4E  D028     BRA 0x3BA0
725:                               //ndat - CHK
726:                               break;
727:                           }                
728:                           case _LIN_GEEST:
729:                           {
730:                               ndat=6;
731:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3B50  0E06     MOVLW 0x6
3B52  EC7E     CALL 0xB6FC, 0
3B54  F05B     NOP
3B56  D849     RCALL PL258
732:           
733:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3B58  EC17     CALL 0xC02E, 0
3B5A  F060     NOP
3B5C  D84D     RCALL PL540
734:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3B5E  EC17     CALL 0xC02E, 0
3B60  F060     NOP
3B62  D84D     RCALL PL614
735:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
3B64  EC17     CALL 0xC02E, 0
3B66  F060     NOP
736:                               SetRSTBuf(3,_LIN_GEEST);        //3 - komenda LIN   
3B68  0E04     MOVLW 0x4
3B6A  6F74     MOVWF _PFNf_prODP, BANKED
3B6C  0E03     MOVLW 0x3
3B6E  EC17     CALL 0xC02E, 0
3B70  F060     NOP
3B72  D848     RCALL PL748
737:                               SetRSTBuf(4,RSDT1.inLDTA1);     //4 - parametr1 LIN (indeks)                    
3B74  EC17     CALL 0xC02E, 0
3B76  F060     NOP
738:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat                    
3B78  0E06     MOVLW 0x6
3B7A  EF9E     GOTO 0xB93C
3B7C  F05C     NOP
739:                               //ndat - CHK
740:                               break;
741:                           } 
742:                           case _LIN_GHIST:
743:                           {
744:                               ndat=5;
745:                               chkndat=SetNDatCHK(ndat);		//oblicz CHK dla liczby danych
3B7E  0E05     MOVLW 0x5
3B80  EC7E     CALL 0xB6FC, 0
3B82  F05B     NOP
3B84  D832     RCALL PL258
746:           
747:                               SetRSTBuf(0,_UNI02_ADDR);		//0 - adres slave
3B86  EC17     CALL 0xC02E, 0
3B88  F060     NOP
3B8A  D836     RCALL PL540
748:                               SetRSTBuf(1,chkndat);			//1 - liczba przesylanych bajtow (ndat)
3B8C  EC17     CALL 0xC02E, 0
3B8E  F060     NOP
3B90  D836     RCALL PL614
749:                               SetRSTBuf(2,_RD_LIN);			//2 - identyfikator paczki danych
3B92  EC17     CALL 0xC02E, 0
3B94  F060     NOP
750:                               SetRSTBuf(3,_LIN_GHIST);        //3 - komenda LIN    
3B96  0E05     MOVLW 0x5
3B98  6F74     MOVWF _PFNf_prODP, BANKED
3B9A  0E03     MOVLW 0x3
3B9C  EC17     CALL 0xC02E, 0
3B9E  F060     NOP
751:                               SetRSCHK(ndat);					//ndat - CHK z bajtow [0..ndat] i zapisuje na poz. ndat                    
3BA0  0E05     MOVLW 0x5
3BA2  EF9E     GOTO 0xB93C
3BA4  F05C     NOP
752:                               //ndat - CHK
753:                               break;
754:                           }                
755:                           default:
756:                               Nop();
3BA6  F000     NOP
757:                               break;
3BA8  0012     RETURN 0
758:                       }
759:                       break;
760:           		}
761:           #endif
762:           	}
763:           }
3BE8  0012     RETURN 0
764:           /*---------------------------------------------------------------------------------*/
765:           //Transmisja danych do/z modulu pobudzen UNI01
766:           //gdzie npow - liczba powtorzen prob transmisji w przypadku niepowodzenia
767:           unsigned char TrToUNI01(unsigned char tDTA)
8304  0100     MOVLB 0x0
8306  6F80     MOVWF _PFNf_set_nco, BANKED
768:           {
769:           	//static unsigned char err;
770:           	//vvv=MGSD.LCN;
771:           	switch(MGSD.KTR)
8308  D05A     BRA 0x83BE
83BE  503F     MOVF 0x3F, W, ACCESS
772:           	{
773:           		case 0:
774:           			MGSD.KTR=1;
830A  0E01     MOVLW 0x1
830C  6E3F     MOVWF 0x3F, ACCESS
775:           		case 1:
776:           			SaveDataToRS(tDTA);
830E  0100     MOVLB 0x0
8310  5180     MOVF _PFNf_set_nco, W, BANKED
8312  ECA7     CALL 0x374E, 0
8314  F01B     NOP
777:           			StartTransData();										//rozpocznij transmisje danych
8316  EC2D     CALL 0xC25A, 0
8318  F061     NOP
778:           			MGSD.KTR=2;
831A  0E02     MOVLW 0x2
831C  6E3F     MOVWF 0x3F, ACCESS
779:           		case 2:
780:           			if(MGSDf_TransData) 									//transmisja w toku?
831E  A804     BTFSS MGSDf_TransData, 4, ACCESS
8320  D004     BRA 0x832A
781:           			{
782:           				TransData(1);										//realizuje proces transmisji
8322  0E01     MOVLW 0x1
8324  ECAF     CALL 0x855E, 0
8326  F042     NOP
783:           				return 0;
8328  0C00     RETLW 0x0
784:           			}
785:           			if(MGSDf_TransOK)										//transmisja przebiegla bez problemu?
832A  AE04     BTFSS MGSDf_TransData, 7, ACCESS
832C  D01F     BRA 0x836C
786:           			{
787:           				RCSTA2bits.CREN=0;												//blokada odbioru na czas analizy danych
832E  9860     BCF RCSTA2, 4, ACCESS
788:           				if(VerifyRSACK()&&VerifyRSCHK(UADt.RNData))			//odpowidz odbiornika pozytywna?
8330  ECC8     CALL 0xC190, 0
8332  F060     NOP
8334  0900     IORLW 0x0
8336  E017     BZ 0x8366
8338  5042     MOVF 0x42, W, ACCESS
833A  ECF3     CALL 0xB7E6, 0
833C  F05B     NOP
833E  0900     IORLW 0x0
8340  E012     BZ 0x8366
789:           				{
790:           					if(xxy++>99) xxy=0;
8342  0101     MOVLB 0x1
8344  2BD2     INCF DtKNF, F, BANKED
8346  05D2     DECF DtKNF, W, BANKED
8348  0100     MOVLB 0x0
834A  6F7F     MOVWF _PFNf_set_fnserw, BANKED
834C  0E63     MOVLW 0x63
834E  657F     CPFSGT _PFNf_set_fnserw, BANKED
8350  D002     BRA 0x8356
8352  0101     MOVLB 0x1
8354  6BD2     CLRF DtKNF, BANKED
791:           					MGSD.LCN=0;										//zeruj licznik niepowodzeñ typu timeout
8356  6A40     CLRF 0x40, ACCESS
792:           					MGSDf_NO_ODB=0;									//zeruj znacznik braku odbiornika
8358  9E03     BCF LIN1f_NDTA, 7, ACCESS
793:           					MGSDf_TransACK=1;								//ustaw bit potwierdzenia odbioru danych
835A  8604     BSF MGSDf_TransData, 3, ACCESS
794:           					SaveRSToData();									//zapisz dane do pamieci
835C  EC20     CALL 0x1240, 0
835E  F009     NOP
795:           					MGSD.KTR=0;
8360  6A3F     CLRF 0x3F, ACCESS
796:           					RCSTA2bits.CREN=1;
8362  8860     BSF RCSTA2, 4, ACCESS
797:           					return 1;
8364  0C01     RETLW 0x1
798:           				}
799:           				else
800:           				{
801:           					MGSDf_TransACK=0;								//wyzeruj bit potwierdzenia odbioru danych
8366  9604     BCF MGSDf_TransData, 3, ACCESS
802:           				}
803:           				RCSTA2bits.CREN=1;
8368  8860     BSF RCSTA2, 4, ACCESS
804:           			}else MGSDf_TransACK=0;									//wyzeruj bit potwierdzenia odbioru danych
836A  D001     BRA 0x836E
836C  9604     BCF MGSDf_TransData, 3, ACCESS
805:           			if(zzz++>99) zzz=0;
836E  0101     MOVLB 0x1
8370  2BD4     INCF 0xD4, F, BANKED
8372  05D4     DECF 0xD4, W, BANKED
8374  0100     MOVLB 0x0
8376  6F7F     MOVWF _PFNf_set_fnserw, BANKED
8378  0E63     MOVLW 0x63
837A  657F     CPFSGT _PFNf_set_fnserw, BANKED
837C  D002     BRA 0x8382
837E  0101     MOVLB 0x1
8380  6BD4     CLRF 0xD4, BANKED
806:           			if(MGSDf_RERR_TIM||MGSDf_TERR_TIM||MGSDf_RERR_REC) if(MGSD.LCN<_NTXNOODB) MGSD.LCN++;		//zwieksz o 1 licznik niepowodzeñ typu timeout
8382  A204     BTFSS MGSDf_TransData, 1, ACCESS
8384  B404     BTFSC MGSDf_TransData, 2, ACCESS
8386  D002     BRA 0x838C
8388  A004     BTFSS MGSDf_TransData, 0, ACCESS
838A  D004     BRA 0x8394
838C  0E64     MOVLW 0x64
838E  6040     CPFSLT 0x40, ACCESS
8390  D001     BRA 0x8394
8392  2A40     INCF 0x40, F, ACCESS
807:           			if(!MGSDf_RERR_TIM&&!MGSDf_TERR_TIM&&!MGSDf_RERR_REC) MGSD.LCN=0;
8394  A204     BTFSS MGSDf_TransData, 1, ACCESS
8396  B404     BTFSC MGSDf_TransData, 2, ACCESS
8398  D002     BRA 0x839E
839A  A004     BTFSS MGSDf_TransData, 0, ACCESS
839C  6A40     CLRF 0x40, ACCESS
808:           			if(MGSD.LCN>_NTONOODB) MGSDf_NO_ODB=1;								//zasygnalizuj brak odbiornika
839E  0E14     MOVLW 0x14
83A0  6440     CPFSGT 0x40, ACCESS
83A2  D002     BRA 0x83A8
83A4  8E03     BSF LIN1f_NDTA, 7, ACCESS
83A6  D001     BRA 0x83AA
809:           			else MGSDf_NO_ODB=0;
83A8  9E03     BCF LIN1f_NDTA, 7, ACCESS
810:           			if(MGSDf_TERR_TIM||MGSDf_RERR_TIM||MGSDf_RERR_REC)	MGSDf_ERRt=1;	//blad transmisji?
83AA  A404     BTFSS MGSDf_TransData, 2, ACCESS
83AC  B204     BTFSC MGSDf_TransData, 1, ACCESS
83AE  D002     BRA 0x83B4
83B0  A004     BTFSS MGSDf_TransData, 0, ACCESS
83B2  D002     BRA 0x83B8
83B4  8C03     BSF LIN1f_NDTA, 6, ACCESS
83B6  D001     BRA 0x83BA
811:           			else MGSDf_ERRt=0;
83B8  9C03     BCF LIN1f_NDTA, 6, ACCESS
812:           			MGSD.KTR=0;
83BA  6A3F     CLRF 0x3F, ACCESS
813:           			return 2;
83BC  0C02     RETLW 0x2
83BE  503F     MOVF 0x3F, W, ACCESS
83C0  E0A4     BZ 0x830A
83C2  0A01     XORLW 0x1
83C4  E0A4     BZ 0x830E
83C6  0A03     XORLW 0x3
83C8  A4D8     BTFSS STATUS, 2, ACCESS
83CA  0C02     RETLW 0x2
83CC  D7A8     BRA 0x831E
814:           	}
815:               return 2;
816:           }
817:           /*---------------------------------------------------------------------------------*/
818:           /*---------------------------------------------------------------------------------*/
819:           /*---------------------------------------------------------------------------------*/
820:           #endif //(_EXT_BOARD!=0)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/ac.c  -----------------------
1:             /*ac.c*/
2:             //Funkcje obslugi przetwornika AC
3:             // (!) Bazuje na funkcjach z pliku: eeprom.c
4:             /*---------------------------------------------------------------------------------*/
5:             //#include <pic18.h>
6:             //#include <htc.h>
7:             #include <xc.h>
8:             #include "global.h"			//parametry globalne
9:             #include "ac.h"				//parametry lokalne
10:            
11:            #if _EXT_BOARD!=0
12:            
13:            /*---------------------------------------------------------------------------------*/
14:            void InitAC(void)
15:            {
16:            	ADIE=0;		//disable AC interrupt
BBE4  9C9D     BCF PIE1, 6, ACCESS
17:            //-----------
18:            #if _ENACQ!=0	
19:            	/*ACQT0=1;	//Acquisition time
20:            	ACQT1=1;	//20TAD
21:            	ACQT2=1;
22:                */   
23:            #else
24:            	ACQT0=0;	//Manual acquisition time
25:            	ACQT1=0;	
26:            	ACQT2=0;
27:            #endif
28:                /*ACQT0 = 1;  //1 TAD
29:                ACQT1 = 0; 
30:                ACQT2 = 0;*/    
31:            //-----------
32:            	/*ADCS0=0;	//fAD = FOSC/32
33:            	ADCS1=1;
34:            	ADCS2=0;*/
35:                ADCS0 = 1; //fAD = FOSC/16
BBE6  80C0     BSF ADCON2, 0, ACCESS
36:                ADCS1 = 0;
BBE8  92C0     BCF ADCON2, 1, ACCESS
37:                ADCS2 = 1;    
BBEA  84C0     BSF ADCON2, 2, ACCESS
38:            //-----------
39:            	VCFG0=0;	//Vref+=VDD
BBEC  98C1     BCF ADCON1, 4, ACCESS
40:            	VCFG1=0;	//Vref-=VSS	
BBEE  9AC1     BCF ADCON1, 5, ACCESS
41:            //-----------
42:            	PCFG0=0;	//AN0 jako wejscie analogowe
BBF0  90C1     BCF ADCON1, 0, ACCESS
43:            	PCFG1=1;
BBF2  82C1     BSF ADCON1, 1, ACCESS
44:            	PCFG2=1;
BBF4  84C1     BSF ADCON1, 2, ACCESS
45:            	PCFG3=1;
BBF6  86C1     BSF ADCON1, 3, ACCESS
46:            //-----------
47:            	ADFM=1;		//(16bit) - wyrownanie do prawej!
BBF8  8EC0     BSF ADCON2, 7, ACCESS
48:            	ADON=1;		//przylacz modul AC
BBFA  80C2     BSF ADCON0, 0, ACCESS
49:            	CHS0=0;		//CHANEL=0
BBFC  94C2     BCF ADCON0, 2, ACCESS
50:            	CHS1=0;
BBFE  96C2     BCF ADCON0, 3, ACCESS
51:            	CHS2=0;
BC00  98C2     BCF ADCON0, 4, ACCESS
52:            	CHS3=0;
BC02  9AC2     BCF ADCON0, 5, ACCESS
53:            }
BC04  0012     RETURN 0
54:            /*---------------------------------------------------------------------------------*/
55:            #if _ENACQ==0
56:            //Opoznienie 50u sek.
57:            void DelayAD(void)	//54u sek.
58:            {
59:            	unsigned char i;
60:            	for(i=0;i<_DLAC;i++)
61:            	{
62:            		asm("nop");
63:            	}
64:            }
65:            #endif
66:            /*---------------------------------------------------------------------------------*/
67:            //Pomiar na wybranym wyjsciu
68:            unsigned int ReadAC(const unsigned char chanel)
A7A4  0100     MOVLB 0x0
A7A6  6F77     MOVWF _PFNf_prn_pg, BANKED
69:            {
70:            #if _ENACQ==0
71:            	DelayAD();						//opoznienie 50 u sek.
72:            #endif
73:            	CHS0=(chanel&0b00000001);		//wybor kanalu pomiarowego
A7A8  A177     BTFSS _PFNf_prn_pg, 0, BANKED
A7AA  D002     BRA 0xA7B0
A7AC  84C2     BSF ADCON0, 2, ACCESS
A7AE  D001     BRA 0xA7B2
A7B0  94C2     BCF ADCON0, 2, ACCESS
74:            	CHS1=((chanel&0b00000010)>>1);
A7B2  D81F     RCALL PL402
A7B4  3176     RRCF _PFNf_prn_in, W, BANKED
A7B6  E302     BNC 0xA7BC
A7B8  86C2     BSF ADCON0, 3, ACCESS
A7BA  D001     BRA 0xA7BE
A7BC  96C2     BCF ADCON0, 3, ACCESS
75:            	CHS2=((chanel&0b00000100)>>2);
A7BE  D819     RCALL PL402
A7C0  90D8     BCF STATUS, 0, ACCESS
A7C2  3376     RRCF _PFNf_prn_in, F, BANKED
A7C4  3176     RRCF _PFNf_prn_in, W, BANKED
A7C6  E302     BNC 0xA7CC
A7C8  88C2     BSF ADCON0, 4, ACCESS
A7CA  D001     BRA 0xA7CE
A7CC  98C2     BCF ADCON0, 4, ACCESS
76:            	CHS3=((chanel&0b00001000)>>3);
A7CE  D811     RCALL PL402
A7D0  90D8     BCF STATUS, 0, ACCESS
A7D2  3376     RRCF _PFNf_prn_in, F, BANKED
A7D4  90D8     BCF STATUS, 0, ACCESS
A7D6  3376     RRCF _PFNf_prn_in, F, BANKED
A7D8  3176     RRCF _PFNf_prn_in, W, BANKED
A7DA  E302     BNC 0xA7E0
A7DC  8AC2     BSF ADCON0, 5, ACCESS
A7DE  D001     BRA 0xA7E2
A7E0  9AC2     BCF ADCON0, 5, ACCESS
77:            	GODONE=1;						//start dla pomiaru
A7E2  82C2     BSF ADCON0, 1, ACCESS
78:            	while(GODONE)continue;
A7E4  B2C2     BTFSC ADCON0, 1, ACCESS
A7E6  D7FE     BRA 0xA7E4
79:            	return ADRES;                   //zwrot wartosci AC (16bit) - wyrownanie do prawej!
A7E8  CFC3     MOVFF ADRES, _PFNf_prODP
A7EA  F074     NOP
A7EC  CFC4     MOVFF ADRESH, _PFNf_prn_cs
A7EE  F075     NOP
80:            }
A7F0  0012     RETURN 0
81:            
82:            #endif //_EXT_BOARD!=0
83:            /*---------------------------------------------------------------------------------*/
84:            /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/LIN1Slave.c  ----------------
1:             /*LIN1Slave.c*/
2:             /*---------------------------------------------------------------------------------*/
3:             //MODUL LIN SLAVE DLA UART1
4:             //Funkcje obslugi RS232 w trybie LIN.
5:             //Interfejs oparty na ukladzie MCP2003A
6:             //W czesci naglowkowej nalezy umiescic
7:             //      #include "LIN1SInterpreter.h"
8:             //W czesci inicializacyjnej nalezy umiescic
9:             //      InitTimer3();
10:            //      InitUart1();
11:            //W petli glownej nalezy umiescic funkcje:
12:            //      LIN1SDeamon();
13:            //W obsludze przerwania:
14:            //      if((RC1IF) && (RC1IE)) //odbior RS232 (RCIF jest zerowane sprzetowo)
15:            //      {
16:            //          IntUSART1SRC();     //slave
17:            //      }
18:            //      if((TX1IF) && (TX1IE)) //transmisja RS232 (TXIF jest zerowane sprzetowo)
19:            //      {
20:            //          IntUSART1STR();     //slave
21:            //      }
22:            //      if((TMR3IF) && (TMR3IE))
23:            //      {
24:            //          TMR3IF = 0;
25:            //          ReloadTimer3(); //obsluga zegara Timer3
26:            //          IntLIN2Tim();   //obsluga zegarow transmitera LIN1
27:            //      }
28:            //-------------------------------------------------
29:            //UWAGA:
30:            //RAMKA WYJSCIOWA DLA SINGLE RESPONSE:
31:                //PIF,NAD,PCI,SID,IDN,DTA1..DTA4,CHK
32:            
33:            //RAMKA ZWROTNA DLA SINGLE RESPONSE:
34:                //ZAPIS DO ODBIORNIKA:
35:                    //NAD,PCI,RSID,CHK                          //odpowiedz pozytywna (potwierdzenie)
36:                    //NAD,PCI,0x7F,SID,ERR,EPar1,Epar2,CHK      //odpowiedz negatywna (sygnalizacja bledu)
37:                //ODCZYT Z ODBIORNIKA:
38:                    //NAD,PCI,RSID,DTA1...DTA5,CHK              //odpowiedz pozytywna (dane zwrotne)
39:            //-------------------------------------------------
40:            //RAMKA WYJSCIOWA DLA MULTI RESPONSE: (IDN - identyfikator paczki danych)
41:                //TFF:
42:                    //PIF,NAD,PCI,SID,IDN,STARTL,STARTH,STOPL,STOPH,CHK
43:                //TCF:
44:                    //ZAPIS DO ODBIORNIKA:
45:                        //Gdy IND>=START i IND<=STOP
46:                            //PIF,NAD,PCI,SID,INDL,INDH,DTA1..DTA4,CHK
47:                        //Gdy IND>STOP
48:                            //PIF,NAD,PCI,SID,INDL,INDH,TCHK,CHK    //suma kontrolna danych z zakresu <START,STOP>
49:                    //ODCZYT Z ODBIORNIKA:
50:                    //PIF,NAD,PCI,SID,INDL,INDH,CHK
51:            
52:            //RAMKA ZWROTNA DLA MULTI RESPONSE:
53:                //ZAPIS DO ODBIORNIKA:
54:                    //TFF,TCF:
55:                        //NAD,PCI,RSID,CHK                          //odpowiedz pozytywna (potwierdzenie kolejnej ramki)
56:                        //NAD,PCI,0x7F,SID,ERR,EPar1,Epar2,CHK      //odpowiedz negatywna (sygnalizacja bledu)
57:                //ODCZYT Z ODBIORNIKA:
58:                    //TFF:
59:                        //NAD,PCI,RSID,CHK                          //odpowiedz pozytywna (potwierdzenie kolejnej ramki)
60:                    //TCF:
61:                        //Gdy IND>=START i IND<=STOP
62:                            //NAD,PCI,RSID,DTA1...DTA5,CHK          //odpowiedz pozytywna (dane zwrotne)
63:                        //Gdy IND>STOP
64:                            //NAD,PCI,RSID,IDN,TCHK,CHK             //odpowiedz pozytywna (suma kontrolna danych z zakresu <START,STOP>)
65:            /*---------------------------------------------------------------------------------*/
66:            //#include <pic18.h>
67:            #include <xc.h>
68:            #include "global.h"			//parametry globalne
69:            #include "main.tp.h"
70:            
71:            #if (_EXT_BOARD>=2)                    //aktywowany modul LIN1SLAVE?
72:            #include "LIN1Slave.h"
73:            #include "amgs_rs9b.h"			//parametry lokalne
74:            extern volatile MGSRSData MGSD;
75:            extern volatile bit MGSDf_NO_ODB;
76:            
77:            volatile static unsigned char dly;
78:            volatile FRAME_LIN1 FTL1,FRL1;
79:            
80:            
81:            //--------------------------------------------------------------------
82:            //zmienne modyfikowane w przerwaniu i programie glownym
83:            volatile UARTData1 UAD1t;
84:            volatile unsigned char bufTUART1[_NRS_TBF1]; //bufor roboczy modulu UART
85:            volatile unsigned char bufRUART1[_NRS_RBF1]; //bufor roboczy modulu UART
86:            volatile unsigned char tbuf[_NRS_TBF2]={0};
87:            //volatile unsigned char pbufFRUART1[8];
88:            volatile near unsigned char RSerial1;
89:            volatile LIN_STAT1 LIN1;
90:            volatile LIN_ERROR_FLAGS1 LIN1ERR;
91:            volatile CMSG_PAR CMSGPar;
92:            extern volatile unsigned char aa,bb,cc,dd,ee,ff;
93:            //extern unsigned char tbuf[];
94:            extern DataPFN PFN;
95:            /*---------------------------------------------------------------------------------*/
96:            #define _MY_NAD1        PFN.ALIN                    //adres wlasny odbiornika
97:            /*---------------------------------------------------------------------------------*/
98:            /*---------------------------------------------------------------------------------*/
99:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
100:           //Obsluga kolejnych komend dla SINGLE FRAME
101:           //Zwrocone 1 wskazuje na zakonczenie procesu, 0 wskazuje na trwanie procesu
102:           //UWAGA maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA
103:           //-------------------------------
104:           //MASTER zada zapisu danych lub wykonania komendy
105:           bit LIN1SInterpreterSF_WR(void)
106:           {
107:               switch(FRL1.SID)                //SID
9346  D040     BRA 0x93C8
93C8  0100     MOVLB 0x0
108:               {
109:                   case 0xB2:
110:                   {
111:                       FTL1f_NoResp=0;
9348  EC37     CALL 0x8E6E, 0
934A  F047     NOP
112:                       FTL1.NAD=_MY_NAD1;                   //Adres odbiornika
113:                       FTL1.PCI_TYPE=_PCI_TSF1;             //Rodzaj ramki
114:                       if(!FRL1.NAD) FTL1f_NoResp=1;         //dla adresu zerowego nie generuj odpowiedzi
934C  0100     MOVLB 0x0
934E  51AF     MOVF 0xAF, W, BANKED
9350  E12A     BNZ 0x93A6
9352  8602     BSF LIN1f_Busy, 3, ACCESS
9354  D028     BRA 0x93A6
115:                       //zapis danych do pamieci, wykonanie komendy - odebrane z MASTER (LIN1SInterpreter.c)
116:                       switch(LIN1SingleResponse_WR())
93A6  EC57     CALL 0x40AE, 0
93A8  F020     NOP
93AA  0A00     XORLW 0x0
93AC  E0D4     BZ 0x9356
93AE  0A01     XORLW 0x1
93B0  E0D9     BZ 0x9364
93B2  0A02     XORLW 0x2
93B4  E0E3     BZ 0x937C
93B6  0A06     XORLW 0x6
93B8  E0EF     BZ 0x9398
93BA  0AF5     XORLW 0xF5
93BC  E0D0     BZ 0x935E
93BE  0A0F     XORLW 0xF
93C0  E0F0     BZ 0x93A2
93C2  D7CE     BRA 0x9360
117:                       {
118:                           case _LIN1_IFINAL:   //wszystko ok
119:                           {
120:                               //potwierdzenie odbioru danych, wykonania komendy
121:                               FTL1.PCI_LENGTH=0x01;                //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
9356  0E01     MOVLW 0x1
9358  ECEC     CALL 0x31D8, 0
935A  F018     NOP
122:                               FTL1.WRD0.byte0=0xB2+0x40;           //RSID=SID+0x40
123:                               break;
935C  D001     BRA 0x9360
124:                           }
125:                           case _LIN1_NORESP:   //decyzja o braku odpowiedzi
126:                           {
127:                               FTL1f_NoResp=1;
935E  8602     BSF LIN1f_Busy, 3, ACCESS
128:                               return 1;
9360  80D8     BSF STATUS, 0, ACCESS
9362  0012     RETURN 0
129:                           }
130:                           case _LIN1_UNCCOM:  //nieznana komenda
131:                           {
132:                               //negatywna odpowiedz ukladu
133:                               if(!FRL1f_RSFrame)
9364  B002     BTFSC LIN1f_Busy, 0, ACCESS
9366  D005     BRA 0x9372
134:                               {
135:                                   LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.IDN,0);
9368  EC29     CALL 0x8E52, 0
936A  F047     NOP
936C  EC6A     CALL 0xAED4, 0
936E  F057     NOP
136:                               }
9370  D7F7     BRA 0x9360
137:                               else
138:                               {
139:                                   LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.RS_IDN,0);
9372  EC30     CALL 0x8E60, 0
9374  F047     NOP
9376  EC6A     CALL 0xAED4, 0
9378  F057     NOP
937A  D7F2     BRA 0x9360
140:                               }
141:                               return 1;
142:                           }
143:                           case _LIN1_INVDTA:  //nieprawidlowe dane
144:                           {
145:                               //negatywna odpowiedz ukladu
146:                               if(!FRL1f_RSFrame)
937C  B002     BTFSC LIN1f_Busy, 0, ACCESS
937E  D006     BRA 0x938C
9380  EC29     CALL 0x8E52, 0
9382  F047     NOP
147:                               {
148:                                   LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.IDN,0);
9384  0E03     MOVLW 0x3
9386  EC6A     CALL 0xAED4, 0
9388  F057     NOP
149:                               }
938A  D7EA     BRA 0x9360
150:                               else
151:                               {
152:                                   LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.RS_IDN,0);
938C  EC30     CALL 0x8E60, 0
938E  F047     NOP
9390  0E03     MOVLW 0x3
9392  EC6A     CALL 0xAED4, 0
9394  F057     NOP
9396  D7E4     BRA 0x9360
153:                               }
154:                               return 1;
155:                           }
156:                           case _LIN1_ERRODP:
157:                           {
158:                               //negatywna odpowiedz ukladu
159:                               LIN1NegativeResponse(_LIN1_ERRODP,0,0,0); //brak lub bledna odpowiedz odbiornika innej sieci (np UNI-02)
9398  EC1B     CALL 0x6C36, 0
939A  F036     NOP
939C  EC6A     CALL 0xAED4, 0
939E  F057     NOP
93A0  D7DF     BRA 0x9360
160:                               return 1;
161:                           }
162:                           case _LIN1_IBUSY:    //trwa proces przetwarzania danych - poczekaj
163:                           {
164:                               return 0;        //czekaj na zakonczenie przetwarzania danych
93A2  90D8     BCF STATUS, 0, ACCESS
93A4  0012     RETURN 0
165:                           }
166:                       }
167:                       break;
168:                   }
169:                   default:        //nie odpowiadaj gdy niewlasciwe SID
170:                   {
171:                       LIN1ERR.USID=1;
93C4  8BD8     BSF 0xD8, 5, BANKED
93C6  D7CB     BRA 0x935E
93C8  0100     MOVLB 0x0
93CA  51B3     MOVF 0xB3, W, BANKED
93CC  0AB2     XORLW 0xB2
93CE  E0BC     BZ 0x9348
93D0  D7F9     BRA 0x93C4
172:                       FTL1f_NoResp=1;
173:                       return 1;
174:                   }
175:               }
176:               return 1;
177:           }
178:           //-------------------------------
179:           //MASTER zada odeslania danych
180:           bit LIN1SInterpreterSF_RD(void)
181:           {
182:               switch(FRL1.SID)                //SID
8DD8  D037     BRA 0x8E48
8E48  0100     MOVLB 0x0
183:               {
184:                   case 0xB2:
185:                   {
186:                       if(!FRL1.NAD&&FRL1.IDN!=0x01)        //adres zerowy akceptowany wylacznie dla zapytania ACK
8DDA  51AF     MOVF 0xAF, W, BANKED
8DDC  E105     BNZ 0x8DE8
8DDE  05B5     DECF 0xB5, W, BANKED
8DE0  E003     BZ 0x8DE8
187:                       {
188:                           FTL1f_NoResp=1;         //dla adresu zerowego i idn!=ACK nie generuj odpowiedzi
8DE2  8602     BSF LIN1f_Busy, 3, ACCESS
189:                           return 1;
8DE4  80D8     BSF STATUS, 0, ACCESS
8DE6  0012     RETURN 0
190:                       }
8DE8  D842     RCALL PL568
191:                       FTL1f_NoResp=0;
192:                       FTL1.NAD=_MY_NAD1;                   //Adres odbiornika
193:                       FTL1.PCI_TYPE=_PCI_TSF1;             //Rodzaj ramki
194:                       //przygotowanie danych do wysylki do MASTER (LIN1SInterpreter.c)
195:                       switch(LIN1SingleResponse_RD())
8DEA  D01D     BRA 0x8E26
8E26  EC8A     CALL 0x2D14, 0
8E28  F016     NOP
8E2A  0A00     XORLW 0x0
8E2C  E0DB     BZ 0x8DE4
8E2E  0A01     XORLW 0x1
8E30  E0DD     BZ 0x8DEC
8E32  0A02     XORLW 0x2
8E34  E0E5     BZ 0x8E00
8E36  0A06     XORLW 0x6
8E38  E0EF     BZ 0x8E18
8E3A  0AF5     XORLW 0xF5
8E3C  E0D2     BZ 0x8DE2
8E3E  0A0F     XORLW 0xF
8E40  E0F0     BZ 0x8E22
8E42  D7D0     BRA 0x8DE4
196:                       {
197:                           case _LIN1_IFINAL:   //wszystko ok, gotow do wysylki danych
198:                           {
199:                               break;
200:                           }
201:                           case _LIN1_NORESP:   //decyzja o braku odpowiedzi
202:                           {
203:                               FTL1f_NoResp=1;
204:                               return 1;
205:                           }
206:                           case _LIN1_UNCCOM:  //nieznana komenda
207:                           {
208:                               //negatywna odpowiedz ukladu
209:                               if(!FRL1f_RSFrame)
8DEC  B002     BTFSC LIN1f_Busy, 0, ACCESS
8DEE  D004     BRA 0x8DF8
8DF0  D830     RCALL PL122
210:                               {
211:                                   LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.IDN,0);
8DF2  EC6A     CALL 0xAED4, 0
8DF4  F057     NOP
212:                               }
8DF6  D7F6     BRA 0x8DE4
213:                               else
214:                               {
215:                                   LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.RS_IDN,0);
8DF8  D833     RCALL PL124
8DFA  EC6A     CALL 0xAED4, 0
8DFC  F057     NOP
8DFE  D7F2     BRA 0x8DE4
216:                               }                        
217:                               return 1;
218:                           }
219:                           case _LIN1_INVDTA:  //nieprawidlowe dane
220:                           {
221:                               //negatywna odpowiedz ukladu
222:                               if(!FRL1f_RSFrame)
8E00  B002     BTFSC LIN1f_Busy, 0, ACCESS
8E02  D005     BRA 0x8E0E
8E04  D826     RCALL PL122
223:                               {                    
224:                                   LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.IDN,0);
8E06  0E03     MOVLW 0x3
8E08  EC6A     CALL 0xAED4, 0
8E0A  F057     NOP
225:                               }
8E0C  D7EB     BRA 0x8DE4
226:                               else
227:                               {
228:                                   LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.RS_IDN,0);                        
8E0E  D828     RCALL PL124
8E10  0E03     MOVLW 0x3
8E12  EC6A     CALL 0xAED4, 0
8E14  F057     NOP
8E16  D7E6     BRA 0x8DE4
229:                               }
230:                               return 1;
231:                           }
232:                           case _LIN1_ERRODP:
233:                           {
234:                               //negatywna odpowiedz ukladu
235:                               LIN1NegativeResponse(_LIN1_ERRODP,0,0,0); //brak lub bledna odpowiedz odbiornika innej sieci (np UNI-02)
8E18  EC1B     CALL 0x6C36, 0
8E1A  F036     NOP
8E1C  EC6A     CALL 0xAED4, 0
8E1E  F057     NOP
8E20  D7E1     BRA 0x8DE4
236:                               return 1;
237:                           }
238:                           case _LIN1_IBUSY:    //trwa proces przetwarzania danych - poczekaj
239:                           {
240:                               return 0;        //czekaj na zakonczenie przetwarzania danych
8E22  90D8     BCF STATUS, 0, ACCESS
8E24  0012     RETURN 0
241:                           }
242:                       }
243:                       break;
244:                   }
245:                   default:        //nie odpowiadaj gdy niewlasciwe SID
246:                   {
247:                       LIN1ERR.USID=1;
8E44  8BD8     BSF 0xD8, 5, BANKED
8E46  D7CD     BRA 0x8DE2
8E48  0100     MOVLB 0x0
8E4A  51B3     MOVF 0xB3, W, BANKED
8E4C  0AB2     XORLW 0xB2
8E4E  E0C5     BZ 0x8DDA
8E50  D7F9     BRA 0x8E44
248:                       FTL1f_NoResp=1;
249:                       return 1;
250:                   }
251:               }
252:               return 1;
253:           }
254:           //---------------------------------------------------------------------------
255:           //Obsluga kolejnych komend dla CONTINIOUS FRAME
256:           //Zwrocone 1 wskazuje na zakonczenie procesu, 0 wskazuje na trwanie procesu
257:           //UWAGA maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA
258:           //-------------------------------
259:           //FIRST FRAME Procedura zwiazana z inicjacja danymch tablicowymi do zapisu/odczytu
260:           bit LIN1SInterpreterFF(void)
261:           {
262:               volatile static unsigned char krok=0;
263:               volatile unsigned char stat;
264:               switch(FRL1.SID)                //SID
6AD6  D0A9     BRA 0x6C2A
6C2A  0100     MOVLB 0x0
265:               {
266:                   case 0xB2:
267:                   {
268:                       if(!FRL1.NAD)                           //dla adresu zerowego transfer tablicowy nie obslugiwany
6AD8  51AF     MOVF 0xAF, W, BANKED
6ADA  E001     BZ 0x6ADE
6ADC  D09A     BRA 0x6C12
269:                       {
270:                           krok=0;
6ADE  0101     MOVLB 0x1
6AE0  6BAE     CLRF FRL1, BANKED
271:                           FTL1f_NoResp=1;                      //dla adresu zerowego nie generuj odpowiedzi
6AE2  8602     BSF LIN1f_Busy, 3, ACCESS
272:                           return 1;
6AE4  80D8     BSF STATUS, 0, ACCESS
6AE6  0012     RETURN 0
273:                       }
274:                       switch(krok)
6C12  0101     MOVLB 0x1
6C14  51AE     MOVF FRL1, W, BANKED
6C16  E101     BNZ 0x6C1A
6C18  D767     BRA 0x6AE8
6C1A  0A01     XORLW 0x1
6C1C  E08D     BZ 0x6B38
6C1E  D7BC     BRA 0x6B98
275:                       {
276:                           case 0:
277:                           {
278:                               //odpowiedz ukladu
279:                               FTL1f_NoResp=0;
6AE8  9602     BCF LIN1f_Busy, 3, ACCESS
280:                               FTL1.NAD=_MY_NAD1;                      //Adres odbiornika
6AEA  C1ED     MOVFF 0x1ED, 0x13F
6AEC  F13F     NOP
281:                               FTL1.PCI_TYPE=_PCI_TFF1;                //Rodzaj ramki
6AEE  0E10     MOVLW 0x10
6AF0  6F41     MOVWF UADt, BANKED
282:                               //FTL1.PCI_LENGTH=0x01;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)  
283:                               FTL1.PCI_LENGTH=0x02;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)            
6AF2  0E02     MOVLW 0x2
6AF4  6F42     MOVWF 0x42, BANKED
284:                               FTL1.WRD0.byte0=0xB2+0x40;              //RSID=SID+0x40
6AF6  0EF2     MOVLW 0xF2
6AF8  6F4A     MOVWF cSk, BANKED
285:           
286:                               //parametry startowe dla kolejnych ramek CF
287:                               FRL1.FFPAR.war=FRL1.WRD1.war;           //dwubajtowy parametr wywolania przy multikomendzie (zapamietanie po weryfikacji)
6AFA  C0BC     MOVFF 0xBC, 0xC6
6AFC  F0C6     NOP
6AFE  C0BD     MOVFF 0xBD, 0xC7
6B00  F0C7     NOP
288:                               FRL1.START.war=0;                       //pczatkowy element tabeli (zawsze 0)
6B02  0100     MOVLB 0x0
6B04  6BC2     CLRF 0xC2, BANKED
6B06  6BC3     CLRF 0xC3, BANKED
289:                               FRL1.STOP.war =FRL1.WRD2.war;           //koncowy element tabeli
6B08  C0BE     MOVFF 0xBE, 0xC4
6B0A  F0C4     NOP
6B0C  C0BF     MOVFF 0xBF, 0xC5
6B0E  F0C5     NOP
290:                               FRL1.PCI_FCOUNT.war=FRL1.START.war;     //poczatkowy indeks tabeli
6B10  C0C2     MOVFF 0xC2, 0xC0
6B12  F0C0     NOP
6B14  C0C3     MOVFF 0xC3, 0xC1
6B16  F0C1     NOP
291:                               FTL1.WRD0.byte1=(FRL1.STOP.war)?((unsigned char)FRL1.STOP.war+1):0;       //zwroc odebrany rozmiar tabeli danych     
6B18  51C4     MOVF 0xC4, W, BANKED
6B1A  11C5     IORWF 0xC5, W, BANKED
6B1C  E103     BNZ 0x6B24
6B1E  6BA1     CLRF _UADtf_RErrREC, BANKED
6B20  6BA2     CLRF _UADtf_TData, BANKED
6B22  D005     BRA 0x6B2E
6B24  29C4     INCF 0xC4, W, BANKED
6B26  6FA1     MOVWF _UADtf_RErrREC, BANKED
6B28  6BA2     CLRF _UADtf_TData, BANKED
6B2A  0E00     MOVLW 0x0
6B2C  23A2     ADDWFC _UADtf_TData, F, BANKED
6B2E  C0A1     MOVFF _UADtf_RErrREC, 0x14B
6B30  F14B     NOP
292:                               krok=1;
6B32  0E01     MOVLW 0x1
6B34  0101     MOVLB 0x1
6B36  6FAE     MOVWF FRL1, BANKED
293:                           }
294:                           case 1:
295:                           {
296:                               //przygotowanie bufora do zapisu/odczytu danych odebranych z MASTER (LIN1SInterpreter.c)
297:                               if((FRL1.PIF.war&0b00111111)==_PIF_WRITE) stat=LIN1StartMultiResponse_WR(); //MASTER zada zapisu nadeslanych danych
6B38  0100     MOVLB 0x0
6B3A  51AE     MOVF FRL1, W, BANKED
6B3C  0B3F     ANDLW 0x3F
6B3E  06E8     DECF WREG, F, ACCESS
6B40  E103     BNZ 0x6B48
6B42  ECEF     CALL 0xBFDE, 0
6B44  F05F     NOP
6B46  D007     BRA 0x6B56
298:                               else
299:                               if((FRL1.PIF.war&0b00111111)==_PIF_READ)    //MASTER zada odeslania danych
6B48  51AE     MOVF FRL1, W, BANKED
6B4A  0B3F     ANDLW 0x3F
6B4C  0A02     XORLW 0x2
6B4E  E105     BNZ 0x6B5A
300:                               {
301:                                   stat=LIN1StartMultiResponse_RD();  
6B50  EC87     CALL 0x270E, 0
6B52  F013     NOP
6B54  0100     MOVLB 0x0
6B56  6FA5     MOVWF f3, BANKED
302:                               }
6B58  D04E     BRA 0x6BF6
303:                               else                                                    //nieznane PIF
304:                               {
305:                                   krok=0;
6B5A  0101     MOVLB 0x1
6B5C  6BAE     CLRF FRL1, BANKED
306:                                   LIN1ERR.UPIF=1;
6B5E  0100     MOVLB 0x0
6B60  8DD8     BSF 0xD8, 6, BANKED
6B62  D7BF     BRA 0x6AE2
307:                                   FTL1f_NoResp=1;
308:                                   return 1;
309:                               }
310:                               //czekaj na przygotowanie danych do wysylki
311:                               switch(stat)
6BF6  51A5     MOVF f3, W, BANKED
6BF8  E0B5     BZ 0x6B64
6BFA  0A01     XORLW 0x1
6BFC  E0D0     BZ 0x6B9E
6BFE  0A03     XORLW 0x3
6C00  E0DC     BZ 0x6BBA
6C02  0A07     XORLW 0x7
6C04  E0EA     BZ 0x6BDA
6C06  0AF5     XORLW 0xF5
6C08  E101     BNZ 0x6C0C
6C0A  D769     BRA 0x6ADE
6C0C  0A0F     XORLW 0xF
6C0E  E0EB     BZ 0x6BE6
6C10  D7EC     BRA 0x6BEA
312:                               {
313:                                   case _LIN1_IFINAL:
314:                                   {
315:                                       if(!FTL1.WRD0.byte1)    //nie nadeslano wymaganej liczby bajtow
6B64  0101     MOVLB 0x1
6B66  514B     MOVF 0x4B, W, BANKED
6B68  E10E     BNZ 0x6B86
316:                                       {
317:                                           FTL1.WRD0.byte1=(FRL1.STOP.war)?((unsigned char)FRL1.STOP.war+1):0;   //zwroc informacje o odsylanej liczbie bajtow
6B6A  0100     MOVLB 0x0
6B6C  51C4     MOVF 0xC4, W, BANKED
6B6E  11C5     IORWF 0xC5, W, BANKED
6B70  E103     BNZ 0x6B78
6B72  6BA3     CLRF _UADtf_TEXT, BANKED
6B74  6BA4     CLRF _UADtf_TEnd, BANKED
6B76  D005     BRA 0x6B82
6B78  29C4     INCF 0xC4, W, BANKED
6B7A  6FA3     MOVWF _UADtf_TEXT, BANKED
6B7C  6BA4     CLRF _UADtf_TEnd, BANKED
6B7E  0E00     MOVLW 0x0
6B80  23A4     ADDWFC _UADtf_TEnd, F, BANKED
6B82  C0A3     MOVFF _UADtf_TEXT, 0x14B
6B84  F14B     NOP
318:                                       }
319:                                       
320:                                       if((FRL1.IDN==0x18)&&(FTL1.WRD0.byte1>4))
6B86  0E18     MOVLW 0x18
6B88  0100     MOVLB 0x0
6B8A  19B5     XORWF 0xB5, W, BANKED
6B8C  E105     BNZ 0x6B98
6B8E  0E04     MOVLW 0x4
6B90  0101     MOVLB 0x1
6B92  654B     CPFSGT 0x4B, BANKED
6B94  D001     BRA 0x6B98
321:                                       {
322:                                           Nop();
6B96  F000     NOP
323:                                       }
324:                                       krok=0;
6B98  0101     MOVLB 0x1
6B9A  6BAE     CLRF FRL1, BANKED
6B9C  D7A3     BRA 0x6AE4
325:                                       return 1;
326:                                   }
327:                                   case _LIN1_UNCCOM:  //nieznana komenda
328:                                   {
329:                                       krok=0;
6B9E  0101     MOVLB 0x1
6BA0  6BAE     CLRF FRL1, BANKED
330:                                       //negatywna odpowiedz ukladu
331:                                       if(!FRL1f_RSFrame)
6BA2  B002     BTFSC LIN1f_Busy, 0, ACCESS
6BA4  D005     BRA 0x6BB0
6BA6  EC29     CALL 0x8E52, 0
6BA8  F047     NOP
332:                                       {                    
333:                                           LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.IDN,0);
6BAA  EC6A     CALL 0xAED4, 0
6BAC  F057     NOP
334:                                       }
6BAE  D79A     BRA 0x6AE4
335:                                       else
336:                                       {
337:                                           LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.RS_IDN,0);                        
6BB0  EC30     CALL 0x8E60, 0
6BB2  F047     NOP
6BB4  EC6A     CALL 0xAED4, 0
6BB6  F057     NOP
6BB8  D795     BRA 0x6AE4
338:                                       }
339:                                       return 1;
340:                                   }
341:                                   case _LIN1_INVPAR:  //nieprawidlowe dane
342:                                   {
343:                                       krok=0;
6BBA  0101     MOVLB 0x1
6BBC  6BAE     CLRF FRL1, BANKED
344:                                       //negatywna odpowiedz ukladu
345:                                       if(!FRL1f_RSFrame)
6BBE  B002     BTFSC LIN1f_Busy, 0, ACCESS
6BC0  D006     BRA 0x6BCE
6BC2  EC29     CALL 0x8E52, 0
6BC4  F047     NOP
346:                                       {                    
347:                                           LIN1NegativeResponse(_LIN1_INVPAR,1,FRL1.IDN,0); //niewlasciwa wartosc parametru
6BC6  0E02     MOVLW 0x2
6BC8  EC6A     CALL 0xAED4, 0
6BCA  F057     NOP
348:                                       }
6BCC  D78B     BRA 0x6AE4
349:                                       else
350:                                       {
351:                                           LIN1NegativeResponse(_LIN1_INVPAR,1,FRL1.RS_IDN,0); //niewlasciwa wartosc parametru                        
6BCE  EC30     CALL 0x8E60, 0
6BD0  F047     NOP
6BD2  0E02     MOVLW 0x2
6BD4  EC6A     CALL 0xAED4, 0
6BD6  F057     NOP
6BD8  D785     BRA 0x6AE4
352:                                       }
353:                                       return 1;
354:                                   }
355:                                   case _LIN1_ERRODP:
356:                                   {
357:                                       krok=0;
6BDA  0101     MOVLB 0x1
6BDC  6BAE     CLRF FRL1, BANKED
6BDE  D82B     RCALL PL278
358:                                       //negatywna odpowiedz ukladu
359:                                       LIN1NegativeResponse(_LIN1_ERRODP,0,0,0); //brak lub bledna odpowiedz odbiornika innej sieci (np UNI-02)
6BE0  EC6A     CALL 0xAED4, 0
6BE2  F057     NOP
6BE4  D77F     BRA 0x6AE4
360:                                       return 1;
361:                                   }
362:                                   case _LIN1_NORESP:   //decyzja o braku odpowiedzi
363:                                   {
364:                                       krok=0;
365:                                       FTL1f_NoResp=1;
366:                                       return 1;
367:                                   }                        
368:                                   case _LIN1_IBUSY:    //trwa proces przetwarzania danych - poczekaj
369:                                   {
370:                                       return 0;        //czekaj na zakonczenie przetwarzania danych
6BE6  90D8     BCF STATUS, 0, ACCESS
6BE8  0012     RETURN 0
371:                                   }
372:                                   default:             //niesprecyzowany stan przetwarzania danych
373:                                   {
374:                                       krok=0;
6BEA  0101     MOVLB 0x1
6BEC  6BAE     CLRF FRL1, BANKED
6BEE  D823     RCALL PL278
375:                                       //negatywna odpowiedz ukladu
376:                                       LIN1NegativeResponse(_LIN1_ERRODP,0,0,0); //brak lub bledna odpowiedz odbiornika innej sieci (np UNI-02)
6BF0  EC6A     CALL 0xAED4, 0
6BF2  F057     NOP
6BF4  D777     BRA 0x6AE4
377:                                       return 1;
378:                                   }
379:                               }                    
380:                           }
381:                       }
382:                       break;
383:                   }
384:                   default:        //nie odpowiadaj gdy niewlasciwe SID
385:                   {
386:                       krok=0;
6C20  0101     MOVLB 0x1
6C22  6BAE     CLRF FRL1, BANKED
387:                       LIN1ERR.USID=1;
6C24  0100     MOVLB 0x0
6C26  8BD8     BSF 0xD8, 5, BANKED
6C28  D75C     BRA 0x6AE2
6C2A  0100     MOVLB 0x0
6C2C  51B3     MOVF 0xB3, W, BANKED
6C2E  0AB2     XORLW 0xB2
6C30  E101     BNZ 0x6C34
6C32  D752     BRA 0x6AD8
6C34  D7F5     BRA 0x6C20
388:                       FTL1f_NoResp=1;
389:                       return 1;
390:                   }
391:               }
392:               krok=0;
393:               return 1;
394:           }
395:           //-------------------------------
396:           //NEXT FRAME Rejestracja danych tablicowych (MASTER zada zapisu nadeslanych danych)
397:           bit LIN1SInterpreterCF_WR(void)
398:           {
399:               unsigned int i;
400:               switch(FRL1.CSID)                //SID
6DA0  D08A     BRA 0x6EB6
6EB6  0100     MOVLB 0x0
401:               {
402:                   case 0xB2:
403:                   {
404:                       if(!FRL1.NAD)                           //dla adresu zerowego transfer tablicowy nie obslugiwany
6DA2  51AF     MOVF 0xAF, W, BANKED
6DA4  E103     BNZ 0x6DAC
405:                       {
406:                           FTL1f_NoResp=1;                      //dla adresu zerowego nie generuj odpowiedzi
6DA6  8602     BSF LIN1f_Busy, 3, ACCESS
407:                           return 1;
6DA8  80D8     BSF STATUS, 0, ACCESS
6DAA  0012     RETURN 0
408:                       }
409:                       //przygotowanie ew. odpowiedzi
410:                       FTL1f_NoResp=0;
6DAC  ECF0     CALL 0x67E0, 0
6DAE  F033     NOP
411:                       FTL1.NAD=_MY_NAD1;                      //Adres odbiornika
412:                       FTL1.PCI_TYPE=_PCI_TCF1;                //Rodzaj ramki
413:                       FTL1.PCI_LENGTH=0x01;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
6DB0  0E01     MOVLW 0x1
6DB2  6F42     MOVWF 0x42, BANKED
414:                       FTL1.WRD0.byte0=0xB2+0x40;              //RSID=SID+0x40
6DB4  0EF2     MOVLW 0xF2
6DB6  6F4A     MOVWF cSk, BANKED
415:           
416:                       FRL1.PCI_FCOUNT.war=FRL1.WRD0.war;      //odczytaj poczatkowy indeks zapisu danych
6DB8  ECE8     CALL 0x67D0, 0
6DBA  F033     NOP
417:                       if(FRL1.PCI_FCOUNT.war>FRL1.STOP.war)   //MASTER przysyla sume kontrolna dla nadeslanych wczesniej danych
6DBC  51C1     MOVF 0xC1, W, BANKED
6DBE  59C5     SUBWFB 0xC5, W, BANKED
6DC0  E238     BC 0x6E32
418:                       {
419:                           if((FRL1.WRD1.byte0==FRL1.IDN)&&(FRL1.WRD1.byte1==CalcTabCHK(FRL1.tab,FRL1.START.war,FRL1.STOP.war)))
6DC2  51B5     MOVF 0xB5, W, BANKED
6DC4  19BC     XORWF 0xBC, W, BANKED
6DC6  E12E     BNZ 0x6E24
6DC8  ECDB     CALL 0x67B6, 0
6DCA  F033     NOP
6DCC  EC59     CALL 0xAAB2, 0
6DCE  F055     NOP
6DD0  19BD     XORWF 0xBD, W, BANKED
6DD2  E01D     BZ 0x6E0E
6DD4  D027     BRA 0x6E24
420:                           {
421:                               switch(LIN1FinishMultiResponse_WR())            //aktualizuj dane (LIN1SInterpreter.c)
6E0E  ECF9     CALL 0xBFF2, 0
6E10  F05F     NOP
6E12  0A01     XORLW 0x1
6E14  E0E0     BZ 0x6DD6
6E16  0A02     XORLW 0x2
6E18  E0EA     BZ 0x6DEE
6E1A  0AF3     XORLW 0xF3
6E1C  E0C4     BZ 0x6DA6
6E1E  0A0F     XORLW 0xF
6E20  E0F4     BZ 0x6E0A
6E22  D7C2     BRA 0x6DA8
422:                               {
423:                                   case _LIN1_NORESP:   //decyzja o braku odpowiedzi
424:                                   {
425:                                       FTL1f_NoResp=1;
426:                                       return 1;
427:                                   }
428:                                   case _LIN1_UNCCOM:  //nieznana komenda
429:                                   {
430:                                       //negatywna odpowiedz ukladu
431:                                       if(!FRL1f_RSFrame)
6DD6  B002     BTFSC LIN1f_Busy, 0, ACCESS
6DD8  D005     BRA 0x6DE4
432:                                       {                            
433:                                           LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.IDN,0);
6DDA  0E01     MOVLW 0x1
6DDC  D872     RCALL PL226
6DDE  EC6A     CALL 0xAED4, 0
6DE0  F057     NOP
434:                                       }
6DE2  D7E2     BRA 0x6DA8
435:                                       else
436:                                       {                            
437:                                           LIN1NegativeResponse(_LIN1_UNCCOM,1,FRL1.RS_IDN,0);
6DE4  0E01     MOVLW 0x1
6DE6  D872     RCALL PL230
6DE8  EC6A     CALL 0xAED4, 0
6DEA  F057     NOP
6DEC  D7DD     BRA 0x6DA8
438:                                       }
439:                                       return 1;
440:                                   }
441:                                   case _LIN1_INVDTA:  //nieprawidlowe dane
442:                                   {
443:                                       //negatywna odpowiedz ukladu
444:                                       if(!FRL1f_RSFrame)
6DEE  B002     BTFSC LIN1f_Busy, 0, ACCESS
6DF0  D006     BRA 0x6DFE
445:                                       {                            
446:                                           LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.IDN,0);
6DF2  0E01     MOVLW 0x1
6DF4  D866     RCALL PL226
6DF6  0E03     MOVLW 0x3
6DF8  EC6A     CALL 0xAED4, 0
6DFA  F057     NOP
447:                                       }
6DFC  D7D5     BRA 0x6DA8
448:                                       else
449:                                       {
450:                                           LIN1NegativeResponse(_LIN1_INVDTA,1,FRL1.RS_IDN,0);                                
6DFE  0E01     MOVLW 0x1
6E00  D865     RCALL PL230
6E02  0E03     MOVLW 0x3
6E04  EC6A     CALL 0xAED4, 0
6E06  F057     NOP
6E08  D7CF     BRA 0x6DA8
451:                                       }
452:                                       return 1;
453:                                   }
454:                                   case _LIN1_IBUSY:    //trwa proces przetwarzania danych - poczekaj
455:                                   {
456:                                       return 0;        //czekaj na zakonczenie przetwarzania danych
6E0A  90D8     BCF STATUS, 0, ACCESS
6E0C  0012     RETURN 0
457:                                   }
458:                               }
459:                           }
460:                           else        
461:                           {
462:                               //negatywna odpowiedz ukladu
463:                               LIN1NegativeResponse(_LIN1_INVCHK,0,0,0); //niewlasciwa wartosc IDN lub CHK
6E24  6B74     CLRF _PFNf_prODP, BANKED
6E26  6B75     CLRF _PFNf_prn_cs, BANKED
6E28  6B76     CLRF _PFNf_prn_in, BANKED
6E2A  0E04     MOVLW 0x4
6E2C  EC6A     CALL 0xAED4, 0
6E2E  F057     NOP
6E30  D7BB     BRA 0x6DA8
464:                           }
465:                           return 1;
466:                       }
467:                       for(i=0;i<4;i++)
6E32  6B82     CLRF _PFNf_str_nco, BANKED
6E34  6B83     CLRF _PFNf_str_ncw, BANKED
6E9E  4B82     INFSNZ _PFNf_str_nco, F, BANKED
6EA0  2B83     INCF _PFNf_str_ncw, F, BANKED
6EA2  5183     MOVF _PFNf_str_ncw, W, BANKED
6EA4  E181     BNZ 0x6DA8
6EA6  0E04     MOVLW 0x4
6EA8  5D82     SUBWF _PFNf_str_nco, W, BANKED
6EAA  E301     BNC 0x6EAE
6EAC  D77D     BRA 0x6DA8
6EAE  D7C3     BRA 0x6E36
6EB0  D77B     BRA 0x6DA8
468:                       {
469:                           if((FRL1.PCI_FCOUNT.war+i>FRL1.STOP.war)||(FRL1.PCI_FCOUNT.war+i>=FRL1.imax))
6E36  D856     RCALL PL476
6E38  5180     MOVF _PFNf_set_nco, W, BANKED
6E3A  5DC4     SUBWF 0xC4, W, BANKED
6E3C  5181     MOVF _PFNf_set_ncw, W, BANKED
6E3E  59C5     SUBWFB 0xC5, W, BANKED
6E40  E3B3     BNC 0x6DA8
6E42  D850     RCALL PL476
6E44  51CA     MOVF 0xCA, W, BANKED
6E46  5D80     SUBWF _PFNf_set_nco, W, BANKED
6E48  51CB     MOVF 0xCB, W, BANKED
6E4A  5981     SUBWFB _PFNf_set_ncw, W, BANKED
6E4C  E2AD     BC 0x6DA8
6E4E  D019     BRA 0x6E82
470:                           {
471:                               break;
472:                           }
473:                           switch(i)
6E82  C082     MOVFF _PFNf_str_nco, _PFNf_set_nco
6E84  F080     NOP
6E86  C083     MOVFF _PFNf_str_ncw, _PFNf_set_ncw
6E88  F081     NOP
6E8A  5181     MOVF _PFNf_set_ncw, W, BANKED
6E8C  E108     BNZ 0x6E9E
6E8E  5180     MOVF _PFNf_set_nco, W, BANKED
6E90  E0DF     BZ 0x6E50
6E92  0A01     XORLW 0x1
6E94  E0E2     BZ 0x6E5A
6E96  0A03     XORLW 0x3
6E98  E0E6     BZ 0x6E66
6E9A  0A01     XORLW 0x1
6E9C  E0EB     BZ 0x6E74
474:                           {
475:                               case 0:
476:                                   FRL1.tab[FRL1.PCI_FCOUNT.war]=FRL1.WRD1.byte0;
6E50  ECF7     CALL 0x67EE, 0
6E52  F033     NOP
6E54  C0BC     MOVFF 0xBC, INDF2
6E56  FFDF     NOP
477:                               break;
6E58  D022     BRA 0x6E9E
478:                               case 1:
479:                                   FRL1.tab[FRL1.PCI_FCOUNT.war+1]=FRL1.WRD1.byte1;
6E5A  D83D     RCALL PL298
6E5C  2980     INCF _PFNf_set_nco, W, BANKED
6E5E  D849     RCALL PL520
6E60  C0BD     MOVFF 0xBD, INDF2
6E62  FFDF     NOP
480:                               break;
6E64  D01C     BRA 0x6E9E
481:                               case 2:
482:                                   FRL1.tab[FRL1.PCI_FCOUNT.war+2]=FRL1.WRD2.byte0;
6E66  D837     RCALL PL298
6E68  0E02     MOVLW 0x2
6E6A  2580     ADDWF _PFNf_set_nco, W, BANKED
6E6C  D842     RCALL PL520
6E6E  C0BE     MOVFF 0xBE, INDF2
6E70  FFDF     NOP
483:                               break;
6E72  D015     BRA 0x6E9E
484:                               case 3:
485:                                   FRL1.tab[FRL1.PCI_FCOUNT.war+3]=FRL1.WRD2.byte1;
6E74  D830     RCALL PL298
6E76  0E03     MOVLW 0x3
6E78  2580     ADDWF _PFNf_set_nco, W, BANKED
6E7A  D83B     RCALL PL520
6E7C  C0BF     MOVFF 0xBF, INDF2
6E7E  FFDF     NOP
486:                               break;
6E80  D00E     BRA 0x6E9E
487:                           }
488:                       }
489:                       break;
490:                   }
491:                   default:    //nie odpowiadaj gdy niewlasciwe SID
492:                   {
493:                       LIN1ERR.USID=1;
6EB2  8BD8     BSF 0xD8, 5, BANKED
6EB4  D778     BRA 0x6DA6
6EB6  0100     MOVLB 0x0
6EB8  51B4     MOVF 0xB4, W, BANKED
6EBA  0AB2     XORLW 0xB2
6EBC  E101     BNZ 0x6EC0
6EBE  D771     BRA 0x6DA2
6EC0  D7F8     BRA 0x6EB2
494:                       FTL1f_NoResp=1;
495:                       return 1;
496:                   }
497:               }
498:               return 1;
499:           }
500:           //-------------------------------
501:           //NEXT FRAME Wysylka danych tablicowych (MASTER zada odeslania danych)
502:           bit LIN1SInterpreterCF_RD(void)
503:           {
504:               switch(FRL1.CSID)                //SID
6646  D08E     BRA 0x6764
6764  0100     MOVLB 0x0
505:               {
506:                   case 0xB2:
507:                   {
508:                       if(!FRL1.NAD)                           //dla adresu zerowego transfer tablicowy nie obslugiwany
6648  51AF     MOVF 0xAF, W, BANKED
664A  E103     BNZ 0x6652
509:                       {
510:                           FTL1f_NoResp=1;                      //dla adresu zerowego nie generuj odpowiedzi
664C  8602     BSF LIN1f_Busy, 3, ACCESS
511:                           return 1;
664E  80D8     BSF STATUS, 0, ACCESS
6650  0012     RETURN 0
512:                       }
6652  D8C6     RCALL PL468
6654  D8BD     RCALL PL250
513:                       //przygotowanie ew. odpowiedzi
514:                       FTL1f_NoResp=0;
515:                       FTL1.NAD=_MY_NAD1;                      //Adres odbiornika
516:                       FTL1.PCI_TYPE=_PCI_TCF1;                //Rodzaj ramki
517:                       FRL1.PCI_FCOUNT.war=FRL1.WRD0.war;      //odczytaj indeks danych do wysylki
518:                       if(FRL1.PCI_FCOUNT.war<=FRL1.STOP.war)
6656  51C1     MOVF 0xC1, W, BANKED
6658  59C5     SUBWFB 0xC5, W, BANKED
665A  E372     BNC 0x6740
519:                       {
520:                           FTL1.PCI_LENGTH=0x06;                   //Rozmiar ramki(liczba bajtow danych bez CHK)
665C  0E06     MOVLW 0x6
665E  0101     MOVLB 0x1
6660  6F42     MOVWF 0x42, BANKED
6662  D8B6     RCALL PL250
521:                           FRL1.PCI_FCOUNT.war=FRL1.WRD0.war;      //odczytaj poczatkowy indeks zapisu danych
522:                           if((FRL1.STOP.war-FRL1.PCI_FCOUNT.war)<6)
6664  6F80     MOVWF _PFNf_set_nco, BANKED
6666  51C1     MOVF 0xC1, W, BANKED
6668  59C5     SUBWFB 0xC5, W, BANKED
666A  6F81     MOVWF _PFNf_set_ncw, BANKED
666C  5181     MOVF _PFNf_set_ncw, W, BANKED
666E  E109     BNZ 0x6682
6670  0E06     MOVLW 0x6
6672  5D80     SUBWF _PFNf_set_nco, W, BANKED
6674  E206     BC 0x6682
523:                           {
524:                               FTL1.PCI_LENGTH=(FRL1.STOP.war-FRL1.PCI_FCOUNT.war)+1;                  //Rozmiar ramki(liczba bajtow danych bez CHK)
6676  51C0     MOVF 0xC0, W, BANKED
6678  5DC4     SUBWF 0xC4, W, BANKED
667A  6F80     MOVWF _PFNf_set_nco, BANKED
667C  2980     INCF _PFNf_set_nco, W, BANKED
667E  0101     MOVLB 0x1
6680  6F42     MOVWF 0x42, BANKED
525:                           }
526:                           if((FRL1.PCI_FCOUNT.war<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war<FRL1.imax))
6682  0100     MOVLB 0x0
6684  51C0     MOVF 0xC0, W, BANKED
6686  5DC4     SUBWF 0xC4, W, BANKED
6688  51C1     MOVF 0xC1, W, BANKED
668A  59C5     SUBWFB 0xC5, W, BANKED
668C  E30A     BNC 0x66A2
668E  51CA     MOVF 0xCA, W, BANKED
6690  5DC0     SUBWF 0xC0, W, BANKED
6692  51CB     MOVF 0xCB, W, BANKED
6694  59C1     SUBWFB 0xC1, W, BANKED
6696  E205     BC 0x66A2
6698  D8AA     RCALL PL488
527:                           FTL1.WRD0.byte0=FRL1.tab[FRL1.PCI_FCOUNT.war];
669A  50DF     MOVF INDF2, W, ACCESS
669C  0101     MOVLB 0x1
669E  6F4A     MOVWF cSk, BANKED
66A0  D002     BRA 0x66A6
528:                           else FTL1.WRD0.byte0=0xFF;
66A2  0101     MOVLB 0x1
66A4  694A     SETF cSk, BANKED
529:                           if((FRL1.PCI_FCOUNT.war+1<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war+1<FRL1.imax))
66A6  0E01     MOVLW 0x1
66A8  D863     RCALL __end_of_LIN1SInterpreterCF_RD
66AA  E30F     BNC 0x66CA
66AC  29C0     INCF 0xC0, W, BANKED
66AE  6F80     MOVWF _PFNf_set_nco, BANKED
66B0  0E00     MOVLW 0x0
66B2  21C1     ADDWFC 0xC1, W, BANKED
66B4  6F81     MOVWF _PFNf_set_ncw, BANKED
66B6  51CA     MOVF 0xCA, W, BANKED
66B8  5D80     SUBWF _PFNf_set_nco, W, BANKED
66BA  51CB     MOVF 0xCB, W, BANKED
66BC  5981     SUBWFB _PFNf_set_ncw, W, BANKED
66BE  E205     BC 0x66CA
530:                           FTL1.WRD0.byte1=FRL1.tab[FRL1.PCI_FCOUNT.war+1];
66C0  D873     RCALL PL152
66C2  2980     INCF _PFNf_set_nco, W, BANKED
66C4  D86A     RCALL PL150
66C6  6F4B     MOVWF 0x4B, BANKED
66C8  D002     BRA 0x66CE
531:                           else FTL1.WRD0.byte1=0xFF;
66CA  0101     MOVLB 0x1
66CC  694B     SETF 0x4B, BANKED
532:                           if((FRL1.PCI_FCOUNT.war+2<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war+2<FRL1.imax))
66CE  0E02     MOVLW 0x2
66D0  D84F     RCALL __end_of_LIN1SInterpreterCF_RD
66D2  E309     BNC 0x66E6
66D4  0E02     MOVLW 0x2
66D6  D857     RCALL PL70
66D8  E206     BC 0x66E6
66DA  D866     RCALL PL152
533:                           FTL1.WRD1.byte0=FRL1.tab[FRL1.PCI_FCOUNT.war+2];
66DC  0E02     MOVLW 0x2
66DE  2580     ADDWF _PFNf_set_nco, W, BANKED
66E0  D85C     RCALL PL150
66E2  6F4C     MOVWF 0x4C, BANKED
66E4  D002     BRA 0x66EA
534:                           else FTL1.WRD1.byte0=0xFF;
66E6  0101     MOVLB 0x1
66E8  694C     SETF 0x4C, BANKED
535:                           if((FRL1.PCI_FCOUNT.war+3<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war+3<FRL1.imax))
66EA  0E03     MOVLW 0x3
66EC  D841     RCALL __end_of_LIN1SInterpreterCF_RD
66EE  E309     BNC 0x6702
66F0  0E03     MOVLW 0x3
66F2  D849     RCALL PL70
66F4  E206     BC 0x6702
66F6  D858     RCALL PL152
536:                           FTL1.WRD1.byte1=FRL1.tab[FRL1.PCI_FCOUNT.war+3];
66F8  0E03     MOVLW 0x3
66FA  2580     ADDWF _PFNf_set_nco, W, BANKED
66FC  D84E     RCALL PL150
66FE  6F4D     MOVWF 0x4D, BANKED
6700  D002     BRA 0x6706
537:                           else FTL1.WRD1.byte1=0xFF;
6702  0101     MOVLB 0x1
6704  694D     SETF 0x4D, BANKED
538:                           if((FRL1.PCI_FCOUNT.war+4<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war+4<FRL1.imax))
6706  0E04     MOVLW 0x4
6708  D833     RCALL __end_of_LIN1SInterpreterCF_RD
670A  E309     BNC 0x671E
670C  0E04     MOVLW 0x4
670E  D83B     RCALL PL70
6710  E206     BC 0x671E
6712  D84A     RCALL PL152
539:                           FTL1.WRD2.byte0=FRL1.tab[FRL1.PCI_FCOUNT.war+4];
6714  0E04     MOVLW 0x4
6716  2580     ADDWF _PFNf_set_nco, W, BANKED
6718  D840     RCALL PL150
671A  6F4E     MOVWF 0x4E, BANKED
671C  D002     BRA 0x6722
540:                           else FTL1.WRD2.byte0=0xFF;
671E  0101     MOVLB 0x1
6720  694E     SETF 0x4E, BANKED
541:                           if((FRL1.PCI_FCOUNT.war+5<=FRL1.STOP.war)&&(FRL1.PCI_FCOUNT.war+5<FRL1.imax))
6722  0E05     MOVLW 0x5
6724  D825     RCALL __end_of_LIN1SInterpreterCF_RD
6726  E309     BNC 0x673A
6728  0E05     MOVLW 0x5
672A  D82D     RCALL PL70
672C  E206     BC 0x673A
672E  D83C     RCALL PL152
542:                           FTL1.WRD2.byte1=FRL1.tab[FRL1.PCI_FCOUNT.war+5];
6730  0E05     MOVLW 0x5
6732  2580     ADDWF _PFNf_set_nco, W, BANKED
6734  D832     RCALL PL150
6736  6F4F     MOVWF 0x4F, BANKED
6738  D78A     BRA 0x664E
543:                           else FTL1.WRD2.byte1=0xFF;
673A  0101     MOVLB 0x1
673C  694F     SETF 0x4F, BANKED
673E  D787     BRA 0x664E
544:                       }
545:                       else        //Wyslij do MASTER sume kontrolna dla przeslanych wczesniej danych
546:                       {
547:                           FTL1.PCI_LENGTH=0x03;                                                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
6740  0E03     MOVLW 0x3
6742  ECEC     CALL 0x31D8, 0
6744  F018     NOP
548:                           FTL1.WRD0.byte0=0xB2+0x40;                                                          //RSID=SID+0x40
549:                           if(!FRL1f_RSFrame)
6746  B002     BTFSC LIN1f_Busy, 0, ACCESS
6748  D003     BRA 0x6750
550:                           {                
551:                               FTL1.WRD0.byte1=FRL1.IDN;                                                       //Identyfikator tablicy danych
674A  C0B5     MOVFF 0xB5, 0x14B
674C  F14B     NOP
552:                           }
674E  D002     BRA 0x6754
553:                           else
554:                           {
555:                               FTL1.WRD0.byte1=FRL1.RS_IDN;                                                    //Identyfikator tablicy danych
6750  C0B9     MOVFF 0xB9, 0x14B
6752  F14B     NOP
556:                           }
557:                           FTL1.WRD1.byte0=CalcTabCHK(FRL1.tab,FRL1.START.war,FRL1.STOP.war);                  //CHK dla tablicy danych w zakresie start-stop
6754  D830     RCALL PL248
6756  EC59     CALL 0xAAB2, 0
6758  F055     NOP
675A  0101     MOVLB 0x1
675C  6F4C     MOVWF 0x4C, BANKED
675E  D777     BRA 0x664E
558:                       }
559:                       break;
560:                   }
561:                   default:    //nie odpowiadaj gdy niewlasciwe SID
562:                   {
563:                       LIN1ERR.USID=1;
6760  8BD8     BSF 0xD8, 5, BANKED
6762  D774     BRA 0x664C
6764  0100     MOVLB 0x0
6766  51B4     MOVF 0xB4, W, BANKED
6768  0AB2     XORLW 0xB2
676A  E101     BNZ 0x676E
676C  D76D     BRA 0x6648
676E  D7F8     BRA 0x6760
564:                       FTL1f_NoResp=1;
565:                       return 1;
566:                   }
567:               }
568:               return 1;
569:           }
570:           //---------------------------------------------------------------------------------
571:           //Przygotowanie odpowiedzi negatywnej (RSID=0x7F)
572:           void LIN1NegativeResponse(unsigned char kod, unsigned char npar, unsigned char par1, unsigned char par2)
AED4  6F77     MOVWF _PFNf_prn_pg, BANKED
573:           {
574:               switch(npar)
AED6  D00F     BRA 0xAEF6
AEF6  0100     MOVLB 0x0
575:               {
576:                   case 0:
577:                   {
578:                       FTL1.PCI_LENGTH=0x03;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
AED8  0E03     MOVLW 0x3
AEDA  D815     RCALL PL204
579:                       FTL1.WRD0.byte0=0x7F;                   //NEG RESP
580:                       FTL1.WRD0.byte1=0xB2;                   //SID
581:                       FTL1.WRD1.byte0=kod;                    //kod bledu
582:                       break;
AEDC  0CB2     RETLW 0xB2
583:                   }
584:                   case 1:
585:                   {
586:                       FTL1.PCI_LENGTH=0x04;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
AEDE  0E04     MOVLW 0x4
AEE0  D812     RCALL PL204
587:                       FTL1.WRD0.byte0=0x7F;                   //NEG RESP
588:                       FTL1.WRD0.byte1=0xB2;                   //SID
589:                       FTL1.WRD1.byte0=kod;                    //kod bledu
590:                       FTL1.WRD1.byte1=par1;                   //parametr pierwszy
AEE2  C075     MOVFF _PFNf_prn_cs, 0x14D
AEE4  F14D     NOP
591:                       break;
AEE6  0CB2     RETLW 0xB2
592:                   }
593:                   case 2:
594:                   {
595:                       FTL1.PCI_LENGTH=0x05;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
AEE8  0E05     MOVLW 0x5
AEEA  D80D     RCALL PL204
596:                       FTL1.WRD0.byte0=0x7F;                   //NEG RESP
597:                       FTL1.WRD0.byte1=0xB2;                   //SID
598:                       FTL1.WRD1.byte0=kod;                    //kod bledu
599:                       FTL1.WRD1.byte1=par1;                   //parametr pierwszy
AEEC  C075     MOVFF _PFNf_prn_cs, 0x14D
AEEE  F14D     NOP
600:                       FTL1.WRD2.byte0=par2;                   //parametr drugi
AEF0  C076     MOVFF _PFNf_prn_in, 0x14E
AEF2  F14E     NOP
601:                       break;
AEF4  0CB2     RETLW 0xB2
AEF6  0100     MOVLB 0x0
AEF8  5174     MOVF _PFNf_prODP, W, BANKED
AEFA  E0EE     BZ 0xAED8
AEFC  0A01     XORLW 0x1
AEFE  E0EF     BZ 0xAEDE
AF00  0A03     XORLW 0x3
AF02  E0F2     BZ 0xAEE8
AF04  D7E9     BRA 0xAED8
602:                   }
603:                   default:
604:                   {
605:                       FTL1.PCI_LENGTH=0x03;                   //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
606:                       FTL1.WRD0.byte0=0x7F;                   //NEG RESP
607:                       FTL1.WRD0.byte1=0xB2;                   //SID
608:                       FTL1.WRD1.byte0=kod;                    //kod bledu
609:                   }
610:               }
611:           }
612:           //---------------------------------------------------------------------------------
613:           //Reakcja na otrzymana paczke danych, decyzja odpowiedzi
614:           //Gdzie zwrocone: 0-oczekiwanie na zakonczenie procesu, 1-gotowa odpowiedz, 2-brak odpowiedzi
615:           unsigned char SetLIN1SData(void)
616:           {
617:           //----------------------------------------------------------------------------
618:           //Analiza odebranej i wstepnie zweryfikowanej paczki, reakcja.
619:           //GDZIE:
620:           //      FRL1.PIF.war                                            //protected idetifier
621:           //      FRL1.PCI_TYPE                                           //Rodzaj ramki
622:           //      FRL1.PCI_LENGTH                                         //Rozmiar ramki(SID+liczba bajtow danych+CHK)
623:           //      FRL1.WRD0.byte0                                         //SID
624:           //      FRL1.WRD0.byte1                                         //DTA1
625:           //      FRL1.WRD1.byte0                                         //DTA2
626:           //      FRL1.WRD1.byte1                                         //DTA3
627:           //      FRL1.WRD2.byte0                                         //DTA4
628:           //      FRL1.WRD2.byte1                                         //DTA5
629:           //      FRL1.SID
630:           //      FRL1.IDN
631:                   switch(FRL1.PIF.war&0b00111111)
9796  D032     BRA 0x97FC
97FC  0100     MOVLB 0x0
97FE  51AE     MOVF FRL1, W, BANKED
9800  0B3F     ANDLW 0x3F
9802  6FA6     MOVWF sign, BANKED
9804  6BA7     CLRF x, BANKED
9806  51A7     MOVF x, W, BANKED
9808  E1F6     BNZ 0x97F6
980A  51A6     MOVF sign, W, BANKED
980C  0A01     XORLW 0x1
980E  E0CE     BZ 0x97AC
9810  0A03     XORLW 0x3
9812  E0E4     BZ 0x97DC
9814  D7F0     BRA 0x97F6
632:                   {
633:                       case _PIF_WRITE:                      //PIF (write param, execute)
634:                       {
635:                           switch(FRL1.PCI_TYPE)       //PCI
97AC  51B1     MOVF 0xB1, W, BANKED
97AE  E0F4     BZ 0x9798
97B0  0A10     XORLW 0x10
97B2  E0F6     BZ 0x97A0
97B4  0A30     XORLW 0x30
97B6  E0F7     BZ 0x97A6
97B8  0A10     XORLW 0x10
97BA  E0EE     BZ 0x9798
97BC  0A70     XORLW 0x70
97BE  E0F0     BZ 0x97A0
97C0  0A10     XORLW 0x10
97C2  E0F1     BZ 0x97A6
97C4  D009     BRA 0x97D8
636:                           {
637:                               case _PCI_TESF1:
638:                               case _PCI_TSF1:
639:                               {
640:                                   //Przetwarzanie danych SF
641:                                   if(!LIN1SInterpreterSF_WR()) return 0;                              //czekaj az dane zostana przetworzone
9798  ECA3     CALL 0x9346, 0
979A  F049     NOP
979C  E23C     BC 0x9816
979E  0C00     RETLW 0x0
642:                                   break;
643:                               }
644:                               case _PCI_TEFF1:
645:                               case _PCI_TFF1:
646:                               {
647:                                   //Przetwarzanie danych FF
648:                                   if(!LIN1SInterpreterFF()) return 0;                              //czekaj az dane zostana przetworzone
97A0  EC6B     CALL 0x6AD6, 0
97A2  F035     NOP
97A4  D7FB     BRA 0x979C
649:                                   break;
650:                               }
651:                               case _PCI_TECF1:
652:                               case _PCI_TCF1:
653:                               {
654:                                   //Przetwarzanie danych CF
655:                                   if(!LIN1SInterpreterCF_WR()) return 0;                              //czekaj az dane zostana przetworzone
97A6  ECD0     CALL 0x6DA0, 0
97A8  F036     NOP
97AA  D7F8     BRA 0x979C
656:                                   break;
657:                               }
658:                               default:
659:                               {
660:                                   LIN1ERR.PCI_TYPE=1;
661:                                   FTL1f_NoResp=1;
662:                                   break;
663:                               }
664:                           }
665:                           break;
666:                       }
667:                       case _PIF_READ:                      //PIF (read param)
668:                       {
669:                           switch(FRL1.PCI_TYPE)       //PCI
97DC  51B1     MOVF 0xB1, W, BANKED
97DE  E0F3     BZ 0x97C6
97E0  0A10     XORLW 0x10
97E2  E0F4     BZ 0x97CC
97E4  0A30     XORLW 0x30
97E6  E0F5     BZ 0x97D2
97E8  0A10     XORLW 0x10
97EA  E0ED     BZ 0x97C6
97EC  0A70     XORLW 0x70
97EE  E0EE     BZ 0x97CC
97F0  0A10     XORLW 0x10
97F2  E0EF     BZ 0x97D2
97F4  D7F1     BRA 0x97D8
670:                           {
671:                               case _PCI_TESF1:
672:                               case _PCI_TSF1:
673:                               {
674:                                   //Przetwarzanie danych SF
675:                                   if(!LIN1SInterpreterSF_RD()) return 0;                              //czekaj az dane zostana przetworzone
97C6  ECEC     CALL 0x8DD8, 0
97C8  F046     NOP
97CA  D7E8     BRA 0x979C
676:                                   break;
677:                               }
678:                               case _PCI_TEFF1:
679:                               case _PCI_TFF1:
680:                               {
681:                                   //Przetwarzanie danych FF
682:                                   if(!LIN1SInterpreterFF()) return 0;                              //czekaj az dane zostana przetworzone
97CC  EC6B     CALL 0x6AD6, 0
97CE  F035     NOP
97D0  D7E5     BRA 0x979C
683:                                   break;
684:                               }
685:                               case _PCI_TECF1:
686:                               case _PCI_TCF1:
687:                               {
688:                                   //Przetwarzanie danych CF
689:                                   if(!LIN1SInterpreterCF_RD()) return 0;                              //czekaj az dane zostana przetworzone
97D2  EC23     CALL 0x6646, 0
97D4  F033     NOP
97D6  D7E2     BRA 0x979C
690:                                   break;
691:                               }
692:                               default:
693:                               {
694:                                   LIN1ERR.PCI_TYPE=1;
97D8  89D7     BSF LIN1ERR, 4, BANKED
97DA  D00E     BRA 0x97F8
695:                                   FTL1f_NoResp=1;
696:                                   break;
697:                               }
698:                           }
699:                           break;
700:                       }
701:                       default:
702:                       {
703:                           LIN1ERR.UPIF=1;
97F6  8DD8     BSF 0xD8, 6, BANKED
704:                           FTL1f_NoResp=1;
97F8  8602     BSF LIN1f_Busy, 3, ACCESS
705:                           break;
97FA  D00D     BRA 0x9816
706:                       }
707:                   }
708:           //----------------------------------------------------------------------------
709:           //Odpowiedz (rezygnacja z odpowiedzi za pomoca FTL1f_NoResp=1)
710:                   if(FTL1f_NoResp) return 2;                               //brak odpowiedzi
9816  B602     BTFSC LIN1f_Busy, 3, ACCESS
9818  0C02     RETLW 0x2
711:                   else return 1;                                          //paczka odpowiedzi gotowa
712:           }
981A  0C01     RETLW 0x1
713:           /*---------------------------------------------------------------------------------*/
714:           /*---------------------------------------------------------------------------------*/
715:           /*-----------------------------ROTECTED DATA-----------------------------------------*/
716:           //Inicjalizacja UART
717:           void InitUart1(void)
718:           {
719:               //unsigned char rc;
720:               //6 wyjscie portu C ustawic jako wyjscie (0)
721:               //7 wyjscie portu C ustawic jako wejscie (1)
722:               U1OD=0;                  //wyjscie z podparciem
A42C  9C8F     BCF LATG, 6, ACCESS
723:               TXSTA1bits.CSRC=0;			//asynch mode
A42E  9EAC     BCF TXSTA1, 7, ACCESS
724:               RCSTA1bits.RX9=0;			//odbior 8 bitowy
A430  9CAB     BCF RCSTA1, 6, ACCESS
725:               BAUDCON1bits.BRG16=_BRG16;          //rozdzielczosc SPBRG1
A432  867E     BSF BAUDCON1, 3, ACCESS
726:           #if _BRG16==0
727:               SPBRG1=0x00FF&_SPBRG;                      //baud rate
728:               SPBRGH1=0;
729:           #else
730:               SPBRG1=0x00FF&_SPBRG;
A434  0E40     MOVLW 0x40
A436  6EAF     MOVWF SPBRG1, ACCESS
731:               SPBRGH1=(0xFF00&_SPBRG)>>8;
A438  0E03     MOVLW 0x3
A43A  6E7F     MOVWF SPBRGH1, ACCESS
732:           #endif
733:               TXSTA1bits.SYNC=_SYNC;		//tryb asynchroniczny/synchroniczny
A43C  98AC     BCF TXSTA1, 4, ACCESS
734:               TXSTA1bits.BRGH=_BRGH;		//predkosc generatora Baud Rate
A43E  84AC     BSF TXSTA1, 2, ACCESS
735:               RCSTA1bits.ADDEN=0;                 //bez adresowania
A440  96AB     BCF RCSTA1, 3, ACCESS
736:               TXSTA1bits.TX9=0;			//nadawanie 8 bitowe
A442  9CAC     BCF TXSTA1, 6, ACCESS
737:               IPR1bits.RC1IP=1;			//wysoki priorytet przerwania
A444  8A9F     BSF IPR1, 5, ACCESS
738:               IPR1bits.TX1IP=1;			//wysoki priorytet przerwania
A446  889F     BSF IPR1, 4, ACCESS
739:               PIE1bits.RC1IE=0;			//nieaktywne przerwanie dla odbioru
A448  9A9D     BCF PIE1, 5, ACCESS
740:               PIE1bits.TX1IE=0;			//nieaktywne przerwanie dla odbioru
A44A  989D     BCF PIE1, 4, ACCESS
741:           
742:               BAUDCON1bits.TXCKP=0;
A44C  987E     BCF BAUDCON1, 4, ACCESS
743:               TXSTA1bits.TXEN=0;			//deaktywacja modulu transmisji
A44E  9AAC     BCF TXSTA1, 5, ACCESS
744:               RCSTA1bits.SPEN=0;			//deaktywacja portu szeregowego
A450  9EAB     BCF RCSTA1, 7, ACCESS
745:               RCSTA1bits.CREN=0;			//deaktywacja odbioru
A452  98AB     BCF RCSTA1, 4, ACCESS
746:           
747:               UAD1tf_RFData=0;
A454  9013     BCF UAD1tf_RFData, 0, ACCESS
748:               UAD1tf_RFBrSn=0;
A456  9E12     BCF RSDT1f_RD_STD, 7, ACCESS
749:               UAD1tf_RFEnd=0;
A458  9213     BCF UAD1tf_RFData, 1, ACCESS
750:               UAD1tf_RFExt=0;
A45A  9413     BCF UAD1tf_RFData, 2, ACCESS
751:           
752:               UAD1tf_TFData=0;
A45C  9613     BCF UAD1tf_RFData, 3, ACCESS
753:               UAD1tf_TFEnd=0;
A45E  9813     BCF UAD1tf_RFData, 4, ACCESS
754:           
755:               UAD1t.Rindeks=0;
A460  6B92     CLRF _RSDT1f_RD_LIN, BANKED
756:               UAD1t.Tindeks=0;
A462  6B93     CLRF _RSDT1f_RD_STD, BANKED
757:               UAD1t.RNData=0;
A464  6B94     CLRF _RSDT1f_RRD_KNF, BANKED
758:               UAD1t.TNData=0;
A466  6B95     CLRF _RSDT1f_RRD_STD, BANKED
759:               UAD1t.tmFR=0;
A468  ECB4     CALL 0xBF68, 0
A46A  F05F     NOP
760:               UAD1t.tmB=0;   
761:           
762:               LIN1f_Busy=0;
A46C  9A02     BCF LIN1f_Busy, 5, ACCESS
763:               LIN1f_FAdta=0;
A46E  9003     BCF LIN1f_NDTA, 0, ACCESS
764:               LIN1f_FResp=0;
A470  9403     BCF LIN1f_NDTA, 2, ACCESS
765:               LIN1f_FTrans=0;
A472  9603     BCF LIN1f_NDTA, 3, ACCESS
766:               LIN1f_NDTA=0;
A474  9803     BCF LIN1f_NDTA, 4, ACCESS
767:               LIN1.State=0;
A476  6BA0     CLRF _UADtf_RErrBUF, BANKED
768:               LIN1.tmAd=0;
A478  EC7E     CALL 0xBCFC, 0
A47A  F05E     NOP
769:               LIN1.tmZw=0;    
770:               LIN1f_FIN=0;
A47C  EC89     CALL 0x7B12, 0
A47E  F03D     NOP
771:               LIN1f_ERRR=0;
772:               LIN1f_ACK=0;
773:               LIN1f_SCS=0;
774:               LIN1f_CHK=0;
A480  9C02     BCF LIN1f_Busy, 6, ACCESS
775:               LIN1ERR.wrd=0;
A482  0100     MOVLB 0x0
A484  6BD7     CLRF LIN1ERR, BANKED
A486  6BD8     CLRF 0xD8, BANKED
776:           
777:               RSerial1=RCREG1;
A488  CFAE     MOVFF RCREG1, RSerial1
A48A  F0DF     NOP
778:               ResetRC1TX1();                      //wylacz nadajnik/odbiornik
A48C  EC74     CALL 0xBCE8, 0
A48E  F05E     NOP
779:               LIN1f_NDTA=1;                        //aktywacja oczekiwania na paczke danych
A490  8803     BSF LIN1f_NDTA, 4, ACCESS
780:           }
A492  0012     RETURN 0
781:           
782:           //---------------------------------------------------------------------------------
783:           //Wlacz caly 1 port szeregowy
784:           void Serial1ON(void)
785:           {
786:               RCSTA1bits.SPEN=1;			//aktywacja portu szeregowego
C286  8EAB     BSF RCSTA1, 7, ACCESS
787:           }
C288  0012     RETURN 0
788:           //Wylacz caly 1 port szeregowy
789:           void Serial1OFF(void)
790:           {
791:               RCSTA1bits.SPEN=0;			//deaktywacja portu szeregowego
C28A  9EAB     BCF RCSTA1, 7, ACCESS
792:           }
C28C  0012     RETURN 0
793:           //Wylacz modul 1  odbioru
794:           void ReaderRX1ON(void)
795:           {
796:               UAD1tf_RFBrSn = 0;                    //restartuj znacznik oczekiwania na BREAk SYNCH
C160  9E12     BCF RSDT1f_RD_STD, 7, ACCESS
797:           #if _RBREAK_SYNCH1==2
798:               BAUDCON1bits.WUE=1;                 //oczekiwanie na BREAK
C162  827E     BSF BAUDCON1, 1, ACCESS
799:               BAUDCON1bits.ABDEN=1;               //AUTOBAUD
C164  807E     BSF BAUDCON1, 0, ACCESS
800:               //BAUDCON1bits.BRG16=_BRG16;
801:           #else
802:               #if _RBREAK_SYNCH1==1
803:                   BAUDCON1bits.WUE=1;             //oczekiwanie na BREAK
804:               #endif
805:           #endif
806:               RCSTA1bits.CREN = 1;		//aktywacja portu szeregowego
C166  88AB     BSF RCSTA1, 4, ACCESS
807:               PIE1bits.RC1IE=1;                   //aktywacja przerwania odbioru
C168  8A9D     BSF PIE1, 5, ACCESS
808:           }
C16A  0012     RETURN 0
809:           //Wlacz modul 1  odbioru
810:           void ReaderRX1OFF(void)
C1FE  D000     BRA PL794
811:           {
812:               RCSTA1bits.CREN = 0;		//deaktywacja portu szeregowego
813:               PIE1bits.RC1IE=0;                   //deaktywacja przerwania odbioru
814:           }
815:           //---------------------------------------------------------------------------------
816:           //Wlacz modul 1 transmisji
817:           void TransmiterTX1ON(void)
818:           {
819:               TXSTA1bits.TXEN=1;			//aktywacja modulu transmisji
C266  8AAC     BSF TXSTA1, 5, ACCESS
820:               PIE1bits.TX1IE=1;
C268  889D     BSF PIE1, 4, ACCESS
821:           }
C26A  0012     RETURN 0
822:           //Wylacz modul 1 transmisji
823:           void TransmiterTX1OFF(void)
824:           {
825:               TXSTA1bits.TXEN=0;			//deaktywacja modulu transmisji
C260  9AAC     BCF TXSTA1, 5, ACCESS
826:               PIE1bits.TX1IE=0;                             //deaktywacja przerwania transmisji
C262  989D     BCF PIE1, 4, ACCESS
827:           }
C264  0012     RETURN 0
828:           //---------------------------------------------------------------------------------
829:           //Aktywuj tryb transmisji BREAK z  synchronizacja
830:           void SetTX1BreakSynch(void)
831:           {
832:               TXSTA1bits.SENDB=1;                 //pierwszy bajt BREAK 0x000
833:               TXREG1=0x00;                         //BREAK - wartosc ignorowana
834:               TXREG1=0x55;                         //bajt synchronizacji 0x55 (na optrzeby autobaudrate)
835:           }
836:           //Aktywuj tryb transmisji BREAK bez bajtu synchronizacji
837:           void SetTX1Break(void)
838:           {
839:               TXSTA1bits.SENDB=1;                 //pierwszy bajt BREAK 0x000
840:               TXREG1=0x00;                         //BREAK - wartosc ignorowana
841:           }
842:           //---------------------------------------------------------------------------------
843:           //Przelacz uklad LIN w tryb Odbioru
844:           void SetLIN1_TOFF_Mode(void)
845:           {
846:               //RC2=0;                              //CS=0
847:               //LATC2=0;
848:               _CS_LIN1=0;
849:               dly=_CS1_DELAY;
850:               while(--dly);
851:               //ustaw TXD=0
852:               //RC6=0;
853:               //LATC6=0;                            //TXD=0
854:               _TXD1=0;
855:               Nop();
856:               Nop();
857:               Nop();
858:               Nop();
859:               Nop();
860:               Nop();
861:               Nop();
862:               Nop();
863:               //Przejscie do TOFF
864:               //RC2=1;                              //CS=1
865:               _CS_LIN1=1;
866:               dly=_CS1_DELAY;
867:               while(--dly);
868:               LIN1.State=_TOFF_MODE1;
869:           }
870:           //Przelacz uklad LIN w tryb wylaczenia
871:           void SetLIN1_PWRD_Mode(void)
872:           {
873:               //RC6=0;
874:               //LATC6=0;                            //TXD=0
875:               _TXD1=0;
876:               Nop();
877:               Nop();
878:               Nop();
879:               Nop();
880:               Nop();
881:               Nop();
882:               Nop();
883:               Nop();
884:               //Przejscie do TOFF
885:               //RC2=1;                              //CS=1
886:               _CS_LIN1=1;
887:               dly=_CS1_DELAY;
888:               while(--dly);
889:               //przejscie do POWER DOWN
890:               //RC2=0;                              //CS=0
891:               //LATC2=0;
892:               _CS_LIN1=0;
893:               dly=_CS1_DELAY;
894:               while(--dly);
895:               LIN1.State=_PWRD_MODE1;
896:           }
897:           //Przelacz uklad LIN w tryb Nadawania
898:           void SetLIN1_OPER_Mode(void)
899:           {
900:               //RC6=1;                               //TXD=1
901:               _TXD1=1;
BB12  8C8B     BSF LATC, 6, ACCESS
902:               Nop();
BB14  F000     NOP
903:               Nop();
BB16  F000     NOP
904:               Nop();
BB18  F000     NOP
905:               Nop();
BB1A  F000     NOP
906:               Nop();
BB1C  F000     NOP
907:               Nop();
BB1E  F000     NOP
908:               Nop();
BB20  F000     NOP
909:               Nop();
BB22  F000     NOP
910:           
911:               //Przejscie do Operation mode
912:               //RC2=1;                              //CS=1
913:               _CS_LIN1=1;
BB24  848B     BSF LATC, 2, ACCESS
914:               dly=_CS1_DELAY;
BB26  0E64     MOVLW 0x64
BB28  0101     MOVLB 0x1
BB2A  6FCD     MOVWF 0xCD, BANKED
915:               while(--dly);
BB2C  2FCD     DECFSZ 0xCD, F, BANKED
BB2E  D7FE     BRA 0xBB2C
916:               LIN1.State=_OPER_MODE1;
BB30  0E02     MOVLW 0x2
BB32  6FA0     MOVWF _UADtf_RErrBUF, BANKED
917:           }
BB34  0C02     RETLW 0x2
918:           //------------------------------------------------------------------------------------
919:           //---------------------------------------------------------------------
920:           //Wyzwolenie transmisji na linii LIN1
921:           bit StartLIN1TR(void)
922:           {
923:               if(!TXSTA1bits.TRMT||!BAUDCON1bits.RCIDL) return 0;       //PIE1bits.TX1IE||trwa transmisja lub odbior danych?
B3B2  A2AC     BTFSS TXSTA1, 1, ACCESS
B3B4  D002     BRA 0xB3BA
B3B6  BC7E     BTFSC BAUDCON1, 6, ACCESS
B3B8  D002     BRA 0xB3BE
B3BA  90D8     BCF STATUS, 0, ACCESS
B3BC  0012     RETURN 0
924:               if(UAD1t.TNData>_NRS_TBF1) UAD1t.TNData=_NRS_TBF1;          //kontrola rozmiaru tablicy
B3BE  0E0F     MOVLW 0xF
B3C0  0101     MOVLB 0x1
B3C2  6595     CPFSGT _RSDT1f_RRD_STD, BANKED
B3C4  D001     BRA 0xB3C8
B3C6  6F95     MOVWF _RSDT1f_RRD_STD, BANKED
925:           
926:               UAD1t.Tindeks=0;                                         //indeks = 0 - pierwszy bajt oznaczony jako adres
B3C8  6B93     CLRF _RSDT1f_RD_STD, BANKED
927:               UAD1tf_TFEnd=0;                                           //wyzeruj znacznik konca nadawania ramki
B3CA  9813     BCF UAD1tf_RFData, 4, ACCESS
928:               //--------------------
929:               //konfiguracja LIN(MCP2003) do transmisji
930:               ReaderRX1OFF();                                         //wylacz odbiornik
B3CC  ECFF     CALL 0xC1FE, 0
B3CE  F060     NOP
931:               Serial1OFF();                                           //wylacz modul serial1
B3D0  EC45     CALL 0xC28A, 0
B3D2  F061     NOP
932:               SetLIN1_OPER_Mode();                                    //konfiguruj uklad LIN w tryb nadawania
B3D4  EC89     CALL 0xBB12, 0
B3D6  F05D     NOP
933:               Serial1ON();                                            //wlacz modul serial1
B3D8  EC43     CALL 0xC286, 0
B3DA  F061     NOP
934:               //--------------------
935:               TransmiterTX1ON();                                      //uruchom transmisje
B3DC  EC33     CALL 0xC266, 0
B3DE  F061     NOP
936:               UAD1t.tmFR=0;                                            //restart timera ramki
B3E0  0101     MOVLB 0x1
B3E2  6B96     CLRF _RSDT1f_RespLIDN, BANKED
B3E4  6B97     CLRF _UAD1tf_RFBrSn, BANKED
937:               //--------------------
938:               return 1;
B3E6  80D8     BSF STATUS, 0, ACCESS
939:           }
B3E8  0012     RETURN 0
940:           //Deaktywacja modulu odbioru danych
941:           //---------------------------------------------------------------------
942:           void StopLIN1TR(void)
943:           {
944:               TransmiterTX1OFF();                                     //zatrzymaj transmisje
BECE  EC30     CALL 0xC260, 0
BED0  F061     NOP
945:              //--------------------
946:               //konfiguracja LIN(MCP2003) do transmisji
947:           
948:               Serial1OFF();                                           //wylacz modul serial1**********
BED2  EC45     CALL 0xC28A, 0
BED4  F061     NOP
949:           
950:               //dly=_CS1_DELAY;
951:               //while(--dly);
952:               //SetLIN1_TOFF_Mode();                                    //konfiguruj uklad LIN1 w tryb odbioru
953:               Serial1ON();                                            //wlacz modul serial1*********
BED6  EC43     CALL 0xC286, 0
BED8  F061     NOP
954:               UAD1tf_TFData = 0;                                        //usun znacznik transmisji danych
BEDA  9613     BCF UAD1tf_RFData, 3, ACCESS
955:               UAD1tf_TFEnd = 0;                                         //wyzeruj znacznik konca odbioru
BEDC  9813     BCF UAD1tf_RFData, 4, ACCESS
956:               UAD1t.tmFR=0;
BEDE  0101     MOVLB 0x1
BEE0  6B96     CLRF _RSDT1f_RespLIDN, BANKED
BEE2  6B97     CLRF _UAD1tf_RFBrSn, BANKED
957:           }
BEE4  0012     RETURN 0
958:           //------------------------------------------------------------------------------------
959:           //--------------------------------------------------------------------------
960:           //--------------------------------------------------------------------------
961:           //Zakonczenie odbioru linii LIN1
962:           void StopLIN1RC(void)
963:           {
964:               ReaderRX1OFF();                                          //zatrzymaj odbior
BF5C  ECFF     CALL 0xC1FE, 0
BF5E  F060     NOP
965:               UAD1tf_RFData = 0;                                         //usun znacznik odbioru danych
BF60  9013     BCF UAD1tf_RFData, 0, ACCESS
966:               UAD1tf_RFEnd = 0;                                          //wyzeruj znacznik konca odbioru
BF62  9213     BCF UAD1tf_RFData, 1, ACCESS
967:               UAD1tf_RFExt = 0;
BF64  9413     BCF UAD1tf_RFData, 2, ACCESS
BF66  D000     BRA PL740
968:               UAD1t.tmFR=0;
969:               UAD1t.tmB=0;
970:           }
971:           //-------------------------------------------------------------------
972:           //Zakonczenie transmisji/odbioru
973:           void ResetRC1TX1(void)
974:           {
975:              LIN1f_Busy=0;
BCE8  9A02     BCF LIN1f_Busy, 5, ACCESS
976:              LIN1f_FResp=0;
BCEA  9403     BCF LIN1f_NDTA, 2, ACCESS
977:              LIN1f_FTrans=0;
BCEC  9603     BCF LIN1f_NDTA, 3, ACCESS
978:              LIN1f_FAdta=0;
BCEE  9003     BCF LIN1f_NDTA, 0, ACCESS
979:              LIN1.tmAd=0;
BCF0  0101     MOVLB 0x1
BCF2  D804     RCALL PL544
980:              LIN1.tmZw=0;   
981:              StopLIN1RC();
BCF4  ECAE     CALL 0xBF5C, 0
BCF6  F05F     NOP
982:              StopLIN1TR();
BCF8  EF67     GOTO 0xBECE
BCFA  F05F     NOP
983:           }
984:           //-------------------------------------------------------------------
985:           //Ustaw podstawowe znaczniki danych 
986:           void LIN1RefStat(void)
987:           {
988:               LIN1f_Busy=0;
B9B4  9A02     BCF LIN1f_Busy, 5, ACCESS
989:               LIN1f_NDTA=0;         
B9B6  9803     BCF LIN1f_NDTA, 4, ACCESS
990:               LIN1f_FIN=1;          //zakonczono odbior/transmisje
B9B8  8203     BSF LIN1f_NDTA, 1, ACCESS
991:               if(LIN1ERR.wrd)
B9BA  0100     MOVLB 0x0
B9BC  51D7     MOVF LIN1ERR, W, BANKED
B9BE  11D8     IORWF 0xD8, W, BANKED
B9C0  E004     BZ 0xB9CA
992:               {
993:                   LIN1f_ERRR=1;
B9C2  8E02     BSF LIN1f_Busy, 7, ACCESS
994:                   LIN1f_ACK=0;
B9C4  9802     BCF LIN1f_Busy, 4, ACCESS
995:                   LIN1f_SCS=0;
B9C6  9A03     BCF LIN1f_NDTA, 5, ACCESS
996:               }
B9C8  0012     RETURN 0
997:               else
998:               {
999:                   LIN1f_ERRR=0;
B9CA  9E02     BCF LIN1f_Busy, 7, ACCESS
1000:                  if(FRL1f_NoResp)
B9CC  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
B9CE  D003     BRA 0xB9D6
1001:                  {
1002:                      LIN1f_ACK=0;
B9D0  9802     BCF LIN1f_Busy, 4, ACCESS
1003:                      LIN1f_SCS=1;     //sukces bez potwierdzenia
B9D2  8A03     BSF LIN1f_NDTA, 5, ACCESS
1004:                  }
B9D4  0012     RETURN 0
1005:                  else
1006:                  {
1007:                      LIN1f_ACK=1;
B9D6  8802     BSF LIN1f_Busy, 4, ACCESS
1008:                      LIN1f_SCS=1;     //sukces z potwierdzeniem
B9D8  8A03     BSF LIN1f_NDTA, 5, ACCESS
1009:                  }
1010:              }
1011:          }
B9DA  0012     RETURN 0
1012:          //-----------------------------------------------------------
1013:          //Oczekiwanie na zwolnienie linii TX1
1014:          unsigned char ChkTX1Busy(void)
1015:          {
1016:              if((!TXSTA1bits.TRMT)&&(UAD1t.tmFR>_LN1_TRMF)) //przekroczony czas aktywnosci linii TX?
BDD0  B2AC     BTFSC TXSTA1, 1, ACCESS
BDD2  D007     BRA 0xBDE2
BDD4  0101     MOVLB 0x1
BDD6  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
BDD8  E103     BNZ 0xBDE0
BDDA  0E1A     MOVLW 0x1A
BDDC  5D96     SUBWF _RSDT1f_RespLIDN, W, BANKED
BDDE  E301     BNC 0xBDE2
1017:              {
1018:                  return 2;
BDE0  0C02     RETLW 0x2
1019:              }
1020:              if(!TXSTA1bits.TRMT) return 1;             //transmisja trwa?
BDE2  A2AC     BTFSS TXSTA1, 1, ACCESS
BDE4  0C01     RETLW 0x1
1021:              UAD1tf_TFEnd=0;                    //zeruj znacznik zakonczenia wysylki ramki
BDE6  9813     BCF UAD1tf_RFData, 4, ACCESS
1022:              return 0;
1023:          
1024:          }
BDE8  0C00     RETLW 0x0
1025:          //-----------------------------------------------------------------
1026:          //Zeruj bufor nadawania
1027:          void ClrLIN2TrnBuf(void)
1028:          {
1029:              volatile unsigned char i;
1030:              
1031:              FTL1.WRD0.byte0=0;                   
B72C  0101     MOVLB 0x1
B72E  6B4A     CLRF cSk, BANKED
1032:              FTL1.WRD0.byte1=0;                   
B730  6B4B     CLRF 0x4B, BANKED
1033:              FTL1.WRD1.byte0=0;                   
B732  6B4C     CLRF 0x4C, BANKED
1034:              FTL1.WRD1.byte1=0;                   
B734  6B4D     CLRF 0x4D, BANKED
1035:              FTL1.WRD2.byte0=0;    
B736  6B4E     CLRF 0x4E, BANKED
1036:              FTL1.WRD2.byte1=0; 
B738  6B4F     CLRF 0x4F, BANKED
1037:              
1038:              for(i=0;i<_NRS_TBF1;i++) bufTUART1[i]=0;
B73A  0100     MOVLB 0x0
B73C  6B74     CLRF _PFNf_prODP, BANKED
B73E  0E0E     MOVLW 0xE
B740  6574     CPFSGT _PFNf_prODP, BANKED
B742  D001     BRA 0xB746
B744  0C0E     RETLW 0xE
B746  0E51     MOVLW 0x51
B748  2574     ADDWF _PFNf_prODP, W, BANKED
B74A  D803     RCALL PL532
B74C  6ADF     CLRF INDF2, ACCESS
B74E  2B74     INCF _PFNf_prODP, F, BANKED
B750  D7F6     BRA 0xB73E
1039:          }
1040:          //-----------------------------------------------------------------
1041:          //Odbior danych w trybie SLAVE
1042:          unsigned char LIN1SRecept(unsigned char ref)
5550  0100     MOVLB 0x0
5552  6FA9     MOVWF dt, BANKED
1043:          {
1044:              volatile static unsigned char krok;
1045:          #if _TESTCHK1!=0
1046:              static unsigned char a;
1047:          #endif
1048:              if(ref)
5554  51A9     MOVF dt, W, BANKED
5556  E101     BNZ 0x555A
5558  D121     BRA 0x579C
1049:              {
1050:                  ClrLIN2TrnBuf();
555A  EC96     CALL 0xB72C, 0
555C  F05B     NOP
1051:                  krok=0;
555E  0101     MOVLB 0x1
5560  6BAF     CLRF 0xAF, BANKED
1052:                  return 0;
5562  0C00     RETLW 0x0
1053:              }
1054:              switch(krok)
579C  0101     MOVLB 0x1
1055:              {
1056:                  case 0:
1057:                  {
1058:                      UAD1t.RNData = 9;                                            //startowy, maksymalny rozmiar ramki
5564  0E09     MOVLW 0x9
5566  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
1059:                      UAD1t.Rindeks = 0;                                           //wyzeruj indeks
5568  6B92     CLRF _RSDT1f_RD_LIN, BANKED
1060:                      UAD1tf_RFData = 0;                                            //usun znacznik odbioru danych
556A  9013     BCF UAD1tf_RFData, 0, ACCESS
1061:                      UAD1tf_RFEnd = 0;                                             //wyzeruj znacznik konca odbioru
556C  9213     BCF UAD1tf_RFData, 1, ACCESS
1062:                      UAD1tf_RFExt = 0;
556E  9413     BCF UAD1tf_RFData, 2, ACCESS
1063:                      UAD1tf_RFBrSn = 0;                                            //przygotuj znacznik oczekiwania na BREAk SYNCH
5570  9E12     BCF RSDT1f_RD_STD, 7, ACCESS
1064:                      //--------------------
1065:                      ReaderRX1ON();                                               //uruchom odbiornik
5572  ECB0     CALL 0xC160, 0
5574  F060     NOP
1066:                      krok=1;
5576  0E01     MOVLW 0x1
5578  6FAF     MOVWF 0xAF, BANKED
1067:                  }
1068:                  case 1:
1069:                  {
1070:                      if(UAD1tf_RFExt)
557A  A413     BTFSS UAD1tf_RFData, 2, ACCESS
557C  D003     BRA 0x5584
1071:                      {
1072:                         UAD1tf_RFExt=0;
557E  9413     BCF UAD1tf_RFData, 2, ACCESS
1073:                         LIN1f_ACK=0;                                             //blad naglowka - odpowiedz negatywna ignoruj paczke
5580  D918     RCALL PL438
1074:                         krok=3;
1075:                         return 4;    //blad naglowka
5582  0C04     RETLW 0x4
1076:                      }           
1077:                      if((!RCSTA1bits.CREN||!PIE1bits.RC1IE))                      //deaktywowany odbior RS w trakcie oczekiwania lub podczas procesu odbioru?
5584  A8AB     BTFSS RCSTA1, 4, ACCESS
5586  D002     BRA 0x558C
5588  BA9D     BTFSC PIE1, 5, ACCESS
558A  D003     BRA 0x5592
1078:                      {
1079:                          if(!UAD1tf_RFEnd||UAD1tf_RFData) return 2;               //restart procedury
558C  B213     BTFSC UAD1tf_RFData, 1, ACCESS
558E  B013     BTFSC UAD1tf_RFData, 0, ACCESS
5590  0C02     RETLW 0x2
1080:                      }            
1081:                      if(UAD1tf_RFData&&!LIN1f_FResp)                                //odebrano pierwszy bajt?
5592  B013     BTFSC UAD1tf_RFData, 0, ACCESS
5594  B403     BTFSC LIN1f_NDTA, 2, ACCESS
5596  D003     BRA 0x559E
1082:                      {
1083:                          LIN1f_FResp=1;                                            //ustaw znacznik odbioru
5598  8403     BSF LIN1f_NDTA, 2, ACCESS
1084:                          UAD1t.tmFR=0;                                            //zeruj zegar ramki
559A  6B96     CLRF _RSDT1f_RespLIDN, BANKED
559C  6B97     CLRF _UAD1tf_RFBrSn, BANKED
1085:                      }
1086:                      if(!UAD1tf_RFEnd) return 0;                                   //czekaj do konca odbioru lub do stanu timeout
559E  A213     BTFSS UAD1tf_RFData, 1, ACCESS
55A0  0C00     RETLW 0x0
1087:                      UAD1tf_RFEnd=0;                                               //zkonczono odbior (odbiornik zatrzymany w przerwaniu)
55A2  9213     BCF UAD1tf_RFData, 1, ACCESS
1088:                      if(ChkR1CHK())                                               //sprawdz CHK
55A4  EC3D     CALL 0x8E7A, 0
55A6  F047     NOP
55A8  E201     BC 0x55AC
55AA  D0AA     BRA 0x5700
1089:                      {
1090:                          LIN1f_CHK=1;
55AC  8C02     BSF LIN1f_Busy, 6, ACCESS
1091:                          if(MGSDf_NO_ODB||PFN.vUNI02<0x09||!PFN.ALIN)             //brak komunikacji z plytka UNI-02 lub wersja oprogramowania UNI-02<09 lub nieprawidlowy adres wlasny LIN?
55AE  BE03     BTFSC LIN1f_NDTA, 7, ACCESS
55B0  D006     BRA 0x55BE
55B2  0E08     MOVLW 0x8
55B4  0101     MOVLB 0x1
55B6  65EC     CPFSGT 0xEC, BANKED
55B8  D002     BRA 0x55BE
55BA  51ED     MOVF 0xED, W, BANKED
55BC  E102     BNZ 0x55C2
55BE  D8F9     RCALL PL438
1092:                          {
1093:                              LIN1f_ACK=0;                      
1094:                              krok=3;
1095:                              return 6;   //blad odbiornika                 
55C0  0C06     RETLW 0x6
1096:                          }
1097:                          else
1098:                          if(!ChkParity1(bufRUART1[0]))        //sprawdz parzystosc
55C2  0102     MOVLB 0x2
55C4  5100     MOVF 0x0, W, BANKED
55C6  EC8E     CALL 0x8F1C, 0
55C8  F047     NOP
55CA  E202     BC 0x55D0
1099:                          {
1100:                              LIN1ERR.ID_PR=1;
55CC  81D7     BSF LIN1ERR, 0, BANKED
55CE  D7D8     BRA 0x5580
1101:                              LIN1f_ACK=0;
1102:                              krok=3;
1103:                              return 4;   //blad parzystosci
1104:                          }
1105:                          else
1106:                          if((!bufRUART1[1]&&(bufRUART1[0]&0b00111111)==_PIF_READ)&&(bufRUART1[4]==0x01)&&(PFN.ALIN==0x05)) //adres zerowy, zadanie wysylki danych ACK do MASTER, ale adres wlasny neutralny?    
55D0  0102     MOVLB 0x2
55D2  5101     MOVF DtCOf_err_CO, W, BANKED
55D4  E10C     BNZ 0x55EE
55D6  5100     MOVF 0x0, W, BANKED
55D8  0B3F     ANDLW 0x3F
55DA  0A02     XORLW 0x2
55DC  E108     BNZ 0x55EE
55DE  0504     DECF MGSDf_TransData, W, BANKED
55E0  E106     BNZ 0x55EE
55E2  0E05     MOVLW 0x5
55E4  0101     MOVLB 0x1
55E6  19ED     XORWF 0xED, W, BANKED
55E8  E102     BNZ 0x55EE
1107:                          {
1108:                              LIN1f_ACK=0;           //zapobiegaj odpowiedzi przy adresie wlasnym neutralnym           
55EA  D8E3     RCALL PL438
1109:                              krok=3;
55EC  0C02     RETLW 0x2
1110:                              return 2;   //ignoruj adres
1111:                          }
1112:                          else                    
1113:                          //if((!bufRUART1[1]&&(bufRUART1[0]&0b00111111)!=_PIF_WRITE)) //adres zerowy i zadanie wysylki danych do MASTER?    
1114:                          if((!bufRUART1[1]&&(bufRUART1[0]&0b00111111)!=_PIF_WRITE)&&(bufRUART1[4]!=0x01)) //adres zerowy i zadanie wysylki danych do MASTER inne niz ACK?
55EE  0102     MOVLB 0x2
55F0  5101     MOVF DtCOf_err_CO, W, BANKED
55F2  E106     BNZ 0x5600
55F4  5100     MOVF 0x0, W, BANKED
55F6  0B3F     ANDLW 0x3F
55F8  06E8     DECF WREG, F, ACCESS
55FA  E002     BZ 0x5600
55FC  0504     DECF MGSDf_TransData, W, BANKED
55FE  E1F5     BNZ 0x55EA
1115:                          {
1116:                              LIN1f_ACK=0;            //adres zerowy akceptuj tylko przy poleceniach zapisu z wyjatkiem polecenia ACK ktore moze byc do odczytu                   
1117:                              krok=3;
1118:                              return 2;   //ignoruj adres
1119:                          }
1120:                          else
1121:                          if(bufRUART1[1]&&(bufRUART1[1]!=_MY_NAD1))                 //adres niezerowy i niezgodny?
5600  5101     MOVF DtCOf_err_CO, W, BANKED
5602  E004     BZ 0x560C
5604  D8DB     RCALL PL616
5606  E002     BZ 0x560C
5608  D8D4     RCALL PL438
1122:                          {
1123:                              LIN1f_ACK=0;                      
1124:                              krok=3;
1125:                              return 3;   //blad adresu
560A  0C03     RETLW 0x3
1126:                          }
1127:                          else                                //zapamietaj ramke
1128:                          {
1129:                              FRL1f_NextFr=1;
560C  8C01     BSF DtCOf_err_CO, 6, ACCESS
1130:                              if(FRL1.PFR<0xFF) FRL1.PFR++;                           //licznik powtorzen polecenia
560E  0100     MOVLB 0x0
5610  29B6     INCF 0xB6, W, BANKED
5612  E001     BZ 0x5616
5614  2BB6     INCF 0xB6, F, BANKED
1131:                              if(FRL1.PIF.war!=bufRUART1[0]) FRL1.PFR=0;
5616  0102     MOVLB 0x2
5618  5100     MOVF 0x0, W, BANKED
561A  0100     MOVLB 0x0
561C  19AE     XORWF FRL1, W, BANKED
561E  E001     BZ 0x5622
5620  6BB6     CLRF 0xB6, BANKED
1132:                              FRL1.PIF.war=bufRUART1[0];                              //protected idetifier
5622  C200     MOVFF bufRUART1, FRL1
5624  F0AE     NOP
1133:                              if(FRL1.NAD!=bufRUART1[1]) FRL1.PFR=0;
5626  0102     MOVLB 0x2
5628  5101     MOVF DtCOf_err_CO, W, BANKED
562A  0100     MOVLB 0x0
562C  19AF     XORWF 0xAF, W, BANKED
562E  E001     BZ 0x5632
5630  6BB6     CLRF 0xB6, BANKED
1134:                              FRL1.NAD=bufRUART1[1];                                  //NAD Adres odbiornika
5632  C201     MOVFF 0x201, 0xAF
5634  F0AF     NOP
1135:                              if(FRL1.PCI!=bufRUART1[2]) FRL1.PFR=0;
5636  0102     MOVLB 0x2
5638  5102     MOVF LIN1f_Busy, W, BANKED
563A  0100     MOVLB 0x0
563C  19B0     XORWF 0xB0, W, BANKED
563E  E001     BZ 0x5642
5640  6BB6     CLRF 0xB6, BANKED
1136:                              FRL1.PCI=bufRUART1[2];                                  //PCI
5642  C202     MOVFF 0x202, 0xB0
5644  F0B0     NOP
1137:                              FRL1.PCI_TYPE=(FRL1.PCI&0xF0);                          //Rodzaj ramki
5646  51B0     MOVF 0xB0, W, BANKED
5648  0BF0     ANDLW 0xF0
564A  6FB1     MOVWF 0xB1, BANKED
1138:                              FRL1.PCI_LENGTH=(FRL1.PCI&0x0F);                        //Rozmiar ramki(SID+liczba bajtow danych+CHK)
564C  51B0     MOVF 0xB0, W, BANKED
564E  0B0F     ANDLW 0xF
5650  6FB2     MOVWF 0xB2, BANKED
1139:                              if(FRL1.WRD0.byte0!=bufRUART1[3]) FRL1.PFR=0;
5652  0102     MOVLB 0x2
5654  5103     MOVF LIN1f_NDTA, W, BANKED
5656  0100     MOVLB 0x0
5658  19BA     XORWF 0xBA, W, BANKED
565A  E001     BZ 0x565E
565C  6BB6     CLRF 0xB6, BANKED
1140:                              FRL1.WRD0.byte0=bufRUART1[3];                           //SID/INDL (licznik)
565E  C203     MOVFF 0x203, 0xBA
5660  F0BA     NOP
1141:                              if(FRL1.WRD0.byte1!=bufRUART1[4]) FRL1.PFR=0;
5662  0102     MOVLB 0x2
5664  5104     MOVF MGSDf_TransData, W, BANKED
5666  0100     MOVLB 0x0
5668  19BB     XORWF 0xBB, W, BANKED
566A  E001     BZ 0x566E
566C  6BB6     CLRF 0xB6, BANKED
1142:                              FRL1.WRD0.byte1=bufRUART1[4];                           //IDN/INDH
566E  C204     MOVFF 0x204, 0xBB
5670  F0BB     NOP
1143:                              FRL1.WRD1.byte0=bufRUART1[5];                           //DTA1/STARTL       - RS [kom,adr]
5672  C205     MOVFF 0x205, 0xBC
5674  F0BC     NOP
1144:                              FRL1.WRD1.byte1=bufRUART1[6];                           //DTA2/STARTH       - RS [dta1,par1]
5676  C206     MOVFF 0x206, 0xBD
5678  F0BD     NOP
1145:                              FRL1.WRD2.byte0=bufRUART1[7];                           //DTA3/STOPL        - RS [dta2]
567A  C207     MOVFF 0x207, 0xBE
567C  F0BE     NOP
1146:                              FRL1.WRD2.byte1=bufRUART1[8];                           //DTA4/STOPH        - RS [dta3]
567E  C208     MOVFF 0x208, 0xBF
5680  F0BF     NOP
1147:          
1148:                              if((FRL1.PCI_TYPE!=_PCI_TCF1)&&(FRL1.PCI_TYPE!=_PCI_TECF1)) //TSF, TFF
5682  0E20     MOVLW 0x20
5684  19B1     XORWF 0xB1, W, BANKED
5686  E044     BZ 0x5710
5688  0E50     MOVLW 0x50
568A  19B1     XORWF 0xB1, W, BANKED
568C  E041     BZ 0x5710
1149:                              {
1150:                                  FRL1.SID=FRL1.WRD0.byte0;                               //SID         
568E  C0BA     MOVFF 0xBA, 0xB3
5690  F0B3     NOP
1151:                                  if(!(bufRUART1[4]&0b10000000))      //tradycyjna ramka LIN
5692  0102     MOVLB 0x2
5694  BF04     BTFSC MGSDf_TransData, 7, BANKED
5696  D005     BRA 0x56A2
1152:                                  {
1153:                                      FRL1f_RSFrame=0;
5698  9002     BCF LIN1f_Busy, 0, ACCESS
1154:                                      FRL1f_RSMultiFrame=0;
569A  9202     BCF LIN1f_Busy, 1, ACCESS
1155:                                      FRL1.IDN=FRL1.WRD0.byte1;                               //IDN                            
569C  C0BB     MOVFF 0xBB, 0xB5
569E  F0B5     NOP
1156:                                  }
56A0  D025     BRA 0x56EC
1157:                                  else    //transportowa ramka LIN (dane z modulu dostepowego WiFi)
1158:                                  {
1159:                                      FRL1f_RSFrame=1;
56A2  8002     BSF LIN1f_Busy, 0, ACCESS
1160:                                      FRL1.IDN=bufRUART1[4];                          //wartosc wstepna, dalej (po analizie danych) podmieniony wartoscia LIN IDN
56A4  C204     MOVFF 0x204, 0xB5
56A6  F0B5     NOP
1161:                                      FRL1.RS_KOM=(bufRUART1[5]&0b11100000)>>5;       //RS(komenda)
56A8  3905     SWAPF PFNf_KnfDisErr, W, BANKED
56AA  42E8     RRNCF WREG, F, ACCESS
56AC  0B07     ANDLW 0x7
56AE  0100     MOVLB 0x0
56B0  6FB7     MOVWF 0xB7, BANKED
1162:                                      if((FRL1.PIF.war&0b00111111)==_PIF_WRITE) FRL1.RS_KOM|=0b10000000;    //znacznik WR
56B2  51AE     MOVF FRL1, W, BANKED
56B4  0B3F     ANDLW 0x3F
56B6  06E8     DECF WREG, F, ACCESS
56B8  E102     BNZ 0x56BE
56BA  8FB7     BSF 0xB7, 7, BANKED
56BC  D001     BRA 0x56C0
1163:                                      else FRL1.RS_KOM&=0b01111111;
56BE  9FB7     BCF 0xB7, 7, BANKED
1164:                                      FRL1.RS_ADR=(bufRUART1[5]&0b00011111);          //RS(adres)
56C0  0102     MOVLB 0x2
56C2  5105     MOVF PFNf_KnfDisErr, W, BANKED
56C4  0B1F     ANDLW 0x1F
56C6  0100     MOVLB 0x0
56C8  6FB8     MOVWF 0xB8, BANKED
1165:                                      FRL1.RS_IDN=bufRUART1[4];                             
56CA  C204     MOVFF 0x204, 0xB9
56CC  F0B9     NOP
1166:                                      if(FRL1.PCI_TYPE==_PCI_TSF1)    //pojedyncza ramka?
56CE  51B1     MOVF 0xB1, W, BANKED
56D0  E109     BNZ 0x56E4
1167:                                      {
1168:                                          FRL1f_RSMultiFrame=0;     
56D2  9202     BCF LIN1f_Busy, 1, ACCESS
1169:                                          FRL1.WRD1.byte0=FRL1.WRD1.byte1;            //dta1,param1
56D4  C0BD     MOVFF 0xBD, 0xBC
56D6  F0BC     NOP
1170:                                          FRL1.WRD1.byte1=FRL1.WRD2.byte0;            //dta2,param2
56D8  C0BE     MOVFF 0xBE, 0xBD
56DA  F0BD     NOP
1171:                                          FRL1.WRD2.byte0=FRL1.WRD2.byte1;            //dta3,param3
56DC  C0BF     MOVFF 0xBF, 0xBE
56DE  F0BE     NOP
1172:                                          FRL1.WRD2.byte1=0;
56E0  6BBF     CLRF 0xBF, BANKED
1173:                                      }
56E2  D004     BRA 0x56EC
1174:                                      else                            //ramka wielokrotna
1175:                                      {
1176:                                          FRL1f_RSMultiFrame=1;
56E4  8202     BSF LIN1f_Busy, 1, ACCESS
1177:                                          FRL1.WRD1.byte0=FRL1.WRD1.byte1;            //param1
56E6  C0BD     MOVFF 0xBD, 0xBC
56E8  F0BC     NOP
1178:                                          FRL1.WRD1.byte1=0;       
56EA  6BBD     CLRF 0xBD, BANKED
1179:                                      }
1180:                                  } 
1181:                                  if((FRL1.PCI_TYPE==_PCI_TFF1)||(FRL1.PCI_TYPE==_PCI_TEFF1))
56EC  0E10     MOVLW 0x10
56EE  0100     MOVLB 0x0
56F0  19B1     XORWF 0xB1, W, BANKED
56F2  E003     BZ 0x56FA
56F4  0E40     MOVLW 0x40
56F6  19B1     XORWF 0xB1, W, BANKED
56F8  E10B     BNZ 0x5710
1182:                                  {
1183:                                      FRL1.CSID=FRL1.SID;
56FA  C0B3     MOVFF 0xB3, 0xB4
56FC  F0B4     NOP
1184:                                  }
1185:                              }
1186:                          }
56FE  D008     BRA 0x5710
1187:                      }
1188:                      else
1189:                      {
1190:                          LIN1ERR.CRC=1;               //blad CRC
5700  0100     MOVLB 0x0
5702  83D7     BSF LIN1ERR, 1, BANKED
1191:                          LIN1f_ACK=0;
5704  9802     BCF LIN1f_Busy, 4, ACCESS
1192:                          LIN1f_CHK=0;
5706  9C02     BCF LIN1f_Busy, 6, ACCESS
1193:                          krok=3;
5708  0E03     MOVLW 0x3
570A  0101     MOVLB 0x1
570C  6FAF     MOVWF 0xAF, BANKED
1194:                          return 5;   //blad CHK
570E  0C05     RETLW 0x5
1195:                      }
1196:                      LIN1f_FResp=0;
5710  9403     BCF LIN1f_NDTA, 2, ACCESS
1197:                      LIN1f_FAdta=1;                   //ustaw znacznik analizy danych
5712  8003     BSF LIN1f_NDTA, 0, ACCESS
1198:                      LIN1.tmAd=0;
5714  0101     MOVLB 0x1
5716  EC7E     CALL 0xBCFC, 0
5718  F05E     NOP
1199:                      LIN1.tmZw=0;            
1200:                      krok=2;
571A  0E02     MOVLW 0x2
571C  6FAF     MOVWF 0xAF, BANKED
571E  D030     BRA 0x5780
1201:                  }
1202:                  case 2:
1203:                  {
1204:                      switch(SetLIN1SData())      //analiza ramki i przygotowanie odpowiedzi
5780  ECCB     CALL 0x9796, 0
5782  F04B     NOP
5784  0A00     XORLW 0x0
5786  B4D8     BTFSC STATUS, 2, ACCESS
5788  0C00     RETLW 0x0
578A  0A01     XORLW 0x1
578C  E0C9     BZ 0x5720
578E  0A03     XORLW 0x3
5790  E0F5     BZ 0x577C
1205:                      {
1206:                          case 0:                 //trwa przetwarzanie danych
1207:                          {
1208:                              return 0;
1209:                          }
1210:                          case 1:                 //gotowa odpowiedz
1211:                          {
1212:          #if ((_TESTCHK1!=0)&&((_TESTCHK1S!=0)||(_TESTCHK1F!=0)||(_TESTCHK1C!=0)))
1213:          #if (_TESTCHK1S!=0)
1214:                              if(FRL1.PCI_TYPE==_PCI_TSF1) a=_TESTCHK1;
1215:                              else
1216:                              if(FRL1.PCI_TYPE==_PCI_TESF1) if(a) a--;
1217:          #else
1218:                              if((FRL1.PCI_TYPE==_PCI_TSF1)||(FRL1.PCI_TYPE==_PCI_TESF1)) a=0;
1219:          #endif                    
1220:          #if (_TESTCHK1F!=0)
1221:                              if(FRL1.PCI_TYPE==_PCI_TFF1) a=_TESTCHK1;
1222:                              else
1223:                              if(FRL1.PCI_TYPE==_PCI_TEFF1) if(a) a--;
1224:          #else
1225:                              if((FRL1.PCI_TYPE==_PCI_TFF1)||(FRL1.PCI_TYPE==_PCI_TEFF1)) a=0;
1226:          #endif
1227:          #if (_TESTCHK1C!=0)
1228:                              if(FRL1.PCI_TYPE==_PCI_TCF1) a=_TESTCHK1;
1229:                              else
1230:                              if(FRL1.PCI_TYPE==_PCI_TECF1) if(a) a--;
1231:          #else
1232:                              if((FRL1.PCI_TYPE==_PCI_TCF1)||(FRL1.PCI_TYPE==_PCI_TECF1)) a=0;
1233:          #endif
1234:          #endif
1235:                              LIN1f_ACK=1;
5720  8802     BSF LIN1f_Busy, 4, ACCESS
1236:                              bufTUART1[0]=_MY_NAD1;                                       //NAD
5722  C1ED     MOVFF 0x1ED, bufTUART1
5724  F351     NOP
1237:                              bufTUART1[1]=(FTL1.PCI_TYPE&0xF0)|(FTL1.PCI_LENGTH&0x0F);    //PCI
5726  C142     MOVFF 0x142, sign
5728  F0A8     NOP
572A  0E0F     MOVLW 0xF
572C  0100     MOVLB 0x0
572E  17A8     ANDWF sign, F, BANKED
5730  0101     MOVLB 0x1
5732  5141     MOVF UADt, W, BANKED
5734  0BF0     ANDLW 0xF0
5736  0100     MOVLB 0x0
5738  11A8     IORWF sign, W, BANKED
573A  0103     MOVLB 0x3
573C  6F52     MOVWF 0x52, BANKED
1238:                              bufTUART1[2]=FTL1.WRD0.byte0;                                //DTA0/RSID
573E  C14A     MOVFF 0x14A, 0x353
5740  F353     NOP
1239:                              bufTUART1[3]=FTL1.WRD0.byte1;                                //DTA1/TCHK
5742  C14B     MOVFF 0x14B, 0x354
5744  F354     NOP
1240:                              
1241:                              bufTUART1[4]=FTL1.WRD1.byte0;                                //DTA2
5746  C14C     MOVFF 0x14C, 0x355
5748  F355     NOP
1242:                              bufTUART1[5]=FTL1.WRD1.byte1;                                //DTA3
574A  C14D     MOVFF 0x14D, 0x356
574C  F356     NOP
1243:                              bufTUART1[6]=FTL1.WRD2.byte0;                                //DTA4
574E  C14E     MOVFF 0x14E, 0x357
5750  F357     NOP
1244:                              bufTUART1[7]=FTL1.WRD2.byte1;                                //DTA5
5752  C14F     MOVFF 0x14F, 0x358
5754  F358     NOP
1245:                              UAD1t.TNData=2+(FTL1.PCI_LENGTH&0x0F)+1;                     //NAD,PCI,liczba danych do wysylki,CHK
5756  0101     MOVLB 0x1
5758  5142     MOVF 0x42, W, BANKED
575A  0B0F     ANDLW 0xF
575C  0F03     ADDLW 0x3
575E  6F95     MOVWF _RSDT1f_RRD_STD, BANKED
1246:          #if _TESTCHK1!=0
1247:                              bufTUART1[UAD1t.TNData-1]=0xFF-CalcT1CHK()+a;                  //neg CHK
1248:          #else
1249:                              bufTUART1[UAD1t.TNData-1]=0xFF-CalcT1CHK();                  //neg CHK
5760  EC77     CALL 0xA2EE, 0
5762  F051     NOP
5764  0AFF     XORLW 0xFF
5766  6FA8     MOVWF sign, BANKED
5768  0E50     MOVLW 0x50
576A  0101     MOVLB 0x1
576C  2595     ADDWF _RSDT1f_RRD_STD, W, BANKED
576E  6ED9     MOVWF FSR2, ACCESS
5770  6ADA     CLRF FSR2H, ACCESS
5772  0E03     MOVLW 0x3
5774  22DA     ADDWFC FSR2H, F, ACCESS
5776  C0A8     MOVFF sign, INDF2
5778  FFDF     NOP
1250:          #endif
1251:                              break;
577A  D00B     BRA 0x5792
1252:                          }
1253:                          case 2:               //decyzja zeby nie generowac odpowiedzi
1254:                          {
1255:                              LIN1f_FAdta=0;     //zeruj znacznik analizy danych
577C  9003     BCF LIN1f_NDTA, 0, ACCESS
577E  D735     BRA 0x55EA
1256:                              LIN1f_ACK=0;
1257:                              krok=3;
1258:                              return 2;         //decyzja o braku odpowiedzi
1259:                          }
1260:                      }
1261:                      LIN1f_FAdta=0;             //zeruj znacznik analizy danych
5792  9003     BCF LIN1f_NDTA, 0, ACCESS
1262:                      krok=3;
5794  0E03     MOVLW 0x3
5796  0101     MOVLB 0x1
5798  6FAF     MOVWF 0xAF, BANKED
1263:                  }
1264:                  case 3:
1265:                  {
1266:                      return 1;
579A  0C01     RETLW 0x1
579C  0101     MOVLB 0x1
579E  51AF     MOVF 0xAF, W, BANKED
57A0  E101     BNZ 0x57A4
57A2  D6E0     BRA 0x5564
57A4  0A01     XORLW 0x1
57A6  E101     BNZ 0x57AA
57A8  D6E8     BRA 0x557A
57AA  0A03     XORLW 0x3
57AC  E0E9     BZ 0x5780
57AE  0A01     XORLW 0x1
57B0  0C01     RETLW 0x1
1267:                  }
1268:              }
1269:              return 1;
1270:          }
1271:          //-----------------------------------------------------------------
1272:          //Transmisja danych w trybie SLAVE
1273:          unsigned char LIN1STrans(unsigned char ref)
9DFE  0100     MOVLB 0x0
9E00  6F74     MOVWF _PFNf_prODP, BANKED
1274:          {
1275:              volatile static unsigned char krok;
1276:          
1277:              //-----------------------------------------------------
1278:              if(ref)
9E02  5174     MOVF _PFNf_prODP, W, BANKED
9E04  E02D     BZ 0x9E60
1279:              {
1280:                  krok=0;
9E06  0101     MOVLB 0x1
9E08  6BB0     CLRF 0xB0, BANKED
1281:                  return 0;
9E0A  0C00     RETLW 0x0
1282:              }
1283:              //Algorytm MASTER
1284:              switch(krok)
9E60  0101     MOVLB 0x1
1285:              {
1286:                  case 0: //rozpoczecie procesu
1287:                  {
1288:                      LIN1f_FTrans=1;
9E0C  8603     BSF LIN1f_NDTA, 3, ACCESS
1289:                      UAD1t.tmFR=0;
9E0E  6B96     CLRF _RSDT1f_RespLIDN, BANKED
9E10  6B97     CLRF _UAD1tf_RFBrSn, BANKED
1290:                      krok=1;
9E12  0E01     MOVLW 0x1
9E14  6FB0     MOVWF 0xB0, BANKED
9E16  D006     BRA 0x9E24
1291:                  }
1292:                  case 1: //oczekiwanie na zwolnienie linii
1293:                  {
1294:                      switch(ChkTX1Busy())                 //oczekuj na zwolnienie linii
9E24  ECE8     CALL 0xBDD0, 0
9E26  F05E     NOP
9E28  0A01     XORLW 0x1
9E2A  B4D8     BTFSC STATUS, 2, ACCESS
9E2C  0C00     RETLW 0x0
9E2E  0A03     XORLW 0x3
9E30  E0F3     BZ 0x9E18
1295:                      {
1296:                          case 1: //busy
1297:                          {
1298:                              return 0;
1299:                          }
1300:                          case 2: //timeout
1301:                          {
1302:                              LIN1ERR.TFTOUT=1;
9E18  0100     MOVLB 0x0
9E1A  85D8     BSF 0xD8, 2, BANKED
1303:                              krok=5;
9E1C  0E05     MOVLW 0x5
9E1E  0101     MOVLB 0x1
9E20  6FB0     MOVWF 0xB0, BANKED
1304:                              return 2;
9E22  0C02     RETLW 0x2
1305:                          }
1306:                      }
1307:          #if _SYG_STN1==1
1308:                      _S_WRITE1=1;
1309:          #endif
1310:                      krok=2;
9E32  0E02     MOVLW 0x2
9E34  0101     MOVLB 0x1
9E36  6FB0     MOVWF 0xB0, BANKED
1311:                  }
1312:                  case 2: //start transmisji
1313:                  {
1314:                      if(!StartLIN1TR()) return 0;                //rozpocznij transmisje
9E38  ECD9     CALL 0xB3B2, 0
9E3A  F059     NOP
9E3C  E201     BC 0x9E40
9E3E  0C00     RETLW 0x0
1315:                      krok=3;
9E40  0E03     MOVLW 0x3
9E42  0101     MOVLB 0x1
9E44  6FB0     MOVWF 0xB0, BANKED
1316:                  }
1317:                  case 3: //oczekiwanie na koniec transmisji
1318:                  {
1319:                      switch(ChkTX1Busy())                 //oczekuj na zwolnienie linii
9E46  ECE8     CALL 0xBDD0, 0
9E48  F05E     NOP
9E4A  0A01     XORLW 0x1
9E4C  B4D8     BTFSC STATUS, 2, ACCESS
9E4E  0C00     RETLW 0x0
9E50  0A03     XORLW 0x3
9E52  E0E2     BZ 0x9E18
1320:                      {
1321:                          case 1: //busy
1322:                          {
1323:                              return 0;
1324:                          }
1325:                          case 2: //timeout
1326:                          {
1327:                              LIN1ERR.TFTOUT=1;
1328:                              krok=5;
1329:                              return 2;
1330:                          }
1331:                      }
1332:                      LIN1f_FTrans=0;
9E54  9603     BCF LIN1f_NDTA, 3, ACCESS
1333:          
1334:                      StopLIN1TR();                               //wylacz modul transmisji
9E56  EC67     CALL 0xBECE, 0
9E58  F05F     NOP
1335:          #if _SYG_STN1==1
1336:                      _S_WRITE1=0;
1337:          #endif
1338:                      krok=5;
9E5A  0E05     MOVLW 0x5
9E5C  6FB0     MOVWF 0xB0, BANKED
1339:                  }
1340:                  case 5:
1341:                  {
1342:                      return 1;
9E5E  0C01     RETLW 0x1
9E60  0101     MOVLB 0x1
9E62  51B0     MOVF 0xB0, W, BANKED
9E64  E0D3     BZ 0x9E0C
9E66  0A01     XORLW 0x1
9E68  E0DD     BZ 0x9E24
9E6A  0A03     XORLW 0x3
9E6C  E0E5     BZ 0x9E38
9E6E  0A01     XORLW 0x1
9E70  E0EA     BZ 0x9E46
9E72  0A06     XORLW 0x6
9E74  0C01     RETLW 0x1
1343:                  }
1344:              }
1345:              return 1;
1346:          }
1347:          //------------------------------------------------------------------------------------
1348:          //Funkcja transmisji/odbioru w trybie SLAVE (umiescic w petli glownej)
1349:          bit LIN1SDeamon(void)
1350:          {
1351:              volatile static unsigned char krok=0;
1352:          
1353:              //-----------------------------------------------
1354:              if(LIN1f_FAdta&&LIN1.tmAd>_LN1_ADTA)                                 //timeout dla przetwarzania danych?
7A0A  A003     BTFSS LIN1f_NDTA, 0, ACCESS
7A0C  D00C     BRA 0x7A26
7A0E  0101     MOVLB 0x1
7A10  51A2     MOVF _UADtf_TData, W, BANKED
7A12  E103     BNZ 0x7A1A
7A14  0E65     MOVLW 0x65
7A16  5DA1     SUBWF _UADtf_RErrREC, W, BANKED
7A18  E306     BNC 0x7A26
1355:              {
1356:                  LIN1ERR.TADTA=1;
7A1A  0100     MOVLB 0x0
7A1C  89D8     BSF 0xD8, 4, BANKED
1357:                  krok=9;
7A1E  0E09     MOVLW 0x9
7A20  0101     MOVLB 0x1
7A22  6FAD     MOVWF 0xAD, BANKED
1358:              }
7A24  D06A     BRA 0x7AFA
1359:              else
1360:              if(LIN1f_FResp&&UAD1tf_RFData&&(UAD1t.tmB>_LN1_RMB))                  //timeout dla bajtu odpowiedzi?
7A26  B403     BTFSC LIN1f_NDTA, 2, ACCESS
7A28  A013     BTFSS UAD1tf_RFData, 0, ACCESS
7A2A  D009     BRA 0x7A3E
7A2C  0101     MOVLB 0x1
7A2E  5199     MOVF _UAD1tf_RFEnd, W, BANKED
7A30  E103     BNZ 0x7A38
7A32  0E04     MOVLW 0x4
7A34  5D98     SUBWF _UAD1tf_RFData, W, BANKED
7A36  E303     BNC 0x7A3E
1361:              {
1362:                  LIN1ERR.RBTOUT=1;
7A38  0100     MOVLB 0x0
7A3A  8FD7     BSF LIN1ERR, 7, BANKED
7A3C  D7F0     BRA 0x7A1E
1363:                  krok=9;
1364:              }
1365:              else
1366:              if(LIN1f_FResp&&(UAD1t.tmFR>_LN1_TRMF))                              //timeout dla ramki odbioru?
7A3E  A403     BTFSS LIN1f_NDTA, 2, ACCESS
7A40  D009     BRA 0x7A54
7A42  0101     MOVLB 0x1
7A44  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
7A46  E103     BNZ 0x7A4E
7A48  0E1A     MOVLW 0x1A
7A4A  5D96     SUBWF _RSDT1f_RespLIDN, W, BANKED
7A4C  E303     BNC 0x7A54
1367:              {
1368:                  LIN1ERR.RFTOUT=1;
7A4E  0100     MOVLB 0x0
7A50  81D8     BSF 0xD8, 0, BANKED
7A52  D7E5     BRA 0x7A1E
1369:                  krok=9;
1370:              }
1371:              else
1372:              if(LIN1f_FTrans&&(UAD1t.tmFR>_LN1_TRMF))                             //timeout dla ramki odpowiedzi?
7A54  A603     BTFSS LIN1f_NDTA, 3, ACCESS
7A56  D009     BRA 0x7A6A
7A58  0101     MOVLB 0x1
7A5A  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
7A5C  E103     BNZ 0x7A64
7A5E  0E1A     MOVLW 0x1A
7A60  5D96     SUBWF _RSDT1f_RespLIDN, W, BANKED
7A62  E303     BNC 0x7A6A
1373:              {
1374:                  LIN1ERR.TFTOUT=1;
7A64  0100     MOVLB 0x0
7A66  85D8     BSF 0xD8, 2, BANKED
7A68  D7DA     BRA 0x7A1E
1375:                  krok=9;
1376:              }
1377:              else
1378:              {
1379:                  if(!LIN1f_NDTA) krok=10;                       //blokada odbioru danych?
7A6A  A803     BTFSS LIN1f_NDTA, 4, ACCESS
7A6C  D857     RCALL PL806
1380:                  //----------------------------------------------------
1381:                  //Przejdz w tryb gotowosci do odbioru nowej paczki danych
1382:                  if(!LIN1f_Busy&&LIN1f_NDTA)                     //odblokowany odbior danych?
7A6E  AA02     BTFSS LIN1f_Busy, 5, ACCESS
7A70  A803     BTFSS LIN1f_NDTA, 4, ACCESS
7A72  D043     BRA 0x7AFA
1383:                  {
1384:                      LIN1ERR.wrd=0;
7A74  0100     MOVLB 0x0
7A76  6BD7     CLRF LIN1ERR, BANKED
7A78  6BD8     CLRF 0xD8, BANKED
1385:                      LIN1f_Busy=1;
7A7A  8A02     BSF LIN1f_Busy, 5, ACCESS
7A7C  D84A     RCALL PL622
1386:                      LIN1f_FIN=0;
1387:                      LIN1f_ERRR=0;
1388:                      LIN1f_ACK=0;
1389:                      LIN1f_SCS=0;
1390:                      LIN1SRecept(1);                          //restart procedury
7A7E  0E01     MOVLW 0x1
7A80  ECA8     CALL 0x5550, 0
7A82  F02A     NOP
1391:                      LIN1STrans(1);                           //restart procedury
7A84  0E01     MOVLW 0x1
7A86  ECFF     CALL 0x9DFE, 0
7A88  F04E     NOP
1392:                      krok=0;
7A8A  0101     MOVLB 0x1
7A8C  6BAD     CLRF 0xAD, BANKED
1393:                  }
1394:              }
7A8E  D035     BRA 0x7AFA
1395:              switch(krok)
7AFA  0101     MOVLB 0x1
7AFC  51AD     MOVF 0xAD, W, BANKED
7AFE  E0D0     BZ 0x7AA0
7B00  0A01     XORLW 0x1
7B02  E0DE     BZ 0x7AC0
7B04  0A03     XORLW 0x3
7B06  E0E8     BZ 0x7AD8
7B08  0A0B     XORLW 0xB
7B0A  E0F0     BZ 0x7AEC
7B0C  0A03     XORLW 0x3
7B0E  E0F3     BZ 0x7AF6
1396:              {
1397:                  case 0:     //gotowosc odbioru
1398:                  {
1399:                      switch(LIN1SRecept(0))
7AA0  0E00     MOVLW 0x0
7AA2  ECA8     CALL 0x5550, 0
7AA4  F02A     NOP
7AA6  0A00     XORLW 0x0
7AA8  B4D8     BTFSC STATUS, 2, ACCESS
7AAA  0012     RETURN 0
7AAC  0A01     XORLW 0x1
7AAE  E0F0     BZ 0x7A90
7AB0  0A03     XORLW 0x3
7AB2  E0F2     BZ 0x7A98
7AB4  0A01     XORLW 0x1
7AB6  E0F0     BZ 0x7A98
7AB8  0A06     XORLW 0x6
7ABA  A4D8     BTFSS STATUS, 2, ACCESS
7ABC  0A03     XORLW 0x3
7ABE  D7EC     BRA 0x7A98
1400:                      {
1401:                          case 0:             //czekaj na koniec odbioru
1402:                              return 0;
1403:                          case 1:             //koniec odbioru(nadaj odpowiedz)
1404:                              krok=1;
7A90  0E01     MOVLW 0x1
7A92  0101     MOVLB 0x1
7A94  6FAD     MOVWF 0xAD, BANKED
7A96  0C01     RETLW 0x1
1405:                              return 0;
1406:                          case 2:             //koniec odbioru(decyzja o braku odpowiedzi)
1407:          #if _LIN1_ALLEODP==1                    
1408:                              if(FRL1f_RSFrame)
1409:                              {                    
1410:                                  if(!FRL1.NAD) //adres 0?
1411:                                  {
1412:                                      krok=9;//brak odpowiedzi
1413:                                  }
1414:                                  else
1415:                                  {
1416:                                      LIN1NegativeResponse(_LIN1_ERREXT,0,0,0);   //inna przyczyna bledu
1417:                                      krok=1;
1418:                                  }
1419:                              }
1420:                              else
1421:                              {
1422:                                  krok=9;
1423:                              }
1424:                              return 0;
1425:          #else
1426:                              krok=9;     //brak odpowiedzi
7A98  0E09     MOVLW 0x9
7A9A  0101     MOVLB 0x1
7A9C  6FAD     MOVWF 0xAD, BANKED
7A9E  0C09     RETLW 0x9
1427:                              return 0;
1428:          #endif
1429:                          case 3:             //niewlasciwy adres
1430:          #if _LIN1_ALLEODP==1                    
1431:                              if(FRL1f_RSFrame)
1432:                              {
1433:                                  LIN1NegativeResponse(_LIN1_ERRADR,0,0,0);
1434:                                  krok=1;
1435:                              }
1436:                              else
1437:                              {
1438:                                  krok=9;     //brak odpowiedzi                       
1439:                              }
1440:                              return 0;                    
1441:                          case 4:             //blad ramki
1442:                              if(FRL1f_RSFrame)
1443:                              {                    
1444:                                  LIN1NegativeResponse(_LIN1_ERRFRM,0,0,0);
1445:                                  krok=1;
1446:                              }
1447:                              else
1448:                              {
1449:                                  krok=9;     //brak odpowiedzi                    
1450:                              }                    
1451:                              return 0;
1452:          #else
1453:                              krok=9;     //brak odpowiedzi
1454:                              return 0;
1455:          #endif                    
1456:                          case 5:             //blad CHK
1457:          #if _LIN1_ALLEODP==1                     
1458:                              if(FRL1f_RSFrame)
1459:                              {                    
1460:                                  LIN1NegativeResponse(_LIN1_ERRCHK,0,0,0);
1461:                                  krok=1;
1462:                              }
1463:                              else
1464:                              {
1465:                                  krok=9;     //brak odpowiedzi
1466:                              }
1467:                              return 0;   
1468:          #else
1469:                              krok=9;     //brak odpowiedzi
1470:                              return 0;
1471:          #endif                    
1472:                          case 6:             //brak odpowiedzi odbiornika    
1473:          #if _LIN1_ALLEODP==1                     
1474:                              if(FRL1f_RSFrame)
1475:                              {                    
1476:                                  LIN1NegativeResponse(_LIN1_ERRODP,0,0,0);
1477:                                  krok=1;
1478:                              }
1479:                              else
1480:                              {
1481:                                  krok=9;     //brak odpowiedzi
1482:                              }
1483:                              return 0;   
1484:          #else                         
1485:                              krok=9; //brak odpowiedzi                 
1486:                              return 0;      
1487:          #endif                    
1488:                          default:
1489:          #if _LIN1_ALLEODP==1                    
1490:                              if(FRL1f_RSFrame)
1491:                              {                    
1492:                                  LIN1NegativeResponse(_LIN1_ERREXT,0,0,0);   //inna przyczyna bledu
1493:                                  krok=1;
1494:                              }
1495:                              else
1496:                              {
1497:                                  krok=9;     //brak odpowiedzi                     
1498:                              }                    
1499:                              return 0;       
1500:          #else
1501:                              krok=9;     //brak odpowiedzi
1502:                              return 0;
1503:          #endif                                    
1504:                      }
1505:                  }
1506:                  case 1:     //zanim odpowiesz odczekaj na zakonczenie transmisji do UNI-02
1507:                  {
1508:                      if(RSDT1f_NewLIDN)      //transmisja zapytania/polecenia do UNI-02?
7AC0  BC11     BTFSC PFNf_zima, 6, ACCESS
1509:                      {
1510:                          if(MGSDf_TransData) return 0;   //czekaj na zakonczenie transmisji
7AC2  A804     BTFSS MGSDf_TransData, 4, ACCESS
7AC4  D001     BRA 0x7AC8
7AC6  0012     RETURN 0
1511:                      }
1512:                      //if(LIN1f_FAdta&&(LIN1.tmZw<_LN1_ADTA)) return 0;      //uplynela minimalna zwloka przed wysylka odpowiedzi?
1513:                      if(LIN1.tmZw<_LN1_TZW) return 0;      //uplynela minimalna zwloka przed wysylka odpowiedzi?
7AC8  51A4     MOVF _UADtf_TEnd, W, BANKED
7ACA  E104     BNZ 0x7AD4
7ACC  0E03     MOVLW 0x3
7ACE  5DA3     SUBWF _UADtf_TEXT, W, BANKED
7AD0  E201     BC 0x7AD4
7AD2  0012     RETURN 0
1514:                      krok=2;
7AD4  0E02     MOVLW 0x2
7AD6  6FAD     MOVWF 0xAD, BANKED
1515:                  }
1516:                  case 2:     //nadawanie odpowiedzi
1517:                  {
1518:                      switch(LIN1STrans(0))           //czekaj na zakonczenie nadawania
7AD8  0E00     MOVLW 0x0
7ADA  ECFF     CALL 0x9DFE, 0
7ADC  F04E     NOP
7ADE  0A00     XORLW 0x0
7AE0  B4D8     BTFSC STATUS, 2, ACCESS
7AE2  0012     RETURN 0
7AE4  0A01     XORLW 0x1
7AE6  E0D8     BZ 0x7A98
7AE8  0A03     XORLW 0x3
7AEA  E0D6     BZ 0x7A98
1519:                      {
1520:                          case 0:
1521:                              return 0;       //czekaj na zakonczenie nadawania
1522:                          case 1:             //koniec transmisji
1523:                          case 2:             //error
1524:                              krok=9;
1525:                              return 0;
1526:                      }
1527:                  }
1528:                  case 9:     //zakoncz procedure/ustaw flagi stanu
1529:                  {
1530:                      ResetRC1TX1();            //wylacz nadajnik/odbiornik
7AEC  EC74     CALL 0xBCE8, 0
7AEE  F05E     NOP
1531:                      LIN1RefStat();          //ustaw flagi stanu
7AF0  ECDA     CALL 0xB9B4, 0
7AF2  F05C     NOP
7AF4  D813     RCALL PL806
1532:          #if _SYG_STN1==1
1533:                      _S_READ1=0;
1534:                      _S_WRITE1=0;
1535:          #endif
1536:                      krok=10;
1537:                  }
1538:                  case 10:    //oczekiwanie na restart procedury
1539:                  {
1540:                      LIN1f_NDTA=1;            //przejdz do gotowosci odbioru
7AF6  8803     BSF LIN1f_NDTA, 4, ACCESS
1541:                      break;
7AF8  0012     RETURN 0
1542:                  }
1543:              }
1544:              return 1;
1545:          }
7B10  0012     RETURN 0
1546:          //-------------------------------------------------------------
1547:          //Oblicz CHK (bez negacji) dla odebranej paczki z nadajnika MASTER i sprawdz zgodnosc
1548:          bit ChkR1CHK(void)
1549:          {
1550:              unsigned char i,j,c,d,s;
1551:          
1552:              if(UAD1t.RNData >= _NRS_RBF1) return 0;
8E7A  0E0E     MOVLW 0xE
8E7C  0101     MOVLB 0x1
8E7E  6594     CPFSGT _RSDT1f_RRD_KNF, BANKED
8E80  D002     BRA 0x8E86
8E82  90D8     BCF STATUS, 0, ACCESS
8E84  0012     RETURN 0
1553:              c=0x00;
8E86  0100     MOVLB 0x0
8E88  6B7F     CLRF _PFNf_set_fnserw, BANKED
1554:           #if _ORYGINAL1_CHK==1
1555:                   #if _CLASR1_CHK==1
1556:                      for(i=1;i<UAD1t.RNData-1;i++)          //classic CHK
1557:                      {
1558:                          if((c+bufRUART1[i])>=256)
1559:                          {
1560:                            c=c+bufRUART1[i]+1;
1561:                          }
1562:                          else c=c+bufRUART1[i];
1563:                      }
1564:                  #else
1565:                      if(((bufRUART1[0]&0b00111111)==0x3C)||((bufRUART1[0]&0b00111111)==0x3D))  //classic CHK
1566:                      {
1567:                          for(i=1;i<UAD1t.RNData-1;i++)          //classic CHK
1568:                          {
1569:                              if((c+bufRUART1[i])>=256)
1570:                              {
1571:                                c=c+bufRUART1[i]+1;
1572:                              }
1573:                              else c=c+bufRUART1[i];
1574:                          }
1575:                      }
1576:                      else    //enhanced CHK
1577:                      {
1578:                          for(i=0;i<UAD1t.RNData-1;i++)          //enhanced CHK
1579:                          {
1580:                              if((c+bufRUART1[i])>=256)
1581:                              {
1582:                                c=c+bufRUART1[i]+1;
1583:                              }
1584:                              else c=c+bufRUART1[i];
1585:                          }
1586:                      }
1587:                  #endif
1588:          #else
1589:              //CRC-8 Dallas/Maxim
1590:              for(i=0;i<UAD1t.RNData-1;i++)
8E8A  6B7D     CLRF _PFNf_set_aleg, BANKED
8E8C  D017     BRA 0x8EBC
8EBA  2B7D     INCF _PFNf_set_aleg, F, BANKED
8EBC  6974     SETF _PFNf_prODP, BANKED
8EBE  6975     SETF _PFNf_prn_cs, BANKED
8EC0  0101     MOVLB 0x1
8EC2  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
8EC4  0100     MOVLB 0x0
8EC6  6F76     MOVWF _PFNf_prn_in, BANKED
8EC8  6B77     CLRF _PFNf_prn_pg, BANKED
8ECA  5174     MOVF _PFNf_prODP, W, BANKED
8ECC  2776     ADDWF _PFNf_prn_in, F, BANKED
8ECE  5175     MOVF _PFNf_prn_cs, W, BANKED
8ED0  2377     ADDWFC _PFNf_prn_pg, F, BANKED
8ED2  517D     MOVF _PFNf_set_aleg, W, BANKED
8ED4  6F78     MOVWF _PFNf_prn_pp, BANKED
8ED6  6B79     CLRF _PFNf_prn_res, BANKED
8ED8  5176     MOVF _PFNf_prn_in, W, BANKED
8EDA  5D78     SUBWF _PFNf_prn_pp, W, BANKED
8EDC  5179     MOVF _PFNf_prn_res, W, BANKED
8EDE  0A80     XORLW 0x80
8EE0  6F7A     MOVWF _PFNf_res, BANKED
8EE2  5177     MOVF _PFNf_prn_pg, W, BANKED
8EE4  0A80     XORLW 0x80
8EE6  597A     SUBWFB _PFNf_res, W, BANKED
8EE8  E3D2     BNC 0x8E8E
1591:              {
1592:                  d=bufRUART1[i];
8E8E  0E00     MOVLW 0x0
8E90  257D     ADDWF _PFNf_set_aleg, W, BANKED
8E92  D83F     RCALL PL676
8E94  50DF     MOVF INDF2, W, ACCESS
8E96  6F7C     MOVWF _PFNf_setKey, BANKED
1593:                  for(j=8;j>0;j--)
8E98  0E08     MOVLW 0x8
8E9A  6F7E     MOVWF _PFNf_set_eco, BANKED
8EB4  077E     DECF _PFNf_set_eco, F, BANKED
8EB6  517E     MOVF _PFNf_set_eco, W, BANKED
8EB8  E1F1     BNZ 0x8E9C
1594:                  {
1595:                      s=(c^d)&0x01;
8E9C  517F     MOVF _PFNf_set_fnserw, W, BANKED
8E9E  197C     XORWF _PFNf_setKey, W, BANKED
8EA0  0B01     ANDLW 0x1
8EA2  6F7B     MOVWF _PFNf_rozruch, BANKED
1596:                      c>>=1;
8EA4  90D8     BCF STATUS, 0, ACCESS
8EA6  337F     RRCF _PFNf_set_fnserw, F, BANKED
1597:                      if(s) c^=0x8c;
8EA8  517B     MOVF _PFNf_rozruch, W, BANKED
8EAA  E002     BZ 0x8EB0
8EAC  0E8C     MOVLW 0x8C
8EAE  1B7F     XORWF _PFNf_set_fnserw, F, BANKED
1598:                      d>>=1;
8EB0  90D8     BCF STATUS, 0, ACCESS
8EB2  337C     RRCF _PFNf_setKey, F, BANKED
1599:                  }
1600:              }
1601:          #endif
1602:              if((bufRUART1[UAD1t.RNData-1]+c)==0xFF) return 1;
8EEA  0EFF     MOVLW 0xFF
8EEC  0101     MOVLB 0x1
8EEE  2594     ADDWF _RSDT1f_RRD_KNF, W, BANKED
8EF0  6ED9     MOVWF FSR2, ACCESS
8EF2  6ADA     CLRF FSR2H, ACCESS
8EF4  0E01     MOVLW 0x1
8EF6  22DA     ADDWFC FSR2H, F, ACCESS
8EF8  50DF     MOVF INDF2, W, ACCESS
8EFA  0100     MOVLB 0x0
8EFC  6F74     MOVWF _PFNf_prODP, BANKED
8EFE  6B75     CLRF _PFNf_prn_cs, BANKED
8F00  517F     MOVF _PFNf_set_fnserw, W, BANKED
8F02  2774     ADDWF _PFNf_prODP, F, BANKED
8F04  0E00     MOVLW 0x0
8F06  2375     ADDWFC _PFNf_prn_cs, F, BANKED
8F08  2974     INCF _PFNf_prODP, W, BANKED
8F0A  1175     IORWF _PFNf_prn_cs, W, BANKED
8F0C  E1BA     BNZ 0x8E82
8F0E  80D8     BSF STATUS, 0, ACCESS
1603:              return 0;
1604:          }
8F10  0012     RETURN 0
1605:          //-------------------------------------------------------------
1606:          //Oblicz CHK (bez negacji) dla wysylanej paczki potwierdzenia SLAVE
1607:          unsigned char CalcT1CHK(void)
1608:          {
1609:              unsigned char i,j,c,d,s;
1610:              c=0x00;
A2EE  0100     MOVLB 0x0
A2F0  6B7F     CLRF _PFNf_set_fnserw, BANKED
1611:          #if _ORYGINAL1_CHK==1
1612:              for(i=0;i<UAD1t.TNData-1;i++)          //classic CHK
1613:              {
1614:                  if((c+bufTUART1[i])>=256)
1615:                  {
1616:                    c=c+bufTUART1[i]+1;
1617:                  }
1618:                  else c=c+bufTUART1[i];
1619:              }
1620:          #else
1621:              //CRC-8 Dallas/Maxim
1622:              for(i=0;i<UAD1t.TNData-1;i++)
A2F2  6B7D     CLRF _PFNf_set_aleg, BANKED
A2F4  D018     BRA 0xA326
A324  2B7D     INCF _PFNf_set_aleg, F, BANKED
A326  6974     SETF _PFNf_prODP, BANKED
A328  6975     SETF _PFNf_prn_cs, BANKED
A32A  0101     MOVLB 0x1
A32C  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
A32E  0100     MOVLB 0x0
A330  6F76     MOVWF _PFNf_prn_in, BANKED
A332  6B77     CLRF _PFNf_prn_pg, BANKED
A334  5174     MOVF _PFNf_prODP, W, BANKED
A336  2776     ADDWF _PFNf_prn_in, F, BANKED
A338  5175     MOVF _PFNf_prn_cs, W, BANKED
A33A  2377     ADDWFC _PFNf_prn_pg, F, BANKED
A33C  517D     MOVF _PFNf_set_aleg, W, BANKED
A33E  6F78     MOVWF _PFNf_prn_pp, BANKED
A340  6B79     CLRF _PFNf_prn_res, BANKED
A342  5176     MOVF _PFNf_prn_in, W, BANKED
A344  5D78     SUBWF _PFNf_prn_pp, W, BANKED
A346  5179     MOVF _PFNf_prn_res, W, BANKED
A348  0A80     XORLW 0x80
A34A  6F7A     MOVWF _PFNf_res, BANKED
A34C  5177     MOVF _PFNf_prn_pg, W, BANKED
A34E  0A80     XORLW 0x80
A350  597A     SUBWFB _PFNf_res, W, BANKED
A352  E3D1     BNC 0xA2F6
1623:              {
1624:                  d=bufTUART1[i];
A2F6  0E51     MOVLW 0x51
A2F8  257D     ADDWF _PFNf_set_aleg, W, BANKED
A2FA  ECA9     CALL 0xB752, 0
A2FC  F05B     NOP
A2FE  50DF     MOVF INDF2, W, ACCESS
A300  6F7C     MOVWF _PFNf_setKey, BANKED
1625:                  for(j=8;j>0;j--)
A302  0E08     MOVLW 0x8
A304  6F7E     MOVWF _PFNf_set_eco, BANKED
A31E  077E     DECF _PFNf_set_eco, F, BANKED
A320  517E     MOVF _PFNf_set_eco, W, BANKED
A322  E1F1     BNZ 0xA306
1626:                  {
1627:                      s=(c^d)&0x01;
A306  517F     MOVF _PFNf_set_fnserw, W, BANKED
A308  197C     XORWF _PFNf_setKey, W, BANKED
A30A  0B01     ANDLW 0x1
A30C  6F7B     MOVWF _PFNf_rozruch, BANKED
1628:                      c>>=1;
A30E  90D8     BCF STATUS, 0, ACCESS
A310  337F     RRCF _PFNf_set_fnserw, F, BANKED
1629:                      if(s) c^=0x8c;
A312  517B     MOVF _PFNf_rozruch, W, BANKED
A314  E002     BZ 0xA31A
A316  0E8C     MOVLW 0x8C
A318  1B7F     XORWF _PFNf_set_fnserw, F, BANKED
1630:                      d>>=1;
A31A  90D8     BCF STATUS, 0, ACCESS
A31C  337C     RRCF _PFNf_setKey, F, BANKED
1631:                  }
1632:              }
1633:          #endif
1634:              return c;
A354  517F     MOVF _PFNf_set_fnserw, W, BANKED
1635:          }
A356  0012     RETURN 0
1636:          //-------------------------------------------------------------------------
1637:          //sprawdz bity pzrzystosci
1638:          bit ChkParity1(unsigned char bt)
8F1C  0100     MOVLB 0x0
8F1E  6F78     MOVWF _PFNf_prn_pp, BANKED
1639:          {
1640:              BTY_VAL1 d;
1641:              d.war=bt;
8F20  C078     MOVFF _PFNf_prn_pp, _PFNf_prn_res
8F22  F079     NOP
1642:              if(d.b6==((d.b0^d.b1^d.b2^d.b4)?1:0))
8F24  AD79     BTFSS _PFNf_prn_res, 6, BANKED
8F26  D003     BRA 0x8F2E
8F28  6B74     CLRF _PFNf_prODP, BANKED
8F2A  2B74     INCF _PFNf_prODP, F, BANKED
8F2C  D002     BRA 0x8F32
8F2E  0100     MOVLB 0x0
8F30  6B74     CLRF _PFNf_prODP, BANKED
8F32  A979     BTFSS _PFNf_prn_res, 4, BANKED
8F34  D003     BRA 0x8F3C
8F36  6B75     CLRF _PFNf_prn_cs, BANKED
8F38  2B75     INCF _PFNf_prn_cs, F, BANKED
8F3A  D002     BRA 0x8F40
8F3C  0100     MOVLB 0x0
8F3E  6B75     CLRF _PFNf_prn_cs, BANKED
8F40  A579     BTFSS _PFNf_prn_res, 2, BANKED
8F42  D003     BRA 0x8F4A
8F44  6B76     CLRF _PFNf_prn_in, BANKED
8F46  2B76     INCF _PFNf_prn_in, F, BANKED
8F48  D002     BRA 0x8F4E
8F4A  0100     MOVLB 0x0
8F4C  6B76     CLRF _PFNf_prn_in, BANKED
8F4E  0E01     MOVLW 0x1
8F50  A379     BTFSS _PFNf_prn_res, 1, BANKED
8F52  0E00     MOVLW 0x0
8F54  6F77     MOVWF _PFNf_prn_pg, BANKED
8F56  0E01     MOVLW 0x1
8F58  A179     BTFSS _PFNf_prn_res, 0, BANKED
8F5A  0E00     MOVLW 0x0
8F5C  D829     RCALL PL410
8F5E  B4D8     BTFSC STATUS, 2, ACCESS
8F60  0E00     MOVLW 0x0
8F62  1974     XORWF _PFNf_prODP, W, BANKED
8F64  E123     BNZ 0x8FAC
1643:                  if(d.b7==((d.b1^d.b3^d.b4^d.b5)?0:1))
8F66  AF79     BTFSS _PFNf_prn_res, 7, BANKED
8F68  D003     BRA 0x8F70
8F6A  6B74     CLRF _PFNf_prODP, BANKED
8F6C  2B74     INCF _PFNf_prODP, F, BANKED
8F6E  D002     BRA 0x8F74
8F70  0100     MOVLB 0x0
8F72  6B74     CLRF _PFNf_prODP, BANKED
8F74  AB79     BTFSS _PFNf_prn_res, 5, BANKED
8F76  D003     BRA 0x8F7E
8F78  6B75     CLRF _PFNf_prn_cs, BANKED
8F7A  2B75     INCF _PFNf_prn_cs, F, BANKED
8F7C  D002     BRA 0x8F82
8F7E  0100     MOVLB 0x0
8F80  6B75     CLRF _PFNf_prn_cs, BANKED
8F82  A979     BTFSS _PFNf_prn_res, 4, BANKED
8F84  D003     BRA 0x8F8C
8F86  6B76     CLRF _PFNf_prn_in, BANKED
8F88  2B76     INCF _PFNf_prn_in, F, BANKED
8F8A  D002     BRA 0x8F90
8F8C  0100     MOVLB 0x0
8F8E  6B76     CLRF _PFNf_prn_in, BANKED
8F90  0E01     MOVLW 0x1
8F92  A779     BTFSS _PFNf_prn_res, 3, BANKED
8F94  0E00     MOVLW 0x0
8F96  6F77     MOVWF _PFNf_prn_pg, BANKED
8F98  0E01     MOVLW 0x1
8F9A  A379     BTFSS _PFNf_prn_res, 1, BANKED
8F9C  0E00     MOVLW 0x0
8F9E  D808     RCALL PL410
8FA0  A4D8     BTFSS STATUS, 2, ACCESS
8FA2  0E00     MOVLW 0x0
8FA4  1974     XORWF _PFNf_prODP, W, BANKED
8FA6  E102     BNZ 0x8FAC
1644:                      return 1;
8FA8  80D8     BSF STATUS, 0, ACCESS
8FAA  0012     RETURN 0
1645:              return 0;
8FAC  90D8     BCF STATUS, 0, ACCESS
1646:          }
8FAE  0012     RETURN 0
1647:          unsigned char iChkParity1(unsigned char bt)
92B6  6E19     MOVWF _LIN1f_FIN, ACCESS
1648:          {
1649:              BTY_VAL1 d;
1650:              d.war=bt;
92B8  C019     MOVFF _LIN1f_FIN, _LIN1f_FResp
92BA  F01A     NOP
1651:              if(d.b6==((d.b0^d.b1^d.b2^d.b4)?1:0))
92BC  AC1A     BTFSS _LIN1f_FResp, 6, ACCESS
92BE  D003     BRA 0x92C6
92C0  6A15     CLRF _LIN1f_Busy, ACCESS
92C2  2A15     INCF _LIN1f_Busy, F, ACCESS
92C4  D001     BRA 0x92C8
92C6  6A15     CLRF _LIN1f_Busy, ACCESS
92C8  A81A     BTFSS _LIN1f_FResp, 4, ACCESS
92CA  D003     BRA 0x92D2
92CC  6A16     CLRF _LIN1f_CHK, ACCESS
92CE  2A16     INCF _LIN1f_CHK, F, ACCESS
92D0  D001     BRA 0x92D4
92D2  6A16     CLRF _LIN1f_CHK, ACCESS
92D4  A41A     BTFSS _LIN1f_FResp, 2, ACCESS
92D6  D003     BRA 0x92DE
92D8  6A17     CLRF _LIN1f_ERRR, ACCESS
92DA  2A17     INCF _LIN1f_ERRR, F, ACCESS
92DC  D001     BRA 0x92E0
92DE  6A17     CLRF _LIN1f_ERRR, ACCESS
92E0  0E01     MOVLW 0x1
92E2  A21A     BTFSS _LIN1f_FResp, 1, ACCESS
92E4  0E00     MOVLW 0x0
92E6  6E18     MOVWF _LIN1f_FAdta, ACCESS
92E8  0E01     MOVLW 0x1
92EA  A01A     BTFSS _LIN1f_FResp, 0, ACCESS
92EC  0E00     MOVLW 0x0
92EE  D824     RCALL PL434
92F0  B4D8     BTFSC STATUS, 2, ACCESS
92F2  0E00     MOVLW 0x0
92F4  1815     XORWF _LIN1f_Busy, W, ACCESS
92F6  E11F     BNZ 0x9336
1652:                  if(d.b7==((d.b1^d.b3^d.b4^d.b5)?0:1))
92F8  AE1A     BTFSS _LIN1f_FResp, 7, ACCESS
92FA  D003     BRA 0x9302
92FC  6A15     CLRF _LIN1f_Busy, ACCESS
92FE  2A15     INCF _LIN1f_Busy, F, ACCESS
9300  D001     BRA 0x9304
9302  6A15     CLRF _LIN1f_Busy, ACCESS
9304  AA1A     BTFSS _LIN1f_FResp, 5, ACCESS
9306  D003     BRA 0x930E
9308  6A16     CLRF _LIN1f_CHK, ACCESS
930A  2A16     INCF _LIN1f_CHK, F, ACCESS
930C  D001     BRA 0x9310
930E  6A16     CLRF _LIN1f_CHK, ACCESS
9310  A81A     BTFSS _LIN1f_FResp, 4, ACCESS
9312  D003     BRA 0x931A
9314  6A17     CLRF _LIN1f_ERRR, ACCESS
9316  2A17     INCF _LIN1f_ERRR, F, ACCESS
9318  D001     BRA 0x931C
931A  6A17     CLRF _LIN1f_ERRR, ACCESS
931C  0E01     MOVLW 0x1
931E  A61A     BTFSS _LIN1f_FResp, 3, ACCESS
9320  0E00     MOVLW 0x0
9322  6E18     MOVWF _LIN1f_FAdta, ACCESS
9324  0E01     MOVLW 0x1
9326  A21A     BTFSS _LIN1f_FResp, 1, ACCESS
9328  0E00     MOVLW 0x0
932A  D806     RCALL PL434
932C  A4D8     BTFSS STATUS, 2, ACCESS
932E  0E00     MOVLW 0x0
9330  1815     XORWF _LIN1f_Busy, W, ACCESS
9332  E101     BNZ 0x9336
1653:                      return 1;
9334  0C01     RETLW 0x1
1654:              return 0;
1655:          }
9336  0C00     RETLW 0x0
1656:          
1657:          bit iAnalizeHeader(volatile unsigned char indeks)
A856  6E1B     MOVWF _LIN1f_FTrans, ACCESS
1658:          {
1659:              switch(indeks)
A858  D022     BRA 0xA89E
A89E  501B     MOVF _LIN1f_FTrans, W, ACCESS
A8A0  E0DC     BZ 0xA85A
A8A2  0A01     XORLW 0x1
A8A4  E0EC     BZ 0xA87E
A8A6  0A03     XORLW 0x3
A8A8  E0F0     BZ 0xA88A
1660:              {
1661:                  case 0:
1662:                  {
1663:                      if(!iChkParity1(bufRUART1[0]))
A85A  0102     MOVLB 0x2
A85C  5100     MOVF 0x0, W, BANKED
A85E  EC5B     CALL 0x92B6, 0
A860  F049     NOP
A862  0900     IORLW 0x0
A864  E102     BNZ 0xA86A
1664:                      {
1665:                          //indeks=13;
1666:                          return 0;
A866  90D8     BCF STATUS, 0, ACCESS
A868  0012     RETURN 0
1667:                      }
1668:                      if((((bufRUART1[0]&0b00111111)!=_PIF_WRITE)&&(bufRUART1[0]&0b00111111)!=_PIF_READ))
A86A  0102     MOVLB 0x2
A86C  5100     MOVF 0x0, W, BANKED
A86E  0B3F     ANDLW 0x3F
A870  06E8     DECF WREG, F, ACCESS
A872  E01B     BZ 0xA8AA
A874  5100     MOVF 0x0, W, BANKED
A876  0B3F     ANDLW 0x3F
A878  0A02     XORLW 0x2
A87A  E1F5     BNZ 0xA866
A87C  D016     BRA 0xA8AA
1669:                      {
1670:                          //indeks=14;
1671:                          return 0;
1672:                      }
1673:                      break;
1674:                  }
1675:                  case 1:
1676:                  {
1677:                      if(bufRUART1[1]&&(bufRUART1[1]!=_MY_NAD1))            //adres niezerowy i niezgodny?
A87E  0102     MOVLB 0x2
A880  5101     MOVF DtCOf_err_CO, W, BANKED
A882  E013     BZ 0xA8AA
A884  ECDE     CALL 0x57BC, 0
A886  F02B     NOP
A888  D7F8     BRA 0xA87A
1678:                      {
1679:                          //indeks=15;
1680:                          return 0;
1681:                      }
1682:                      break;
1683:                  }
1684:                  case 2:
1685:                  {
1686:                      UAD1t.RNData=3+(bufRUART1[2]&0x0F)+1;                 //PFI,NAD,PCI+liczba danych+CHK
A88A  0102     MOVLB 0x2
A88C  5102     MOVF LIN1f_Busy, W, BANKED
A88E  0B0F     ANDLW 0xF
A890  0F04     ADDLW 0x4
A892  0101     MOVLB 0x1
A894  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
1687:                      if(UAD1t.RNData>10)                                   //przekroczony maksymalny rozmiar ramki?
A896  0E0A     MOVLW 0xA
A898  6594     CPFSGT _RSDT1f_RRD_KNF, BANKED
A89A  D007     BRA 0xA8AA
A89C  D7E4     BRA 0xA866
1688:                      {
1689:                          //indeks=16;
1690:                          return 0;
1691:                      }
1692:                      break;
1693:                  }
1694:              }
1695:              return 1;
A8AA  80D8     BSF STATUS, 0, ACCESS
1696:          }
A8AC  0012     RETURN 0
1697:          /*
1698:          void iRestartRX(void)
1699:          {
1700:              RSerial1 = RCREG1;
1701:              UAD1t.RNData = 9;                                            //startowy, maksymalny rozmiar ramki
1702:              UAD1t.Rindeks = 0;                                           //wyzeruj indeks
1703:              UAD1tf_RFData = 0;                                            //usun znacznik odbioru danych
1704:              UAD1tf_RFEnd = 0;                                             //wyzeruj znacznik konca odbioru
1705:              UAD1tf_RFBrSn = 0;                                            //przygotuj znacznik oczekiwania na BREAk SYNCH
1706:          
1707:              UAD1t.tmB=0;                                                 //zeruj timer odbioru bajtu
1708:          
1709:              RCSTA1bits.CREN = 0;                                        //deaktywacja portu szeregowego
1710:              PIE1bits.RC1IE=0;                                           //deaktywacja przerwania odbioru
1711:          
1712:              UAD1tf_RFExt = 1;                                            //ustaw znacznik anulowania odbioru
1713:          }
1714:          */
1715:          //------------------------------------------------------------------------------------
1716:          //------------------------------------------------------------------------------------
1717:          //------------------------------------------------------------------------------------	
1718:          //Zegary LIN1 (umiescic w przerwaniu od timer3)
1719:          void IntLIN1Tim(void)
1720:          {
1721:              if(UAD1t.tmB<0xFFFF) UAD1t.tmB++;       //timer dla  bajtu (odbior)
B530  0101     MOVLB 0x1
B532  2998     INCF _UAD1tf_RFData, W, BANKED
B534  E102     BNZ 0xB53A
B536  2999     INCF _UAD1tf_RFEnd, W, BANKED
B538  E002     BZ 0xB53E
B53A  4B98     INFSNZ _UAD1tf_RFData, F, BANKED
B53C  2B99     INCF _UAD1tf_RFEnd, F, BANKED
1722:              if(UAD1t.tmFR<0xFFFF) UAD1t.tmFR++;     //timer dla ramki (odbior/nadawanie)
B53E  2996     INCF _RSDT1f_RespLIDN, W, BANKED
B540  E102     BNZ 0xB546
B542  2997     INCF _UAD1tf_RFBrSn, W, BANKED
B544  E002     BZ 0xB54A
B546  4B96     INFSNZ _RSDT1f_RespLIDN, F, BANKED
B548  2B97     INCF _UAD1tf_RFBrSn, F, BANKED
1723:              if(LIN1.tmAd<0xFFFF) LIN1.tmAd++;       //timer dla przetwarzania odebranej paczki
B54A  29A1     INCF _UADtf_RErrREC, W, BANKED
B54C  E102     BNZ 0xB552
B54E  29A2     INCF _UADtf_TData, W, BANKED
B550  E002     BZ 0xB556
B552  4BA1     INFSNZ _UADtf_RErrREC, F, BANKED
B554  2BA2     INCF _UADtf_TData, F, BANKED
1724:              if(LIN1.tmZw<0xFFFF) LIN1.tmZw++;       //timer dla minimalna zwloka przed wysylka odpowiedzi
B556  29A3     INCF _UADtf_TEXT, W, BANKED
B558  E103     BNZ 0xB560
B55A  29A4     INCF _UADtf_TEnd, W, BANKED
B55C  B4D8     BTFSC STATUS, 2, ACCESS
B55E  0012     RETURN 0
B560  4BA3     INFSNZ _UADtf_TEXT, F, BANKED
B562  2BA4     INCF _UADtf_TEnd, F, BANKED
1725:          }
B564  0012     RETURN 0
1726:          //------------------------------------------------------------------------------------	
1727:          //---------------------------------------------------------------------
1728:          //Odbior danych nadsylanych przez SLAVE (umiescic w przerwaniu od RX1)
1729:          /*
1730:          void IntUSART1SRC(void)
1731:          {
1732:              //if(UAD1tf_RFEnd)     //po odbiorze i
1733:              //{
1734:              //    RSerial1 = RCREG1;
1735:              //    return;
1736:              //}
1737:              if(RCSTA1bits.FERR||RCSTA1bits.OERR)
1738:              {
1739:                  #if _SYG_STN1==1
1740:                  _S_READ1=0;
1741:                  #endif
1742:                  RSerial1 = RCREG1;      //Wyzeruj RCSTA1bits.FERR
1743:                  RCSTA1bits.CREN = 0;    //Wyzeruj RCSTA1bits.OERR
1744:                  iRestartRX();
1745:                  return;
1746:              }
1747:          #if _SYG_STN1==1
1748:              _S_READ1=1;
1749:          #endif
1750:              RSerial1 = RCREG1;
1751:              UAD1t.tmB=0;                                             //zeruj timer odbioru bajtu
1752:              UAD1tf_RFData=1;
1753:              //--------------------
1754:              if(!UAD1tf_RFBrSn)                                        //oczekiwanie na BREAK i SYNCH
1755:              {
1756:                  UAD1t.Rindeks++;
1757:                  if(UAD1t.Rindeks>_RBREAK_SYNCH1)                       //pomin 2 pierwsze bajty
1758:                  {
1759:                      UAD1t.Rindeks=0;
1760:                      UAD1tf_RFBrSn=1;
1761:                  }else return;
1762:              }
1763:              //-------------------
1764:              if(UAD1t.Rindeks < _NRS_RBF1)                             //mozliwe przepelnienienie bufora odbioru?
1765:              {
1766:                  bufRUART1[UAD1t.Rindeks] = RSerial1;                  //zapamietaj dana w buforze od pozycji 0
1767:                  if(!iAnalizeHeader(UAD1t.Rindeks))                    //kontroluj parametry ramki
1768:                  {
1769:                      #if _SYG_STN1==1
1770:                          _S_READ1=0;
1771:                      #endif
1772:                      iRestartRX();
1773:                      return;
1774:                  }
1775:                  UAD1t.Rindeks++;
1776:                  if(UAD1t.Rindeks >= UAD1t.RNData)                     //ostatni bajt ramki?
1777:                  {
1778:                      RCSTA1bits.CREN = 0;
1779:                      PIE1bits.RC1IE=0;                                 //deaktywacja przerwania dla odbioru
1780:                      UAD1tf_RFData = 0;                                 //sygnalizuj deaktywacje odbioru danych
1781:                      UAD1tf_RFEnd = 1;                                  //ustaw znacznik ze odebrano kompletna paczke danych
1782:                      #if _SYG_STN1==1
1783:                          _S_READ1=0;
1784:                      #endif
1785:                  }
1786:              }
1787:              else
1788:              {
1789:                  #if _SYG_STN1==1
1790:                      _S_READ1=0;
1791:                  #endif
1792:                  iRestartRX();
1793:                  return;
1794:              }
1795:          }
1796:          */
1797:          void IntUSART1SRC(void)
1798:          {
1799:              if(RCSTA1bits.FERR||RCSTA1bits.OERR)
A0C0  B4AB     BTFSC RCSTA1, 2, ACCESS
A0C2  D002     BRA 0xA0C8
A0C4  A2AB     BTFSS RCSTA1, 1, ACCESS
A0C6  D007     BRA 0xA0D6
1800:              {
1801:                  RSerial1 = RCREG1;       //Wyzeruj RCSTA1bits.FERR
A0C8  CFAE     MOVFF RCREG1, RSerial1
A0CA  F0DF     NOP
1802:                  PIE1bits.RC1IE=0;       //deaktywacja przerwania odbioru
A0CC  9A9D     BCF PIE1, 5, ACCESS
1803:                  RCSTA1bits.CREN = 0;    //Wyzeruj RCSTA1bits.OERR
A0CE  98AB     BCF RCSTA1, 4, ACCESS
1804:                  LIN1ERR.BT=1;
A0D0  0100     MOVLB 0x0
A0D2  85D7     BSF LIN1ERR, 2, BANKED
1805:          #if _SYG_STN1==1
1806:                  _S_READ1=0;
1807:          #endif
1808:                  return;
A0D4  0012     RETURN 0
1809:              }
1810:          #if _SYG_STN1==1
1811:              _S_READ1=1;
1812:          #endif
1813:              RSerial1 = RCREG1;
A0D6  CFAE     MOVFF RCREG1, RSerial1
A0D8  F0DF     NOP
1814:              UAD1t.tmB=0;                                             //zeruj timer odbioru bajtu
A0DA  0101     MOVLB 0x1
A0DC  6B98     CLRF _UAD1tf_RFData, BANKED
A0DE  6B99     CLRF _UAD1tf_RFEnd, BANKED
1815:              UAD1tf_RFData=1;
A0E0  8013     BSF UAD1tf_RFData, 0, ACCESS
1816:              //--------------------
1817:              if(!UAD1tf_RFBrSn)                                        //oczekiwanie na BREAK i SYNCH
A0E2  BE12     BTFSC RSDT1f_RD_STD, 7, ACCESS
A0E4  D006     BRA 0xA0F2
1818:              {
1819:                  UAD1t.Rindeks++;
A0E6  2B92     INCF _RSDT1f_RD_LIN, F, BANKED
1820:                  if(UAD1t.Rindeks>_RBREAK_SYNCH1)                       //pomin 2 pierwsze bajty
A0E8  0E02     MOVLW 0x2
A0EA  6592     CPFSGT _RSDT1f_RD_LIN, BANKED
A0EC  0C02     RETLW 0x2
1821:                  {
1822:                      UAD1t.Rindeks=0;
A0EE  6B92     CLRF _RSDT1f_RD_LIN, BANKED
1823:                      UAD1tf_RFBrSn=1;
A0F0  8E12     BSF RSDT1f_RD_STD, 7, ACCESS
1824:                  }else return;
1825:              }
1826:              //-------------------
1827:              if(UAD1t.Rindeks < _NRS_RBF1)                             //mozliwe przepelnienienie bufora odbioru?
A0F2  0E0F     MOVLW 0xF
A0F4  6192     CPFSLT _RSDT1f_RD_LIN, BANKED
A0F6  D01A     BRA 0xA12C
1828:              {
1829:                  bufRUART1[UAD1t.Rindeks] = RSerial1;                   //zapamietaj dana w buforze od pozycji 0
A0F8  0E00     MOVLW 0x0
A0FA  2592     ADDWF _RSDT1f_RD_LIN, W, BANKED
A0FC  EC89     CALL 0x8F12, 0
A0FE  F047     NOP
A100  C0DF     MOVFF RSerial1, INDF2
A102  FFDF     NOP
1830:          
1831:                  if(!iAnalizeHeader(UAD1t.Rindeks))
A104  5192     MOVF _RSDT1f_RD_LIN, W, BANKED
A106  EC2B     CALL 0xA856, 0
A108  F054     NOP
A10A  E205     BC 0xA116
1832:                  {
1833:                      RCSTA1bits.CREN = 0;
A10C  98AB     BCF RCSTA1, 4, ACCESS
1834:                      PIE1bits.RC1IE=0;                                   //deaktywacja przerwania odbioru
A10E  9A9D     BCF PIE1, 5, ACCESS
1835:                      UAD1tf_RFData = 0;                                  //sygnalizuj deaktywacje odbioru danych
A110  9013     BCF UAD1tf_RFData, 0, ACCESS
1836:                      UAD1tf_RFExt = 1;                                   //ustaw znacznik anulowania odbioru
A112  8413     BSF UAD1tf_RFData, 2, ACCESS
1837:                      #if _SYG_STN1==1
1838:                          _S_READ1=0;
1839:                      #endif
1840:                      return;
A114  0012     RETURN 0
1841:                  }
1842:                  UAD1t.Rindeks++;
A116  0101     MOVLB 0x1
A118  2B92     INCF _RSDT1f_RD_LIN, F, BANKED
1843:                  if(UAD1t.Rindeks >= UAD1t.RNData)                     //ostatni bajt ramki?
A11A  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
A11C  5D92     SUBWF _RSDT1f_RD_LIN, W, BANKED
A11E  A0D8     BTFSS STATUS, 0, ACCESS
A120  0012     RETURN 0
1844:                  {
1845:                      RCSTA1bits.CREN = 0;
A122  98AB     BCF RCSTA1, 4, ACCESS
1846:                      PIE1bits.RC1IE=0;                   //deaktywacja przerwania odbioru
A124  9A9D     BCF PIE1, 5, ACCESS
1847:                      UAD1tf_RFData = 0;                                 //sygnalizuj deaktywacje odbioru danych
A126  9013     BCF UAD1tf_RFData, 0, ACCESS
1848:                      UAD1tf_RFEnd = 1;                                  //ustaw znacznik ze odebrano kompletna paczke danych
A128  8213     BSF UAD1tf_RFData, 1, ACCESS
A12A  0012     RETURN 0
1849:                      #if _SYG_STN1==1
1850:                          _S_READ1=0;
1851:                      #endif
1852:                  }
1853:              }
1854:              else
1855:              {
1856:                  LIN1ERR.BUF=1;                    //blad przepelnienia bufora
A12C  0100     MOVLB 0x0
A12E  8DD7     BSF LIN1ERR, 6, BANKED
1857:                  RCSTA1bits.CREN = 0;
A130  EF00     GOTO 0xC200
A132  F061     NOP
1858:                  PIE1bits.RC1IE=0;                   //deaktywacja przerwania odbioru
1859:                  #if _SYG_STN1==1
1860:                      _S_READ1=0;
1861:                  #endif
1862:              }
1863:          }
1864:           
1865:          //------------------------------------------------------------------------------------
1866:          
1867:          //---------------------------------------------------------------------
1868:          //Transmisja danych do SLAVE (umiescic w przerwaniu od TX1)
1869:          void IntUSART1STR(void)
1870:          {
1871:              if(UAD1t.Tindeks>=_NRS_TBF1) return;
BAC8  0E0E     MOVLW 0xE
BACA  0101     MOVLB 0x1
BACC  6593     CPFSGT _RSDT1f_RD_STD, BANKED
BACE  D001     BRA 0xBAD2
BAD0  0C0E     RETLW 0xE
1872:              TXREG1=bufTUART1[UAD1t.Tindeks++];	//rozpoczyna transmisje
BAD2  0E51     MOVLW 0x51
BAD4  2593     ADDWF _RSDT1f_RD_STD, W, BANKED
BAD6  ECA9     CALL 0xB752, 0
BAD8  F05B     NOP
BADA  50DF     MOVF INDF2, W, ACCESS
BADC  6EAD     MOVWF TXREG1, ACCESS
BADE  2B93     INCF _RSDT1f_RD_STD, F, BANKED
1873:              if(UAD1t.Tindeks>=UAD1t.TNData)
BAE0  5195     MOVF _RSDT1f_RRD_STD, W, BANKED
BAE2  5D93     SUBWF _RSDT1f_RD_STD, W, BANKED
BAE4  A0D8     BTFSS STATUS, 0, ACCESS
BAE6  0012     RETURN 0
1874:              {
1875:                  UAD1tf_TFEnd=1;                            //ustaw znacznik zakonczenia wysylki ramki
BAE8  8813     BSF UAD1tf_RFData, 4, ACCESS
1876:                                                            //UWAGA: transmisja trwa!
1877:                  PIE1bits.TX1IE=0;                         //deaktywacja przerwania od transmisji
BAEA  989D     BCF PIE1, 4, ACCESS
1878:              }
1879:          }
BAEC  0012     RETURN 0
1880:          //---------------------------------------------------------------------
1881:          //---------------------------------------------------------------------
1882:          //---------------------------------------------------------------------
1883:          //Liczy CHK elementow tablicy tab poczynajac od indeksu start a konczac na stop
1884:          unsigned char CalcTabCHK(unsigned char *tab, unsigned int start, unsigned int stop)
1885:          {
1886:              unsigned int i;
1887:              unsigned char j,c,d,s;
1888:              c=0x00;
AAB2  0100     MOVLB 0x0
AAB4  6B7F     CLRF _PFNf_set_fnserw, BANKED
1889:          
1890:              //CRC-8 Dallas/Maxim
1891:              for(i=start;i<=stop;i++)
AAB6  C076     MOVFF _PFNf_prn_in, _PFNf_setKey
AAB8  F07C     NOP
AABA  C077     MOVFF _PFNf_prn_pg, _PFNf_set_aleg
AABC  F07D     NOP
AABE  D01B     BRA 0xAAF6
AAF2  4B7C     INFSNZ _PFNf_setKey, F, BANKED
AAF4  2B7D     INCF _PFNf_set_aleg, F, BANKED
AAF6  517C     MOVF _PFNf_setKey, W, BANKED
AAF8  5D78     SUBWF _PFNf_prn_pp, W, BANKED
AAFA  517D     MOVF _PFNf_set_aleg, W, BANKED
AAFC  5979     SUBWFB _PFNf_prn_res, W, BANKED
AAFE  E2E0     BC 0xAAC0
1892:              {
1893:                  d=tab[i];
AAC0  517C     MOVF _PFNf_setKey, W, BANKED
AAC2  2574     ADDWF _PFNf_prODP, W, BANKED
AAC4  6ED9     MOVWF FSR2, ACCESS
AAC6  517D     MOVF _PFNf_set_aleg, W, BANKED
AAC8  2175     ADDWFC _PFNf_prn_cs, W, BANKED
AACA  6EDA     MOVWF FSR2H, ACCESS
AACC  50DF     MOVF INDF2, W, ACCESS
AACE  6F7B     MOVWF _PFNf_rozruch, BANKED
1894:                  for(j=8;j>0;j--)
AAD0  0E08     MOVLW 0x8
AAD2  6F7E     MOVWF _PFNf_set_eco, BANKED
AAEC  077E     DECF _PFNf_set_eco, F, BANKED
AAEE  517E     MOVF _PFNf_set_eco, W, BANKED
AAF0  E1F1     BNZ 0xAAD4
1895:                  {
1896:                      s=(c^d)&0x01;
AAD4  517F     MOVF _PFNf_set_fnserw, W, BANKED
AAD6  197B     XORWF _PFNf_rozruch, W, BANKED
AAD8  0B01     ANDLW 0x1
AADA  6F7A     MOVWF _PFNf_res, BANKED
1897:                      c>>=1;
AADC  90D8     BCF STATUS, 0, ACCESS
AADE  337F     RRCF _PFNf_set_fnserw, F, BANKED
1898:                      if(s) c^=0x8c;
AAE0  517A     MOVF _PFNf_res, W, BANKED
AAE2  E002     BZ 0xAAE8
AAE4  0E8C     MOVLW 0x8C
AAE6  1B7F     XORWF _PFNf_set_fnserw, F, BANKED
1899:                      d>>=1;
AAE8  90D8     BCF STATUS, 0, ACCESS
AAEA  337B     RRCF _PFNf_rozruch, F, BANKED
1900:                  }
1901:              }
1902:              return c;
AB00  517F     MOVF _PFNf_set_fnserw, W, BANKED
1903:          }
AB02  0012     RETURN 0
1904:          #endif      //(_EXT_BOARD>=2)
---  C:/praca/PICC/T02_T03/UNI-02/PLCD_T03/v11_11/KNF/T03_LCD_BOARD.EXT2PGD/LIN1SInterpreter.c  ---------
1:             /*LIN1SInterpreter.c*/
2:             /*Reakcja na odpowiedz SLAVE*/
3:             //#include <pic18.h>
4:             #include <xc.h>
5:             #include <stdio.h>
6:             #include "global.h"			//parametry globalne
7:             #include "wersja.h"			//parametry globalne
8:             #include "main.tp.h"			
9:             #if (_EXT_BOARD>=2)                     //aktywowany modul LIN1SLAVE?
10:            
11:            #include "LIN1SInterpreter.h"
12:            #include "amgs_rs9b.h"
13:            #include "konfig3.h"
14:            #include "ot.tp.h"
15:            
16:            extern volatile unsigned char stbf[32];
17:            extern unsigned char tbuf[];
18:            extern FRAME_LIN1 FRL1,FTL1;
19:            extern tpRSDTA1 RSDT1;
20:            extern CDtPZK CPZK[];
21:            extern volatile CMSG_PAR CMSGPar;
22:            extern volatile tpOTMaster OTMaster;
23:            extern volatile DataPFN PFN;
24:            //unsigned char ccc;
25:            //------------------------------------------------------------
26:            //------------------------------------------------------------
27:            //******************************** POLECENIE WYKONANIA POLECENIA/ZAPISU DANYCH OTRZYMANYCH Z MASTER **************************************
28:            //------------------------------------------------------------
29:            //------------------------------------------------------------
30:            //SINGLE RESPONSE
31:            //Interpretacja komendy i odebranych danych
32:            //UWAGA: zwrot wartosci _LIN1_IBUSY sygnalizuje trwanie procesu (maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA)
33:            unsigned char LIN1SingleResponse_WR(void)
34:            {
35:                static unsigned char krok,bidn;
36:            
37:                BitSet2(&RSDT1.inLNSTAT,_FLIN,1);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
40AE  0E7C     MOVLW 0x7C
40B0  ECF1     CALL 0x31E2, 0
40B2  F018     NOP
40B4  EC6D     CALL 0xACDA, 0
40B6  F056     NOP
38:                PFNf_FLIN=1;
40B8  8A05     BSF PFNf_KnfDisErr, 5, ACCESS
39:                StartRTdS(_RTFLIN);    
40BA  0E08     MOVLW 0x8
40BC  EC55     CALL 0xBCAA, 0
40BE  F05E     NOP
40:                if(FRL1f_RSFrame)                 //ramka nadeslana z modulu Wifi?
40C0  A002     BTFSS LIN1f_Busy, 0, ACCESS
40C2  D005     BRA 0x40CE
41:                {
42:                    if(!RSFInterpreter_SingleWR()) return _LIN1_UNCCOM;       
40C4  EC49     CALL 0x8092, 0
40C6  F040     NOP
40C8  0900     IORLW 0x0
40CA  E101     BNZ 0x40CE
40CC  0C01     RETLW 0x1
43:                }
44:                //----------------
45:                if(bidn!=FRL1.IDN)                      //przy zmianie komendy zeruj stan procedury bezposredniej komunikacji z UNI-02
40CE  0101     MOVLB 0x1
40D0  51B2     MOVF 0xB2, W, BANKED
40D2  0100     MOVLB 0x0
40D4  19B5     XORWF 0xB5, W, BANKED
40D6  E101     BNZ 0x40DA
40D8  D1A4     BRA 0x4422
46:                {
47:                    bidn=FRL1.IDN;
40DA  C0B5     MOVFF 0xB5, bidn
40DC  F1B2     NOP
48:                    krok=0;
40DE  0101     MOVLB 0x1
40E0  6BB3     CLRF 0xB3, BANKED
40E2  D19F     BRA 0x4422
49:                }
50:                //komenda na ktora nastapila reakcja ukladu SLAVE
51:                switch(FRL1.IDN)                        //identyfikator komendy
4422  0100     MOVLB 0x0
52:                {
53:                    case _CLIN_WRD_LADDR:                //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1)
54:                    case _CLIN_WRD_LIFADDR:              //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1) po spelnieniu warunku
55:                    {
56:                        if((FRL1.IDN!=_CLIN_WRD_LADDR)) PFNf_fshowLaddr=0;
40E4  05B5     DECF 0xB5, W, BANKED
40E6  E04F     BZ 0x4186
40E8  920B     BCF PFNf_lato, 1, ACCESS
40EA  D04D     BRA 0x4186
57:                        //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
58:                        switch(krok)
4186  0101     MOVLB 0x1
4188  51B3     MOVF 0xB3, W, BANKED
418A  E0B0     BZ 0x40EC
418C  0A01     XORLW 0x1
418E  E0B6     BZ 0x40FC
4190  0A03     XORLW 0x3
4192  E0E5     BZ 0x415E
4194  0A01     XORLW 0x1
4196  E0EC     BZ 0x4170
59:                        {
60:                            case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
61:                                if(!LINWaitForAnswerUNI02(_LIN_SADR)) return _LIN1_IBUSY;
40EC  0E7F     MOVLW 0x7F
40EE  ECAE     CALL 0xB75C, 0
40F0  F05B     NOP
40F2  0900     IORLW 0x0
40F4  E101     BNZ 0x40F8
40F6  0CFF     RETLW 0xFF
62:                                krok++;
40F8  0101     MOVLB 0x1
40FA  2BB3     INCF 0xB3, F, BANKED
63:                            case 1:         //1.Wysylka komendy do UNI-02
64:                            {
65:                                //wstepny warunek
66:                                if((FRL1.IDN==_CLIN_WRD_LIFADDR))  //warunkowe przypisanie adresu odbiornikowi z adresem neutralnym?
40FC  0E02     MOVLW 0x2
40FE  0100     MOVLB 0x0
4100  19B5     XORWF 0xB5, W, BANKED
4102  E11B     BNZ 0x413A
67:                                {
68:                                    PFNf_fsetLaddr=1;               //ustaw tryb wyswietlania adresu lin
4104  800B     BSF PFNf_lato, 0, ACCESS
69:                                    StartRTdS(_RTALIN);             //timer do autowyjscia z trybu
4106  0E0A     MOVLW 0xA
4108  EC55     CALL 0xBCAA, 0
410A  F05E     NOP
70:            #if _KEY_BBOARD==0                         
71:                                    if(PFNf_setKey&&RdPrt(S_SET))   //przytrzymany przycisk SET?
72:                                    {
73:                                        return _LIN1_NORESP;        //zignoruj polecenie
74:                                    }
75:            #endif
76:            #if _KEY_BBOARD==1                         
77:                                    if(PFNf_setKey&&RdPrt(S_KOM))   //przytrzymany przycisk KOM?
410C  A80F     BTFSS PFNf_set_fnserw, 4, ACCESS
410E  D005     BRA 0x411A
4110  0E02     MOVLW 0x2
4112  EC02     CALL 0xBA04, 0
4114  F05D     NOP
4116  E301     BNC 0x411A
78:                                    {
79:                                        return _LIN1_NORESP;        //zignoruj polecenie
4118  0CF0     RETLW 0xF0
80:                                    }
81:            #endif                        
82:                                    //warunek dla _CLIN_WRD_LIFADR
83:            #if _KEY_BBOARD==0                         
84:                                    if(!RdPrt(S_SET))               //puszczony przycisk SET?
85:                                    {
86:                                        PFNf_setKey=0;
87:                                        return _LIN1_NORESP;        //zignoruj polecenie
88:                                    }
89:            #endif
90:            #if _KEY_BBOARD==1                         
91:                                    if(!RdPrt(S_KOM))               //puszczony przycisk KOM?
411A  0E02     MOVLW 0x2
411C  EC02     CALL 0xBA04, 0
411E  F05D     NOP
4120  E202     BC 0x4126
92:                                    {
93:                                        PFNf_setKey=0;
4122  980F     BCF PFNf_set_fnserw, 4, ACCESS
4124  0CF0     RETLW 0xF0
94:                                        return _LIN1_NORESP;        //zignoruj polecenie
95:                                    }
96:            #endif                        
97:                                    PFNf_setKey=1;                  //nacisniety przycisk SET - wykonaj polecenie
4126  880F     BSF PFNf_set_fnserw, 4, ACCESS
98:                                    if(PFN.ALIN==FRL1.WRD1.byte0)   //adres zgodny z parametrem1?
4128  51BC     MOVF 0xBC, W, BANKED
412A  0101     MOVLB 0x1
412C  19ED     XORWF 0xED, W, BANKED
412E  E105     BNZ 0x413A
99:                                    {
100:                                       if(FRL1.NAD) return _LIN1_IFINAL;
4130  0100     MOVLB 0x0
4132  51AF     MOVF 0xAF, W, BANKED
4134  B4D8     BTFSC STATUS, 2, ACCESS
4136  0CF0     RETLW 0xF0
4138  0C00     RETLW 0x0
101:                                       else return _LIN1_NORESP;
102:                                   }
103:                               }
104:                               //komendy i parametry wywolania dla UNI-02
105:                               RSDT1.inLIDN=_LIN_SADR;             //komenda
413A  0E7F     MOVLW 0x7F
413C  D9B6     RCALL PL440
106:                               RSDT1.inLDTA1=FRL1.WRD1.byte0;      //parametr1
107:                               
108:                               //start wywolania
109:                               if(!FRL1.NAD) FRL1f_ZeroAdr=1;
413E  0100     MOVLB 0x0
4140  51AF     MOVF 0xAF, W, BANKED
4142  E102     BNZ 0x4148
4144  8402     BSF LIN1f_Busy, 2, ACCESS
4146  D001     BRA 0x414A
110:                               else FRL1f_ZeroAdr=0;
4148  9402     BCF LIN1f_Busy, 2, ACCESS
111:                               RSDT1f_NewLIDN=1;
414A  ECF9     CALL 0x31F2, 0
414C  F018     NOP
112:                               RSDT1.ACKUNI=0;
113:                               FRL1f_NextFr=0;
114:                               krok++;
414E  2BB3     INCF 0xB3, F, BANKED
4150  D006     BRA 0x415E
115:                           }
116:                           case 2:         //2.Oczekiwanie na odpowiedz
117:                           {
118:                               switch(LINWaitForAnswerUNI02(_LIN_SADR))
415E  0E7F     MOVLW 0x7F
4160  ECAE     CALL 0xB75C, 0
4162  F05B     NOP
4164  0A00     XORLW 0x0
4166  B4D8     BTFSC STATUS, 2, ACCESS
4168  0CFF     RETLW 0xFF
416A  0A01     XORLW 0x1
416C  E0F2     BZ 0x4152
416E  D7F4     BRA 0x4158
119:                               {
120:                                   case 0:
121:                                       return _LIN1_IBUSY;
122:                                   case 1:
123:                                       krok++;
4152  0101     MOVLB 0x1
4154  2BB3     INCF 0xB3, F, BANKED
124:                                       break;
4156  D00C     BRA 0x4170
125:                                   default:
126:                                       krok=0;
4158  0101     MOVLB 0x1
415A  6BB3     CLRF 0xB3, BANKED
127:                                       return _LIN1_ERRODP;
415C  0C05     RETLW 0x5
128:                               }
129:                           }
130:                           case 3:         //3.Przygotowanie danych dla LIN
131:                           {
132:                               krok=0;
4170  6BB3     CLRF 0xB3, BANKED
133:                               if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
4172  B402     BTFSC LIN1f_Busy, 2, ACCESS
4174  0CF0     RETLW 0xF0
134:                               if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
4176  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
4178  0C05     RETLW 0x5
135:                               {
136:                                   if(RSDT1.outLDTA1!=RSDT1.inLDTA1)                               //kontrlola wykonania polecenia przez UNI-02
417A  0102     MOVLB 0x2
417C  51A1     MOVF _UADtf_RErrREC, W, BANKED
417E  1972     XORWF _PFNf_pobRT, W, BANKED
4180  B4D8     BTFSC STATUS, 2, ACCESS
4182  0C00     RETLW 0x0
4184  0C05     RETLW 0x5
137:                                   {
138:                                       return _LIN1_ERRODP;
139:                                   }
140:                               }
141:                               else                                                                //aktualizowano ramke - odpowiedz negatywna
142:                               {
143:                                   return _LIN1_ERRODP;
144:                               }
145:                           }
146:                       }
147:                       break;
4198  0C00     RETLW 0x0
148:                   }
149:                   case _CLIN_WRD_SHOWADDR:    //wyswietl adres LIN
150:                   {
151:                       if(!PFNf_fsetLaddr)
419A  B00B     BTFSC PFNf_lato, 0, ACCESS
419C  D005     BRA 0x41A8
152:                       {
153:                           PFNf_fshowLaddr=1;                  //ustaw tryb wyswietlania adresu lin
419E  820B     BSF PFNf_lato, 1, ACCESS
154:                           StartRTdS(_RTALIN);                 //timer do autowyjscia z trybu
41A0  0E0A     MOVLW 0xA
41A2  EC55     CALL 0xBCAA, 0
41A4  F05E     NOP
155:                       }
41A6  D001     BRA 0x41AA
156:                       else PFNf_fshowLaddr=0;
41A8  920B     BCF PFNf_lato, 1, ACCESS
157:                       if(!FRL1.NAD) return _LIN1_NORESP;
41AA  51AF     MOVF 0xAF, W, BANKED
41AC  A4D8     BTFSS STATUS, 2, ACCESS
41AE  0C00     RETLW 0x0
41B0  0CF0     RETLW 0xF0
158:                       break;
159:                   }
160:                   case _CLIN_WRD_PULSE:   //pulsacja podswietlenia
161:                   {
162:                       switch(FRL1.WRD1.byte0)
41C8  51BC     MOVF 0xBC, W, BANKED
41CA  E0F3     BZ 0x41B2
41CC  0A01     XORLW 0x1
41CE  E0F3     BZ 0x41B6
41D0  D7F8     BRA 0x41C2
163:                       {
164:                           case 0: //wylacz pulsacje
165:                           {
166:                               PFNf_fshowLpulse=0;            //ustaw tryb wyswietlania adresu lin
41B2  940B     BCF PFNf_lato, 2, ACCESS
41B4  D007     BRA 0x41C4
167:                               PFNf_foneLpulse=0;             //ustaw tryb wyswietlania adresu lin
168:                               break;
169:                           }
170:                           case 1: //wlacz pulsacje z autowygaszeniem
171:                           {
172:                               if((!PFNf_fshowLpulse)||(!PFNf_foneLpulse));            //ustaw tryb wyswietlania adresu lin
173:                               {
174:                                   PFNf_fshowLpulse=1;                 //ustaw tryb pulsaacji podswietlenia
41B6  840B     BSF PFNf_lato, 2, ACCESS
175:                                   PFNf_foneLpulse=1;
41B8  8E0A     BSF PFNf_firstEdge, 7, ACCESS
176:                                   StartRTdS(_RTALIN);                 //timer do autowyjscia z trybu pulsacji podswietlenia
41BA  0E0A     MOVLW 0xA
41BC  EC55     CALL 0xBCAA, 0
41BE  F05E     NOP
177:                               }
178:                               break;
41C0  D7F4     BRA 0x41AA
179:                           }
180:                           default: //wlacz ciagla pulsacje
181:                           {
182:                               PFNf_fshowLpulse=1;            //ustaw tryb wyswietlania adresu lin
41C2  840B     BSF PFNf_lato, 2, ACCESS
183:                               PFNf_foneLpulse=0;
41C4  9E0A     BCF PFNf_firstEdge, 7, ACCESS
184:                               break;
41C6  D7F1     BRA 0x41AA
185:                           }
186:                       }
187:                       if(!FRL1.NAD) return _LIN1_NORESP;
188:                       break;
189:                   }
190:                   case _CLIN_WRD_PCW:     //zmiana nastawy CW
191:                   {
192:                       if(!PFNf_EnAleg)
41D2  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
41D4  D013     BRA 0x41FC
193:                       {
194:                           if((FRL1.WRD1.byte0>=PFN.minPCW)&&(FRL1.WRD1.byte0<=PFN.maxPCW))
41D6  D97B     RCALL PL628
41D8  51EA     MOVF __pdataBANK0, W, BANKED
41DA  0100     MOVLB 0x0
41DC  5D7B     SUBWF _PFNf_rozruch, W, BANKED
41DE  0101     MOVLB 0x1
41E0  51EB     MOVF k, W, BANKED
41E2  0100     MOVLB 0x0
41E4  597C     SUBWFB _PFNf_setKey, W, BANKED
41E6  A0D8     BTFSS STATUS, 0, ACCESS
41E8  0C05     RETLW 0x5
41EA  51BC     MOVF 0xBC, W, BANKED
41EC  6F7B     MOVWF _PFNf_rozruch, BANKED
41EE  D94D     RCALL PL368
41F0  A0D8     BTFSS STATUS, 0, ACCESS
41F2  0C05     RETLW 0x5
195:                           {
196:                               PFN.PCW=(unsigned int)FRL1.WRD1.byte0;
41F4  C0BC     MOVFF 0xBC, 0x1F0
41F6  F1F0     NOP
41F8  6BF1     CLRF 0xF1, BANKED
197:                           }
41FA  0C00     RETLW 0x0
198:                           else return _LIN1_ERRODP;
199:                       }
200:                       else
201:                       {
202:                           if((FRL1.WRD1.byte0>=PFN.minPCW-1)&&(FRL1.WRD1.byte0<=PFN.maxPCW))
41FC  697B     SETF _PFNf_rozruch, BANKED
41FE  697C     SETF _PFNf_setKey, BANKED
4200  EE21     LFSR 2, 0x1EA
4202  F0EA     NOP
4204  CFDE     MOVFF POSTINC2, _PFNf_set_aleg
4206  F07D     NOP
4208  CFDD     MOVFF POSTDEC2, _PFNf_set_eco
420A  F07E     NOP
420C  517B     MOVF _PFNf_rozruch, W, BANKED
420E  277D     ADDWF _PFNf_set_aleg, F, BANKED
4210  517C     MOVF _PFNf_setKey, W, BANKED
4212  237E     ADDWFC _PFNf_set_eco, F, BANKED
4214  51BC     MOVF 0xBC, W, BANKED
4216  6F7F     MOVWF _PFNf_set_fnserw, BANKED
4218  6B80     CLRF _PFNf_set_nco, BANKED
421A  517D     MOVF _PFNf_set_aleg, W, BANKED
421C  5D7F     SUBWF _PFNf_set_fnserw, W, BANKED
421E  517E     MOVF _PFNf_set_eco, W, BANKED
4220  5980     SUBWFB _PFNf_set_nco, W, BANKED
4222  A0D8     BTFSS STATUS, 0, ACCESS
4224  0C05     RETLW 0x5
4226  51BC     MOVF 0xBC, W, BANKED
4228  6F7B     MOVWF _PFNf_rozruch, BANKED
422A  D92F     RCALL PL368
422C  E2E3     BC 0x41F4
422E  0C05     RETLW 0x5
203:                           {
204:                               PFN.PCW=(unsigned int)FRL1.WRD1.byte0;
205:                           }
206:                           else return _LIN1_ERRODP;
207:                       }                
208:                       break;
209:                   }  
210:                   case _CLIN_WRD_PCO:     //zmiana nastawy CO
211:                   {
212:                       if((FRL1.WRD1.byte0>=PFN.minPCO)&&(FRL1.WRD1.byte0<=PFN.maxPCO))
4230  D94E     RCALL PL628
4232  51E6     MOVF 0xE6, W, BANKED
4234  0100     MOVLB 0x0
4236  5D7B     SUBWF _PFNf_rozruch, W, BANKED
4238  0101     MOVLB 0x1
423A  51E7     MOVF 0xE7, W, BANKED
423C  0100     MOVLB 0x0
423E  597C     SUBWFB _PFNf_setKey, W, BANKED
4240  A0D8     BTFSS STATUS, 0, ACCESS
4242  0C05     RETLW 0x5
4244  51BC     MOVF 0xBC, W, BANKED
4246  6F7B     MOVWF _PFNf_rozruch, BANKED
4248  6B7C     CLRF _PFNf_setKey, BANKED
424A  517B     MOVF _PFNf_rozruch, W, BANKED
424C  0101     MOVLB 0x1
424E  5DE4     SUBWF 0xE4, W, BANKED
4250  0100     MOVLB 0x0
4252  517C     MOVF _PFNf_setKey, W, BANKED
4254  0101     MOVLB 0x1
4256  59E5     SUBWFB 0xE5, W, BANKED
4258  A0D8     BTFSS STATUS, 0, ACCESS
425A  0C05     RETLW 0x5
213:                       {
214:                           PFN.PCO=(unsigned int)FRL1.WRD1.byte0;
425C  C0BC     MOVFF 0xBC, 0x1EE
425E  F1EE     NOP
4260  6BEF     CLRF 0xEF, BANKED
215:                       }
4262  0C00     RETLW 0x0
216:                       else return _LIN1_ERRODP;
217:                       break;
218:                   }
219:                   case _CLIN_WRD_ECO:     //zmiana nastawy ECO
220:                   {
221:                       if((FRL1.WRD1.byte0>=1)&&(FRL1.WRD1.byte0<=9))
4264  51BC     MOVF 0xBC, W, BANKED
4266  B4D8     BTFSC STATUS, 2, ACCESS
4268  0C05     RETLW 0x5
426A  0E0A     MOVLW 0xA
426C  61BC     CPFSLT 0xBC, BANKED
426E  0C05     RETLW 0x5
222:                       {
223:                           PFN.ECO=(unsigned int)FRL1.WRD1.byte0;
4270  C0BC     MOVFF 0xBC, 0x1F2
4272  F1F2     NOP
4274  0101     MOVLB 0x1
4276  6BF3     CLRF 0xF3, BANKED
224:                       }
4278  0C00     RETLW 0x0
225:                       else return _LIN1_ERRODP;
226:                       break;
227:                   }  
228:                   case _CLIN_WRD_TRB:     //zmiana trybu pracy
229:                   {
230:                       //ccc=FRL1.WRD1.byte0;
231:                       if(FRL1.WRD1.byte0<=2)
427A  0E03     MOVLW 0x3
427C  61BC     CPFSLT 0xBC, BANKED
427E  0C05     RETLW 0x5
232:                       {
233:                           if(FRL1.WRD1.byte0==2)
4280  0E02     MOVLW 0x2
4282  19BC     XORWF 0xBC, W, BANKED
4284  E102     BNZ 0x428A
234:                           {
235:                               PFNf_off=1;                                     //tryb OFF
4286  8A0C     BSF PFNf_off, 5, ACCESS
236:                           }
4288  0C00     RETLW 0x0
237:                           else
238:                           if(FRL1.WRD1.byte0==1)
428A  05BC     DECF 0xBC, W, BANKED
428C  E104     BNZ 0x4296
239:                           {
240:                               PFNf_off=0;
428E  9A0C     BCF PFNf_off, 5, ACCESS
241:                               PFNf_lato=1;                                    //tryb LATO
4290  880B     BSF PFNf_lato, 4, ACCESS
242:                               PFNf_zima=0;
4292  9811     BCF PFNf_zima, 4, ACCESS
243:                           }
4294  0C00     RETLW 0x0
244:                           else
245:                           {
246:                               PFNf_off=0;
4296  9A0C     BCF PFNf_off, 5, ACCESS
247:                               PFNf_lato=0;                                    
4298  980B     BCF PFNf_lato, 4, ACCESS
248:                               PFNf_zima=1;                                    //tryb ZIMA
429A  8811     BSF PFNf_zima, 4, ACCESS
429C  0C00     RETLW 0x0
249:                           }
250:                       }
251:                       else return _LIN1_ERRODP;
252:                       break;
253:                   }
254:                   case _CLIN_WRD_RES:      //aktywowac przycisk RESET?
255:                   {
256:                       PFNf_res=1;
429E  840F     BSF PFNf_set_fnserw, 2, ACCESS
257:                       SetPrt(S_OFF,1);
42A0  0E01     MOVLW 0x1
42A2  6F74     MOVWF _PFNf_prODP, BANKED
42A4  0E00     MOVLW 0x0
42A6  ECDC     CALL 0xADB8, 0
42A8  F056     NOP
258:                       PFNf_set_nco=0;
42AA  9010     BCF PFNf_str_nco, 0, ACCESS
42AC  D903     RCALL PL460
259:                       PFNf_set_ncw=0;
260:                       PFNf_str_nco=0;
261:                       PFNf_str_ncw=0;
262:                       PFNf_mod_ncw=0;
263:                       PFNf_set_eco=0;
264:                       PFNf_mod_eco=0;
265:                       PFNf_prn_res=0;
42AE  920F     BCF PFNf_set_fnserw, 1, ACCESS
266:                       PFNf_set_fnserw=0;
42B0  9E0F     BCF PFNf_set_fnserw, 7, ACCESS
267:                       PFNf_fnserw=0;
42B2  9C0A     BCF PFNf_firstEdge, 6, ACCESS
268:                       PFNf_set_aleg=0;
42B4  D04B     BRA 0x434C
269:                       PFNf_aleg=0;            
42B6  9208     BCF PFNf_b_set_nco, 1, ACCESS
270:                       break;
42B8  0C00     RETLW 0x0
271:                   }          
272:                   case _CLIN_WRD_BRES:      //usunac blokade awaryjna?
273:                   {
274:                       if(PFNf_opgres)       //wylaczenie awaryjne?
42BA  A80D     BTFSS PFNf_plmCO, 4, ACCESS
42BC  D005     BRA 0x42C8
275:                       {
276:                           if(FRL1.WRD1.byte0==0xAA)
42BE  0EAA     MOVLW 0xAA
42C0  19BC     XORWF 0xBC, W, BANKED
42C2  E102     BNZ 0x42C8
277:                           {
278:                               PFNf_LINres=1;
42C4  8607     BSF PFNf_OTTimeout, 3, ACCESS
279:                           }
42C6  0C00     RETLW 0x0
280:                           else 
281:                           {
282:                               PFNf_LINres=0;                
42C8  9607     BCF PFNf_OTTimeout, 3, ACCESS
42CA  0C00     RETLW 0x0
283:                           }
284:                       }
285:                       else
286:                       {
287:                           PFNf_LINres=0;                
288:                       }
289:                       break;
290:                   }
291:                   case _CLIN_WRD_FSR:      //aktywuj/deaktywuj funkcje serwisowa
292:                   {
293:                       if(!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres)     //blokada nieaktywna?
42CC  A00B     BTFSS PFNf_lato, 0, ACCESS
42CE  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
42D0  0C00     RETLW 0x0
42D2  B80D     BTFSC PFNf_plmCO, 4, ACCESS
42D4  0C00     RETLW 0x0
294:                       {
295:                           if(FRL1.WRD1.byte0)
42D6  51BC     MOVF 0xBC, W, BANKED
42D8  E01D     BZ 0x4314
296:                           {
297:                               if(PFNf_zima&&!PFNf_obgCW&&!PFNf_set_fnserw)
42DA  B811     BTFSC PFNf_zima, 4, ACCESS
42DC  B80C     BTFSC PFNf_off, 4, ACCESS
42DE  D00D     BRA 0x42FA
42E0  AE0F     BTFSS PFNf_set_fnserw, 7, ACCESS
298:                               {
299:                                   if(!PFNf_ferr&&!PFNf_fmsg&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg)
42E2  B20A     BTFSC PFNf_firstEdge, 1, ACCESS
42E4  D00A     BRA 0x42FA
42E6  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
42E8  BA0C     BTFSC PFNf_off, 5, ACCESS
42EA  D007     BRA 0x42FA
42EC  AC0A     BTFSS PFNf_firstEdge, 6, ACCESS
42EE  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
42F0  D004     BRA 0x42FA
300:                                   {
301:                                       PFNf_set_fnserw=1;
42F2  8E0F     BSF PFNf_set_fnserw, 7, ACCESS
42F4  D8D3     RCALL PL404
302:                                       PFNf_fnserw=1;
303:                                       PFNf_prn_res=0;
304:                                       PFNf_set_nco=0;
305:                                       PFNf_set_ncw=0;
306:                                       PFNf_set_eco=0;
307:                                       PFNf_b_ofnserw=0;
308:                                       StartRTdS(_RTFSP);
42F6  EC55     CALL 0xBCAA, 0
42F8  F05E     NOP
309:                                   }
310:                               }
311:                               if(!PFNf_off&&(PFNf_fnserw||PFNf_ofnserw))					//aktywna funkcja serwisowa?
42FA  BA0C     BTFSC PFNf_off, 5, ACCESS
42FC  0C00     RETLW 0x0
42FE  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
4300  D002     BRA 0x4306
4302  AE0C     BTFSS PFNf_off, 7, ACCESS
4304  0C00     RETLW 0x0
312:                               {
313:                                   if(FRL1.WRD1.byte0==2)PFNf_fns_max=0;
4306  0E02     MOVLW 0x2
4308  19BC     XORWF 0xBC, W, BANKED
430A  E102     BNZ 0x4310
430C  9A0A     BCF PFNf_firstEdge, 5, ACCESS
430E  0C00     RETLW 0x0
314:                                   else PFNf_fns_max=1;                    
4310  8A0A     BSF PFNf_firstEdge, 5, ACCESS
4312  0C00     RETLW 0x0
315:                               }
316:                           }
317:                           else
318:                           {
319:                               PFNf_LINresSR=1;
4314  8A07     BSF PFNf_OTTimeout, 5, ACCESS
320:                               PFNf_set_fnserw=0;
4316  9E0F     BCF PFNf_set_fnserw, 7, ACCESS
321:                               PFNf_fnserw=0;                
4318  9C0A     BCF PFNf_firstEdge, 6, ACCESS
431A  0C00     RETLW 0x0
322:                           }
323:                       }
324:                       break;
325:                   }
326:                   case _CLIN_WRD_ANL:      //aktywuj/deaktywuj funkcje antylegionella
327:                   {
328:                       if(!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres)     //blokada nieaktywna?
431C  A00B     BTFSS PFNf_lato, 0, ACCESS
431E  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
4320  0C00     RETLW 0x0
4322  B80D     BTFSC PFNf_plmCO, 4, ACCESS
4324  0C00     RETLW 0x0
329:                       {            
330:                           if(FRL1.WRD1.byte0)
4326  51BC     MOVF 0xBC, W, BANKED
4328  E010     BZ 0x434A
331:                           {
332:                               if(PFNf_EnAleg&&!PFNf_set_aleg)
432A  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
432C  BA0F     BTFSC PFNf_set_fnserw, 5, ACCESS
432E  0C00     RETLW 0x0
333:                               {
334:                                   if(!PFNf_ferr&&!PFNf_fmsg&&!PFNf_off&&!PFNf_fnserw&&!PFNf_aleg)
4330  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
4332  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
4334  0C00     RETLW 0x0
4336  AA0C     BTFSS PFNf_off, 5, ACCESS
4338  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
433A  0C00     RETLW 0x0
433C  B208     BTFSC PFNf_b_set_nco, 1, ACCESS
433E  0C00     RETLW 0x0
335:                                   {
336:                                       PFNf_set_aleg=1;
4340  8A0F     BSF PFNf_set_fnserw, 5, ACCESS
4342  D8BF     RCALL PL466
337:                                       PFNf_aleg=1;
338:                                       PFNf_set_nco=0;
339:                                       PFNf_set_ncw=0;
340:                                       PFNf_set_eco=0;
341:                                       PFNf_b_oaleg=0;
342:                                       StartRTdS(_RTFSP);
4344  EC55     CALL 0xBCAA, 0
4346  F05E     NOP
4348  0C00     RETLW 0x0
343:                                   }
344:                               }
345:                           }
346:                           else
347:                           {
348:                               PFNf_LINresAL=1;
434A  8807     BSF PFNf_OTTimeout, 4, ACCESS
349:                               PFNf_set_aleg=0;
434C  9A0F     BCF PFNf_set_fnserw, 5, ACCESS
434E  D7B3     BRA 0x42B6
350:                               PFNf_aleg=0;                
351:                           }
352:                       }
353:                       break;
354:                   }    
355:                   case _CLIN_WRD_PKNF:              //zmien parametr konfiguracyjny plytki sterujacej UNI-02 
356:                   {
357:                       //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
358:                       switch(krok)
43A4  0101     MOVLB 0x1
43A6  51B3     MOVF 0xB3, W, BANKED
43A8  E0D3     BZ 0x4350
43AA  0A01     XORLW 0x1
43AC  E0D9     BZ 0x4360
43AE  0A03     XORLW 0x3
43B0  E0E8     BZ 0x4382
43B2  0A01     XORLW 0x1
43B4  A4D8     BTFSS STATUS, 2, ACCESS
43B6  0C00     RETLW 0x0
43B8  D7ED     BRA 0x4394
359:                       {
360:                           case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
361:                               if(!LINWaitForAnswerUNI02(_LIN_WPKNF)) return _LIN1_IBUSY;
4350  0E80     MOVLW 0x80
4352  ECAE     CALL 0xB75C, 0
4354  F05B     NOP
4356  0900     IORLW 0x0
4358  E101     BNZ 0x435C
435A  0CFF     RETLW 0xFF
362:                               krok++;
435C  0101     MOVLB 0x1
435E  2BB3     INCF 0xB3, F, BANKED
363:                           case 1:         //1.Wysylka komendy do UNI-02
364:                           {
365:                               //komendy i parametry wywolania dla UNI-02
366:                               RSDT1.inLIDN=_LIN_WPKNF;             //komenda
4360  0E80     MOVLW 0x80
4362  D8A3     RCALL PL440
367:                               RSDT1.inLDTA1=FRL1.WRD1.byte0;      //parametr1 (indeks parametru)
368:                               RSDT1.inLDTA2=FRL1.WRD1.byte1;      //parametr1 (wartosc parametru)                     
4364  C0BD     MOVFF 0xBD, 0x2A2
4366  F2A2     NOP
369:                               //start wywolania
370:                               if(!FRL1.NAD) FRL1f_ZeroAdr=1;
4368  0100     MOVLB 0x0
436A  51AF     MOVF 0xAF, W, BANKED
436C  E102     BNZ 0x4372
436E  8402     BSF LIN1f_Busy, 2, ACCESS
4370  D001     BRA 0x4374
371:                               else FRL1f_ZeroAdr=0;
4372  9402     BCF LIN1f_Busy, 2, ACCESS
4374  ECF9     CALL 0x31F2, 0
4376  F018     NOP
372:                               RSDT1f_NewLIDN=1;
373:                               RSDT1.ACKUNI=0;
374:                               FRL1f_NextFr=0;
375:                               krok++;
4378  2BB3     INCF 0xB3, F, BANKED
437A  D003     BRA 0x4382
376:                           }
377:                           case 2:         //2.Oczekiwanie na odpowiedz
378:                           {
379:                               switch(LINWaitForAnswerUNI02(_LIN_WPKNF))
4382  0E80     MOVLW 0x80
4384  ECAE     CALL 0xB75C, 0
4386  F05B     NOP
4388  0A00     XORLW 0x0
438A  B4D8     BTFSC STATUS, 2, ACCESS
438C  0CFF     RETLW 0xFF
438E  0A01     XORLW 0x1
4390  E0F5     BZ 0x437C
4392  D6E2     BRA 0x4158
380:                               {
381:                                   case 0:
382:                                       return _LIN1_IBUSY;
383:                                   case 1:
384:                                       krok++;
437C  0101     MOVLB 0x1
437E  2BB3     INCF 0xB3, F, BANKED
385:                                       break;
4380  D009     BRA 0x4394
386:                                   default:
387:                                       krok=0;
388:                                       return _LIN1_ERRODP;
389:                               }
390:                           }
391:                           case 3:         //3.Przygotowanie danych dla LIN
392:                           {
393:                               krok=0;
4394  6BB3     CLRF 0xB3, BANKED
394:                               if(FRL1f_ZeroAdr) return _LIN1_NORESP;                              //odpowiedz do LIN nie ma byc generowana?
4396  B402     BTFSC LIN1f_Busy, 2, ACCESS
4398  0CF0     RETLW 0xF0
395:                               if(!FRL1f_NextFr)                                                   //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
439A  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
439C  0C05     RETLW 0x5
396:                               {
397:                                   if(RSDT1.outLDTA2) return _LIN1_ERRODP;                         //status operacji na UNI-02 wskazuje na blad?
439E  0102     MOVLB 0x2
43A0  5173     MOVF _PFNf_popFN, W, BANKED
43A2  D6EE     BRA 0x4180
398:                               }
399:                               else                                                                //aktualizowano ramke - odpowiedz negatywna
400:                               {
401:                                   return _LIN1_ERRODP;
402:                               }
403:                           }
404:                       }
405:                       break;
406:                   }
407:                   case _CLIN_WRD_RT:     //ustaw pobudzenie RT
408:                   {
409:                       if(FRL1.WRD1.byte0>0)
43BA  51BC     MOVF 0xBC, W, BANKED
43BC  E002     BZ 0x43C2
410:                       {
411:                           PFNf_LIN_RT=1;
43BE  8207     BSF PFNf_OTTimeout, 1, ACCESS
412:                       }
43C0  0C00     RETLW 0x0
413:                       else
414:                       {
415:                           PFNf_LIN_RT=0;                
43C2  9207     BCF PFNf_OTTimeout, 1, ACCESS
43C4  0C00     RETLW 0x0
416:                       }
417:                       break;
418:                   }
419:                   case _CLIN_WRD_CW:     //ustaw pobudzenie z timera zasobnika
420:                   {
421:                       if((FRL1.WRD1.byte0>0)&&PFNf_EnAleg)
43C6  51BC     MOVF 0xBC, W, BANKED
43C8  E004     BZ 0x43D2
43CA  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
43CC  D002     BRA 0x43D2
422:                       {
423:                           PFNf_LIN_CW=1;
43CE  8206     BSF PFNf_LIN_CW, 1, ACCESS
424:                       }
43D0  0C00     RETLW 0x0
425:                       else
426:                       {
427:                           PFNf_LIN_CW=0;                
43D2  9206     BCF PFNf_LIN_CW, 1, ACCESS
43D4  0C00     RETLW 0x0
428:                       }
429:                       break;
430:                   } 
431:                   case _CLIN_WRD_ENDO:     //ustaw nowy punkt regulacji dla grzania WG
432:                   {
433:                       if(PFNf_prODP)      //aktywna procedura odpowietrzajaca?
43D6  A80E     BTFSS PFNf_popFN, 4, ACCESS
43D8  D002     BRA 0x43DE
434:                       {
435:                           PFNf_LIN_ENDO=1;  
43DA  8606     BSF PFNf_LIN_CW, 3, ACCESS
436:                       }
43DC  0C00     RETLW 0x0
437:                       else
438:                       {
439:                           PFNf_LIN_ENDO=0;
43DE  9606     BCF PFNf_LIN_CW, 3, ACCESS
43E0  0C00     RETLW 0x0
440:                       }
441:                       break;
442:                   }         
443:                   case _CLIN_WRD_SETP:     //ustaw nowy punkt regulacji dla grzania WG
444:                   {
445:                       if((PFNf_LIN_STR&&PFNf_FLIN)||(PFNf_LIN_KSK&&PFNf_FLIN))    //LIN w trybie pracy sterowanie?
43E2  A407     BTFSS PFNf_OTTimeout, 2, ACCESS
43E4  D002     BRA 0x43EA
43E6  BA05     BTFSC PFNf_KnfDisErr, 5, ACCESS
43E8  D003     BRA 0x43F0
43EA  BC06     BTFSC PFNf_LIN_CW, 6, ACCESS
43EC  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
43EE  0C05     RETLW 0x5
446:                       {
447:                           if(FRL1.WRD1.byte0<PFN.SETPmin)
43F0  0101     MOVLB 0x1
43F2  51FA     MOVF 0xFA, W, BANKED
43F4  0100     MOVLB 0x0
43F6  5DBC     SUBWF 0xBC, W, BANKED
43F8  E203     BC 0x4400
448:                           {
449:                               PFN.CONTSETP=PFN.SETPmin;
43FA  C1FA     MOVFF 0x1FA, 0x1F9
43FC  F1F9     NOP
450:                           }    
43FE  0C00     RETLW 0x0
451:                           else
452:                           if(FRL1.WRD1.byte0>PFN.SETPmax)
4400  51BC     MOVF 0xBC, W, BANKED
4402  0101     MOVLB 0x1
4404  5DFB     SUBWF 0xFB, W, BANKED
4406  E203     BC 0x440E
453:                           {
454:                               PFN.CONTSETP=PFN.SETPmax;
4408  C1FB     MOVFF 0x1FB, 0x1F9
440A  F1F9     NOP
455:                           }
440C  0C00     RETLW 0x0
456:                           else PFN.CONTSETP=FRL1.WRD1.byte0;
440E  C0BC     MOVFF 0xBC, 0x1F9
4410  F1F9     NOP
4412  0C00     RETLW 0x0
457:                       }
458:                       else return _LIN1_ERRODP;   
459:                       break;
460:                   }   
461:                   case _CLIN_WRD_PRD:      //ustawic specjalny tryb pracy sterownika?
462:                   {
463:                       if(FRL1.WRD1.byte0==0xAA)
4414  0EAA     MOVLW 0xAA
4416  19BC     XORWF 0xBC, W, BANKED
4418  A4D8     BTFSS STATUS, 2, ACCESS
441A  0C05     RETLW 0x5
464:                       {
465:                           PFN.STRB=FRL1.WRD1.byte1;    
441C  C0BD     MOVFF 0xBD, 0x1FC
441E  F1FC     NOP
466:                       }
4420  0C00     RETLW 0x0
4422  0100     MOVLB 0x0
4424  51B5     MOVF 0xB5, W, BANKED
4426  0A01     XORLW 0x1
4428  E101     BNZ 0x442C
442A  D65C     BRA 0x40E4
442C  0A03     XORLW 0x3
442E  E101     BNZ 0x4432
4430  D659     BRA 0x40E4
4432  0A01     XORLW 0x1
4434  E101     BNZ 0x4438
4436  D6B1     BRA 0x419A
4438  0A07     XORLW 0x7
443A  E101     BNZ 0x443E
443C  D6C5     BRA 0x41C8
443E  0A01     XORLW 0x1
4440  E101     BNZ 0x4444
4442  D6C7     BRA 0x41D2
4444  0A03     XORLW 0x3
4446  E101     BNZ 0x444A
4448  D6F3     BRA 0x4230
444A  0A01     XORLW 0x1
444C  E101     BNZ 0x4450
444E  D70A     BRA 0x4264
4450  0A0F     XORLW 0xF
4452  E101     BNZ 0x4456
4454  D712     BRA 0x427A
4456  0A01     XORLW 0x1
4458  E101     BNZ 0x445C
445A  D721     BRA 0x429E
445C  0A03     XORLW 0x3
445E  E101     BNZ 0x4462
4460  D72C     BRA 0x42BA
4462  0A01     XORLW 0x1
4464  E101     BNZ 0x4468
4466  D732     BRA 0x42CC
4468  0A07     XORLW 0x7
446A  E101     BNZ 0x446E
446C  D757     BRA 0x431C
446E  0A02     XORLW 0x2
4470  E099     BZ 0x43A4
4472  0A01     XORLW 0x1
4474  E0A2     BZ 0x43BA
4476  0A1F     XORLW 0x1F
4478  E0A6     BZ 0x43C6
447A  0A01     XORLW 0x1
447C  E0AC     BZ 0x43D6
447E  0A03     XORLW 0x3
4480  E0B0     BZ 0x43E2
4482  0A01     XORLW 0x1
4484  A4D8     BTFSS STATUS, 2, ACCESS
4486  0C01     RETLW 0x1
4488  D7C5     BRA 0x4414
467:                       else return _LIN1_ERRODP;
468:                       break;
469:                   }        
470:                   default:                   //nieznana komenda
471:                   {
472:                       return _LIN1_UNCCOM;
473:                   }
474:               }
475:               return _LIN1_IFINAL;            //koniec przetwarzania danych, automatyczne potwierdzenie
476:           }
477:           //------------------------------------------------------------
478:           //------------------------------------------------------------
479:           //MULTIRESPONSE
480:           //PRZYGOTOWANIE bufora do wypelnienia przez dane nadeslane z MASTER (wskazanie adresu i rozmiaru)
481:           //UWAGA: zwrot wartosci _LIN1_IBUSY sygnalizuje trwanie procesu (maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA)
482:           //Start odbioru - wskazanie bufora na dane
483:           unsigned char LIN1StartMultiResponse_WR(void)
484:           {
485:               BitSet2(&RSDT1.inLNSTAT,_FLIN,1);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
BFDE  0E7C     MOVLW 0x7C
BFE0  ECF1     CALL 0x31E2, 0
BFE2  F018     NOP
BFE4  EC6D     CALL 0xACDA, 0
BFE6  F056     NOP
486:               PFNf_FLIN=1;    
BFE8  8A05     BSF PFNf_KnfDisErr, 5, ACCESS
487:               StartRTdS(_RTFLIN);
BFEA  0E08     MOVLW 0x8
BFEC  EC55     CALL 0xBCAA, 0
BFEE  F05E     NOP
488:               /*
489:               switch(FRL1.IDN)               //komenda na ktora nastapila reakcja ukladu SLAVE
490:               {
491:                   case 0x01:        //identyfikator komendy
492:                   {
493:                       FRL1.imax=32;          //rozmiar tabeli
494:                       FRL1.tab=tbuf;         //adres tabeli
495:           
496:                       break;
497:                   }
498:                   default:                   //nieznana komenda
499:                   {
500:                       return _LIN1_UNCCOM;
501:                   }
502:               }
503:               if((FRL1.STOP.war<FRL1.START.war)||(FRL1.STOP.war>=FRL1.imax))
504:               {
505:                   return _LIN1_INVPAR;       //nieprawidlowy parametr
506:               }
507:               return _LIN1_IFINAL;            //koniec przetwarzania danych, automatyczne potwierdzenie
508:                */
509:               return _LIN1_UNCCOM;            //brak wsparcia dla komendy
510:           }
BFF0  0C01     RETLW 0x1
511:           //Koniec odbioru - aktualizacja danych danymi z bufora w zakresie start-stop
512:           unsigned char LIN1FinishMultiResponse_WR(void)
513:           {
514:               BitSet2(&RSDT1.inLNSTAT,_FLIN,1);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
BFF2  0E7C     MOVLW 0x7C
BFF4  ECF1     CALL 0x31E2, 0
BFF6  F018     NOP
BFF8  EC6D     CALL 0xACDA, 0
BFFA  F056     NOP
515:               PFNf_FLIN=1;    
BFFC  8A05     BSF PFNf_KnfDisErr, 5, ACCESS
516:               StartRTdS(_RTFLIN);
BFFE  0E08     MOVLW 0x8
C000  EC55     CALL 0xBCAA, 0
C002  F05E     NOP
517:               /*
518:               switch(FRL1.IDN)               //komenda na ktora nastapila reakcja ukladu SLAVE
519:               {
520:                   case 0x01:                 //identyfikator komendy
521:                   {           
522:                       break;
523:                   }
524:                   default:                   //nieznana komenda
525:                   {
526:                       return _LIN1_UNCCOM;
527:                   }
528:               }
529:               return _LIN1_IFINAL;            //koniec przetwarzania danych, automatyczne potwierdzenie     
530:               */
531:               return _LIN1_UNCCOM;
532:           }
C004  0C01     RETLW 0x1
533:           //------------------------------------------------------------
534:           //------------------------------------------------------------
535:           //******************************** POLECENIE WYSYLKI WSKAZANYCH DANYCH DO MASTER**************************************
536:           //------------------------------------------------------------
537:           //------------------------------------------------------------
538:           //SINGLE RESPONSE
539:           //interpretacja komendy, ew. parametrow i zwrotna wysylka danych
540:           //UWAGA: zwrot wartosci _LIN1_IBUSY sygnalizuje trwanie procesu (maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA)
541:           unsigned char LIN1SingleResponse_RD(void)
542:           {
543:               volatile unsigned char dt;
544:               static unsigned char krok;
545:               BitSet2(&RSDT1.inLNSTAT,_FLIN,1);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
2D14  0E7C     MOVLW 0x7C
2D16  0100     MOVLB 0x0
2D18  DA64     RCALL PL104
2D1A  EC6D     CALL 0xACDA, 0
2D1C  F056     NOP
546:               PFNf_FLIN=1;    
2D1E  8A05     BSF PFNf_KnfDisErr, 5, ACCESS
547:               StartRTdS(_RTFLIN);   
2D20  0E08     MOVLW 0x8
2D22  EC55     CALL 0xBCAA, 0
2D24  F05E     NOP
548:               //----------------    
549:               if(FRL1f_RSFrame)                 //ramka nadeslana z modulu Wifi?
2D26  A002     BTFSS LIN1f_Busy, 0, ACCESS
2D28  D200     BRA 0x312A
550:               {
551:                   if(!RSFInterpreter_SingleRD()) return _LIN1_UNCCOM;       
2D2A  EC90     CALL 0x7D20, 0
2D2C  F03E     NOP
2D2E  0900     IORLW 0x0
2D30  E001     BZ 0x2D34
2D32  D1FB     BRA 0x312A
2D34  0C01     RETLW 0x1
552:               }    
553:               //----------------   
554:               //komenda na ktora nastapila reakcja ukladu SLAVE
555:               switch(FRL1.IDN)                        //identyfikator komendy
312A  0100     MOVLB 0x0
556:               {      
557:                   case _CLIN_RRD_ACK:                                     //wygeneruj potwierdzenie w odpowiedzi na wywolanie adresem
558:                   {
559:                       if(!FRL1.NAD&&FRL1.WRD1.byte0&&(FRL1.WRD1.byte0!=PFN.ALIN)) //adres zerowy i pierwszy parametr wywolania (0...4) ró¿ny od zera i rozny od adresu wlasnego?
2D36  51AF     MOVF 0xAF, W, BANKED
2D38  E108     BNZ 0x2D4A
2D3A  51BC     MOVF 0xBC, W, BANKED
2D3C  E006     BZ 0x2D4A
2D3E  0101     MOVLB 0x1
2D40  51ED     MOVF 0xED, W, BANKED
2D42  0100     MOVLB 0x0
2D44  19BC     XORWF 0xBC, W, BANKED
2D46  E001     BZ 0x2D4A
560:                       {
561:                           return _LIN1_NORESP;        //ignoruj wywolanie
2D48  0CF0     RETLW 0xF0
562:                       }               
563:                       FTL1.PCI_LENGTH=0x06;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2D4A  0E06     MOVLW 0x6
2D4C  DA45     RCALL PL64
564:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
565:                       FTL1.WRD0.byte1=_LIN_OID;                           //identyfikator odbiornika
2D4E  0E01     MOVLW 0x1
2D50  6F4B     MOVWF 0x4B, BANKED
566:                       FTL1.WRD1.byte0=_WERSJA;                            //data0: wersja oprogramowania plytki wyswietlacza
2D52  0E0B     MOVLW 0xB
2D54  6F4C     MOVWF 0x4C, BANKED
567:                       FTL1.WRD1.byte1=PFN.vUNI02;                         //data1: wersja oprogramowania plytki UNI-02
2D56  C1EC     MOVFF 0x1EC, 0x14D
2D58  F14D     NOP
568:                       FTL1.WRD2.byte0=(PFNf_EnAleg)?0x01:0x02;            //data2: aktualna konfiguracja sterownika (1F/2F)   
2D5A  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
2D5C  D004     BRA 0x2D66
2D5E  0100     MOVLB 0x0
2D60  6B9E     CLRF _UADtf_REXT, BANKED
2D62  0E02     MOVLW 0x2
2D64  D003     BRA 0x2D6C
2D66  0100     MOVLB 0x0
2D68  6B9E     CLRF _UADtf_REXT, BANKED
2D6A  0E01     MOVLW 0x1
2D6C  6F9D     MOVWF _UADtf_RData, BANKED
2D6E  C09D     MOVFF _UADtf_RData, 0x14E
2D70  F14E     NOP
569:                       dt=0x01;                                            //(1-p³ytka UNI-02)                                          
2D72  0E01     MOVLW 0x1
2D74  6FA3     MOVWF _UADtf_TEXT, BANKED
570:                       dt=dt|(_KEY_BBOARD<<4);                             //(0-4 key, 1-7key)
2D76  51A3     MOVF _UADtf_TEXT, W, BANKED
2D78  0910     IORLW 0x10
2D7A  6FA3     MOVWF _UADtf_TEXT, BANKED
571:                       FTL1.WRD2.byte1=dt;                                 //cztery m³odsze bity - identyfikator warstwy sprzetowej plyty sterujacej (1-p³ytka UNI-02)      
2D7C  C0A3     MOVFF _UADtf_TEXT, 0x14F
2D7E  F14F     NOP
572:                                                                           //cztery starsze bity - identyfikator warstwy sprzetowej p³ytki LCD (0-4 key, 1-7key)
573:                       break;
2D80  0C00     RETLW 0x0
574:                   }
575:                   case _CLIN_RRD_PCW:                 //wygeneruj wartosc PCW
576:                   {
577:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2D82  0E04     MOVLW 0x4
2D84  DA29     RCALL PL64
578:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
579:                       FTL1.WRD0.byte1=(unsigned char)PFN.PCW;//RSDT1.outPCW;                       //parametr  //********************
2D86  C1F0     MOVFF 0x1F0, 0x14B
2D88  F14B     NOP
580:                       if(!PFNf_EnAleg)
2D8A  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
2D8C  D003     BRA 0x2D94
581:                       {
582:                           FTL1.WRD1.byte0=(unsigned char)PFN.minPCW;//RSDT1.outPCWmn;                     //dolna granica parametru
2D8E  C1EA     MOVFF 0x1EA, 0x14C
2D90  F14C     NOP
583:                       }
2D92  D002     BRA 0x2D98
584:                       else
585:                       {
586:                           FTL1.WRD1.byte0=(unsigned char)PFN.minPCW-1;//RSDT1.outPCWmn-1;                   //dolna granica parametru  
2D94  05EA     DECF __pdataBANK0, W, BANKED
2D96  6F4C     MOVWF 0x4C, BANKED
587:                       }
588:                       FTL1.WRD1.byte1=(unsigned char)PFN.maxPCW;//RSDT1.outPCWmx;                         //gorna granica parametru
2D98  C1E8     MOVFF 0x1E8, 0x14D
2D9A  F14D     NOP
589:                       break;
2D9C  0C00     RETLW 0x0
590:                   } 
591:                   case _CLIN_RRD_PCO:                 //wygeneruj wartosc PCO
592:                   {
593:                       FTL1.PCI_LENGTH=0x05;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2D9E  0E05     MOVLW 0x5
2DA0  DA1B     RCALL PL64
594:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
595:                       FTL1.WRD0.byte1=(unsigned char)PFN.PCO;//RSDT1.outPCO;                       //parametr    //********************        
2DA2  C1EE     MOVFF 0x1EE, 0x14B
2DA4  F14B     NOP
596:                       FTL1.WRD1.byte0=(unsigned char)PFN.minPCO;//RSDT1.outPCOmn;                     //dolna granica parametru
2DA6  C1E6     MOVFF 0x1E6, 0x14C
2DA8  F14C     NOP
597:                       FTL1.WRD1.byte1=(unsigned char)PFN.maxPCO;//RSDT1.outPCOmx;                     //gorna granica parametru
2DAA  C1E4     MOVFF 0x1E4, 0x14D
2DAC  F14D     NOP
598:                       FTL1.WRD2.byte0=(PFNf_pgd)?1:0;                     //rodzaj danej (0-nastawa PCO, 1-wsp. KT)  
2DAE  0E00     MOVLW 0x0
2DB0  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
2DB2  0E01     MOVLW 0x1
2DB4  D0B9     BRA 0x2F28
599:                       break;
600:                   } 
601:                   case _CLIN_RRD_ECO:                 //wygeneruj wartosc ECO
602:                   {
603:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2DB6  0E04     MOVLW 0x4
2DB8  DA0F     RCALL PL64
604:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
605:                       FTL1.WRD0.byte1=(unsigned char)PFN.ECO;//RSDT1.outECO;                            //parametr  //********************
2DBA  C1F2     MOVFF 0x1F2, 0x14B
2DBC  F14B     NOP
606:                       FTL1.WRD1.byte0=1;                                  //dolna granica parametru            
2DBE  0E01     MOVLW 0x1
2DC0  6F4C     MOVWF 0x4C, BANKED
607:                       FTL1.WRD1.byte1=9;                                  //gorna granica parametru                       
2DC2  0E09     MOVLW 0x9
2DC4  D16B     BRA 0x309C
608:                       break;
609:                   }    
610:                   case _CLIN_RRD_TRB:                 //wygeneruj tryb pracy ********************** PFNf_ofzima,PFNf_oflato,PFNf_ofoff
611:                   {
612:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2DC6  0E04     MOVLW 0x4
2DC8  DA07     RCALL PL64
613:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
614:                       if(PFNf_off)
2DCA  AA0C     BTFSS PFNf_off, 5, ACCESS
2DCC  D002     BRA 0x2DD2
615:                       {
616:                           FTL1.WRD0.byte1=2;                              //tryb OFF
2DCE  0E02     MOVLW 0x2
2DD0  D003     BRA 0x2DD8
617:                       }
618:                       else
619:                       if(PFNf_lato)
2DD2  A80B     BTFSS PFNf_lato, 4, ACCESS
2DD4  D003     BRA 0x2DDC
620:                       {
621:                           FTL1.WRD0.byte1=1;                              //tryb LATO
2DD6  0E01     MOVLW 0x1
2DD8  6F4B     MOVWF 0x4B, BANKED
622:                       }
2DDA  D001     BRA 0x2DDE
623:                       else
624:                       {
625:                           FTL1.WRD0.byte1=0;                              //tryb ZIMA
2DDC  6B4B     CLRF 0x4B, BANKED
626:                       }
627:                       /*if(PFNf_ofoff)
628:                       {
629:                           FTL1.WRD0.byte1=2;                              //tryb OFF
630:                       }
631:                       else
632:                       if(PFNf_oflato)
633:                       {
634:                           FTL1.WRD0.byte1=1;                              //tryb LATO
635:                       }
636:                       else
637:                       {
638:                           FTL1.WRD0.byte1=0;                              //tryb ZIMA
639:                       }*/            
640:                       FTL1.WRD1.byte0=0;                                  //dolna granica parametru
2DDE  6B4C     CLRF 0x4C, BANKED
641:                       FTL1.WRD1.byte1=2;                                  //gorna granica parametru
2DE0  0E02     MOVLW 0x2
2DE2  D15C     BRA 0x309C
642:                       break;
643:                   } 
644:                   case _CLIN_RRD_RES:                 //wygeneruj stan przycisku res
645:                   {
646:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2DE4  0E02     MOVLW 0x2
2DE6  D9F8     RCALL PL64
647:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
648:                       if(PFNf_res)                                        //nacisniety przycisk RESET?
2DE8  B40F     BTFSC PFNf_set_fnserw, 2, ACCESS
649:                       {
650:                           FTL1.WRD0.byte1=1;                              //parametr
2DEA  D0B6     BRA 0x2F58
651:                       }
652:                       else
653:                       {
654:                           FTL1.WRD0.byte1=0;                              //parametr                
2DEC  6B4B     CLRF 0x4B, BANKED
655:                       }
656:                       break;     
2DEE  0C00     RETLW 0x0
657:                   }        
658:                   case _CLIN_RRD_BRES:                                    //wygeneruj informacje o blokadzie awaryjnej
659:                   {
660:                       FTL1.PCI_LENGTH=0x03;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2DF0  0E03     MOVLW 0x3
2DF2  D9F2     RCALL PL64
661:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
662:                       if((!PFNf_opgres)&&PFNf_fmsg)
2DF4  A80D     BTFSS PFNf_plmCO, 4, ACCESS
2DF6  A60A     BTFSS PFNf_firstEdge, 3, ACCESS
2DF8  D005     BRA 0x2E04
663:                       {
664:                           FTL1.WRD0.byte1=1;                              //wylaczenie bez blokady awaryjnej (sygnalizacja, realizacja procedury awaryjnej)
2DFA  0E01     MOVLW 0x1
2DFC  6F4B     MOVWF 0x4B, BANKED
665:                           FTL1.WRD1.byte0=PFN.KAWR;                
2DFE  C1E2     MOVFF 0x1E2, 0x14C
2E00  F14C     NOP
666:                       }
2E02  D007     BRA 0x2E12
667:                       else
668:                       if((PFNf_opgres)&&PFNf_ferr) 
2E04  B80D     BTFSC PFNf_plmCO, 4, ACCESS
2E06  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
2E08  D004     BRA 0x2E12
669:                       {
670:                           FTL1.WRD0.byte1=2;                              //wylaczenie z blokada awaryjna
2E0A  0E02     MOVLW 0x2
2E0C  6F4B     MOVWF 0x4B, BANKED
671:                           FTL1.WRD1.byte0=PFN.KERR;                                            
2E0E  C1E3     MOVFF 0x1E3, 0x14C
2E10  F14C     NOP
672:                       }
673:                       if((!PFNf_opgres)&&PFNf_ferr)
2E12  A80D     BTFSS PFNf_plmCO, 4, ACCESS
2E14  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
2E16  D005     BRA 0x2E22
674:                       {
675:                           FTL1.WRD0.byte1=3;                              //wylaczenie bez blokady awaryjnej (sygnalizacja, autowznowienie pracy po usunieciu przyczyny awarii)
2E18  0E03     MOVLW 0x3
2E1A  6F4B     MOVWF 0x4B, BANKED
676:                           FTL1.WRD1.byte0=PFN.KERR;                
2E1C  C1E3     MOVFF 0x1E3, 0x14C
2E1E  F14C     NOP
677:                       }
2E20  0C00     RETLW 0x0
678:                       else
679:                       {
680:                           FTL1.WRD0.byte1=0;                              //brak stanu awaryjnego
2E22  6B4B     CLRF 0x4B, BANKED
681:                           FTL1.WRD1.byte0=0;                                                                           
2E24  6B4C     CLRF 0x4C, BANKED
2E26  0C00     RETLW 0x0
682:                       }
683:                       
684:                       /*if(PFNf_opgres)                                     //wylaczenie awaryjne?
685:                       {
686:                           FTL1.WRD0.byte1=1;                              //parametr
687:                       }
688:                       else
689:                       {
690:                           FTL1.WRD0.byte1=0;                              //parametr                
691:                       }*/
692:                       break;     
693:                   }
694:                   case _CLIN_RRD_FSR:                //wygeneruj informacje o funkcji serwisowej 
695:                   {
696:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2E28  0E02     MOVLW 0x2
2E2A  D9D6     RCALL PL64
697:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
698:                       if(PFNf_ofnserw)                                    //aktywna funkcja serwisowa?
2E2C  AE0C     BTFSS PFNf_off, 7, ACCESS
2E2E  D004     BRA 0x2E38
699:                       {
700:                           if(PFNf_fns_max) FTL1.WRD0.byte1=1;             //praca na mocy maksymalnej
2E30  BA0A     BTFSC PFNf_firstEdge, 5, ACCESS
2E32  D092     BRA 0x2F58
701:                           else FTL1.WRD0.byte1=2;                         //praca na mocy minimalnej
2E34  0E02     MOVLW 0x2
2E36  D091     BRA 0x2F5A
702:                       }
703:                       else
704:                       {
705:                           if(!PFNf_ferr&&!PFNf_fmsg&&!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres&&PFNf_zima&&!PFNf_obgCW&&!PFNf_off&&!PFNf_aleg)
2E38  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
2E3A  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
2E3C  D00B     BRA 0x2E54
2E3E  A00B     BTFSS PFNf_lato, 0, ACCESS
2E40  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
2E42  D008     BRA 0x2E54
2E44  A80D     BTFSS PFNf_plmCO, 4, ACCESS
2E46  A811     BTFSS PFNf_zima, 4, ACCESS
2E48  D005     BRA 0x2E54
2E4A  A80C     BTFSS PFNf_off, 4, ACCESS
2E4C  BA0C     BTFSC PFNf_off, 5, ACCESS
2E4E  D002     BRA 0x2E54
2E50  A208     BTFSS PFNf_b_set_nco, 1, ACCESS
2E52  D7CC     BRA 0x2DEC
706:                           {               
707:                               FTL1.WRD0.byte1=0;                              //funkcja nieaktywna   
708:                           }
709:                           else 
710:                           {
711:                               FTL1.WRD0.byte1=3;                              //nie mozna aktywowac funkcji                    
2E54  0E03     MOVLW 0x3
2E56  D081     BRA 0x2F5A
712:                           }
713:                       }
714:                       break;     
715:                   }  
716:                   case _CLIN_RRD_ANL:                 //wygeneruj informacje o stanie funkcji antylegionella
717:                   {
718:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2E58  0E02     MOVLW 0x2
2E5A  D9BE     RCALL PL64
719:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
720:                       if(PFNf_oaleg)                                      //aktywna funkcja antylegionella?
2E5C  B40C     BTFSC PFNf_off, 2, ACCESS
2E5E  D07C     BRA 0x2F58
721:                       {
722:                           FTL1.WRD0.byte1=1;                              //funkcja aktywna
723:                       }
724:                       else
725:                       {
726:                           if(!PFNf_ferr&&!PFNf_fmsg&&!PFNf_fsetLaddr&&!PFNf_aktywne_KNF&&!PFNf_opgres&&PFNf_EnAleg&&!PFNf_off&&!PFNf_fnserw)
2E60  A20A     BTFSS PFNf_firstEdge, 1, ACCESS
2E62  B60A     BTFSC PFNf_firstEdge, 3, ACCESS
2E64  D7F7     BRA 0x2E54
2E66  A00B     BTFSS PFNf_lato, 0, ACCESS
2E68  B008     BTFSC PFNf_b_set_nco, 0, ACCESS
2E6A  D7F4     BRA 0x2E54
2E6C  A80D     BTFSS PFNf_plmCO, 4, ACCESS
2E6E  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
2E70  D7F1     BRA 0x2E54
2E72  AA0C     BTFSS PFNf_off, 5, ACCESS
2E74  BC0A     BTFSC PFNf_firstEdge, 6, ACCESS
2E76  D7EE     BRA 0x2E54
2E78  D7B9     BRA 0x2DEC
727:                           {               
728:                               FTL1.WRD0.byte1=0;                          //funkcja nieaktywna   
729:                           }
730:                           else 
731:                           {
732:                               FTL1.WRD0.byte1=3;                          //nie mozna aktywowac funkcji                    
733:                           }               
734:                       }
735:                       break;     
736:                   }   
737:                   case _CLIN_RRD_NKNF:                //wygeneruj pinformacje o liczbie parametrow konfiguracyjnych
738:                   {
739:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2E7A  0E02     MOVLW 0x2
2E7C  D9AD     RCALL PL64
740:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
741:                       FTL1.WRD0.byte1=SetKNPAR();                         //liczba parametrow konfiguracyjnych           
2E7E  ECD3     CALL 0xABA6, 0
2E80  F055     NOP
2E82  0101     MOVLB 0x1
2E84  D06A     BRA 0x2F5A
742:                       break;     
743:                   } 
744:                   case _CLIN_RRD_PKNF:              //zmin parametr konfiguracyjny plytki sterujacej UNI-02 
745:                   {
746:                       //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
747:                       switch(krok)
2F30  0101     MOVLB 0x1
2F32  51B1     MOVF 0xB1, W, BANKED
2F34  E0A8     BZ 0x2E86
2F36  0A01     XORLW 0x1
2F38  E0AE     BZ 0x2E96
2F3A  0A03     XORLW 0x3
2F3C  E0BE     BZ 0x2EBA
2F3E  0A01     XORLW 0x1
2F40  E0C5     BZ 0x2ECC
2F42  0C00     RETLW 0x0
748:                       {
749:                           case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
750:                               if(!LINWaitForAnswerUNI02(_LIN_RPKNF)) return _LIN1_IBUSY;
2E86  0E02     MOVLW 0x2
2E88  ECAE     CALL 0xB75C, 0
2E8A  F05B     NOP
2E8C  0900     IORLW 0x0
2E8E  E101     BNZ 0x2E92
2E90  0CFF     RETLW 0xFF
751:                               krok++;
2E92  0101     MOVLB 0x1
2E94  2BB1     INCF 0xB1, F, BANKED
752:                           case 1:         //1.Wysylka komendy do UNI-02
753:                           {
754:                               //komendy i parametry wywolania dla UNI-02
755:                               RSDT1.inLIDN=_LIN_RPKNF;             //komenda
2E96  0E02     MOVLW 0x2
2E98  EC55     CALL 0x44AA, 0
2E9A  F022     NOP
756:                               RSDT1.inLDTA1=FRL1.WRD1.byte0;      //parametr1 (indeks parametru)    
757:                               
758:                               //start wywolania
759:                               if(!FRL1.NAD) FRL1f_ZeroAdr=1;
2E9C  0100     MOVLB 0x0
2E9E  51AF     MOVF 0xAF, W, BANKED
2EA0  E102     BNZ 0x2EA6
2EA2  8402     BSF LIN1f_Busy, 2, ACCESS
2EA4  D001     BRA 0x2EA8
760:                               else FRL1f_ZeroAdr=0;
2EA6  9402     BCF LIN1f_Busy, 2, ACCESS
2EA8  D9A4     RCALL PL178
761:                               RSDT1f_NewLIDN=1;
762:                               RSDT1.ACKUNI=0;
763:                               FRL1f_NextFr=0;
764:                               krok++;
2EAA  2BB1     INCF 0xB1, F, BANKED
2EAC  D006     BRA 0x2EBA
765:                           }
766:                           case 2:         //2.Oczekiwanie na odpowiedz
767:                           {
768:                               switch(LINWaitForAnswerUNI02(_LIN_RPKNF))
2EBA  0E02     MOVLW 0x2
2EBC  ECAE     CALL 0xB75C, 0
2EBE  F05B     NOP
2EC0  0A00     XORLW 0x0
2EC2  B4D8     BTFSC STATUS, 2, ACCESS
2EC4  0CFF     RETLW 0xFF
2EC6  0A01     XORLW 0x1
2EC8  E0F2     BZ 0x2EAE
2ECA  D7F4     BRA 0x2EB4
769:                               {
770:                                   case 0:
771:                                       return _LIN1_IBUSY;
772:                                   case 1:
773:                                       krok++;
2EAE  0101     MOVLB 0x1
2EB0  2BB1     INCF 0xB1, F, BANKED
774:                                       break;
2EB2  D00C     BRA 0x2ECC
775:                                   default:
776:                                       krok=0;
2EB4  0101     MOVLB 0x1
2EB6  6BB1     CLRF 0xB1, BANKED
777:                                       return _LIN1_ERRODP;
2EB8  0C05     RETLW 0x5
778:                               }
779:                           }
780:                           case 3:         //3.Przygotowanie danych dla LIN
781:                           {
782:                               krok=0;
2ECC  6BB1     CLRF 0xB1, BANKED
783:                               if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
2ECE  B402     BTFSC LIN1f_Busy, 2, ACCESS
2ED0  0CF0     RETLW 0xF0
784:                               if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
2ED2  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
2ED4  D02B     BRA 0x2F2C
785:                               {
786:                                   if(RSDT1.outLDTA2) return _LIN1_ERRODP;                         //status operacji na UNI-02 wskazuje na blad?
2ED6  0102     MOVLB 0x2
2ED8  5173     MOVF _PFNf_popFN, W, BANKED
2EDA  E001     BZ 0x2EDE
2EDC  0C05     RETLW 0x5
787:                                   FTL1.PCI_LENGTH=0x05;                                           //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2EDE  0E05     MOVLW 0x5
2EE0  D97B     RCALL PL64
788:                                   FTL1.WRD0.byte0=0xB2+0x40;                                      //RSID=SID+0x40
789:                                   if(RSDT1.inLDTA1<_KNPAR)
2EE2  0E1D     MOVLW 0x1D
2EE4  0102     MOVLB 0x2
2EE6  61A1     CPFSLT _UADtf_RErrREC, BANKED
2EE8  0C05     RETLW 0x5
790:                                   {
791:                                       FTL1.WRD0.byte1=RSDT1.outLDTA1;  
2EEA  C272     MOVFF 0x272, 0x14B
2EEC  F14B     NOP
792:                                       FTL1.WRD1.byte0=(unsigned char) CPZK[RSDT1.inLDTA1].min;
2EEE  51A1     MOVF _UADtf_RErrREC, W, BANKED
2EF0  0D05     MULLW 0x5
2EF2  D96B     RCALL PL48
2EF4  0008     TBLRD*
2EF6  CFF5     MOVFF TABLAT, 0x14C
2EF8  F14C     NOP
793:                                       FTL1.WRD1.byte1=(unsigned char) CPZK[RSDT1.inLDTA1].max; 
2EFA  51A1     MOVF _UADtf_RErrREC, W, BANKED
2EFC  0D05     MULLW 0x5
2EFE  D950     RCALL __end_of_LIN1SingleResponse_RD
2F00  0008     TBLRD*
2F02  CFF5     MOVFF TABLAT, 0x14D
2F04  F14D     NOP
794:                                       FTL1.WRD2.byte0=0;
2F06  0101     MOVLB 0x1
2F08  6B4E     CLRF 0x4E, BANKED
795:                                       /*if(PZK[RSDT1.inLDTA1].fl.T) FTL1.WRD2.byte0=1;
796:                                       if(PZK[RSDT1.inLDTA1].fl.P) FTL1.WRD2.byte0=2;*/ 
797:                                       if(CPZK[RSDT1.inLDTA1].flwar&0b00001000) FTL1.WRD2.byte0=1;
2F0A  D979     RCALL PL186
2F0C  D954     RCALL PL36
2F0E  0008     TBLRD*
2F10  A6F5     BTFSS TABLAT, 3, ACCESS
2F12  D003     BRA 0x2F1A
2F14  0E01     MOVLW 0x1
2F16  0101     MOVLB 0x1
2F18  6F4E     MOVWF 0x4E, BANKED
798:                                       if(CPZK[RSDT1.inLDTA1].flwar&0b00010000) FTL1.WRD2.byte0=2;                            
2F1A  D971     RCALL PL186
2F1C  D94C     RCALL PL36
2F1E  0008     TBLRD*
2F20  A8F5     BTFSS TABLAT, 4, ACCESS
2F22  0C00     RETLW 0x0
2F24  0E02     MOVLW 0x2
2F26  0101     MOVLB 0x1
2F28  6F4E     MOVWF 0x4E, BANKED
2F2A  0C00     RETLW 0x0
799:                                   }
800:                                   else return _LIN1_ERRODP;
801:                                           
802:                               }
803:                               else                                                                //aktualizowano ramke - odpowiedz negatywna
804:                               {
805:                                   Nop();
2F2C  F000     NOP
2F2E  0C05     RETLW 0x5
806:                                   return _LIN1_ERRODP;
807:                               }
808:                           }
809:                       }
810:                       break;
811:                   }
812:                   case _CLIN_RRD_RT:                                      //wygeneruj pinformacje o pobudzeniu RT
813:                   {
814:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2F44  0E02     MOVLW 0x2
2F46  D948     RCALL PL64
815:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
816:                       FTL1.WRD0.byte1=(PFNf_pobRT)?1:0;                   //liczba parametrow konfiguracyjnych           
2F48  0E00     MOVLW 0x0
2F4A  B40E     BTFSC PFNf_popFN, 2, ACCESS
2F4C  0E01     MOVLW 0x1
2F4E  D005     BRA 0x2F5A
817:                       break;     
818:                   }         
819:                   case _CLIN_RRD_CW:                                      //wygeneruj pinformacje o pobudzeniu CW/stanie timera zasobnika
820:                   {
821:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2F50  0E02     MOVLW 0x2
2F52  D942     RCALL PL64
822:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
823:                       FTL1.WRD0.byte1=(PFNf_timZAS)?1:0;                  //pobudzenie CW           
2F54  0E00     MOVLW 0x0
2F56  BC10     BTFSC PFNf_str_nco, 6, ACCESS
2F58  0E01     MOVLW 0x1
2F5A  6F4B     MOVWF 0x4B, BANKED
824:                       break;     
2F5C  0C00     RETLW 0x0
825:                   }  
826:                   case _CLIN_RRD_10V:                                     //wygeneruj informacje o interfejsie 10V
827:                   {
828:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2F5E  0E04     MOVLW 0x4
2F60  D93B     RCALL PL64
829:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
830:                       FTL1.WRD0.byte1=(PFNf_EnF10V)?1:0;                  //aktywnosc interfejsu 10V
2F62  0E00     MOVLW 0x0
2F64  B605     BTFSC PFNf_KnfDisErr, 3, ACCESS
2F66  0E01     MOVLW 0x1
2F68  6F4B     MOVWF 0x4B, BANKED
831:                       FTL1.WRD1.byte0=(PFNf_10V_RT)?1:0;                  //Pobudzenie RT od interfejsu 10V
2F6A  0E00     MOVLW 0x0
2F6C  B005     BTFSC PFNf_KnfDisErr, 0, ACCESS
2F6E  0E01     MOVLW 0x1
2F70  6F4C     MOVWF 0x4C, BANKED
832:                       FTL1.WRD1.byte1=PFN.PCO10V;                         //nowa wartosc SETPOINT z interfejsu 10V
2F72  C1F7     MOVFF 0x1F7, 0x14D
2F74  F14D     NOP
833:                       break;
2F76  0C00     RETLW 0x0
834:                   } 
835:                   case _CLIN_RRD_SETP:                                    //wygeneruj pinformacje o wartosci SETP
836:                   {
837:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2F78  0E04     MOVLW 0x4
2F7A  D92E     RCALL PL64
838:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
839:                       FTL1.WRD0.byte1=PFN.CONTSETP;                       //docelowa wartosc modulacji dla grzania obiegu WG       
2F7C  C1F9     MOVFF 0x1F9, 0x14B
2F7E  F14B     NOP
840:                       FTL1.WRD1.byte0=PFN.SETPmin;                        //dolna granica dla SETP
2F80  C1FA     MOVFF 0x1FA, 0x14C
2F82  F14C     NOP
841:                       FTL1.WRD1.byte1=PFN.SETPmax;                        //gorna granica dla SETP (wartosc graniczna grzania WG)
2F84  C1FB     MOVFF 0x1FB, 0x14D
2F86  F14D     NOP
842:                       break;     
2F88  0C00     RETLW 0x0
843:                   }
844:                   case _CLIN_RRD_ZW:                                      //temp. z czujnika zewnetrznego, aktywnosc regulatora pogodowego, wsp. KT
845:                   {
846:                       FTL1.PCI_LENGTH=0x05;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2F8A  0E05     MOVLW 0x5
2F8C  D925     RCALL PL64
847:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
848:                       FTL1.WRD0.byte1=(PFNf_tmpZW)?1:0;                   //aktywnosc czujnika (0-brak)
2F8E  0E00     MOVLW 0x0
2F90  BE10     BTFSC PFNf_str_nco, 7, ACCESS
2F92  0E01     MOVLW 0x1
2F94  6F4B     MOVWF 0x4B, BANKED
849:                       FTL1.WRD1.byte0=(PFNf_tmpZW)?PFN.ZW:0;              //temp zewnetrzna
2F96  BE10     BTFSC PFNf_str_nco, 7, ACCESS
2F98  D003     BRA 0x2FA0
2F9A  0100     MOVLB 0x0
2F9C  6B9F     CLRF _UADtf_REnd, BANKED
2F9E  D003     BRA 0x2FA6
2FA0  C1DE     MOVFF 0x1DE, _UADtf_REnd
2FA2  F09F     NOP
2FA4  0100     MOVLB 0x0
2FA6  6BA0     CLRF _UADtf_RErrBUF, BANKED
2FA8  C09F     MOVFF _UADtf_REnd, 0x14C
2FAA  F14C     NOP
850:                       FTL1.WRD1.byte1=(PFNf_pgd)?1:0;                     //aktywnosc regulatora pogodowego (0-nieaktywny)   
2FAC  0E00     MOVLW 0x0
2FAE  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
2FB0  0E01     MOVLW 0x1
2FB2  0101     MOVLB 0x1
2FB4  6F4D     MOVWF 0x4D, BANKED
851:                       FTL1.WRD2.byte0=(PFNf_pgd)?(unsigned char)PFN.PCO:0;               //wartosc KT
2FB6  BA0D     BTFSC PFNf_plmCO, 5, ACCESS
2FB8  D003     BRA 0x2FC0
2FBA  0100     MOVLB 0x0
2FBC  6BA1     CLRF _UADtf_RErrREC, BANKED
2FBE  D003     BRA 0x2FC6
2FC0  C1EE     MOVFF 0x1EE, _UADtf_RErrREC
2FC2  F0A1     NOP
2FC4  0100     MOVLB 0x0
2FC6  6BA2     CLRF _UADtf_TData, BANKED
2FC8  C0A1     MOVFF _UADtf_RErrREC, 0x14E
2FCA  F14E     NOP
852:                       break;
2FCC  0C00     RETLW 0x0
853:                   }        
854:                   case _CLIN_RRD_INT:                                     //wygeneruj informacje zbiorcza o aktywnosci interfejsach 10V,OT,LIN
855:                   {
856:                       FTL1.PCI_LENGTH=0x04;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
2FCE  0E04     MOVLW 0x4
2FD0  D903     RCALL PL64
857:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40 
858:                       //------------------------------            
859:                       //interfejs komunikacyjny - status i docelowa wartosc modulacji
860:                       dt=0;
2FD2  0100     MOVLB 0x0
2FD4  6BA3     CLRF _UADtf_TEXT, BANKED
861:                       //LIN
862:                       if(PFNf_FLIN)   dt=dt|0b10000000;                                                       //aktywnosc LIN
2FD6  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
2FD8  D003     BRA 0x2FE0
2FDA  51A3     MOVF _UADtf_TEXT, W, BANKED
2FDC  0980     IORLW 0x80
2FDE  6FA3     MOVWF _UADtf_TEXT, BANKED
863:                       if((PFNf_LIN_RT&&PFNf_FLIN)||(PFNf_LIN_PBCO&&PFNf_FLIN))                                //RT LIN
2FE0  A207     BTFSS PFNf_OTTimeout, 1, ACCESS
2FE2  D002     BRA 0x2FE8
2FE4  BA05     BTFSC PFNf_KnfDisErr, 5, ACCESS
2FE6  D003     BRA 0x2FEE
2FE8  BE06     BTFSC PFNf_LIN_CW, 7, ACCESS
2FEA  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
2FEC  D003     BRA 0x2FF4
864:                       {
865:                           dt=dt|0b01000000;
2FEE  51A3     MOVF _UADtf_TEXT, W, BANKED
2FF0  0940     IORLW 0x40
2FF2  6FA3     MOVWF _UADtf_TEXT, BANKED
866:                       }
867:                       if((PFNf_EnAleg&&PFNf_LIN_CW&&PFNf_FLIN)||(PFNf_EnAleg&&PFNf_LIN_PBCW&&PFNf_FLIN))      //CW LIN
2FF4  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
2FF6  A206     BTFSS PFNf_LIN_CW, 1, ACCESS
2FF8  D002     BRA 0x2FFE
2FFA  BA05     BTFSC PFNf_KnfDisErr, 5, ACCESS
2FFC  D005     BRA 0x3008
2FFE  B405     BTFSC PFNf_KnfDisErr, 2, ACCESS
3000  A007     BTFSS PFNf_OTTimeout, 0, ACCESS
3002  D005     BRA 0x300E
3004  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
3006  D003     BRA 0x300E
868:                       {
869:                           dt=dt|0b00100000;
3008  51A3     MOVF _UADtf_TEXT, W, BANKED
300A  0920     IORLW 0x20
300C  6FA3     MOVWF _UADtf_TEXT, BANKED
870:                       }            
871:                       //OT
872:                       if(PFNf_FOT) dt=dt|0b00010000;                                                          //aktywnosc OT
300E  BC05     BTFSC PFNf_KnfDisErr, 6, ACCESS
3010  D90E     RCALL PL812
873:                       if(OTMaster.Status._CH_enable&&PFNf_FOT) dt=dt|0b00001000;                              //RT OT   
3012  0101     MOVLB 0x1
3014  B165     BTFSC 0x65, 0, BANKED
3016  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
3018  D001     BRA 0x301C
301A  D8FC     RCALL PL646
874:                       if(PFNf_EnAleg&&(OTMaster.Status._DHW_enable&&PFNf_FOT)) dt=dt|0b00000100;              //CW OT            
301C  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
301E  D006     BRA 0x302C
3020  0101     MOVLB 0x1
3022  B365     BTFSC 0x65, 1, BANKED
3024  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
3026  D002     BRA 0x302C
3028  0100     MOVLB 0x0
302A  D8FD     RCALL PL780
875:                       //10V
876:                       if(PFNf_EnF10V) dt=dt|0b00000010;                                                       //aktywnosc 10V
302C  A605     BTFSS PFNf_KnfDisErr, 3, ACCESS
302E  D002     BRA 0x3034
3030  0100     MOVLB 0x0
3032  D901     RCALL PL836
877:                       if(PFNf_10V_RT&&PFNf_EnF10V) dt=dt|0b00000001;                                          //RT 10V     
3034  B005     BTFSC PFNf_KnfDisErr, 0, ACCESS
3036  A605     BTFSS PFNf_KnfDisErr, 3, ACCESS
3038  D002     BRA 0x303E
303A  0100     MOVLB 0x0
303C  D8F0     RCALL PL778
878:                      
879:                       FTL1.WRD0.byte1=dt;                                                                     //status interfejsow 
303E  C0A3     MOVFF _UADtf_TEXT, 0x14B
3040  F14B     NOP
880:                       //------------------------------
881:                       dt=0;
3042  0100     MOVLB 0x0
3044  6BA3     CLRF _UADtf_TEXT, BANKED
882:                       if(PFNf_LIN_KSK&&PFNf_FLIN) dt=dt|0b00000100;                                           //tryb kaskada interfejsu LIN
3046  BC06     BTFSC PFNf_LIN_CW, 6, ACCESS
3048  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
304A  D001     BRA 0x304E
304C  D8EC     RCALL PL780
883:                       if(PFNf_LIN_STR&&PFNf_FLIN) dt=dt|0b00000010;                                           //tryb sterowania z zadanym SETP z interfejsu LIN
304E  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
3050  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
3052  D001     BRA 0x3056
3054  D8F0     RCALL PL836
884:                       if(PFNf_LIN_DPGD&&PFNf_FLIN) dt=dt|0b00000001;                                          //deaktywacja wbudowanego regulatora pogodowego za po¶rednictwem interfejsu LIN
3056  B406     BTFSC PFNf_LIN_CW, 2, ACCESS
3058  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
305A  D001     BRA 0x305E
305C  D8E0     RCALL PL778
885:                       if(OTMaster.Ref._Control_Setpoint&&PFNf_FOT) dt=dt|0b00010000;                          //tryb sterowania z zadanym SETP z interfejsu OT
305E  0101     MOVLB 0x1
3060  BD5E     BTFSC 0x5E, 6, BANKED
3062  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
3064  D002     BRA 0x306A
3066  0100     MOVLB 0x0
3068  D8E2     RCALL PL812
886:                       if(PFNf_OT_DPGD&&PFNf_FOT) dt=dt|0b00001000;                                            //deaktywacja wbudowanego regulatora pogodowego za po¶rednictwem interfejsu OT
306A  BE07     BTFSC PFNf_OTTimeout, 7, ACCESS
306C  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
306E  D001     BRA 0x3072
3070  D8D1     RCALL PL646
887:                       
888:                       FTL1.WRD1.byte0=dt;
3072  C0A3     MOVFF _UADtf_TEXT, 0x14C
3074  F14C     NOP
889:                       //------------------------------
890:                       //docelowa wartosc modulacji
891:                       if((PFNf_LIN_KSK&&PFNf_FLIN)||(PFNf_LIN_STR&&PFNf_FLIN))
3076  AC06     BTFSS PFNf_LIN_CW, 6, ACCESS
3078  D002     BRA 0x307E
307A  BA05     BTFSC PFNf_KnfDisErr, 5, ACCESS
307C  D003     BRA 0x3084
307E  B407     BTFSC PFNf_OTTimeout, 2, ACCESS
3080  AA05     BTFSS PFNf_KnfDisErr, 5, ACCESS
3082  D003     BRA 0x308A
892:                       {
893:                           FTL1.WRD1.byte1=PFN.CONTSETP; 
3084  C1F9     MOVFF 0x1F9, 0x14D
3086  F14D     NOP
894:                       }
3088  0C00     RETLW 0x0
895:                       else
896:                       if(OTMaster.Ref._Control_Setpoint&&PFNf_FOT)
308A  0101     MOVLB 0x1
308C  BD5E     BTFSC 0x5E, 6, BANKED
308E  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
3090  D007     BRA 0x30A0
3092  D8B9     RCALL PL294
897:                       {
898:                           FTL1.WRD1.byte1=(unsigned char)OTMaster.Control_Setpoint;
3094  EC6D     CALL 0x86DA, 0
3096  F043     NOP
3098  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
309A  0101     MOVLB 0x1
309C  6F4D     MOVWF 0x4D, BANKED
899:                       }
309E  0C00     RETLW 0x0
900:                       else
901:                       if(PFNf_EnF10V)
30A0  B605     BTFSC PFNf_KnfDisErr, 3, ACCESS
30A2  D767     BRA 0x2F72
902:                       {
903:                           FTL1.WRD1.byte1=PFN.PCO10V;
904:                       }
905:                       else
906:                       {
907:                           FTL1.WRD1.byte1=0;
30A4  6B4D     CLRF 0x4D, BANKED
30A6  0C00     RETLW 0x0
908:                       }
909:                       break;
910:                   }
911:                   case _CLIN_RRD_PRD:                                     //specjalny tryb pracy sterownika
912:                   {
913:                       FTL1.PCI_LENGTH=0x02;                               //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
30A8  0E02     MOVLW 0x2
30AA  D896     RCALL PL64
914:                       FTL1.WRD0.byte0=0xB2+0x40;                          //RSID=SID+0x40
915:                       FTL1.WRD0.byte1=PFN.STRB;                           //specjalny tryb pracy sterownika           
30AC  C1FC     MOVFF 0x1FC, 0x14B
30AE  F14B     NOP
916:                       break;     
30B0  0C00     RETLW 0x0
917:                   }   
918:                   case _CLIN_RRD_STH:              //odczytaj statystyki zdarzen awaryjnych 
919:                   {
920:                       //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
921:                       switch(krok)
3116  0101     MOVLB 0x1
3118  51B1     MOVF 0xB1, W, BANKED
311A  E0CB     BZ 0x30B2
311C  0A01     XORLW 0x1
311E  E0D1     BZ 0x30C2
3120  0A03     XORLW 0x3
3122  E0DE     BZ 0x30E0
3124  0A01     XORLW 0x1
3126  E0E5     BZ 0x30F2
3128  0C00     RETLW 0x0
922:                       {
923:                           case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
924:                               if(!LINWaitForAnswerUNI02(_LIN_GSTAT)) return _LIN1_IBUSY;
30B2  0E03     MOVLW 0x3
30B4  ECAE     CALL 0xB75C, 0
30B6  F05B     NOP
30B8  0900     IORLW 0x0
30BA  E101     BNZ 0x30BE
30BC  0CFF     RETLW 0xFF
925:                               krok++;
30BE  0101     MOVLB 0x1
30C0  2BB1     INCF 0xB1, F, BANKED
926:                           case 1:         //1.Wysylka komendy do UNI-02
927:                           {
928:                               //komendy i parametry wywolania dla UNI-02
929:                               RSDT1.inLIDN=_LIN_GSTAT;             //komenda    
30C2  0E03     MOVLW 0x3
30C4  0102     MOVLB 0x2
30C6  6FA0     MOVWF _UADtf_RErrBUF, BANKED
930:                               
931:                               //start wywolania
932:                               if(!FRL1.NAD) FRL1f_ZeroAdr=1;
30C8  0100     MOVLB 0x0
30CA  51AF     MOVF 0xAF, W, BANKED
30CC  E102     BNZ 0x30D2
30CE  8402     BSF LIN1f_Busy, 2, ACCESS
30D0  D001     BRA 0x30D4
933:                               else FRL1f_ZeroAdr=0;
30D2  9402     BCF LIN1f_Busy, 2, ACCESS
30D4  D88E     RCALL PL178
934:                               RSDT1f_NewLIDN=1;
935:                               RSDT1.ACKUNI=0;
936:                               FRL1f_NextFr=0;
937:                               krok++;
30D6  2BB1     INCF 0xB1, F, BANKED
30D8  D003     BRA 0x30E0
938:                           }
939:                           case 2:         //2.Oczekiwanie na odpowiedz
940:                           {
941:                               switch(LINWaitForAnswerUNI02(_LIN_GSTAT))
30E0  0E03     MOVLW 0x3
30E2  ECAE     CALL 0xB75C, 0
30E4  F05B     NOP
30E6  0A00     XORLW 0x0
30E8  B4D8     BTFSC STATUS, 2, ACCESS
30EA  0CFF     RETLW 0xFF
30EC  0A01     XORLW 0x1
30EE  E0F5     BZ 0x30DA
30F0  D6E1     BRA 0x2EB4
942:                               {
943:                                   case 0:
944:                                       return _LIN1_IBUSY;
945:                                   case 1:
946:                                       krok++;
30DA  0101     MOVLB 0x1
30DC  2BB1     INCF 0xB1, F, BANKED
947:                                       break;
30DE  D009     BRA 0x30F2
948:                                   default:
949:                                       krok=0;
950:                                       return _LIN1_ERRODP;
951:                               }
952:                           }
953:                           case 3:         //3.Przygotowanie danych dla KSK
954:                           {
955:                               krok=0;
30F2  6BB1     CLRF 0xB1, BANKED
956:                               if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
30F4  B402     BTFSC LIN1f_Busy, 2, ACCESS
30F6  0CF0     RETLW 0xF0
957:                               if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji ramki LIN?
30F8  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
30FA  0C05     RETLW 0x5
958:                               {
959:                                   FTL1.PCI_LENGTH=0x05;                                           //Rozmiar ramki(RSID+liczba bajtow danych bez CHK)
30FC  0E05     MOVLW 0x5
30FE  6F42     MOVWF 0x42, BANKED
960:                                   FTL1.WRD0.byte0=0xB2+0x40;                                      //RSID=SID+0x40
3100  0EF2     MOVLW 0xF2
3102  6F4A     MOVWF cSk, BANKED
961:                                   FTL1.WRD0.byte1=RSDT1.outLDTA1;  
3104  C272     MOVFF 0x272, 0x14B
3106  F14B     NOP
962:                                   FTL1.WRD1.byte0=RSDT1.outLDTA2;
3108  C273     MOVFF 0x273, 0x14C
310A  F14C     NOP
963:                                   FTL1.WRD1.byte1=RSDT1.outLDTA3; 
310C  C274     MOVFF 0x274, 0x14D
310E  F14D     NOP
964:                                   FTL1.WRD2.byte0=RSDT1.outLDTA4;               
3110  C275     MOVFF 0x275, 0x14E
3112  F14E     NOP
965:                               }
3114  0C00     RETLW 0x0
3116  0101     MOVLB 0x1
3118  51B1     MOVF 0xB1, W, BANKED
311A  E0CB     BZ 0x30B2
311C  0A01     XORLW 0x1
311E  E0D1     BZ 0x30C2
3120  0A03     XORLW 0x3
3122  E0DE     BZ 0x30E0
3124  0A01     XORLW 0x1
3126  E0E5     BZ 0x30F2
3128  0C00     RETLW 0x0
312A  0100     MOVLB 0x0
312C  51B5     MOVF 0xB5, W, BANKED
312E  0A01     XORLW 0x1
3130  E101     BNZ 0x3134
3132  D601     BRA 0x2D36
3134  0A04     XORLW 0x4
3136  E101     BNZ 0x313A
3138  D624     BRA 0x2D82
313A  0A03     XORLW 0x3
313C  E101     BNZ 0x3140
313E  D62F     BRA 0x2D9E
3140  0A01     XORLW 0x1
3142  E101     BNZ 0x3146
3144  D638     BRA 0x2DB6
3146  0A0F     XORLW 0xF
3148  E101     BNZ 0x314C
314A  D63D     BRA 0x2DC6
314C  0A01     XORLW 0x1
314E  E101     BNZ 0x3152
3150  D649     BRA 0x2DE4
3152  0A03     XORLW 0x3
3154  E101     BNZ 0x3158
3156  D64C     BRA 0x2DF0
3158  0A01     XORLW 0x1
315A  E101     BNZ 0x315E
315C  D665     BRA 0x2E28
315E  0A07     XORLW 0x7
3160  E101     BNZ 0x3164
3162  D67A     BRA 0x2E58
3164  0A01     XORLW 0x1
3166  E101     BNZ 0x316A
3168  D688     BRA 0x2E7A
316A  0A03     XORLW 0x3
316C  E101     BNZ 0x3170
316E  D6E0     BRA 0x2F30
3170  0A01     XORLW 0x1
3172  E101     BNZ 0x3176
3174  D6E7     BRA 0x2F44
3176  0A1F     XORLW 0x1F
3178  E101     BNZ 0x317C
317A  D6EA     BRA 0x2F50
317C  0A02     XORLW 0x2
317E  E101     BNZ 0x3182
3180  D6EE     BRA 0x2F5E
3182  0A01     XORLW 0x1
3184  E101     BNZ 0x3188
3186  D6F8     BRA 0x2F78
3188  0A07     XORLW 0x7
318A  E101     BNZ 0x318E
318C  D6FE     BRA 0x2F8A
318E  0A01     XORLW 0x1
3190  E101     BNZ 0x3194
3192  D71D     BRA 0x2FCE
3194  0A03     XORLW 0x3
3196  E088     BZ 0x30A8
3198  0A0F     XORLW 0xF
319A  A4D8     BTFSS STATUS, 2, ACCESS
319C  0C01     RETLW 0x1
319E  D7BB     BRA 0x3116
966:                               else                                                                //aktualizowano ramke - odpowiedz negatywna
967:                               {
968:                                   return _LIN1_ERRODP;
969:                               }
970:                           }
971:                       }
972:                       break;
973:                   }        
974:                   default:                   //nieznana komenda
975:                   {
976:                       return _LIN1_UNCCOM;
977:                   }
978:               }
979:               return _LIN1_IFINAL;            //koniec przetwarzania danych
980:           }
981:           //------------------------------------------------------------
982:           //------------------------------------------------------------
983:           //MULTIRESPONSE
984:           //PRZYGOTOWANIE bufora do wysylki do MASTER (wskazanie adresu i rozmiaru oraz aktualizacja danych bufora)
985:           //UWAGA: zwrot wartosci _LIN1_IBUSY sygnalizuje trwanie procesu (maksymalny czas zajetosci zdefiniowany parametrem _LN1_ADTA)
986:           //Start nadawania - aktualizacja danych w buforze, wskazanie bufora z danymi
987:           unsigned char LIN1StartMultiResponse_RD(void)
988:           {
989:               volatile unsigned char dt,i;
990:               static unsigned char krok,bidn;
991:               BitSet2(&RSDT1.inLNSTAT,_FLIN,1);        //odswiez znacznik komunikacji LIN dla ukladu UNI-02
270E  0E7C     MOVLW 0x7C
2710  ECF1     CALL 0x31E2, 0
2712  F018     NOP
2714  EC6D     CALL 0xACDA, 0
2716  F056     NOP
992:               PFNf_FLIN=1;    
2718  8A05     BSF PFNf_KnfDisErr, 5, ACCESS
993:               StartRTdS(_RTFLIN);
271A  0E08     MOVLW 0x8
271C  EC55     CALL 0xBCAA, 0
271E  F05E     NOP
994:               
995:               //----------------    
996:               if(FRL1f_RSFrame)                 //ramka nadeslana z modulu Wifi?
2720  A002     BTFSS LIN1f_Busy, 0, ACCESS
2722  D005     BRA 0x272E
997:               {
998:                   if(!RSFInterpreter_MultiRD()) return _LIN1_UNCCOM;       
2724  EC75     CALL 0x94EA, 0
2726  F04A     NOP
2728  0900     IORLW 0x0
272A  E101     BNZ 0x272E
272C  0C01     RETLW 0x1
999:               }    
1000:              //----------------
1001:              if(bidn!=FRL1.IDN)                      //przy zmianie komendy zeruj stan procedury bezposredniej komunikacji z UNI-02
272E  0101     MOVLB 0x1
2730  51B4     MOVF 0xB4, W, BANKED
2732  0100     MOVLB 0x0
2734  19B5     XORWF 0xB5, W, BANKED
2736  E101     BNZ 0x273A
2738  D282     BRA 0x2C3E
1002:              {
1003:                  bidn=FRL1.IDN;
273A  C0B5     MOVFF 0xB5, bidn
273C  F1B4     NOP
1004:                  krok=0;
273E  0101     MOVLB 0x1
2740  6BB5     CLRF 0xB5, BANKED
2742  D27D     BRA 0x2C3E
1005:              }
1006:              //komenda na ktora nastapila reakcja ukladu SLAVE
1007:              switch(FRL1.IDN)                        //identyfikator komendy
2C3E  0100     MOVLB 0x0
2C40  51B5     MOVF 0xB5, W, BANKED
2C42  0A02     XORLW 0x2
2C44  E101     BNZ 0x2C48
2C46  D57E     BRA 0x2744
2C48  0A01     XORLW 0x1
2C4A  E101     BNZ 0x2C4E
2C4C  D5BA     BRA 0x27C2
2C4E  0A07     XORLW 0x7
2C50  E101     BNZ 0x2C54
2C52  D6C0     BRA 0x29D4
2C54  0A15     XORLW 0x15
2C56  E101     BNZ 0x2C5A
2C58  D63D     BRA 0x28D4
2C5A  0A06     XORLW 0x6
2C5C  E101     BNZ 0x2C60
2C5E  D763     BRA 0x2B26
2C60  0A0F     XORLW 0xF
2C62  A4D8     BTFSS STATUS, 2, ACCESS
2C64  0C01     RETLW 0x1
2C66  D7E1     BRA 0x2C2A
1008:              {
1009:                  case _CLIN_RRD_STD:                 //odeslij do KSK standardowa paczke danych opisujaca stan sterownika
1010:                  {          
1011:                      //Odpowiedz zwrotna LCD do KSK
1012:                      //Przygotowanie danych dla KSK
1013:                      FRL1.imax=_NDT_RRD_STD;          //rozmiar tabeli
2744  6BCB     CLRF 0xCB, BANKED
2746  0E17     MOVLW 0x17
2748  DAB4     RCALL PL114
1014:                      FRL1.tab=tbuf;         //adres tabeli
1015:                      if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;
274A  E104     BNZ 0x2754
274C  51CA     MOVF 0xCA, W, BANKED
274E  11CB     IORWF 0xCB, W, BANKED
2750  E001     BZ 0x2754
2752  DAB7     RCALL PL118
1016:                      //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war
1017:                      tbuf[0]=RSDT1.outRDZ0;
2754  C230     MOVFF 0x230, tbuf
2756  F2A6     NOP
1018:                      tbuf[1]=RSDT1.outRDZ1;
2758  C231     MOVFF 0x231, 0x2A7
275A  F2A7     NOP
1019:                      tbuf[2]=RSDT1.outSTAT0;
275C  C245     MOVFF 0x245, 0x2A8
275E  F2A8     NOP
1020:                      if(PFNf_EnAleg)
2760  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
2762  D003     BRA 0x276A
1021:                      {
1022:                          tbuf[2]|=0b00000010;
2764  0102     MOVLB 0x2
2766  83A8     BSF sign, 1, BANKED
1023:                      }
2768  D002     BRA 0x276E
1024:                      else
1025:                      {
1026:                          tbuf[2]&=0b11111101;
276A  0102     MOVLB 0x2
276C  93A8     BCF sign, 1, BANKED
1027:                      }            
1028:                      tbuf[3]=RSDT1.outSTAT1;
276E  C246     MOVFF 0x246, 0x2A9
2770  F2A9     NOP
1029:                      tbuf[4]=RSDT1.outSTAT2;
2772  C247     MOVFF 0x247, 0x2AA
2774  F2AA     NOP
1030:                      if(PFNf_off)
2776  AA0C     BTFSS PFNf_off, 5, ACCESS
2778  D002     BRA 0x277E
1031:                      {
1032:                          tbuf[4]|=0b01000000;                             //ustaw tryb OFF
277A  8DAA     BSF f, 6, BANKED
1033:                      }
277C  D001     BRA 0x2780
1034:                      else
1035:                      {
1036:                          tbuf[4]&=0b10111111;                             //zeruj tryb OFF
277E  9DAA     BCF f, 6, BANKED
1037:                      }
1038:                      if(PFNf_lato)
2780  A80B     BTFSS PFNf_lato, 4, ACCESS
2782  D003     BRA 0x278A
1039:                      {
1040:                          tbuf[4]|=0b00100000;                              //ustaw tryb LATO
2784  8BAA     BSF f, 5, BANKED
1041:                          tbuf[4]&=0b11101111;                              //zeruj tryb ZIMA
2786  99AA     BCF f, 4, BANKED
1042:                      }
2788  D002     BRA 0x278E
1043:                      else
1044:                      {
1045:                          tbuf[4]|=0b00010000;                              //ustaw tryb ZIMA
278A  89AA     BSF f, 4, BANKED
1046:                          tbuf[4]&=0b11011111;                              //zeruj tryb LATO
278C  9BAA     BCF f, 5, BANKED
1047:                      }            
1048:                      tbuf[5]=RSDT1.outSTAT3;
278E  C248     MOVFF 0x248, 0x2AB
2790  F2AB     NOP
1049:                      tbuf[6]=RSDT1.outCO;
2792  DA78     RCALL PL98
1050:                      tbuf[7]=RSDT1.outCW;
1051:                      tbuf[8]=RSDT1.outCS;
1052:                      tbuf[9]=RSDT1.outIN;
1053:                      tbuf[10]=RSDT1.outVNT;
1054:                      tbuf[11]=(unsigned char)PFN.PCO;//RSDT1.outPCO;//**********************
1055:                      tbuf[12]=(unsigned char)PFN.PCW;//RSDT1.outPCW;//**********************
1056:                      tbuf[13]=RSDT1.outPPCO;
1057:                      tbuf[14]=RSDT1.outPPCW;
1058:                      tbuf[15]=RSDT1.outERR;
1059:                      tbuf[16]=RSDT1.outAWR;
1060:                      tbuf[17]=RSDT1.outECO;
2794  C242     MOVFF 0x242, 0x2B7
2796  F2B7     NOP
1061:                      tbuf[18]=RSDT1.outPP;
2798  C243     MOVFF 0x243, 0x2B8
279A  F2B8     NOP
1062:                      tbuf[19]=RSDT1.outPG;//23
279C  C244     MOVFF 0x244, 0x2B9
279E  F2B9     NOP
1063:                      if(RSDT1.vSTD==1)
27A0  052F     DECF _PFNf_KnfDisErr, W, BANKED
27A2  E105     BNZ 0x27AE
1064:                      {
1065:                          tbuf[20]=RSDT1.outCO;
27A4  C233     MOVFF 0x233, 0x2BA
27A6  F2BA     NOP
1066:                          tbuf[21]=RSDT1.outCW;                
27A8  C234     MOVFF 0x234, 0x2BB
27AA  F2BB     NOP
1067:                      }
27AC  D004     BRA 0x27B6
1068:                      else
1069:                      {
1070:                          tbuf[20]=RSDT1.outrCO;
27AE  C24B     MOVFF 0x24B, 0x2BA
27B0  F2BA     NOP
1071:                          tbuf[21]=RSDT1.outrCW; 
27B2  C24C     MOVFF 0x24C, 0x2BB
27B4  F2BB     NOP
1072:                      }
1073:                      if(RSDT1.vSTD>=4)
27B6  0E03     MOVLW 0x3
27B8  652F     CPFSGT _PFNf_KnfDisErr, BANKED
27BA  D001     BRA 0x27BE
27BC  D088     BRA 0x28CE
1074:                      {
1075:                          tbuf[22]=RSDT1.outZW; 
1076:                      }
1077:                      else
1078:                      {
1079:                          tbuf[22]=0;
27BE  6BBC     CLRF 0xBC, BANKED
27C0  D253     BRA 0x2C68
1080:                      }            
1081:                      //------------------------------
1082:                      break;
1083:                  }
1084:                  case _CLIN_RRD_STD2:                 //odeslij do KSK rozszerzona paczke danych opisujaca stan sterownika
1085:                  {
1086:                      //-----------------------------------
1087:                      //Parametry transmisji cyklicznej
1088:                      if(FRL1f_RSFrame)                 //ramka nadeslana z modulu Wifi?
27C2  A002     BTFSS LIN1f_Busy, 0, ACCESS
27C4  D003     BRA 0x27CC
1089:                      {
1090:                          CMSGPar.PAR0=0;
27C6  6BD5     CLRF CMSGPar, BANKED
1091:                          CMSGPar.PAR1=0;                
27C8  6BD6     CLRF 0xD6, BANKED
1092:                      }
27CA  D004     BRA 0x27D4
1093:                      else
1094:                      {
1095:                          CMSGPar.PAR0=FRL1.WRD1.byte0;
27CC  C0BC     MOVFF 0xBC, CMSGPar
27CE  F0D5     NOP
1096:                          CMSGPar.PAR1=FRL1.WRD1.byte1;
27D0  C0BD     MOVFF 0xBD, 0xD6
27D2  F0D6     NOP
1097:                      }
1098:                      PFNf_LIN_CK=1;
27D4  8006     BSF PFNf_LIN_CW, 0, ACCESS
1099:                      if(CMSGPar._EN_POB_CO) PFNf_LIN_EPBCO=1;    //znacznik waznosci stanu PBCO
27D6  A5D5     BTFSS CMSGPar, 2, BANKED
27D8  D002     BRA 0x27DE
27DA  8806     BSF PFNf_LIN_CW, 4, ACCESS
27DC  D001     BRA 0x27E0
1100:                      else PFNf_LIN_EPBCO=0;           
27DE  9806     BCF PFNf_LIN_CW, 4, ACCESS
1101:                      if(CMSGPar._KSK_POB_CO&&CMSGPar._EN_POB_CO) PFNf_LIN_PBCO=1;    //cyklicznie odswierzane pobudzenie dla obiegu CO
27E0  B1D5     BTFSC CMSGPar, 0, BANKED
27E2  A5D5     BTFSS CMSGPar, 2, BANKED
27E4  D002     BRA 0x27EA
27E6  8E06     BSF PFNf_LIN_CW, 7, ACCESS
27E8  D001     BRA 0x27EC
1102:                      else PFNf_LIN_PBCO=0;
27EA  9E06     BCF PFNf_LIN_CW, 7, ACCESS
1103:                      if(CMSGPar._EN_POB_CW) PFNf_LIN_EPBCW=1;    //znacznik waznosci stanu PBCW
27EC  A7D5     BTFSS CMSGPar, 3, BANKED
27EE  D002     BRA 0x27F4
27F0  8A06     BSF PFNf_LIN_CW, 5, ACCESS
27F2  D001     BRA 0x27F6
1104:                      else PFNf_LIN_EPBCW=0;
27F4  9A06     BCF PFNf_LIN_CW, 5, ACCESS
1105:                      if(CMSGPar._KSK_POB_CW&&CMSGPar._EN_POB_CW) PFNf_LIN_PBCW=1;    //cyklicznie odswierzane pobudzenie dla obiegu CW
27F6  B3D5     BTFSC CMSGPar, 1, BANKED
27F8  A7D5     BTFSS CMSGPar, 3, BANKED
27FA  D002     BRA 0x2800
27FC  8007     BSF PFNf_OTTimeout, 0, ACCESS
27FE  D001     BRA 0x2802
1106:                      else PFNf_LIN_PBCW=0; 
2800  9007     BCF PFNf_OTTimeout, 0, ACCESS
1107:                      if(CMSGPar._TRB_KSK) PFNf_LIN_KSK=1;
2802  A9D5     BTFSS CMSGPar, 4, BANKED
2804  D002     BRA 0x280A
2806  8C06     BSF PFNf_LIN_CW, 6, ACCESS
2808  D001     BRA 0x280C
1108:                      else PFNf_LIN_KSK=0;
280A  9C06     BCF PFNf_LIN_CW, 6, ACCESS
1109:                      if(CMSGPar._TRB_STR) PFNf_LIN_STR=1;
280C  ADD5     BTFSS CMSGPar, 6, BANKED
280E  D002     BRA 0x2814
2810  8407     BSF PFNf_OTTimeout, 2, ACCESS
2812  D001     BRA 0x2816
1110:                      else PFNf_LIN_STR=0;
2814  9407     BCF PFNf_OTTimeout, 2, ACCESS
1111:          
1112:                      if(PFNf_LIN_KSK||PFNf_LIN_STR)
2816  BC06     BTFSC PFNf_LIN_CW, 6, ACCESS
2818  D002     BRA 0x281E
281A  A407     BTFSS PFNf_OTTimeout, 2, ACCESS
281C  D01D     BRA 0x2858
1113:                      {
1114:                          if(CMSGPar._DPGD) PFNf_LIN_DPGD=1;
281E  AFD5     BTFSS CMSGPar, 7, BANKED
2820  D002     BRA 0x2826
2822  8406     BSF PFNf_LIN_CW, 2, ACCESS
2824  D001     BRA 0x2828
1115:                          else PFNf_LIN_DPGD=0;
2826  9406     BCF PFNf_LIN_CW, 2, ACCESS
1116:                          if(CMSGPar._NST_PCO)                        //nowa wartosc docelowej temperatury WG?
2828  ABD5     BTFSS CMSGPar, 5, BANKED
282A  D017     BRA 0x285A
1117:                          {
1118:                              CMSGPar._NST_PCO=0;
282C  9BD5     BCF CMSGPar, 5, BANKED
1119:                              if((CMSGPar.PAR1>=PFN.SETPmin)&&(CMSGPar.PAR1<=PFN.SETPmax))
282E  DA68     RCALL PL698
2830  E307     BNC 0x2840
2832  51D6     MOVF 0xD6, W, BANKED
2834  0101     MOVLB 0x1
2836  5DFB     SUBWF 0xFB, W, BANKED
2838  E303     BNC 0x2840
1120:                              {
1121:                                  PFN.CONTSETP=CMSGPar.PAR1;
283A  C0D6     MOVFF 0xD6, 0x1F9
283C  F1F9     NOP
1122:                              }  
283E  D00D     BRA 0x285A
1123:                              else
1124:                              if(CMSGPar.PAR1<PFN.SETPmin)    
2840  DA5F     RCALL PL698
2842  E203     BC 0x284A
1125:                              {
1126:                                  PFN.CONTSETP=PFN.SETPmin;
2844  C1FA     MOVFF 0x1FA, 0x1F9
2846  F1F9     NOP
1127:                              }
2848  D008     BRA 0x285A
1128:                              else
1129:                              if(CMSGPar.PAR1>PFN.SETPmax)
284A  51D6     MOVF 0xD6, W, BANKED
284C  0101     MOVLB 0x1
284E  5DFB     SUBWF 0xFB, W, BANKED
2850  E204     BC 0x285A
1130:                              {
1131:                                  PFN.CONTSETP=PFN.SETPmax;      
2852  C1FB     MOVFF 0x1FB, 0x1F9
2854  F1F9     NOP
1132:                              }                    
1133:                          }
1134:                      }
2856  D001     BRA 0x285A
1135:                      else
1136:                      {
1137:                          PFNf_LIN_DPGD=0;
2858  9406     BCF PFNf_LIN_CW, 2, ACCESS
1138:                      }
1139:                      //-----------------------------------
1140:                      //Odpowiedz zwrotna LCD do KSK
1141:                      //Przygotowanie danych dla KSK
1142:                      FRL1.imax=_NDT_RRD_STD2;          //rozmiar tabeli
285A  0100     MOVLB 0x0
285C  6BCB     CLRF 0xCB, BANKED
285E  0E17     MOVLW 0x17
2860  DA28     RCALL PL114
1143:                      FRL1.tab=tbuf;         //adres tabeli
1144:                      if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;            
2862  E104     BNZ 0x286C
2864  51CA     MOVF 0xCA, W, BANKED
2866  11CB     IORWF 0xCB, W, BANKED
2868  E001     BZ 0x286C
286A  DA2B     RCALL PL118
1145:                      //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war
1146:                      tbuf[0]=RSDT1.outSTAT0;
286C  C245     MOVFF 0x245, tbuf
286E  F2A6     NOP
1147:                      if(PFNf_EnAleg)
2870  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
2872  D003     BRA 0x287A
1148:                      {
1149:                          tbuf[0]|=0b00000010;
2874  0102     MOVLB 0x2
2876  83A6     BSF sign, 1, BANKED
1150:                      }
2878  D002     BRA 0x287E
1151:                      else
1152:                      {
1153:                          tbuf[0]&=0b11111101;
287A  0102     MOVLB 0x2
287C  93A6     BCF sign, 1, BANKED
1154:                      }         
1155:                      tbuf[1]=RSDT1.outSTAT1;
287E  C246     MOVFF 0x246, 0x2A7
2880  F2A7     NOP
1156:                      tbuf[2]=RSDT1.outSTAT2;
2882  C247     MOVFF 0x247, 0x2A8
2884  F2A8     NOP
1157:                      if(PFNf_off)
2886  AA0C     BTFSS PFNf_off, 5, ACCESS
2888  D002     BRA 0x288E
1158:                      {
1159:                          tbuf[2]|=0b01000000;                             //ustaw tryb OFF
288A  8DA8     BSF sign, 6, BANKED
1160:                      }
288C  D001     BRA 0x2890
1161:                      else
1162:                      {
1163:                          tbuf[2]&=0b10111111;                             //zeruj tryb OFF
288E  9DA8     BCF sign, 6, BANKED
1164:                      }
1165:                      if(PFNf_lato)
2890  A80B     BTFSS PFNf_lato, 4, ACCESS
2892  D003     BRA 0x289A
1166:                      {
1167:                          tbuf[2]|=0b00100000;                              //ustaw tryb LATO
2894  8BA8     BSF sign, 5, BANKED
1168:                          tbuf[2]&=0b11101111;                              //zeruj tryb ZIMA
2896  99A8     BCF sign, 4, BANKED
1169:                      }
2898  D002     BRA 0x289E
1170:                      else
1171:                      {
1172:                          tbuf[2]|=0b00010000;                              //ustaw tryb ZIMA
289A  89A8     BSF sign, 4, BANKED
1173:                          tbuf[2]&=0b11011111;                              //zeruj tryb LATO
289C  9BA8     BCF sign, 5, BANKED
1174:                      }            
1175:                      tbuf[3]=RSDT1.outSTAT3;
289E  C248     MOVFF 0x248, 0x2A9
28A0  F2A9     NOP
1176:                      tbuf[4]=RSDT1.outSTAT4;
28A2  C249     MOVFF 0x249, 0x2AA
28A4  F2AA     NOP
1177:                      tbuf[5]=RSDT1.outSTAT5;            
28A6  C24A     MOVFF 0x24A, 0x2AB
28A8  F2AB     NOP
28AA  D9EC     RCALL PL98
1178:                      tbuf[6]=RSDT1.outCO;
1179:                      tbuf[7]=RSDT1.outCW;
1180:                      tbuf[8]=RSDT1.outCS;
1181:                      tbuf[9]=RSDT1.outIN;
1182:                      tbuf[10]=RSDT1.outVNT;
1183:                      tbuf[11]=(unsigned char)PFN.PCO;//RSDT1.outPCO;//**********************
1184:                      tbuf[12]=(unsigned char)PFN.PCW;//RSDT1.outPCW;//**********************
1185:                      tbuf[13]=RSDT1.outPPCO;
1186:                      tbuf[14]=RSDT1.outPPCW;
1187:                      tbuf[15]=RSDT1.outERR;
1188:                      tbuf[16]=RSDT1.outAWR;
1189:                      tbuf[17]=RSDT1.outPP;
28AC  C243     MOVFF 0x243, 0x2B7
28AE  F2B7     NOP
1190:                      tbuf[18]=RSDT1.outPG;
28B0  C244     MOVFF 0x244, 0x2B8
28B2  F2B8     NOP
1191:                      if(RSDT1.vSTD==1)
28B4  052F     DECF _PFNf_KnfDisErr, W, BANKED
28B6  E105     BNZ 0x28C2
1192:                      {
1193:                          tbuf[19]=RSDT1.outCO;
28B8  C233     MOVFF 0x233, 0x2B9
28BA  F2B9     NOP
1194:                          tbuf[20]=RSDT1.outCW;                
28BC  C234     MOVFF 0x234, 0x2BA
28BE  F2BA     NOP
1195:                      }
28C0  D004     BRA 0x28CA
1196:                      else
1197:                      {
1198:                          tbuf[19]=RSDT1.outrCO;
28C2  C24B     MOVFF 0x24B, 0x2B9
28C4  F2B9     NOP
1199:                          tbuf[20]=RSDT1.outrCW; 
28C6  C24C     MOVFF 0x24C, 0x2BA
28C8  F2BA     NOP
1200:                      }
1201:          
1202:                      tbuf[21]=PFN.CONTSETP;                                                                  //docelowa wartosc modulacji dla temp zasilania
28CA  C1F9     MOVFF 0x1F9, 0x2BB
28CC  F2BB     NOP
1203:                      tbuf[22]=RSDT1.outZW;                                                                   
28CE  C24D     MOVFF 0x24D, 0x2BC
28D0  F2BC     NOP
1204:                      break;
28D2  D1CA     BRA 0x2C68
1205:                  }
1206:                  case _CLIN_RRD_OT:
1207:                  {
1208:                      //-----------------------------------
1209:                      //Odpowiedz zwrotna LCD
1210:                      FRL1.imax=_NDT_RRD_OT;          //rozmiar tabeli
28D4  6BCB     CLRF 0xCB, BANKED
28D6  0E09     MOVLW 0x9
28D8  D9EC     RCALL PL114
1211:                      FRL1.tab=tbuf;         //adres tabeli
1212:                      if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;            
28DA  E104     BNZ 0x28E4
28DC  51CA     MOVF 0xCA, W, BANKED
28DE  11CB     IORWF 0xCB, W, BANKED
28E0  E001     BZ 0x28E4
28E2  D9EF     RCALL PL118
1213:          
1214:                      if(PFNf_FOT)
28E4  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
28E6  D06B     BRA 0x29BE
1215:                      {
1216:                          tbuf[0]=1;                                      //znacznik aktywnosci interfejsu
28E8  0E01     MOVLW 0x1
28EA  0102     MOVLB 0x2
28EC  6FA6     MOVWF sign, BANKED
1217:                          //Class 2, ID=2
1218:                          if(OTMaster.Ref._MemberID)                      //znacznik ID regulatora
28EE  0101     MOVLB 0x1
28F0  A15E     BTFSS 0x5E, 0, BANKED
28F2  D003     BRA 0x28FA
1219:                          {
1220:                              tbuf[1]=OTMaster.MemberID;
28F4  C162     MOVFF 0x162, 0x2A7
28F6  F2A7     NOP
1221:                          }
28F8  D002     BRA 0x28FE
1222:                          else
1223:                          {
1224:                              tbuf[1]=0;
28FA  0102     MOVLB 0x2
28FC  6BA7     CLRF x, BANKED
1225:                          }
1226:                          //Class 2, ID=126
1227:                          if(OTMaster.Ref._ProductVer)                    //wersja regulatora                   
28FE  0101     MOVLB 0x1
2900  AB5E     BTFSS 0x5E, 5, BANKED
2902  D003     BRA 0x290A
1228:                          {
1229:                              tbuf[2]=OTMaster.ProductVer;
2904  C164     MOVFF 0x164, 0x2A8
2906  F2A8     NOP
1230:                          }
2908  D002     BRA 0x290E
1231:                          else
1232:                          {
1233:                              tbuf[2]=0;
290A  0102     MOVLB 0x2
290C  6BA8     CLRF sign, BANKED
1234:                          }
1235:                          //Class 2, ID=126
1236:                          if(OTMaster.Ref._ProductType)                   //typ regulatora
290E  0101     MOVLB 0x1
2910  A95E     BTFSS 0x5E, 4, BANKED
2912  D003     BRA 0x291A
1237:                          {
1238:                              tbuf[3]=OTMaster.ProductType;
2914  C163     MOVFF 0x163, 0x2A9
2916  F2A9     NOP
1239:                          }
2918  D002     BRA 0x291E
1240:                          else
1241:                          {
1242:                              tbuf[3]=0;
291A  0102     MOVLB 0x2
291C  6BA9     CLRF dt, BANKED
1243:                          }     
1244:                          //Class 2, ID=124
1245:                          if(OTMaster.Ref._OTVer)                         //wersja protokolu OT
291E  0101     MOVLB 0x1
2920  A75E     BTFSS 0x5E, 3, BANKED
2922  D003     BRA 0x292A
1246:                          {
1247:                              tbuf[4]=OTMaster.OTVer;
2924  C160     MOVFF 0x160, 0x2AA
2926  F2AA     NOP
1248:                          }
2928  D002     BRA 0x292E
1249:                          else
1250:                          {
1251:                              tbuf[4]=0;
292A  0102     MOVLB 0x2
292C  6BAA     CLRF f, BANKED
1252:                          }    
1253:                          //Class 1, ID=0
1254:                          if(OTMaster.Ref._Status)                        //sta
292E  0101     MOVLB 0x1
2930  A35E     BTFSS 0x5E, 1, BANKED
2932  D003     BRA 0x293A
1255:                          {
1256:                              //byte1 - Master status
1257:                              /*bit: description [ clear/0, set/1]
1258:                              0: CH enable [ CH is disabled, CH is enabled]           //pobudzenie RT
1259:                              1: DHW enable [ DHW is disabled, DHW is enabled]        //timer zasobnika
1260:                              2: Cooling enable [ Cooling is disabled, Cooling is enabled]
1261:                              3: OTC active [OTC not active, OTC is active]
1262:                              4: CH2 enable [CH2 is disabled, CH2 is enabled]
1263:                              5: Summer/winter mode [winter mode active, summer mode active]
1264:                              6: DHW blocking [DHW unblocked, DHW blocked]
1265:                              7: reserved
1266:                               */                
1267:                              tbuf[5]=OTMaster.Status.war;
2934  C165     MOVFF 0x165, 0x2AB
2936  F2AB     NOP
1268:                          }
2938  D002     BRA 0x293E
1269:                          else
1270:                          {
1271:                              tbuf[5]=0;
293A  0102     MOVLB 0x2
293C  6BAB     CLRF 0xAB, BANKED
1272:                          }  
1273:                          //Class 2, ID=2
1274:                          if(OTMaster.Ref._Config)
293E  0101     MOVLB 0x1
2940  A55E     BTFSS 0x5E, 2, BANKED
2942  D003     BRA 0x294A
1275:                          {
1276:                              /*bit: description [ clear/0, set/1]
1277:                              0: Smart Power [not implemented, implemented]
1278:                              1-7: reserved*/                
1279:                              tbuf[6]=OTMaster.Config.war;
2944  C166     MOVFF 0x166, 0x2AC
2946  F2AC     NOP
1280:                          }
2948  D002     BRA 0x294E
1281:                          else
1282:                          {
1283:                              tbuf[6]=0;
294A  0102     MOVLB 0x2
294C  6BAC     CLRF 0xAC, BANKED
1284:                          }    
1285:                          //Status interfejsu OT
1286:                          dt=0;
294E  0100     MOVLB 0x0
2950  6B9F     CLRF _UADtf_REnd, BANKED
1287:                          if(PFNf_FOT) dt=dt|0b00000001;                                                          //aktywnosc OT
2952  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
2954  D003     BRA 0x295C
2956  519F     MOVF _UADtf_REnd, W, BANKED
2958  0901     IORLW 0x1
295A  6F9F     MOVWF _UADtf_REnd, BANKED
1288:                          if(OTMaster.Status._CH_enable&&PFNf_FOT) dt=dt|0b00000010;                              //RT OT   
295C  0101     MOVLB 0x1
295E  B165     BTFSC 0x65, 0, BANKED
2960  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
2962  D004     BRA 0x296C
2964  0100     MOVLB 0x0
2966  519F     MOVF _UADtf_REnd, W, BANKED
2968  0902     IORLW 0x2
296A  6F9F     MOVWF _UADtf_REnd, BANKED
1289:                          if(PFNf_EnAleg&&(OTMaster.Status._DHW_enable&&PFNf_FOT)) dt=dt|0b00000100;              //CW OT            
296C  A405     BTFSS PFNf_KnfDisErr, 2, ACCESS
296E  D008     BRA 0x2980
2970  0101     MOVLB 0x1
2972  B365     BTFSC 0x65, 1, BANKED
2974  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
2976  D004     BRA 0x2980
2978  0100     MOVLB 0x0
297A  519F     MOVF _UADtf_REnd, W, BANKED
297C  0904     IORLW 0x4
297E  6F9F     MOVWF _UADtf_REnd, BANKED
1290:                          if(OTMaster.Ref._Control_Setpoint&&PFNf_FOT) dt=dt|0b00001000;                          //tryb sterowania z zadanym SETP z interfejsu OT
2980  0101     MOVLB 0x1
2982  BD5E     BTFSC 0x5E, 6, BANKED
2984  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
2986  D004     BRA 0x2990
2988  0100     MOVLB 0x0
298A  519F     MOVF _UADtf_REnd, W, BANKED
298C  0908     IORLW 0x8
298E  6F9F     MOVWF _UADtf_REnd, BANKED
1291:                          if(PFNf_OT_DPGD&&PFNf_FOT) dt=dt|0b00010000;                                            //deaktywacja wbudowanego regulatora pogodowego za po¶rednictwem interfejsu OT
2990  BE07     BTFSC PFNf_OTTimeout, 7, ACCESS
2992  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
2994  D004     BRA 0x299E
2996  0100     MOVLB 0x0
2998  519F     MOVF _UADtf_REnd, W, BANKED
299A  0910     IORLW 0x10
299C  6F9F     MOVWF _UADtf_REnd, BANKED
1292:          
1293:                          tbuf[7]=dt;                
299E  C09F     MOVFF _UADtf_REnd, 0x2AD
29A0  F2AD     NOP
1294:                          
1295:                          //Class 1, ID=1
1296:                          if(OTMaster.Ref._Control_Setpoint&&PFNf_FOT)
29A2  0101     MOVLB 0x1
29A4  BD5E     BTFSC 0x5E, 6, BANKED
29A6  AC05     BTFSS PFNf_KnfDisErr, 6, ACCESS
29A8  D008     BRA 0x29BA
29AA  EC03     CALL 0x3206, 0
29AC  F019     NOP
1297:                          {
1298:                              tbuf[8]=(unsigned char)OTMaster.Control_Setpoint;                     
29AE  EC6D     CALL 0x86DA, 0
29B0  F043     NOP
29B2  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
29B4  0102     MOVLB 0x2
29B6  6FAE     MOVWF FRL1, BANKED
1299:                          }
29B8  D157     BRA 0x2C68
1300:                          else
1301:                          {
1302:                              tbuf[8]=0;            
29BA  0102     MOVLB 0x2
29BC  D009     BRA 0x29D0
1303:                          }                
1304:                      }
1305:                      else
1306:                      {
1307:                          tbuf[0]=0;
29BE  0102     MOVLB 0x2
29C0  6BA6     CLRF sign, BANKED
1308:                          tbuf[1]=0;
29C2  6BA7     CLRF x, BANKED
1309:                          tbuf[2]=0;   
29C4  6BA8     CLRF sign, BANKED
1310:                          tbuf[3]=0;
29C6  6BA9     CLRF dt, BANKED
1311:                          tbuf[4]=0;
29C8  6BAA     CLRF f, BANKED
1312:                          tbuf[5]=0;     
29CA  6BAB     CLRF 0xAB, BANKED
1313:                          tbuf[6]=0; 
29CC  6BAC     CLRF 0xAC, BANKED
1314:                          tbuf[7]=0;    
29CE  6BAD     CLRF 0xAD, BANKED
1315:                          tbuf[8]=0;                
29D0  6BAE     CLRF FRL1, BANKED
29D2  D14A     BRA 0x2C68
1316:                      } 
1317:                      break;
1318:                  }
1319:                  case _CLIN_RRD_KNF:
1320:                  {
1321:                      //-----------------------------------
1322:                      //Odpowiedz zwrotna LCD
1323:                      FRL1.imax=_NDT_RRD_KNF;             //rozmiar tabeli
29D4  6BCB     CLRF 0xCB, BANKED
29D6  0E1D     MOVLW 0x1D
29D8  D96C     RCALL PL114
1324:                      FRL1.tab=tbuf;                      //adres tabeli
1325:                      if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;
29DA  E104     BNZ 0x29E4
29DC  51CA     MOVF 0xCA, W, BANKED
29DE  11CB     IORWF 0xCB, W, BANKED
29E0  E001     BZ 0x29E4
29E2  D96F     RCALL PL118
1326:                      //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war
1327:                      tbuf[0]=RSDT1.outMSTR;
29E4  C254     MOVFF 0x254, tbuf
29E6  F2A6     NOP
1328:                      tbuf[1]=RSDT1.outMMAXU;
29E8  C255     MOVFF 0x255, 0x2A7
29EA  F2A7     NOP
1329:                      tbuf[2]=RSDT1.outMMAXG;
29EC  C256     MOVFF 0x256, 0x2A8
29EE  F2A8     NOP
1330:                      tbuf[3]=RSDT1.outMMIN;
29F0  C25D     MOVFF 0x25D, 0x2A9
29F2  F2A9     NOP
1331:                      tbuf[4]=RSDT1.outMMAX; 
29F4  C25E     MOVFF 0x25E, 0x2AA
29F6  F2AA     NOP
1332:                      tbuf[5]=RSDT1.outKODKT;   
29F8  C258     MOVFF 0x258, 0x2AB
29FA  F2AB     NOP
1333:                      tbuf[6]=RSDT1.outWOBG;                       
29FC  C259     MOVFF 0x259, 0x2AC
29FE  F2AC     NOP
1334:                      tbuf[7]=RSDT1.outOPDG;
2A00  C25B     MOVFF 0x25B, 0x2AD
2A02  F2AD     NOP
1335:                      tbuf[8]=RSDT1.outTPCS;            
2A04  C25C     MOVFF 0x25C, 0x2AE
2A06  F2AE     NOP
1336:                      tbuf[9]=RSDT1.outWANL;
2A08  C257     MOVFF 0x257, 0x2AF
2A0A  F2AF     NOP
1337:                      tbuf[10]=RSDT1.outNOKR;
2A0C  C25A     MOVFF 0x25A, 0x2B0
2A0E  F2B0     NOP
1338:                      tbuf[11]=RSDT1.outRDPM;
2A10  C25F     MOVFF 0x25F, 0x2B1
2A12  F2B1     NOP
1339:                      tbuf[12]=RSDT1.outDTPM;
2A14  C260     MOVFF 0x260, 0x2B2
2A16  F2B2     NOP
1340:                      tbuf[13]=RSDT1.outMDPM;
2A18  C261     MOVFF 0x261, 0x2B3
2A1A  F2B3     NOP
1341:                      tbuf[14]=RSDT1.outTECO;
2A1C  C262     MOVFF 0x262, 0x2B4
2A1E  F2B4     NOP
1342:                      tbuf[15]=RSDT1.outTMMAXG2;
2A20  C263     MOVFF 0x263, 0x2B5
2A22  F2B5     NOP
1343:                      tbuf[16]=RSDT1.outMMAXG2;
2A24  C264     MOVFF 0x264, 0x2B6
2A26  F2B6     NOP
1344:                      tbuf[17]=RSDT1.outMGPM;
2A28  C265     MOVFF 0x265, 0x2B7
2A2A  F2B7     NOP
1345:                      tbuf[18]=RSDT1.outMGPM2;  
2A2C  C266     MOVFF 0x266, 0x2B8
2A2E  F2B8     NOP
1346:                      tbuf[19]=RSDT1.outHSCO;
2A30  C267     MOVFF 0x267, 0x2B9
2A32  F2B9     NOP
1347:                      tbuf[20]=RSDT1.outCONW;  
2A34  C268     MOVFF 0x268, 0x2BA
2A36  F2BA     NOP
1348:                      tbuf[21]=RSDT1.outPROP;
2A38  C269     MOVFF 0x269, 0x2BB
2A3A  F2BB     NOP
1349:                      tbuf[22]=RSDT1.outRFAN; 
2A3C  C26A     MOVFF 0x26A, 0x2BC
2A3E  F2BC     NOP
1350:                      tbuf[23]=RSDT1.outTSTR;        
2A40  C26B     MOVFF 0x26B, 0x2BD
2A42  F2BD     NOP
1351:                      tbuf[24]=RSDT1.outTL3;  
2A44  C26C     MOVFF 0x26C, 0x2BE
2A46  F2BE     NOP
1352:                      tbuf[25]=RSDT1.outPGDR;
2A48  C26D     MOVFF 0x26D, 0x2BF
2A4A  F2BF     NOP
1353:                      tbuf[26]=RSDT1.outPGDG; 
2A4C  C26E     MOVFF 0x26E, 0x2C0
2A4E  F2C0     NOP
1354:                      tbuf[27]=RSDT1.outPGDO;
2A50  C26F     MOVFF 0x26F, 0x2C1
2A52  F2C1     NOP
1355:                      tbuf[28]=RSDT1.outPGMX;            
2A54  C270     MOVFF 0x270, 0x2C2
2A56  F2C2     NOP
1356:                      break;
2A58  D107     BRA 0x2C68
1357:                  }   
1358:                  case _CLIN_RRD_EEST:
1359:                  {
1360:                      //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
1361:                      switch(krok)
2B26  0101     MOVLB 0x1
2B28  51B5     MOVF 0xB5, W, BANKED
2B2A  E097     BZ 0x2A5A
2B2C  0A01     XORLW 0x1
2B2E  E09D     BZ 0x2A6A
2B30  0A03     XORLW 0x3
2B32  E0B9     BZ 0x2AA6
2B34  0A01     XORLW 0x1
2B36  E0C0     BZ 0x2AB8
2B38  D097     BRA 0x2C68
1362:                      {
1363:                          case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
1364:                              if(!LINWaitForAnswerUNI02(_LIN_GEEST)) return _LIN1_IBUSY;
2A5A  0E04     MOVLW 0x4
2A5C  ECAE     CALL 0xB75C, 0
2A5E  F05B     NOP
2A60  0900     IORLW 0x0
2A62  E101     BNZ 0x2A66
2A64  0CFF     RETLW 0xFF
1365:                              krok++;
2A66  0101     MOVLB 0x1
2A68  2BB5     INCF 0xB5, F, BANKED
1366:                          case 1:         //1.Wysylka komendy do UNI-02
1367:                          {
1368:                              //komendy i parametry wywolania dla UNI-02
1369:                              RSDT1.inLIDN=_LIN_GEEST;             //komenda  
2A6A  0E04     MOVLW 0x4
2A6C  EC55     CALL 0x44AA, 0
2A6E  F022     NOP
1370:                              RSDT1.inLDTA1=FRL1.WRD1.byte0;       //parametr = nr statusu
1371:                              for(i=0;i<32;i++) stbf[i]=0;
2A70  0100     MOVLB 0x0
2A72  6BA0     CLRF _UADtf_RErrBUF, BANKED
2A74  0E1F     MOVLW 0x1F
2A76  65A0     CPFSGT _UADtf_RErrBUF, BANKED
2A78  D001     BRA 0x2A7C
2A7A  D006     BRA 0x2A88
2A7C  0E00     MOVLW 0x0
2A7E  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2A80  D927     RCALL PL292
2A82  6ADF     CLRF INDF2, ACCESS
2A84  2BA0     INCF _UADtf_RErrBUF, F, BANKED
2A86  D7F6     BRA 0x2A74
1372:                              
1373:                              //start wywolania
1374:                              if(!FRL1.NAD) FRL1f_ZeroAdr=1;
2A88  51AF     MOVF 0xAF, W, BANKED
2A8A  E102     BNZ 0x2A90
2A8C  8402     BSF LIN1f_Busy, 2, ACCESS
2A8E  D001     BRA 0x2A92
1375:                              else FRL1f_ZeroAdr=0;
2A90  9402     BCF LIN1f_Busy, 2, ACCESS
2A92  ECF9     CALL 0x31F2, 0
2A94  F018     NOP
1376:                              RSDT1f_NewLIDN=1;
1377:                              RSDT1.ACKUNI=0;
1378:                              FRL1f_NextFr=0;
1379:                              krok++;
2A96  2BB5     INCF 0xB5, F, BANKED
2A98  D006     BRA 0x2AA6
1380:                          }
1381:                          case 2:         //2.Oczekiwanie na odpowiedz
1382:                          {
1383:                              switch(LINWaitForAnswerUNI02(_LIN_GEEST))
2AA6  0E04     MOVLW 0x4
2AA8  ECAE     CALL 0xB75C, 0
2AAA  F05B     NOP
2AAC  0A00     XORLW 0x0
2AAE  B4D8     BTFSC STATUS, 2, ACCESS
2AB0  0CFF     RETLW 0xFF
2AB2  0A01     XORLW 0x1
2AB4  E0F2     BZ 0x2A9A
2AB6  D7F4     BRA 0x2AA0
1384:                              {
1385:                                  case 0:
1386:                                      return _LIN1_IBUSY;
1387:                                  case 1:
1388:                                      krok++;
2A9A  0101     MOVLB 0x1
2A9C  2BB5     INCF 0xB5, F, BANKED
1389:                                      break;
2A9E  D00C     BRA 0x2AB8
1390:                                  default:
1391:                                      krok=0;
2AA0  0101     MOVLB 0x1
2AA2  6BB5     CLRF 0xB5, BANKED
1392:                                      return _LIN1_ERRODP;
2AA4  0C05     RETLW 0x5
1393:                              }
1394:                          }
1395:                          case 3:         //3.Przygotowanie danych dla LIN
1396:                          {
1397:                              krok=0;
2AB8  6BB5     CLRF 0xB5, BANKED
1398:                              if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
2ABA  B402     BTFSC LIN1f_Busy, 2, ACCESS
2ABC  0CF0     RETLW 0xF0
1399:                              if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
2ABE  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
2AC0  0C05     RETLW 0x5
1400:                              {
1401:                                  if(!stbf[0]&&!stbf[1]) 
2AC2  0103     MOVLB 0x3
2AC4  5100     MOVF 0x0, W, BANKED
2AC6  E106     BNZ 0x2AD4
2AC8  5101     MOVF DtCOf_err_CO, W, BANKED
2ACA  E104     BNZ 0x2AD4
1402:                                  {
1403:                                      FRL1.imax=2;             //rozmiar tabeli
2ACC  0100     MOVLB 0x0
2ACE  6BCB     CLRF 0xCB, BANKED
2AD0  0E02     MOVLW 0x2
2AD2  D003     BRA 0x2ADA
1404:                                  }
1405:                                  else
1406:                                  {           
1407:                                      FRL1.imax=_NDT_RRD_EEST;             //rozmiar tabeli
2AD4  0100     MOVLB 0x0
2AD6  6BCB     CLRF 0xCB, BANKED
2AD8  0E17     MOVLW 0x17
2ADA  D8EB     RCALL PL114
1408:                                  }
1409:                                  FRL1.tab=tbuf;                      //adres tabeli
1410:                                  if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;
2ADC  E104     BNZ 0x2AE6
2ADE  51CA     MOVF 0xCA, W, BANKED
2AE0  11CB     IORWF 0xCB, W, BANKED
2AE2  E001     BZ 0x2AE6
2AE4  D8EE     RCALL PL118
1411:                                  //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war
1412:                                  for(i=0;i<_NRS_TBF2;i++)
2AE6  6BA0     CLRF _UADtf_RErrBUF, BANKED
2AE8  0E4F     MOVLW 0x4F
2AEA  65A0     CPFSGT _UADtf_RErrBUF, BANKED
2AEC  D001     BRA 0x2AF0
2AEE  D002     BRA 0x2AF4
2AF2  D7FA     BRA 0x2AE8
1413:                                  {
1414:                                      tbuf[i]=0;    
2AF0  D8F4     RCALL PL362
1415:                                  }                        
1416:                                  for(i=0;i<FRL1.imax;i++)
2AF4  6BA0     CLRF _UADtf_RErrBUF, BANKED
2AF6  D00D     BRA 0x2B12
2B12  51A0     MOVF _UADtf_RErrBUF, W, BANKED
2B14  6F9D     MOVWF _UADtf_RData, BANKED
2B16  6B9E     CLRF _UADtf_REXT, BANKED
2B18  51CA     MOVF 0xCA, W, BANKED
2B1A  5D9D     SUBWF _UADtf_RData, W, BANKED
2B1C  51CB     MOVF 0xCB, W, BANKED
2B1E  599E     SUBWFB _UADtf_REXT, W, BANKED
2B20  E301     BNC 0x2B24
2B22  D0A2     BRA 0x2C68
2B24  D7E9     BRA 0x2AF8
1417:                                  {
1418:                                      if(i>=32) break;
2AF8  0E1F     MOVLW 0x1F
2AFA  65A0     CPFSGT _UADtf_RErrBUF, BANKED
2AFC  D001     BRA 0x2B00
2AFE  D0B4     BRA 0x2C68
1419:                                      tbuf[i]=stbf[i];    
2B00  0E00     MOVLW 0x0
2B02  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2B04  D8E5     RCALL PL292
2B06  0EA6     MOVLW 0xA6
2B08  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2B0A  6EE1     MOVWF FSR1, ACCESS
2B0C  6AE2     CLRF FSR1H, ACCESS
2B0E  0E02     MOVLW 0x2
2B10  D8ED     RCALL PL638
1420:                                  }                          
1421:                              }
1422:                              else                                                                //aktualizowano ramke - odpowiedz negatywna
1423:                              {
1424:                                  return _LIN1_ERRODP;
1425:                              }
1426:                          }
1427:                      }
1428:                      break;
1429:                  }
1430:                  case _CLIN_RRD_HIST:
1431:                  {
1432:                      //konieczna odpowiedz zwrotna UNI-02 do KSK stanowiaca potwierdzenie wykonania komendy
1433:                      switch(krok)
2C2A  0101     MOVLB 0x1
2C2C  51B5     MOVF 0xB5, W, BANKED
2C2E  E085     BZ 0x2B3A
2C30  0A01     XORLW 0x1
2C32  E08B     BZ 0x2B4A
2C34  0A03     XORLW 0x3
2C36  E0A4     BZ 0x2B80
2C38  0A01     XORLW 0x1
2C3A  E0AB     BZ 0x2B92
2C3C  D015     BRA 0x2C68
1434:                      {
1435:                          case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
1436:                              if(!LINWaitForAnswerUNI02(_LIN_GHIST)) return _LIN1_IBUSY;
2B3A  0E05     MOVLW 0x5
2B3C  ECAE     CALL 0xB75C, 0
2B3E  F05B     NOP
2B40  0900     IORLW 0x0
2B42  E101     BNZ 0x2B46
2B44  0CFF     RETLW 0xFF
1437:                              krok++;
2B46  0101     MOVLB 0x1
2B48  2BB5     INCF 0xB5, F, BANKED
1438:                          case 1:         //1.Wysylka komendy do UNI-02
1439:                          {
1440:                              //komendy i parametry wywolania dla UNI-02
1441:                              RSDT1.inLIDN=_LIN_GHIST;             //komenda
2B4A  0E05     MOVLW 0x5
2B4C  0102     MOVLB 0x2
2B4E  6FA0     MOVWF _UADtf_RErrBUF, BANKED
1442:                              for(i=0;i<32;i++) stbf[i]=0;
2B50  0100     MOVLB 0x0
2B52  6BA0     CLRF _UADtf_RErrBUF, BANKED
2B54  0E1F     MOVLW 0x1F
2B56  65A0     CPFSGT _UADtf_RErrBUF, BANKED
2B58  D001     BRA 0x2B5C
2B5A  D006     BRA 0x2B68
2B5C  0E00     MOVLW 0x0
2B5E  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2B60  D8B7     RCALL PL292
2B62  6ADF     CLRF INDF2, ACCESS
2B64  2BA0     INCF _UADtf_RErrBUF, F, BANKED
2B66  D7F6     BRA 0x2B54
1443:                              
1444:                              //start wywolania
1445:                              if(!FRL1.NAD) FRL1f_ZeroAdr=1;
2B68  51AF     MOVF 0xAF, W, BANKED
2B6A  E102     BNZ 0x2B70
2B6C  8402     BSF LIN1f_Busy, 2, ACCESS
2B6E  D001     BRA 0x2B72
1446:                              else FRL1f_ZeroAdr=0;
2B70  9402     BCF LIN1f_Busy, 2, ACCESS
2B72  ECF9     CALL 0x31F2, 0
2B74  F018     NOP
1447:                              RSDT1f_NewLIDN=1;
1448:                              RSDT1.ACKUNI=0;
1449:                              FRL1f_NextFr=0;
1450:                              krok++;
2B76  2BB5     INCF 0xB5, F, BANKED
2B78  D003     BRA 0x2B80
1451:                          }
1452:                          case 2:         //2.Oczekiwanie na odpowiedz
1453:                          {
1454:                              switch(LINWaitForAnswerUNI02(_LIN_GHIST))
2B80  0E05     MOVLW 0x5
2B82  ECAE     CALL 0xB75C, 0
2B84  F05B     NOP
2B86  0A00     XORLW 0x0
2B88  B4D8     BTFSC STATUS, 2, ACCESS
2B8A  0CFF     RETLW 0xFF
2B8C  0A01     XORLW 0x1
2B8E  E0F5     BZ 0x2B7A
2B90  D787     BRA 0x2AA0
1455:                              {
1456:                                  case 0:
1457:                                      return _LIN1_IBUSY;
1458:                                  case 1:
1459:                                      krok++;
2B7A  0101     MOVLB 0x1
2B7C  2BB5     INCF 0xB5, F, BANKED
1460:                                      break;
2B7E  D009     BRA 0x2B92
1461:                                  default:
1462:                                      krok=0;
1463:                                      return _LIN1_ERRODP;
1464:                              }
1465:                          }
1466:                          case 3:         //3.Przygotowanie danych dla LIN
1467:                          {
1468:                              krok=0;
2B92  6BB5     CLRF 0xB5, BANKED
1469:                              if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
2B94  B402     BTFSC LIN1f_Busy, 2, ACCESS
2B96  0CF0     RETLW 0xF0
1470:                              if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
2B98  BC01     BTFSC DtCOf_err_CO, 6, ACCESS
2B9A  0C05     RETLW 0x5
1471:                              {
1472:                                  for(i=0;i<_NRS_TBF2;i++)
2B9C  0100     MOVLB 0x0
2B9E  6BA0     CLRF _UADtf_RErrBUF, BANKED
2BA0  0E4F     MOVLW 0x4F
2BA2  65A0     CPFSGT _UADtf_RErrBUF, BANKED
2BA4  D001     BRA 0x2BA8
2BA6  D002     BRA 0x2BAC
2BAA  D7FA     BRA 0x2BA0
1473:                                  {
1474:                                      tbuf[i]=0;    
2BA8  D898     RCALL PL362
1475:                                  }                        
1476:                                  if((!stbf[0]&&!stbf[1])||!stbf[2]) 
2BAC  0103     MOVLB 0x3
2BAE  5100     MOVF 0x0, W, BANKED
2BB0  E102     BNZ 0x2BB6
2BB2  5101     MOVF DtCOf_err_CO, W, BANKED
2BB4  E002     BZ 0x2BBA
2BB6  5102     MOVF LIN1f_Busy, W, BANKED
2BB8  E106     BNZ 0x2BC6
1477:                                  {
1478:                                      tbuf[0]=stbf[0];
2BBA  D8A7     RCALL PL712
1479:                                      tbuf[1]=stbf[1];                            
1480:                                      FRL1.imax=2;             //rozmiar tabeli
2BBC  0100     MOVLB 0x0
2BBE  6BCB     CLRF 0xCB, BANKED
2BC0  0E02     MOVLW 0x2
2BC2  6FCA     MOVWF 0xCA, BANKED
1481:                                  }
2BC4  D026     BRA 0x2C12
1482:                                  else
2BC6  D8A1     RCALL PL712
1483:                                  {           
1484:                                      tbuf[0]=stbf[0];
1485:                                      tbuf[1]=stbf[1];                            
1486:                                      FRL1.imax=2+stbf[2];             //rozmiar tabeli
2BC8  0E02     MOVLW 0x2
2BCA  2502     ADDWF LIN1f_Busy, W, BANKED
2BCC  0100     MOVLB 0x0
2BCE  6FCA     MOVWF 0xCA, BANKED
2BD0  6BCB     CLRF 0xCB, BANKED
2BD2  0E00     MOVLW 0x0
2BD4  23CB     ADDWFC 0xCB, F, BANKED
1487:                                      for(i=0;i<stbf[2];i++)
2BD6  6BA0     CLRF _UADtf_RErrBUF, BANKED
2BD8  D017     BRA 0x2C08
2C08  0103     MOVLB 0x3
2C0A  5102     MOVF LIN1f_Busy, W, BANKED
2C0C  0100     MOVLB 0x0
2C0E  5DA0     SUBWF _UADtf_RErrBUF, W, BANKED
2C10  E3E4     BNC 0x2BDA
1488:                                      {
1489:                                          if((3+i)>=32) break;                    
2BDA  51A0     MOVF _UADtf_RErrBUF, W, BANKED
2BDC  6F9D     MOVWF _UADtf_RData, BANKED
2BDE  6B9E     CLRF _UADtf_REXT, BANKED
2BE0  0E03     MOVLW 0x3
2BE2  279D     ADDWF _UADtf_RData, F, BANKED
2BE4  0E00     MOVLW 0x0
2BE6  239E     ADDWFC _UADtf_REXT, F, BANKED
2BE8  BF9E     BTFSC _UADtf_REXT, 7, BANKED
2BEA  D005     BRA 0x2BF6
2BEC  519E     MOVF _UADtf_REXT, W, BANKED
2BEE  E111     BNZ 0x2C12
2BF0  0E20     MOVLW 0x20
2BF2  5D9D     SUBWF _UADtf_RData, W, BANKED
2BF4  E20E     BC 0x2C12
1490:                                          tbuf[2+i]=stbf[3+i];    
2BF6  0E03     MOVLW 0x3
2BF8  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2BFA  D87D     RCALL PL662
2BFC  0EA8     MOVLW 0xA8
2BFE  25A0     ADDWF _UADtf_RErrBUF, W, BANKED
2C00  6EE1     MOVWF FSR1, ACCESS
2C02  6AE2     CLRF FSR1H, ACCESS
2C04  0E02     MOVLW 0x2
2C06  D872     RCALL PL638
1491:                                      }                
1492:                                  }
1493:                                  FRL1.tab=tbuf;                      //adres tabeli
2C12  0EA6     MOVLW 0xA6
2C14  6FCC     MOVWF 0xCC, BANKED
2C16  0E02     MOVLW 0x2
2C18  6FCD     MOVWF 0xCD, BANKED
1494:                                  if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;
2C1A  51C4     MOVF 0xC4, W, BANKED
2C1C  11C5     IORWF 0xC5, W, BANKED
2C1E  E124     BNZ 0x2C68
2C20  51CA     MOVF 0xCA, W, BANKED
2C22  11CB     IORWF 0xCB, W, BANKED
2C24  E021     BZ 0x2C68
2C26  D84D     RCALL PL118
2C28  D01F     BRA 0x2C68
1495:                                  //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war                           
1496:                              }
1497:                              else                                                                //aktualizowano ramke - odpowiedz negatywna
1498:                              {
1499:                                  return _LIN1_ERRODP;
1500:                              }
1501:                          }
1502:                      }
1503:                      break;            
1504:                  }        
1505:                  /*case _CLIN_RRD_KNF:                         //odeslij do KSK paczke danych opisujaca konfiguracje sterownika
1506:                  {
1507:                      //konieczna odpowiedz zwrotna UNI-02 do KSK
1508:                      switch(krok)
1509:                      {
1510:                          case 0:         //0.Odczekaj na zakonczenie poprzedniej transmisji do UNI-02
1511:                              if(!LINWaitForAnswerUNI02(_LIN_GKNF)) return _LIN1_IBUSY;
1512:                              krok++;
1513:                          case 1:         //1.Wysylka komendy do UNI-02
1514:                          {
1515:                              //start wywolania
1516:                              if(!FRL1.NAD) FRL1f_ZeroAdr=1;
1517:                              else FRL1f_ZeroAdr=0;
1518:                              RSDT1.inLIDN=_LIN_GKNF;
1519:                              RSDT1f_NewLIDN=1;
1520:                              RSDT1.ACKUNI=0;
1521:                              FRL1f_NextFr=0;
1522:                              krok++;
1523:                          }
1524:                          case 2:         //2.Oczekiwanie na odpowiedz z UNI-02
1525:                          {
1526:                              switch(LINWaitForAnswerUNI02(_LIN_GKNF))
1527:                              {
1528:                                  case 0:
1529:                                      return _LIN1_IBUSY;
1530:                                  case 1:
1531:                                      krok++;
1532:                                      break;
1533:                                  default:
1534:                                      krok=0;
1535:                                      return _LIN1_ERRODP;
1536:                              }
1537:                          }
1538:                          case 3:         //3.Przygotowanie danych dla LIN
1539:                          {
1540:                              krok=0;
1541:                              if(FRL1f_ZeroAdr) return _LIN1_NORESP;                               //odpowiedz do LIN nie ma byc generowana?
1542:                              if(!FRL1f_NextFr)                                                    //w trakcie wysylki do UNI-02 nie bylo aktualizacji inna ramka LIN?
1543:                              {
1544:                                  FRL1.imax=_NDT_RRD_KNF;             //rozmiar tabeli
1545:                                  FRL1.tab=tbuf;                      //adres tabeli
1546:                                  if(!FRL1.STOP.war&&FRL1.imax) FRL1.STOP.war=FRL1.imax-1;
1547:                                  //!!!! aktualizacja zawartosci tabeli w zakresie od FRL1.START.war do FRL1.STOP.war
1548:                                  tbuf[0]=RSDT1.outKSTAT0;
1549:                                  if(PFNf_aktywne_KNF)                //aktywny tryb konfiguracji?
1550:                                  {
1551:                                      tbuf[1]=RSDT1.outKRK;
1552:                                      tbuf[2]=RSDT1.outPRM;
1553:                                  }
1554:                                  else
1555:                                  {
1556:                                      tbuf[1]=0;
1557:                                      tbuf[2]=0;
1558:                                  }
1559:                                  tbuf[3]=RSDT1.outMSTR;
1560:                                  tbuf[4]=RSDT1.outMMAXU;
1561:                                  tbuf[5]=RSDT1.outMMAXG;
1562:                                  tbuf[6]=RSDT1.outOPDG;
1563:                                  tbuf[7]=RSDT1.outWANL;
1564:                                  tbuf[8]=RSDT1.outKODKT;
1565:                                  tbuf[9]=RSDT1.outWOBG;
1566:                                  tbuf[10]=RSDT1.outNOKR;
1567:                                  tbuf[11]=RSDT1.outTPCS;
1568:                                  tbuf[12]=RSDT1.outMMIN;
1569:                                  tbuf[13]=RSDT1.outMMAX;
1570:                                  tbuf[14]=RSDT1.outRDPM;
1571:                                  tbuf[15]=RSDT1.outDTPM;
1572:                                  tbuf[16]=RSDT1.outMDPM;
1573:                                  tbuf[17]=RSDT1.outTECO;
1574:                                  tbuf[18]=RSDT1.outTMMAXG2;
1575:                                  tbuf[19]=RSDT1.outMMAXG2;
1576:                                  tbuf[20]=RSDT1.outMGPM;
1577:                                  tbuf[21]=RSDT1.outMGPM2;  
1578:                                  tbuf[22]=RSDT1.outHSCO;
1579:                                  tbuf[23]=RSDT1.outCONW;  
1580:                                  tbuf[24]=RSDT1.outPROP;
1581:                                  tbuf[25]=RSDT1.outRFAN; 
1582:                                  tbuf[26]=RSDT1.outTSTR;        
1583:                                  tbuf[27]=RSDT1.outTL3;  
1584:                                  tbuf[28]=RSDT1.outPGDR;
1585:                                  tbuf[29]=RSDT1.outPGDG; 
1586:                                  tbuf[30]=RSDT1.outPGDO;                        
1587:                              }
1588:                              else                                                                //aktualizowano ramke - odpowiedz negatywna
1589:                              {
1590:                                  Nop();
1591:                                  return _LIN1_ERRODP;
1592:                              }
1593:                              break;
1594:                          }
1595:                      }
1596:                      break;
1597:                  }*/
1598:                  default:                   //nieznana komenda
1599:                  {
1600:                      return _LIN1_UNCCOM;
1601:                  }
1602:              }
1603:              if((FRL1.STOP.war<FRL1.START.war)||(FRL1.STOP.war>=FRL1.imax))
2C68  0100     MOVLB 0x0
2C6A  51C2     MOVF 0xC2, W, BANKED
2C6C  5DC4     SUBWF 0xC4, W, BANKED
2C6E  51C3     MOVF 0xC3, W, BANKED
2C70  59C5     SUBWFB 0xC5, W, BANKED
2C72  A0D8     BTFSS STATUS, 0, ACCESS
2C74  0C02     RETLW 0x2
2C76  51CA     MOVF 0xCA, W, BANKED
2C78  5DC4     SUBWF 0xC4, W, BANKED
2C7A  51CB     MOVF 0xCB, W, BANKED
2C7C  59C5     SUBWFB 0xC5, W, BANKED
2C7E  E301     BNC 0x2C82
1604:              {
1605:                  return _LIN1_INVPAR;       //nieprawidlowy parametr
2C80  0C02     RETLW 0x2
1606:              }
1607:              return _LIN1_IFINAL;            //koniec przetwarzania danych
1608:          }
2C82  0C00     RETLW 0x0
1609:          //------------------------------------------------------------
1610:          //------------------------------------------------------------
1611:          //Oczekiwanie na odpowiedz UNI-02
1612:          unsigned char LINWaitForAnswerUNI02(const unsigned char kmn)
B75C  0100     MOVLB 0x0
B75E  6F74     MOVWF _PFNf_prODP, BANKED
1613:          {
1614:              if(RSDT1f_NewLIDN) return 0;  //oczekiwanie na zakonczenie transmisji
B760  BC11     BTFSC PFNf_zima, 6, ACCESS
B762  0C00     RETLW 0x0
1615:              if(RSDT1.ACKUNI!=1) 
B764  0102     MOVLB 0x2
B766  05A5     DECF f3, W, BANKED
B768  E002     BZ 0xB76E
1616:              {
1617:                  RSDT1f_RD_LIN=0;
B76A  9412     BCF RSDT1f_RD_STD, 2, ACCESS
1618:                  return 2;
B76C  0C02     RETLW 0x2
1619:              }
1620:              if(!RSDT1f_RD_LIN) return 2;   //nie zaktualizowano danych z UNI-02?
B76E  A412     BTFSS RSDT1f_RD_STD, 2, ACCESS
B770  0C02     RETLW 0x2
1621:              RSDT1f_RD_LIN=0;
B772  9412     BCF RSDT1f_RD_STD, 2, ACCESS
1622:              if((RSDT1.outLIDN!=kmn)||(RSDT1.outLIDN!=RSDT1.inLIDN)) return 2;  //nie prawidlowa komenda?
B774  0100     MOVLB 0x0
B776  5174     MOVF _PFNf_prODP, W, BANKED
B778  0102     MOVLB 0x2
B77A  1971     XORWF _PFNf_pmpPWM, W, BANKED
B77C  A4D8     BTFSS STATUS, 2, ACCESS
B77E  0C02     RETLW 0x2
B780  51A0     MOVF _UADtf_RErrBUF, W, BANKED
B782  1971     XORWF _PFNf_pmpPWM, W, BANKED
B784  E001     BZ 0xB788
B786  0C02     RETLW 0x2
1623:              return 1;   //odpowiedz gotowa do interpretacji
1624:          }
B788  0C01     RETLW 0x1
1625:          //------------------------------------------------------------
1626:          //------------------------------------------------------------
1627:          //------------------------------------------------------------
1628:          //------------------------------------------------------------
1629:          //Decyzja po otrzymaniu ramki z modulu Wifi
1630:          //------------------------------------------------------------
1631:          //------------------------------------------------------------
1632:          #if _OLD_RS_KOM!=0
1633:          unsigned char RSFInterpreter_SingleRD(void)
1634:          {
1635:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
1636:              if(FRL1.RS_KOM!=0x07) return 0;     //nieprawidlowa komenda?
1637:              
1638:              switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
1639:              {
1640:                  case 0x01:
1641:                  {
1642:                      FRL1.IDN=_CLIN_RRD_ACK;
1643:                      return 1;
1644:                  }
1645:                  case 0x05:
1646:                  {
1647:                      FRL1.IDN=_CLIN_RRD_PCW;
1648:                      return 1;                    
1649:                  }    
1650:                  case 0x06:
1651:                  {
1652:                      FRL1.IDN=_CLIN_RRD_PCO;
1653:                      return 1;                    
1654:                  }
1655:                  case 0x07:
1656:                  {
1657:                      FRL1.IDN=_CLIN_RRD_ECO;
1658:                      return 1;                    
1659:                  }
1660:                  case 0x08:
1661:                  {
1662:                      FRL1.IDN=_CLIN_RRD_TRB;
1663:                      return 1;                    
1664:                  }     
1665:                  case 0x09:
1666:                  {
1667:                      FRL1.IDN=_CLIN_RRD_RES;
1668:                      return 1;                    
1669:                  }   
1670:                  case 0x0A:
1671:                  {
1672:                      FRL1.IDN=_CLIN_RRD_BRES;
1673:                      return 1;                    
1674:                  }     
1675:                  case 0x0B:
1676:                  {
1677:                      FRL1.IDN=_CLIN_RRD_FSR;
1678:                      return 1;                    
1679:                  }  
1680:                  case 0x0C:
1681:                  {
1682:                      FRL1.IDN=_CLIN_RRD_ANL;
1683:                      return 1;                    
1684:                  } 
1685:                  case 0x0D:
1686:                  {
1687:                      FRL1.IDN=_CLIN_RRD_NKNF;
1688:                      return 1;                    
1689:                  } 
1690:                  case 0x0E:
1691:                  {
1692:                      FRL1.IDN=_CLIN_RRD_PKNF;
1693:                      return 1;                    
1694:                  }  
1695:                  case 0x0F:
1696:                  {
1697:                      FRL1.IDN=_CLIN_RRD_RT;
1698:                      return 1;                    
1699:                  }
1700:                  case 0x10:
1701:                  {
1702:                      FRL1.IDN=_CLIN_RRD_CW;
1703:                      return 1;                    
1704:                  }   
1705:                  case 0x11:
1706:                  {
1707:                      FRL1.IDN=_CLIN_RRD_10V;
1708:                      return 1;                    
1709:                  }  
1710:                  case 0x12:
1711:                  {
1712:                      FRL1.IDN=_CLIN_RRD_SETP;
1713:                      return 1;                    
1714:                  } 
1715:                  case 0x13:
1716:                  {
1717:                      FRL1.IDN=_CLIN_RRD_ZW;
1718:                      return 1;                    
1719:                  }  
1720:                  case 0x14:
1721:                  {
1722:                      FRL1.IDN=_CLIN_RRD_INT;
1723:                      return 1;                    
1724:                  } 
1725:                  case 0x15:
1726:                  {
1727:                      FRL1.IDN=_CLIN_RRD_PRD;
1728:                      return 1;                    
1729:                  }        
1730:                  default:
1731:                  {
1732:                      return 0;
1733:                  }
1734:              }          
1735:          }
1736:          //------------------------------------------------------------
1737:          //------------------------------------------------------------
1738:          unsigned char RSFInterpreter_MultiRD(void)
1739:          {
1740:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
1741:          
1742:              switch(FRL1.RS_KOM)
1743:              {
1744:                  case 0x01:
1745:                  {    
1746:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS 
1747:                      {
1748:                          case 0x01:
1749:                          {
1750:                              FRL1.IDN=_CLIN_RRD_STD2;
1751:                              //if(!FRL1.STOP.war) FRL1.STOP.war=_NDT_RRD_STD2;
1752:                              return 1;
1753:                          }        
1754:                          default:
1755:                          {
1756:                              return 0;
1757:                          }
1758:                      }
1759:                  }
1760:                  case 0x07:
1761:                  {    
1762:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS 
1763:                      {
1764:                          case 0x02:
1765:                          {
1766:                              FRL1.IDN=_CLIN_RRD_OT;
1767:                              //if(!FRL1.STOP.war) FRL1.STOP.war=_NDT_RRD_OT;
1768:                              return 1;
1769:                          } 
1770:                          case 0x03:
1771:                          {
1772:                              FRL1.IDN=_CLIN_RRD_KNF;
1773:                              //if(!FRL1.STOP.war) FRL1.STOP.war=_NDT_RRD_KNF;                    
1774:                              return 1;
1775:                          }                
1776:                          default:
1777:                          {
1778:                              return 0;
1779:                          }
1780:                      }
1781:                  }        
1782:                  default:
1783:                  {
1784:                      return 0;
1785:                  }
1786:              }
1787:          }
1788:          //------------------------------------------------------------
1789:          //------------------------------------------------------------
1790:          unsigned char RSFInterpreter_SingleWR(void)
1791:          {
1792:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
1793:              
1794:              switch(FRL1.RS_KOM)
1795:              {
1796:                  case 0x82:
1797:                  {
1798:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
1799:                      {
1800:                          case 0x01:
1801:                          {
1802:                              FRL1.IDN=_CLIN_WRD_LADDR;                //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1)
1803:                              return 1;                    
1804:                          }    
1805:                          case 0x02:
1806:                          {
1807:                              FRL1.IDN=_CLIN_WRD_LIFADDR;              //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1) po spelnieniu warunku
1808:                              return 1;                    
1809:                          }
1810:                          case 0x03:
1811:                          {
1812:                              FRL1.IDN=_CLIN_WRD_SHOWADDR;            //wyswietl adres LIN;
1813:                              return 1;                    
1814:                          }
1815:                          case 0x04:
1816:                          {
1817:                              FRL1.IDN=_CLIN_WRD_PULSE;              //pulsacja podswietlenia
1818:                              return 1;                    
1819:                          }                              
1820:                          default:
1821:                          {
1822:                              return 0;
1823:                          }
1824:                      }
1825:                  }
1826:                  case 0x87:
1827:                  {
1828:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
1829:                      {
1830:                          case 0x05:
1831:                          {
1832:                              FRL1.IDN=_CLIN_WRD_PCW;
1833:                              return 1;                    
1834:                          }    
1835:                          case 0x06:
1836:                          {
1837:                              FRL1.IDN=_CLIN_WRD_PCO;
1838:                              return 1;                    
1839:                          }
1840:                          case 0x07:
1841:                          {
1842:                              FRL1.IDN=_CLIN_WRD_ECO;
1843:                              return 1;                    
1844:                          }
1845:                          case 0x08:
1846:                          {
1847:                              FRL1.IDN=_CLIN_WRD_TRB;
1848:                              return 1;                    
1849:                          }     
1850:                          case 0x09:
1851:                          {
1852:                              FRL1.IDN=_CLIN_WRD_RES;
1853:                              return 1;                    
1854:                          }   
1855:                          case 0x0A:
1856:                          {
1857:                              FRL1.IDN=_CLIN_WRD_BRES;
1858:                              return 0;                       //brak mozliwosci zdalnego resetu 
1859:                          }     
1860:                          case 0x0B:
1861:                          {
1862:                              FRL1.IDN=_CLIN_WRD_FSR;
1863:                              return 1;                    
1864:                          }  
1865:                          case 0x0C:
1866:                          {
1867:                              FRL1.IDN=_CLIN_WRD_ANL;
1868:                              return 1;                    
1869:                          } 
1870:                          case 0x0E:
1871:                          {
1872:                              FRL1.IDN=_CLIN_WRD_PKNF;
1873:                              return 1;                    
1874:                          }  
1875:                          case 0x0F:
1876:                          {
1877:                              FRL1.IDN=_CLIN_WRD_RT;
1878:                              return 1;                    
1879:                          }
1880:                          case 0x10:
1881:                          {
1882:                              FRL1.IDN=_CLIN_WRD_CW;
1883:                              return 1;                    
1884:                          }
1885:                          case 0x11:
1886:                          {
1887:                              FRL1.IDN=_CLIN_WRD_ENDO;
1888:                              return 1;                    
1889:                          }
1890:                          case 0x12:
1891:                          {
1892:                              FRL1.IDN=_CLIN_WRD_PRD;
1893:                              return 1;                    
1894:                          }        
1895:                          default:
1896:                          {
1897:                              return 0;
1898:                          }
1899:                      }             
1900:                  }
1901:                  default:
1902:                  {
1903:                      return 0;
1904:                  }
1905:              }              
1906:          }
1907:          #else
1908:          //----------------------------------------------------------------
1909:          //Pojedyncza ramka odczytu RD
1910:          unsigned char RSFInterpreter_SingleRD(void)
1911:          {
1912:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
7D20  0E01     MOVLW 0x1
7D22  65B8     CPFSGT 0xB8, BANKED
7D24  D060     BRA 0x7DE6
7D26  0C00     RETLW 0x0
1913:          
1914:              switch(FRL1.RS_KOM)
7DE6  51B7     MOVF 0xB7, W, BANKED
1915:              {
1916:                  case 0x03:  //Parametry konfiguracji
1917:                  {
1918:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
7D32  D860     RCALL PL582
7D34  A4D8     BTFSS STATUS, 2, ACCESS
7D36  0C00     RETLW 0x0
7D38  5174     MOVF _PFNf_prODP, W, BANKED
7D3A  0A01     XORLW 0x1
7D3C  E0F5     BZ 0x7D28
7D3E  0A03     XORLW 0x3
7D40  A4D8     BTFSS STATUS, 2, ACCESS
7D42  0C00     RETLW 0x0
7D44  D7F4     BRA 0x7D2E
1919:                      {
1920:                          case 0x01://liczba parametrow konfiguracyjnych
1921:                          {
1922:                              FRL1.IDN=_CLIN_RRD_NKNF;
7D28  0E0D     MOVLW 0xD
7D2A  6FB5     MOVWF 0xB5, BANKED
1923:                              return 1;
7D2C  0C01     RETLW 0x1
1924:                          }
1925:                          case 0x02://wartosc wbranego parametru konfiguracji, warto¶ci graniczne
1926:                          {
1927:                              FRL1.IDN=_CLIN_RRD_PKNF;
7D2E  0E0E     MOVLW 0xE
7D30  D7FC     BRA 0x7D2A
1928:                              return 1;                    
1929:                          }
1930:                          default:
1931:                          {
1932:                              return 0;
1933:                          }
1934:                      }
1935:                  }       
1936:                  case 0x07:  //Pozostale parametry
1937:                  {        
1938:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
7D96  D82E     RCALL PL582
7D98  A4D8     BTFSS STATUS, 2, ACCESS
7D9A  0C00     RETLW 0x0
7D9C  5174     MOVF _PFNf_prODP, W, BANKED
7D9E  0A01     XORLW 0x1
7DA0  E0D2     BZ 0x7D46
7DA2  0A03     XORLW 0x3
7DA4  E0D2     BZ 0x7D4A
7DA6  0A01     XORLW 0x1
7DA8  E0D2     BZ 0x7D4E
7DAA  0A07     XORLW 0x7
7DAC  E0D2     BZ 0x7D52
7DAE  0A01     XORLW 0x1
7DB0  E0D2     BZ 0x7D56
7DB2  0A03     XORLW 0x3
7DB4  E0D2     BZ 0x7D5A
7DB6  0A01     XORLW 0x1
7DB8  E0D2     BZ 0x7D5E
7DBA  0A0F     XORLW 0xF
7DBC  E0D2     BZ 0x7D62
7DBE  0A01     XORLW 0x1
7DC0  E0D2     BZ 0x7D66
7DC2  0A03     XORLW 0x3
7DC4  E0D2     BZ 0x7D6A
7DC6  0A01     XORLW 0x1
7DC8  E0D2     BZ 0x7D6E
7DCA  0A07     XORLW 0x7
7DCC  E0D2     BZ 0x7D72
7DCE  0A01     XORLW 0x1
7DD0  E0D2     BZ 0x7D76
7DD2  0A03     XORLW 0x3
7DD4  E0D2     BZ 0x7D7A
7DD6  0A01     XORLW 0x1
7DD8  E0D2     BZ 0x7D7E
7DDA  0A1F     XORLW 0x1F
7DDC  E0D2     BZ 0x7D82
7DDE  0A01     XORLW 0x1
7DE0  A4D8     BTFSS STATUS, 2, ACCESS
7DE2  0C00     RETLW 0x0
7DE4  D7D0     BRA 0x7D86
1939:                      {
1940:                          case 0x01:  //potwierdzenie obecnosci wraz z kompletem danych o sterowniku
1941:                          {
1942:                              FRL1.IDN=_CLIN_RRD_ACK;
7D46  0E01     MOVLW 0x1
7D48  D7F0     BRA 0x7D2A
1943:                              return 1;
1944:                          }
1945:                          case 0x02:  //Nastawa PCW, wartosci graniczne
1946:                          {
1947:                              FRL1.IDN=_CLIN_RRD_PCW;
7D4A  0E05     MOVLW 0x5
7D4C  D7EE     BRA 0x7D2A
1948:                              return 1;                    
1949:                          }    
1950:                          case 0x03://Nastawa PCO, wartosci graniczne
1951:                          {
1952:                              FRL1.IDN=_CLIN_RRD_PCO;
7D4E  0E06     MOVLW 0x6
7D50  D7EC     BRA 0x7D2A
1953:                              return 1;                    
1954:                          }
1955:                          case 0x04://Nastawa ECO, wartosci graniczne
1956:                          {
1957:                              FRL1.IDN=_CLIN_RRD_ECO;
7D52  0E07     MOVLW 0x7
7D54  D7EA     BRA 0x7D2A
1958:                              return 1;                    
1959:                          }
1960:                          case 0x05://Tryb pracy , wartosci graniczne
1961:                          {
1962:                              FRL1.IDN=_CLIN_RRD_TRB;
7D56  0E08     MOVLW 0x8
7D58  D7E8     BRA 0x7D2A
1963:                              return 1;                    
1964:                          }     
1965:                          case 0x06://Stan przycisku reset
1966:                          {
1967:                              FRL1.IDN=_CLIN_RRD_RES;
7D5A  0E09     MOVLW 0x9
7D5C  D7E6     BRA 0x7D2A
1968:                              return 1;                    
1969:                          }   
1970:                          case 0x07://Blokada awaryjna
1971:                          {
1972:                              FRL1.IDN=_CLIN_RRD_BRES;
7D5E  0E0A     MOVLW 0xA
7D60  D7E4     BRA 0x7D2A
1973:                              return 1;                    
1974:                          }     
1975:                          case 0x08://Funkcja serwisowa
1976:                          {
1977:                              FRL1.IDN=_CLIN_RRD_FSR;
7D62  0E0B     MOVLW 0xB
7D64  D7E2     BRA 0x7D2A
1978:                              return 1;                    
1979:                          }  
1980:                          case 0x09://Funkcja antylegionella
1981:                          {
1982:                              FRL1.IDN=_CLIN_RRD_ANL;
7D66  0E0C     MOVLW 0xC
7D68  D7E0     BRA 0x7D2A
1983:                              return 1;                    
1984:                          }  
1985:                          case 0x0A://Pobudzenie RT
1986:                          {
1987:                              FRL1.IDN=_CLIN_RRD_RT;
7D6A  0E0F     MOVLW 0xF
7D6C  D7DE     BRA 0x7D2A
1988:                              return 1;                    
1989:                          }
1990:                          case 0x0B://Pobudzenie CW / timera zasobnika
1991:                          {
1992:                              FRL1.IDN=_CLIN_RRD_CW;
7D6E  0E10     MOVLW 0x10
7D70  D7DC     BRA 0x7D2A
1993:                              return 1;                    
1994:                          }   
1995:                          case 0x0C://Status interfejsu 10V
1996:                          {
1997:                              FRL1.IDN=_CLIN_RRD_10V;
7D72  0E12     MOVLW 0x12
7D74  D7DA     BRA 0x7D2A
1998:                              return 1;                    
1999:                          }  
2000:                          case 0x0D://Docelowa wartosc modulacji przy grzaniu obiegu WG (SETP)
2001:                          {
2002:                              FRL1.IDN=_CLIN_RRD_SETP;
7D76  0E13     MOVLW 0x13
7D78  D7D8     BRA 0x7D2A
2003:                              return 1;                    
2004:                          } 
2005:                          case 0x0E://Temp zewnetrzna, reg pogodowy
2006:                          {
2007:                              FRL1.IDN=_CLIN_RRD_ZW;
7D7A  0E14     MOVLW 0x14
7D7C  D7D6     BRA 0x7D2A
2008:                              return 1;                    
2009:                          }  
2010:                          case 0x0F://Status interfejsów
2011:                          {
2012:                              FRL1.IDN=_CLIN_RRD_INT;
7D7E  0E15     MOVLW 0x15
7D80  D7D4     BRA 0x7D2A
2013:                              return 1;                    
2014:                          } 
2015:                          case 0x10://Specjalny tryb pracy sterownika
2016:                          {
2017:                              FRL1.IDN=_CLIN_RRD_PRD;
7D82  0E16     MOVLW 0x16
7D84  D7D2     BRA 0x7D2A
2018:                              return 1;                    
2019:                          }    
2020:                          case 0x11://Statystyki zdarzen awaryjnych
2021:                          {
2022:                              if(PFN.vUNI02<11) return 0;
7D86  0E0B     MOVLW 0xB
7D88  0101     MOVLB 0x1
7D8A  61EC     CPFSLT 0xEC, BANKED
7D8C  D001     BRA 0x7D90
7D8E  0C00     RETLW 0x0
2023:                              FRL1.IDN=_CLIN_RRD_STH;
7D90  0E19     MOVLW 0x19
7D92  0100     MOVLB 0x0
7D94  D7CA     BRA 0x7D2A
7D96  D82E     RCALL PL582
7D98  A4D8     BTFSS STATUS, 2, ACCESS
7D9A  0C00     RETLW 0x0
7D9C  5174     MOVF _PFNf_prODP, W, BANKED
7D9E  0A01     XORLW 0x1
7DA0  E0D2     BZ 0x7D46
7DA2  0A03     XORLW 0x3
7DA4  E0D2     BZ 0x7D4A
7DA6  0A01     XORLW 0x1
7DA8  E0D2     BZ 0x7D4E
7DAA  0A07     XORLW 0x7
7DAC  E0D2     BZ 0x7D52
7DAE  0A01     XORLW 0x1
7DB0  E0D2     BZ 0x7D56
7DB2  0A03     XORLW 0x3
7DB4  E0D2     BZ 0x7D5A
7DB6  0A01     XORLW 0x1
7DB8  E0D2     BZ 0x7D5E
7DBA  0A0F     XORLW 0xF
7DBC  E0D2     BZ 0x7D62
7DBE  0A01     XORLW 0x1
7DC0  E0D2     BZ 0x7D66
7DC2  0A03     XORLW 0x3
7DC4  E0D2     BZ 0x7D6A
7DC6  0A01     XORLW 0x1
7DC8  E0D2     BZ 0x7D6E
7DCA  0A07     XORLW 0x7
7DCC  E0D2     BZ 0x7D72
7DCE  0A01     XORLW 0x1
7DD0  E0D2     BZ 0x7D76
7DD2  0A03     XORLW 0x3
7DD4  E0D2     BZ 0x7D7A
7DD6  0A01     XORLW 0x1
7DD8  E0D2     BZ 0x7D7E
7DDA  0A1F     XORLW 0x1F
7DDC  E0D2     BZ 0x7D82
7DDE  0A01     XORLW 0x1
7DE0  A4D8     BTFSS STATUS, 2, ACCESS
7DE2  0C00     RETLW 0x0
7DE4  D7D0     BRA 0x7D86
7DE6  51B7     MOVF 0xB7, W, BANKED
7DE8  0A03     XORLW 0x3
7DEA  E0A3     BZ 0x7D32
7DEC  0A04     XORLW 0x4
7DEE  A4D8     BTFSS STATUS, 2, ACCESS
7DF0  0C00     RETLW 0x0
7DF2  D7D1     BRA 0x7D96
2024:                              return 1;
2025:                          }                
2026:                          default:
2027:                          {
2028:                              return 0;
2029:                          }
2030:                      }
2031:                  }
2032:                  default:
2033:                  {
2034:                      return 0;
2035:                  }            
2036:              }      
2037:          }
2038:          //----------------------------------------------------------------
2039:          //Multi ramka odczytu RD
2040:          unsigned char RSFInterpreter_MultiRD(void)
2041:          {
2042:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
94EA  0E01     MOVLW 0x1
94EC  65B8     CPFSGT 0xB8, BANKED
94EE  D033     BRA 0x9556
94F0  0C00     RETLW 0x0
2043:          
2044:              switch(FRL1.RS_KOM)
9556  51B7     MOVF 0xB7, W, BANKED
2045:              {
2046:                  case 0x01:  //Status w multiramce
2047:                  {    
2048:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS 
94F8  D837     RCALL PL378
94FA  A4D8     BTFSS STATUS, 2, ACCESS
94FC  0C00     RETLW 0x0
94FE  5174     MOVF _PFNf_prODP, W, BANKED
9500  0A01     XORLW 0x1
9502  A4D8     BTFSS STATUS, 2, ACCESS
9504  0C00     RETLW 0x0
9506  D7F5     BRA 0x94F2
2049:                      {
2050:                          case 0x01://STATUS - Pobierz komplet danych okreslajacych stan urz±dzenia
2051:                          {
2052:                              FRL1.IDN=_CLIN_RRD_STD2;
94F2  0E03     MOVLW 0x3
94F4  6FB5     MOVWF 0xB5, BANKED
2053:                              return 1;
94F6  0C01     RETLW 0x1
2054:                          }        
2055:                          default:
2056:                          {
2057:                              return 0;
2058:                          }
2059:                      }
2060:                  }
2061:                  case 0x03:  //Parametry konfiguracyjne w multiramce
2062:                  {    
2063:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS 
950C  D82D     RCALL PL378
950E  A4D8     BTFSS STATUS, 2, ACCESS
9510  0C00     RETLW 0x0
9512  5174     MOVF _PFNf_prODP, W, BANKED
9514  0A01     XORLW 0x1
9516  A4D8     BTFSS STATUS, 2, ACCESS
9518  0C00     RETLW 0x0
951A  D7F6     BRA 0x9508
2064:                      {
2065:                          case 0x01://KONFIG - Pobierz komplet parametrow konfiguracyjnych (wartosci bez min/max)
2066:                          {
2067:                              FRL1.IDN=_CLIN_RRD_KNF;                 
9508  0E04     MOVLW 0x4
950A  D7F4     BRA 0x94F4
2068:                              return 1;
2069:                          }                
2070:                          default:
2071:                          {
2072:                              return 0;
2073:                          }
2074:                      }
2075:                  }        
2076:                  case 0x07:  //Pozostale parametry w multiramce
2077:                  {    
2078:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS 
953E  D814     RCALL PL378
9540  A4D8     BTFSS STATUS, 2, ACCESS
9542  0C00     RETLW 0x0
9544  5174     MOVF _PFNf_prODP, W, BANKED
9546  0A01     XORLW 0x1
9548  E0E9     BZ 0x951C
954A  0A03     XORLW 0x3
954C  E0E9     BZ 0x9520
954E  0A01     XORLW 0x1
9550  A4D8     BTFSS STATUS, 2, ACCESS
9552  0C00     RETLW 0x0
9554  D7EC     BRA 0x952E
2079:                      {
2080:                          case 0x01://Status interfejsu OT
2081:                          {
2082:                              FRL1.IDN=_CLIN_RRD_OT;
951C  0E11     MOVLW 0x11
951E  D7EA     BRA 0x94F4
2083:                              return 1;
2084:                          }   
2085:                          case 0x02://Status sterownika z momentu wylaczenia awaryjnego z blokada
2086:                          {
2087:                              if(PFN.vUNI02<11) return 0;
9520  0E0B     MOVLW 0xB
9522  0101     MOVLB 0x1
9524  61EC     CPFSLT 0xEC, BANKED
9526  D001     BRA 0x952A
9528  0C00     RETLW 0x0
2088:                              FRL1.IDN=_CLIN_RRD_EEST;
952A  0E17     MOVLW 0x17
952C  D006     BRA 0x953A
2089:                              return 1;
2090:                          }
2091:                          case 0x03://Odczyt zapisu historii zdarzen awaryjnych (do 16 ostatnich zdarzen)
2092:                          {
2093:                              if(PFN.vUNI02<11) return 0;
952E  0E0B     MOVLW 0xB
9530  0101     MOVLB 0x1
9532  61EC     CPFSLT 0xEC, BANKED
9534  D001     BRA 0x9538
9536  0C00     RETLW 0x0
2094:                              FRL1.IDN=_CLIN_RRD_HIST;
9538  0E18     MOVLW 0x18
953A  0100     MOVLB 0x0
953C  D7DB     BRA 0x94F4
953E  D814     RCALL PL378
9540  A4D8     BTFSS STATUS, 2, ACCESS
9542  0C00     RETLW 0x0
9544  5174     MOVF _PFNf_prODP, W, BANKED
9546  0A01     XORLW 0x1
9548  E0E9     BZ 0x951C
954A  0A03     XORLW 0x3
954C  E0E9     BZ 0x9520
954E  0A01     XORLW 0x1
9550  A4D8     BTFSS STATUS, 2, ACCESS
9552  0C00     RETLW 0x0
9554  D7EC     BRA 0x952E
9556  51B7     MOVF 0xB7, W, BANKED
9558  0A01     XORLW 0x1
955A  E0CE     BZ 0x94F8
955C  0A02     XORLW 0x2
955E  E0D6     BZ 0x950C
9560  0A04     XORLW 0x4
9562  A4D8     BTFSS STATUS, 2, ACCESS
9564  0C00     RETLW 0x0
9566  D7EB     BRA 0x953E
2095:                              return 1;
2096:                          }                
2097:                          default:
2098:                          {
2099:                              return 0;
2100:                          }
2101:                      }
2102:                  }        
2103:                  default:
2104:                  {
2105:                      return 0;
2106:                  }
2107:              }
2108:          }
2109:          //----------------------------------------------------------------
2110:          //Pojedyncza ramka zapisu WD
2111:          unsigned char RSFInterpreter_SingleWR(void)
2112:          {
2113:              if(FRL1.RS_ADR>1) return 0;   //ADR paczki RS >1 ?
8092  0E01     MOVLW 0x1
8094  65B8     CPFSGT 0xB8, BANKED
8096  D059     BRA 0x814A
8098  0C00     RETLW 0x0
2114:              
2115:              switch(FRL1.RS_KOM)
814A  51B7     MOVF 0xB7, W, BANKED
2116:              {
2117:                  case 0x82:  //Konfiguracja magistrali LIN, wizualizacja i sterowanie pulsacja podswietlenia
2118:                  {
2119:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
80AC  D857     RCALL PL388
80AE  A4D8     BTFSS STATUS, 2, ACCESS
80B0  0C00     RETLW 0x0
80B2  5174     MOVF _PFNf_prODP, W, BANKED
80B4  0A01     XORLW 0x1
80B6  E0F1     BZ 0x809A
80B8  0A03     XORLW 0x3
80BA  E0F2     BZ 0x80A0
80BC  0A01     XORLW 0x1
80BE  E0F2     BZ 0x80A4
80C0  0A07     XORLW 0x7
80C2  A4D8     BTFSS STATUS, 2, ACCESS
80C4  0C00     RETLW 0x0
80C6  D7F0     BRA 0x80A8
2120:                      {
2121:                          case 0x01:
2122:                          {
2123:                              FRL1.IDN=_CLIN_WRD_LADDR;                //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1)
809A  0E01     MOVLW 0x1
809C  6FB5     MOVWF 0xB5, BANKED
2124:                              return 1;                    
809E  0C01     RETLW 0x1
2125:                          }    
2126:                          case 0x02:
2127:                          {
2128:                              FRL1.IDN=_CLIN_WRD_LIFADDR;              //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1) po spelnieniu warunku
80A0  0E02     MOVLW 0x2
80A2  D7FC     BRA 0x809C
2129:                              return 1;                    
2130:                          }
2131:                          case 0x03:
2132:                          {
2133:                              FRL1.IDN=_CLIN_WRD_SHOWADDR;            //wyswietl adres LIN;
80A4  0E03     MOVLW 0x3
80A6  D7FA     BRA 0x809C
2134:                              return 1;                    
2135:                          }
2136:                          case 0x04:
2137:                          {
2138:                              FRL1.IDN=_CLIN_WRD_PULSE;              //pulsacja podswietlenia
80A8  0E04     MOVLW 0x4
80AA  D7F8     BRA 0x809C
2139:                              return 1;                    
2140:                          }                              
2141:                          default:
2142:                          {
2143:                              return 0;
2144:                          }
2145:                      }
2146:                  }
2147:                  case 0x83:  //Parametry konfiguracyjne
2148:                  {
2149:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
80CC  D847     RCALL PL388
80CE  A4D8     BTFSS STATUS, 2, ACCESS
80D0  0C00     RETLW 0x0
80D2  5174     MOVF _PFNf_prODP, W, BANKED
80D4  0A01     XORLW 0x1
80D6  A4D8     BTFSS STATUS, 2, ACCESS
80D8  0C00     RETLW 0x0
80DA  D7F6     BRA 0x80C8
2150:                      {
2151:                          case 0x01://Zapis parametru konfiguracji
2152:                          {
2153:                              FRL1.IDN=_CLIN_WRD_PKNF;                //zmien adres LIN plytki sterujacej UNI-02 (nowy adres w parametr1)
80C8  0E0E     MOVLW 0xE
80CA  D7E8     BRA 0x809C
2154:                              return 1;                    
2155:                          }                                 
2156:                          default:
2157:                          {
2158:                              return 0;
2159:                          }
2160:                      }
2161:                  }        
2162:                  case 0x87:  //Pozostale parametry
2163:                  {
2164:                      switch(FRL1.RS_IDN&0b01111111) //IDN paczki RS
810E  D826     RCALL PL388
8110  A4D8     BTFSS STATUS, 2, ACCESS
8112  0C00     RETLW 0x0
8114  5174     MOVF _PFNf_prODP, W, BANKED
8116  0A01     XORLW 0x1
8118  E0E1     BZ 0x80DC
811A  0A03     XORLW 0x3
811C  E0E1     BZ 0x80E0
811E  0A01     XORLW 0x1
8120  E0E1     BZ 0x80E4
8122  0A07     XORLW 0x7
8124  E0E1     BZ 0x80E8
8126  0A01     XORLW 0x1
8128  E0E1     BZ 0x80EC
812A  0A03     XORLW 0x3
812C  E0E1     BZ 0x80F0
812E  0A01     XORLW 0x1
8130  E0E2     BZ 0x80F6
8132  0A0F     XORLW 0xF
8134  E0E2     BZ 0x80FA
8136  0A01     XORLW 0x1
8138  E0E2     BZ 0x80FE
813A  0A03     XORLW 0x3
813C  E0E2     BZ 0x8102
813E  0A01     XORLW 0x1
8140  E0E2     BZ 0x8106
8142  0A07     XORLW 0x7
8144  A4D8     BTFSS STATUS, 2, ACCESS
8146  0C00     RETLW 0x0
8148  D7E0     BRA 0x810A
2165:                      {
2166:                          case 0x01://Zapisz nastwê PCW
2167:                          {
2168:                              FRL1.IDN=_CLIN_WRD_PCW;
80DC  0E05     MOVLW 0x5
80DE  D7DE     BRA 0x809C
2169:                              return 1;                    
2170:                          }    
2171:                          case 0x02://Zapisz nastwê PCO
2172:                          {
2173:                              FRL1.IDN=_CLIN_WRD_PCO;
80E0  0E06     MOVLW 0x6
80E2  D7DC     BRA 0x809C
2174:                              return 1;                    
2175:                          }
2176:                          case 0x03://Zapisz nastwê ECO
2177:                          {
2178:                              FRL1.IDN=_CLIN_WRD_ECO;
80E4  0E07     MOVLW 0x7
80E6  D7DA     BRA 0x809C
2179:                              return 1;                    
2180:                          }
2181:                          case 0x04://Zapisz tryb pracy
2182:                          {
2183:                              FRL1.IDN=_CLIN_WRD_TRB;
80E8  0E08     MOVLW 0x8
80EA  D7D8     BRA 0x809C
2184:                              return 1;                    
2185:                          }     
2186:                          case 0x05://Chwilowa aktywacja przycisku reset
2187:                          {
2188:                              FRL1.IDN=_CLIN_WRD_RES;
80EC  0E09     MOVLW 0x9
80EE  D7D6     BRA 0x809C
2189:                              return 1;                    
2190:                          }   
2191:                          case 0x06://Zniesienie blokady awaryjnej
2192:                          {
2193:                              FRL1.IDN=_CLIN_WRD_BRES;
80F0  0E0A     MOVLW 0xA
80F2  6FB5     MOVWF 0xB5, BANKED
80F4  0C00     RETLW 0x0
2194:                              return 0;                       //brak mozliwosci zdalnego resetu 
2195:                          }     
2196:                          case 0x07://Sterowanie funkcj± serwisow±
2197:                          {
2198:                              FRL1.IDN=_CLIN_WRD_FSR;
80F6  0E0B     MOVLW 0xB
80F8  D7D1     BRA 0x809C
2199:                              return 1;                    
2200:                          }  
2201:                          case 0x08://Sterowanie funkcj± antylegionella
2202:                          {
2203:                              FRL1.IDN=_CLIN_WRD_ANL;
80FA  0E0C     MOVLW 0xC
80FC  D7CF     BRA 0x809C
2204:                              return 1;                    
2205:                          }   
2206:                          case 0x09://Zdalne pobudzenie RT
2207:                          {
2208:                              FRL1.IDN=_CLIN_WRD_RT;
80FE  0E0F     MOVLW 0xF
8100  D7CD     BRA 0x809C
2209:                              return 1;                    
2210:                          }
2211:                          case 0x0A://Zdalne pobudzenie od timera zasobnika
2212:                          {
2213:                              FRL1.IDN=_CLIN_WRD_CW;
8102  0E10     MOVLW 0x10
8104  D7CB     BRA 0x809C
2214:                              return 1;                    
2215:                          }
2216:                          case 0x0B://Deaktywacja proc. odpowietrzenia 
2217:                          {
2218:                              FRL1.IDN=_CLIN_WRD_ENDO;
8106  0E11     MOVLW 0x11
8108  D7C9     BRA 0x809C
2219:                              return 1;                    
2220:                          }
2221:                          case 0x0C://Specjalny tryb pracy sterownika
2222:                          {
2223:                              FRL1.IDN=_CLIN_WRD_PRD;
810A  0E13     MOVLW 0x13
810C  D7C7     BRA 0x809C
810E  D826     RCALL PL388
8110  A4D8     BTFSS STATUS, 2, ACCESS
8112  0C00     RETLW 0x0
8114  5174     MOVF _PFNf_prODP, W, BANKED
8116  0A01     XORLW 0x1
8118  E0E1     BZ 0x80DC
811A  0A03     XORLW 0x3
811C  E0E1     BZ 0x80E0
811E  0A01     XORLW 0x1
8120  E0E1     BZ 0x80E4
8122  0A07     XORLW 0x7
8124  E0E1     BZ 0x80E8
8126  0A01     XORLW 0x1
8128  E0E1     BZ 0x80EC
812A  0A03     XORLW 0x3
812C  E0E1     BZ 0x80F0
812E  0A01     XORLW 0x1
8130  E0E2     BZ 0x80F6
8132  0A0F     XORLW 0xF
8134  E0E2     BZ 0x80FA
8136  0A01     XORLW 0x1
8138  E0E2     BZ 0x80FE
813A  0A03     XORLW 0x3
813C  E0E2     BZ 0x8102
813E  0A01     XORLW 0x1
8140  E0E2     BZ 0x8106
8142  0A07     XORLW 0x7
8144  A4D8     BTFSS STATUS, 2, ACCESS
8146  0C00     RETLW 0x0
8148  D7E0     BRA 0x810A
814A  51B7     MOVF 0xB7, W, BANKED
814C  0A82     XORLW 0x82
814E  E0AE     BZ 0x80AC
8150  0A01     XORLW 0x1
8152  E0BC     BZ 0x80CC
8154  0A04     XORLW 0x4
8156  A4D8     BTFSS STATUS, 2, ACCESS
8158  0C00     RETLW 0x0
815A  D7D9     BRA 0x810E
2224:                              return 1;                    
2225:                          }        
2226:                          default:
2227:                          {
2228:                              return 0;
2229:                          }
2230:                      }             
2231:                  }
2232:                  default:
2233:                  {
2234:                      return 0;
2235:                  }
2236:              }              
2237:          }
2238:          //----------------------------------------------------------------
2239:          #endif
2240:          //------------------------------------------------------------
2241:          //------------------------------------------------------------
2242:          //------------------------------------------------------------
2243:          #endif      //(_EXT_BOARD>=2)
2244:          
2245:          
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/trunc.c  ---------------------------------
1:             #include	<math.h>
2:             #include	<limits.h>
3:             #include	<float.h>
4:             
5:             #if	sizeof(double) <= sizeof(long)
6:             #define	_frndint(x)	((double)(long)(x))
7:             #else
8:             extern double	_frndint(double);
9:             #endif
10:            
11:            
12:            double
13:            trunc(double x)
14:            {
15:            	double	i;
16:            	int	expon;
17:            
18:            	frexp(x, &expon);
9A2A  C0A7     MOVFF x, _PFNf_prODP
9A2C  F074     NOP
9A2E  C0A8     MOVFF sign, _PFNf_prn_cs
9A30  F075     NOP
9A32  C0A9     MOVFF dt, _PFNf_prn_in
9A34  F076     NOP
9A36  0EF5     MOVLW 0xF5
9A38  6F77     MOVWF _PFNf_prn_pg, BANKED
9A3A  0E03     MOVLW 0x3
9A3C  6F78     MOVWF _PFNf_prn_pp, BANKED
9A3E  EC83     CALL 0xA906, 0
9A40  F054     NOP
19:            	if(expon < 0)
9A42  0103     MOVLB 0x3
9A44  AFF6     BTFSS 0xF6, 7, BANKED
9A46  D005     BRA 0x9A52
20:            		return 0.0;
9A48  0100     MOVLB 0x0
9A4A  6BA7     CLRF x, BANKED
9A4C  6BA8     CLRF sign, BANKED
9A4E  6BA9     CLRF dt, BANKED
9A50  0012     RETURN 0
21:            	if((unsigned)expon > sizeof(double) * CHAR_BIT - 4)
9A52  51F6     MOVF 0xF6, W, BANKED
9A54  E103     BNZ 0x9A5C
9A56  0E15     MOVLW 0x15
9A58  5DF5     SUBWF 0xF5, W, BANKED
9A5A  E307     BNC 0x9A6A
22:            		return x;		/* already an integer */
9A5C  C0A7     MOVFF x, x
9A5E  F0A7     NOP
9A60  C0A8     MOVFF sign, sign
9A62  F0A8     NOP
9A64  C0A9     MOVFF dt, dt
9A66  F0A9     NOP
9A68  0012     RETURN 0
23:            	i = _frndint(x);
9A6A  C0A7     MOVFF x, _RSDT1f_NewLIDN
9A6C  F08E     NOP
9A6E  C0A8     MOVFF sign, _RSDT1f_NoRespToLIN
9A70  F08F     NOP
9A72  C0A9     MOVFF dt, _RSDT1f_OdpLIDN
9A74  F090     NOP
9A76  EC6D     CALL 0x86DA, 0
9A78  F043     NOP
9A7A  C08E     MOVFF _RSDT1f_NewLIDN, _UADtf_RData
9A7C  F09D     NOP
9A7E  C08F     MOVFF _RSDT1f_NoRespToLIN, _UADtf_REXT
9A80  F09E     NOP
9A82  C090     MOVFF _RSDT1f_OdpLIDN, _UADtf_REnd
9A84  F09F     NOP
9A86  C091     MOVFF _RSDT1f_RD_KNF, _UADtf_RErrBUF
9A88  F0A0     NOP
9A8A  EC7E     CALL 0xA4FC, 0
9A8C  F052     NOP
9A8E  C09D     MOVFF _UADtf_RData, __pcstackBANK3
9A90  F3F2     NOP
9A92  C09E     MOVFF _UADtf_REXT, 0x3F3
9A94  F3F3     NOP
9A96  C09F     MOVFF _UADtf_REnd, 0x3F4
9A98  F3F4     NOP
24:            	return i;
9A9A  C3F2     MOVFF __pcstackBANK3, x
9A9C  F0A7     NOP
9A9E  C3F3     MOVFF 0x3F3, sign
9AA0  F0A8     NOP
9AA2  C3F4     MOVFF 0x3F4, dt
9AA4  F0A9     NOP
25:            }
9AA6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/round.c  ---------------------------------
1:             #include	<math.h>
2:             #include	<limits.h>
3:             #include	<float.h>
4:             
5:             double
6:             round(double x)
7:             {
8:             	double	f;
9:             
10:            	f = x-trunc(x);
9D0E  C4DE     MOVFF __pcstackBANK4, f1
9D10  F3F7     NOP
9D12  C4DF     MOVFF 0x4DF, 0x3F8
9D14  F3F8     NOP
9D16  C4E0     MOVFF 0x4E0, 0x3F9
9D18  F3F9     NOP
9D1A  D82E     RCALL PL484
9D1C  EC15     CALL 0x9A2A, 0
9D1E  F04D     NOP
9D20  C0A7     MOVFF x, f2
9D22  F3FA     NOP
9D24  C0A8     MOVFF sign, 0x3FB
9D26  F3FB     NOP
9D28  C0A9     MOVFF dt, 0x3FC
9D2A  F3FC     NOP
9D2C  ECBD     CALL 0xB37A, 0
9D2E  F059     NOP
9D30  C3F7     MOVFF f1, f
9D32  F0AA     NOP
9D34  C3F8     MOVFF 0x3F8, 0xAB
9D36  F0AB     NOP
9D38  C3F9     MOVFF 0x3F9, 0xAC
9D3A  F0AC     NOP
11:            	x += f;
9D3C  C4DE     MOVFF __pcstackBANK4, _RSDT1f_NewLIDN
9D3E  F08E     NOP
9D40  C4DF     MOVFF 0x4DF, _RSDT1f_NoRespToLIN
9D42  F08F     NOP
9D44  C4E0     MOVFF 0x4E0, _RSDT1f_OdpLIDN
9D46  F090     NOP
9D48  C0AA     MOVFF f, _RSDT1f_RD_KNF
9D4A  F091     NOP
9D4C  C0AB     MOVFF 0xAB, _RSDT1f_RD_LIN
9D4E  F092     NOP
9D50  C0AC     MOVFF 0xAC, _RSDT1f_RD_STD
9D52  F093     NOP
9D54  ECD5     CALL 0x71AA, 0
9D56  F038     NOP
9D58  C08E     MOVFF _RSDT1f_NewLIDN, __pcstackBANK4
9D5A  F4DE     NOP
9D5C  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x4DF
9D5E  F4DF     NOP
9D60  C090     MOVFF _RSDT1f_OdpLIDN, 0x4E0
9D62  F4E0     NOP
9D64  D809     RCALL PL484
12:            	return trunc(x);
9D66  EC15     CALL 0x9A2A, 0
9D68  F04D     NOP
9D6A  C0A7     MOVFF x, __pcstackBANK4
9D6C  F4DE     NOP
9D6E  C0A8     MOVFF sign, 0x4DF
9D70  F4DF     NOP
9D72  C0A9     MOVFF dt, 0x4E0
9D74  F4E0     NOP
13:            }
9D76  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lwtoft.c  --------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
BC6A  C07C     MOVFF _PFNf_setKey, _PFNf_prODP
BC6C  F074     NOP
BC6E  C07D     MOVFF _PFNf_set_aleg, _PFNf_prn_cs
BC70  F075     NOP
BC72  0100     MOVLB 0x0
BC74  EC44     CALL 0xB888, 0
BC76  F05C     NOP
BC78  EC88     CALL 0x9710, 0
BC7A  F04B     NOP
BC7C  C074     MOVFF _PFNf_prODP, _PFNf_setKey
BC7E  F07C     NOP
BC80  C075     MOVFF _PFNf_prn_cs, _PFNf_set_aleg
BC82  F07D     NOP
BC84  C076     MOVFF _PFNf_prn_in, _PFNf_set_eco
BC86  F07E     NOP
31:            }
BC88  0012     RETURN 0
32:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lwmod.c  ---------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
B162  5176     MOVF _PFNf_prn_in, W, BANKED
B164  1177     IORWF _PFNf_prn_pg, W, BANKED
B166  E017     BZ 0xB196
14:            		counter = 1;
B168  0E01     MOVLW 0x1
B16A  6F78     MOVWF _PFNf_prn_pp, BANKED
15:            		while((divisor & 0x8000) == 0) {
B16C  D004     BRA 0xB176
B176  AF77     BTFSS _PFNf_prn_pg, 7, BANKED
B178  D7FA     BRA 0xB16E
16:            			divisor <<= 1;
B16E  90D8     BCF STATUS, 0, ACCESS
B170  3776     RLCF _PFNf_prn_in, F, BANKED
B172  3777     RLCF _PFNf_prn_pg, F, BANKED
17:            			counter++;
B174  2B78     INCF _PFNf_prn_pp, F, BANKED
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
B17A  5176     MOVF _PFNf_prn_in, W, BANKED
B17C  5D74     SUBWF _PFNf_prODP, W, BANKED
B17E  5177     MOVF _PFNf_prn_pg, W, BANKED
B180  5975     SUBWFB _PFNf_prn_cs, W, BANKED
B182  E304     BNC 0xB18C
21:            				dividend -= divisor;
B184  5176     MOVF _PFNf_prn_in, W, BANKED
B186  5F74     SUBWF _PFNf_prODP, F, BANKED
B188  5177     MOVF _PFNf_prn_pg, W, BANKED
B18A  5B75     SUBWFB _PFNf_prn_cs, F, BANKED
22:            			divisor >>= 1;
B18C  90D8     BCF STATUS, 0, ACCESS
B18E  3377     RRCF _PFNf_prn_pg, F, BANKED
B190  3376     RRCF _PFNf_prn_in, F, BANKED
23:            		} while(--counter != 0);
B192  2F78     DECFSZ _PFNf_prn_pp, F, BANKED
B194  D7F2     BRA 0xB17A
24:            	}
25:            	return dividend;
B196  C074     MOVFF _PFNf_prODP, _PFNf_prODP
B198  F074     NOP
B19A  C075     MOVFF _PFNf_prn_cs, _PFNf_prn_cs
B19C  F075     NOP
26:            }
B19E  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lwdiv.c  ---------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
AD24  6B7E     CLRF _PFNf_set_eco, BANKED
AD26  6B7F     CLRF _PFNf_set_fnserw, BANKED
AD6E  6A19     CLRF _LIN1f_FIN, ACCESS
15:            	if(divisor != 0) {
AD28  517C     MOVF _PFNf_setKey, W, BANKED
AD2A  117D     IORWF _PFNf_set_aleg, W, BANKED
AD2C  E01B     BZ 0xAD64
AD72  5017     MOVF _LIN1f_ERRR, W, ACCESS
AD74  1018     IORWF _LIN1f_FAdta, W, ACCESS
AD76  E01B     BZ 0xADAE
16:            		counter = 1;
AD2E  0E01     MOVLW 0x1
AD30  6F80     MOVWF _PFNf_set_nco, BANKED
AD78  0E01     MOVLW 0x1
AD7A  6E1B     MOVWF _LIN1f_FTrans, ACCESS
17:            		while((divisor & 0x8000) == 0) {
AD32  D004     BRA 0xAD3C
AD3C  AF7D     BTFSS _PFNf_set_aleg, 7, BANKED
AD3E  D7FA     BRA 0xAD34
AD7C  D004     BRA 0xAD86
AD86  AE18     BTFSS _LIN1f_FAdta, 7, ACCESS
AD88  D7FA     BRA 0xAD7E
18:            			divisor <<= 1;
AD34  90D8     BCF STATUS, 0, ACCESS
AD36  377C     RLCF _PFNf_setKey, F, BANKED
AD38  377D     RLCF _PFNf_set_aleg, F, BANKED
AD7E  90D8     BCF STATUS, 0, ACCESS
AD80  3617     RLCF _LIN1f_ERRR, F, ACCESS
AD82  3618     RLCF _LIN1f_FAdta, F, ACCESS
19:            			counter++;
AD3A  2B80     INCF _PFNf_set_nco, F, BANKED
AD84  2A1B     INCF _LIN1f_FTrans, F, ACCESS
20:            		}
21:            		do {
22:            			quotient <<= 1;
AD40  90D8     BCF STATUS, 0, ACCESS
AD42  377E     RLCF _PFNf_set_eco, F, BANKED
AD44  377F     RLCF _PFNf_set_fnserw, F, BANKED
AD8A  90D8     BCF STATUS, 0, ACCESS
AD8C  3619     RLCF _LIN1f_FIN, F, ACCESS
AD8E  361A     RLCF _LIN1f_FResp, F, ACCESS
23:            			if(divisor <= dividend) {
AD46  517C     MOVF _PFNf_setKey, W, BANKED
AD48  5D7A     SUBWF _PFNf_res, W, BANKED
AD4A  517D     MOVF _PFNf_set_aleg, W, BANKED
AD4C  597B     SUBWFB _PFNf_rozruch, W, BANKED
AD4E  E305     BNC 0xAD5A
AD90  5017     MOVF _LIN1f_ERRR, W, ACCESS
AD92  5C15     SUBWF _LIN1f_Busy, W, ACCESS
AD94  5018     MOVF _LIN1f_FAdta, W, ACCESS
AD96  5816     SUBWFB _LIN1f_CHK, W, ACCESS
AD98  E305     BNC 0xADA4
24:            				dividend -= divisor;
AD50  517C     MOVF _PFNf_setKey, W, BANKED
AD52  5F7A     SUBWF _PFNf_res, F, BANKED
AD54  517D     MOVF _PFNf_set_aleg, W, BANKED
AD56  5B7B     SUBWFB _PFNf_rozruch, F, BANKED
AD9A  5017     MOVF _LIN1f_ERRR, W, ACCESS
AD9C  5E15     SUBWF _LIN1f_Busy, F, ACCESS
AD9E  5018     MOVF _LIN1f_FAdta, W, ACCESS
ADA0  5A16     SUBWFB _LIN1f_CHK, F, ACCESS
25:            				quotient |= 1;
AD58  817E     BSF _PFNf_set_eco, 0, BANKED
ADA2  8019     BSF _LIN1f_FIN, 0, ACCESS
26:            			}
27:            			divisor >>= 1;
AD5A  90D8     BCF STATUS, 0, ACCESS
AD5C  337D     RRCF _PFNf_set_aleg, F, BANKED
AD5E  337C     RRCF _PFNf_setKey, F, BANKED
ADA4  90D8     BCF STATUS, 0, ACCESS
ADA6  3218     RRCF _LIN1f_FAdta, F, ACCESS
ADA8  3217     RRCF _LIN1f_ERRR, F, ACCESS
28:            		} while(--counter != 0);
AD60  2F80     DECFSZ _PFNf_set_nco, F, BANKED
AD62  D7EE     BRA 0xAD40
ADAA  2E1B     DECFSZ _LIN1f_FTrans, F, ACCESS
ADAC  D7EE     BRA 0xAD8A
29:            	}
30:            	return quotient;
AD64  C07E     MOVFF _PFNf_set_eco, _PFNf_res
AD66  F07A     NOP
AD68  C07F     MOVFF _PFNf_set_fnserw, _PFNf_rozruch
AD6A  F07B     NOP
ADAE  C019     MOVFF _LIN1f_FIN, _LIN1f_Busy
ADB0  F015     NOP
ADB2  C01A     MOVFF _LIN1f_FResp, _LIN1f_CHK
ADB4  F016     NOP
31:            }
AD6C  0012     RETURN 0
ADB6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lldiv.c  ---------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lldiv(unsigned long int divisor, unsigned long int dividend)
7:             #else
8:             __lldiv(unsigned long int dividend, unsigned long int divisor)
9:             #endif
10:            {
11:            	unsigned long int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
9F62  6A1D     CLRF _LIN1f_SCS, ACCESS
9F64  6A1E     CLRF _MGSDf_ERRt, ACCESS
9F66  6A1F     CLRF _MGSDf_NO_ODB, ACCESS
9F68  6A20     CLRF _MGSDf_RERR_REC, ACCESS
15:            	if(divisor != 0) {
9F6A  5019     MOVF _LIN1f_FIN, W, ACCESS
9F6C  101A     IORWF _LIN1f_FResp, W, ACCESS
9F6E  101B     IORWF _LIN1f_FTrans, W, ACCESS
9F70  101C     IORWF _LIN1f_NDTA, W, ACCESS
9F72  E029     BZ 0x9FC6
16:            		counter = 1;
9F74  0E01     MOVLW 0x1
9F76  6E21     MOVWF _MGSDf_RERR_TIM, ACCESS
17:            		while((divisor & 0x80000000UL) == 0) {
9F78  D006     BRA 0x9F86
9F86  AE1C     BTFSS _LIN1f_NDTA, 7, ACCESS
9F88  D7F8     BRA 0x9F7A
18:            			divisor <<= 1;
9F7A  90D8     BCF STATUS, 0, ACCESS
9F7C  3619     RLCF _LIN1f_FIN, F, ACCESS
9F7E  361A     RLCF _LIN1f_FResp, F, ACCESS
9F80  361B     RLCF _LIN1f_FTrans, F, ACCESS
9F82  361C     RLCF _LIN1f_NDTA, F, ACCESS
19:            			counter++;
9F84  2A21     INCF _MGSDf_RERR_TIM, F, ACCESS
20:            		}
21:            		do {
22:            			quotient <<= 1;
9F8A  90D8     BCF STATUS, 0, ACCESS
9F8C  361D     RLCF _LIN1f_SCS, F, ACCESS
9F8E  361E     RLCF _MGSDf_ERRt, F, ACCESS
9F90  361F     RLCF _MGSDf_NO_ODB, F, ACCESS
9F92  3620     RLCF _MGSDf_RERR_REC, F, ACCESS
23:            			if(divisor <= dividend) {
9F94  5019     MOVF _LIN1f_FIN, W, ACCESS
9F96  5C15     SUBWF _LIN1f_Busy, W, ACCESS
9F98  501A     MOVF _LIN1f_FResp, W, ACCESS
9F9A  5816     SUBWFB _LIN1f_CHK, W, ACCESS
9F9C  501B     MOVF _LIN1f_FTrans, W, ACCESS
9F9E  5817     SUBWFB _LIN1f_ERRR, W, ACCESS
9FA0  501C     MOVF _LIN1f_NDTA, W, ACCESS
9FA2  5818     SUBWFB _LIN1f_FAdta, W, ACCESS
9FA4  E309     BNC 0x9FB8
24:            				dividend -= divisor;
9FA6  5019     MOVF _LIN1f_FIN, W, ACCESS
9FA8  5E15     SUBWF _LIN1f_Busy, F, ACCESS
9FAA  501A     MOVF _LIN1f_FResp, W, ACCESS
9FAC  5A16     SUBWFB _LIN1f_CHK, F, ACCESS
9FAE  501B     MOVF _LIN1f_FTrans, W, ACCESS
9FB0  5A17     SUBWFB _LIN1f_ERRR, F, ACCESS
9FB2  501C     MOVF _LIN1f_NDTA, W, ACCESS
9FB4  5A18     SUBWFB _LIN1f_FAdta, F, ACCESS
25:            				quotient |= 1;
9FB6  801D     BSF _LIN1f_SCS, 0, ACCESS
26:            			}
27:            			divisor >>= 1;
9FB8  90D8     BCF STATUS, 0, ACCESS
9FBA  321C     RRCF _LIN1f_NDTA, F, ACCESS
9FBC  321B     RRCF _LIN1f_FTrans, F, ACCESS
9FBE  321A     RRCF _LIN1f_FResp, F, ACCESS
9FC0  3219     RRCF _LIN1f_FIN, F, ACCESS
28:            		} while(--counter != 0);
9FC2  2E21     DECFSZ _MGSDf_RERR_TIM, F, ACCESS
9FC4  D7E2     BRA 0x9F8A
29:            	}
30:            	return quotient;
9FC6  C01D     MOVFF _LIN1f_SCS, _LIN1f_Busy
9FC8  F015     NOP
9FCA  C01E     MOVFF _MGSDf_ERRt, _LIN1f_CHK
9FCC  F016     NOP
9FCE  C01F     MOVFF _MGSDf_NO_ODB, _LIN1f_ERRR
9FD0  F017     NOP
9FD2  C020     MOVFF _MGSDf_RERR_REC, _LIN1f_FAdta
9FD4  F018     NOP
31:            }
9FD6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lbtoft.c  --------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert byte to float
12:            #ifdef _OLDLIB
13:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
14:            float
15:            __lbtoft(unsigned char c)
16:            {
17:            	float	f1;
18:            	
19:            	if(c == 0)
20:            		return 0.0;
21:            	f1_as_mant1 = c;
22:            	__ftpack(&f1_as_mant1, 127+15);
23:            	return f1;
24:            }
25:            #else
26:            float
27:            __lbtoft(unsigned char c)
B86A  0100     MOVLB 0x0
B86C  6F7F     MOVWF _PFNf_set_fnserw, BANKED
28:            {
29:            	return __ftpack(c, 127+15, 0);
B86E  517F     MOVF _PFNf_set_fnserw, W, BANKED
B870  6F74     MOVWF _PFNf_prODP, BANKED
B872  6B75     CLRF _PFNf_prn_cs, BANKED
B874  D809     RCALL PL574
B876  EC88     CALL 0x9710, 0
B878  F04B     NOP
B87A  C074     MOVFF _PFNf_prODP, _PFNf_setKey
B87C  F07C     NOP
B87E  C075     MOVFF _PFNf_prn_cs, _PFNf_set_aleg
B880  F07D     NOP
B882  C076     MOVFF _PFNf_prn_in, _PFNf_set_eco
B884  F07E     NOP
30:            }
B886  0012     RETURN 0
31:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lbmod.c  ---------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
BAA2  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
BAA4  0E08     MOVLW 0x8
BAA6  6E2A     MOVWF _PFNf_EnAleg, ACCESS
10:            	rem = 0;
BAA8  6A2B     CLRF _PFNf_EnF10V, ACCESS
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
BAAA  90D8     BCF STATUS, 0, ACCESS
BAAC  3429     RLCF _PFNf_10V_nPCO, W, ACCESS
BAAE  342B     RLCF _PFNf_EnF10V, W, ACCESS
BAB0  6E2B     MOVWF _PFNf_EnF10V, ACCESS
13:            		dividend <<= 1;
BAB2  90D8     BCF STATUS, 0, ACCESS
BAB4  3629     RLCF _PFNf_10V_nPCO, F, ACCESS
14:            		if(divisor <= rem)
BAB6  5028     MOVF _PFNf_10V_RT, W, ACCESS
BAB8  5C2B     SUBWF _PFNf_EnF10V, W, ACCESS
BABA  E302     BNC 0xBAC0
15:            			rem -= divisor;
BABC  5028     MOVF _PFNf_10V_RT, W, ACCESS
BABE  5E2B     SUBWF _PFNf_EnF10V, F, ACCESS
16:            	} while(--counter != 0);
BAC0  2E2A     DECFSZ _PFNf_EnAleg, F, ACCESS
BAC2  D7F3     BRA 0xBAAA
17:            	return rem;
BAC4  502B     MOVF _PFNf_EnF10V, W, ACCESS
18:            }
BAC6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/lbdiv.c  ---------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
B4C4  0100     MOVLB 0x0
B4C6  6F75     MOVWF _PFNf_prn_cs, BANKED
B5CE  6E29     MOVWF _PFNf_10V_nPCO, ACCESS
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
B4C8  6B77     CLRF _PFNf_prn_pg, BANKED
B5D0  6A2B     CLRF _PFNf_EnF10V, ACCESS
10:            	if(divisor != 0) {
B4CA  5174     MOVF _PFNf_prODP, W, BANKED
B4CC  E014     BZ 0xB4F6
B5D2  5028     MOVF _PFNf_10V_RT, W, ACCESS
B5D4  E014     BZ 0xB5FE
11:            		counter = 1;
B4CE  0E01     MOVLW 0x1
B4D0  6F76     MOVWF _PFNf_prn_in, BANKED
B5D6  0E01     MOVLW 0x1
B5D8  6E2A     MOVWF _PFNf_EnAleg, ACCESS
12:            		while((divisor & 0x80) == 0) {
B4D2  D003     BRA 0xB4DA
B4DA  AF74     BTFSS _PFNf_prODP, 7, BANKED
B4DC  D7FB     BRA 0xB4D4
B5DA  D003     BRA 0xB5E2
B5E2  AE28     BTFSS _PFNf_10V_RT, 7, ACCESS
B5E4  D7FB     BRA 0xB5DC
13:            			divisor <<= 1;
B4D4  90D8     BCF STATUS, 0, ACCESS
B4D6  3774     RLCF _PFNf_prODP, F, BANKED
B5DC  90D8     BCF STATUS, 0, ACCESS
B5DE  3628     RLCF _PFNf_10V_RT, F, ACCESS
14:            			counter++;
B4D8  2B76     INCF _PFNf_prn_in, F, BANKED
B5E0  2A2A     INCF _PFNf_EnAleg, F, ACCESS
15:            		}
16:            		do {
17:            			quotient <<= 1;
B4DE  90D8     BCF STATUS, 0, ACCESS
B4E0  3777     RLCF _PFNf_prn_pg, F, BANKED
B5E6  90D8     BCF STATUS, 0, ACCESS
B5E8  362B     RLCF _PFNf_EnF10V, F, ACCESS
18:            			if(divisor <= dividend) {
B4E2  5174     MOVF _PFNf_prODP, W, BANKED
B4E4  5D75     SUBWF _PFNf_prn_cs, W, BANKED
B4E6  E303     BNC 0xB4EE
B5EA  5028     MOVF _PFNf_10V_RT, W, ACCESS
B5EC  5C29     SUBWF _PFNf_10V_nPCO, W, ACCESS
B5EE  E303     BNC 0xB5F6
19:            				dividend -= divisor;
B4E8  5174     MOVF _PFNf_prODP, W, BANKED
B4EA  5F75     SUBWF _PFNf_prn_cs, F, BANKED
B5F0  5028     MOVF _PFNf_10V_RT, W, ACCESS
B5F2  5E29     SUBWF _PFNf_10V_nPCO, F, ACCESS
20:            				quotient |= 1;
B4EC  8177     BSF _PFNf_prn_pg, 0, BANKED
B5F4  802B     BSF _PFNf_EnF10V, 0, ACCESS
21:            			}
22:            			divisor >>= 1;
B4EE  90D8     BCF STATUS, 0, ACCESS
B4F0  3374     RRCF _PFNf_prODP, F, BANKED
B5F6  90D8     BCF STATUS, 0, ACCESS
B5F8  3228     RRCF _PFNf_10V_RT, F, ACCESS
23:            		} while(--counter != 0);
B4F2  2F76     DECFSZ _PFNf_prn_in, F, BANKED
B4F4  D7F4     BRA 0xB4DE
B5FA  2E2A     DECFSZ _PFNf_EnAleg, F, ACCESS
B5FC  D7F4     BRA 0xB5E6
24:            	}
25:            	return quotient;
B4F6  5177     MOVF _PFNf_prn_pg, W, BANKED
B5FE  502B     MOVF _PFNf_EnF10V, W, ACCESS
26:            }
B4F8  0012     RETURN 0
B600  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/fttol.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
86DA  C090     MOVFF _RSDT1f_OdpLIDN, _RSDT1f_RD_LIN
86DC  F092     NOP
86DE  0100     MOVLB 0x0
86E0  6B93     CLRF _RSDT1f_RD_STD, BANKED
86E2  6B94     CLRF _RSDT1f_RRD_KNF, BANKED
86E4  358F     RLCF _RSDT1f_NoRespToLIN, W, BANKED
86E6  3792     RLCF _RSDT1f_RD_LIN, F, BANKED
86E8  E301     BNC 0x86EC
86EA  8193     BSF _RSDT1f_RD_STD, 0, BANKED
86EC  5192     MOVF _RSDT1f_RD_LIN, W, BANKED
86EE  6F9C     MOVWF _UAD1tf_TFEnd, BANKED
86F0  519C     MOVF _UAD1tf_TFEnd, W, BANKED
86F2  E105     BNZ 0x86FE
50:            		return 0;
86F4  6B8E     CLRF _RSDT1f_NewLIDN, BANKED
86F6  6B8F     CLRF _RSDT1f_NoRespToLIN, BANKED
86F8  6B90     CLRF _RSDT1f_OdpLIDN, BANKED
86FA  6B91     CLRF _RSDT1f_RD_KNF, BANKED
86FC  0012     RETURN 0
51:            	sign1 = f1_as_mant1 >> 23;
86FE  0E17     MOVLW 0x17
8700  6F92     MOVWF _RSDT1f_RD_LIN, BANKED
8702  C08E     MOVFF _RSDT1f_NewLIDN, _RSDT1f_RD_STD
8704  F093     NOP
8706  C08F     MOVFF _RSDT1f_NoRespToLIN, _RSDT1f_RRD_KNF
8708  F094     NOP
870A  C090     MOVFF _RSDT1f_OdpLIDN, _RSDT1f_RRD_STD
870C  F095     NOP
870E  2992     INCF _RSDT1f_RD_LIN, W, BANKED
8710  6F96     MOVWF _RSDT1f_RespLIDN, BANKED
8712  D004     BRA 0x871C
8714  90D8     BCF STATUS, 0, ACCESS
8716  3395     RRCF _RSDT1f_RRD_STD, F, BANKED
8718  3394     RRCF _RSDT1f_RRD_KNF, F, BANKED
871A  3393     RRCF _RSDT1f_RD_STD, F, BANKED
871C  2F96     DECFSZ _RSDT1f_RespLIDN, F, BANKED
871E  D7FA     BRA 0x8714
8720  0100     MOVLB 0x0
8722  5193     MOVF _RSDT1f_RD_STD, W, BANKED
8724  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
52:            	f1_as_mant1 |= 0x8000UL;
8726  8F8F     BSF _RSDT1f_NoRespToLIN, 7, BANKED
53:            	f1_as_mant1 &= 0xFFFFUL;
8728  6B90     CLRF _RSDT1f_OdpLIDN, BANKED
54:            	lval = f1_as_mant1;
872A  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
872C  6F98     MOVWF _UAD1tf_RFData, BANKED
872E  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
8730  6F99     MOVWF _UAD1tf_RFEnd, BANKED
8732  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
8734  6F9A     MOVWF _UAD1tf_RFExt, BANKED
8736  6B9B     CLRF _UAD1tf_TFData, BANKED
55:            	exp1 -= 127+15;
8738  0E8E     MOVLW 0x8E
873A  5F9C     SUBWF _UAD1tf_TFEnd, F, BANKED
56:            	if((signed char)exp1 < 0) {
873C  AF9C     BTFSS _UAD1tf_TFEnd, 7, BANKED
873E  D00C     BRA 0x8758
57:            		if((signed char)exp1 < -15)
8740  519C     MOVF _UAD1tf_TFEnd, W, BANKED
8742  0A80     XORLW 0x80
8744  0F8F     ADDLW 0x8F
8746  E3D6     BNC 0x86F4
58:            			return 0;
59:            		do
60:            			lval >>= 1;
8748  90D8     BCF STATUS, 0, ACCESS
874A  339B     RRCF _UAD1tf_TFData, F, BANKED
874C  339A     RRCF _UAD1tf_RFExt, F, BANKED
874E  3399     RRCF _UAD1tf_RFEnd, F, BANKED
8750  3398     RRCF _UAD1tf_RFData, F, BANKED
61:            		while(++exp1 != 0);
8752  3F9C     INCFSZ _UAD1tf_TFEnd, F, BANKED
8754  D7F9     BRA 0x8748
8756  D00C     BRA 0x8770
62:            	} else {
63:            		if(exp1 >= 24)
8758  0E17     MOVLW 0x17
875A  659C     CPFSGT _UAD1tf_TFEnd, BANKED
875C  D007     BRA 0x876C
875E  D7CA     BRA 0x86F4
64:            			return 0;
65:            		while(exp1 != 0) {
876C  519C     MOVF _UAD1tf_TFEnd, W, BANKED
876E  E1F8     BNZ 0x8760
66:            			lval <<= 1;
8760  90D8     BCF STATUS, 0, ACCESS
8762  3798     RLCF _UAD1tf_RFData, F, BANKED
8764  3799     RLCF _UAD1tf_RFEnd, F, BANKED
8766  379A     RLCF _UAD1tf_RFExt, F, BANKED
8768  379B     RLCF _UAD1tf_TFData, F, BANKED
67:            			exp1--;
876A  079C     DECF _UAD1tf_TFEnd, F, BANKED
68:            		}
69:            	}
70:            	if(sign1)
8770  5197     MOVF _UAD1tf_RFBrSn, W, BANKED
8772  E008     BZ 0x8784
71:            		lval = -lval;
8774  1F9B     COMF _UAD1tf_TFData, F, BANKED
8776  1F9A     COMF _UAD1tf_RFExt, F, BANKED
8778  1F99     COMF _UAD1tf_RFEnd, F, BANKED
877A  6D98     NEGF _UAD1tf_RFData, BANKED
877C  0E00     MOVLW 0x0
877E  2399     ADDWFC _UAD1tf_RFEnd, F, BANKED
8780  239A     ADDWFC _UAD1tf_RFExt, F, BANKED
8782  239B     ADDWFC _UAD1tf_TFData, F, BANKED
72:            	return lval;
8784  C098     MOVFF _UAD1tf_RFData, _RSDT1f_NewLIDN
8786  F08E     NOP
8788  C099     MOVFF _UAD1tf_RFEnd, _RSDT1f_NoRespToLIN
878A  F08F     NOP
878C  C09A     MOVFF _UAD1tf_RFExt, _RSDT1f_OdpLIDN
878E  F090     NOP
8790  C09B     MOVFF _UAD1tf_TFData, _RSDT1f_RD_KNF
8792  F091     NOP
73:            }
8794  0012     RETURN 0
74:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/ftsub.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	if (f2 != 0) {
B37A  0103     MOVLB 0x3
B37C  51FA     MOVF 0xFA, W, BANKED
B37E  11FB     IORWF 0xFB, W, BANKED
B380  11FC     IORWF 0xFC, W, BANKED
B382  E002     BZ 0xB388
24:            		f2_as_mant2 ^= 0x800000;
B384  0E80     MOVLW 0x80
B386  1BFC     XORWF 0xFC, F, BANKED
25:            	}
26:            	return __ftadd(f1, f2);
B388  C3F7     MOVFF f1, _RSDT1f_NewLIDN
B38A  F08E     NOP
B38C  C3F8     MOVFF 0x3F8, _RSDT1f_NoRespToLIN
B38E  F08F     NOP
B390  C3F9     MOVFF 0x3F9, _RSDT1f_OdpLIDN
B392  F090     NOP
B394  C3FA     MOVFF f2, _RSDT1f_RD_KNF
B396  F091     NOP
B398  C3FB     MOVFF 0x3FB, _RSDT1f_RD_LIN
B39A  F092     NOP
B39C  C3FC     MOVFF 0x3FC, _RSDT1f_RD_STD
B39E  F093     NOP
B3A0  ECD5     CALL 0x71AA, 0
B3A2  F038     NOP
B3A4  C08E     MOVFF _RSDT1f_NewLIDN, f1
B3A6  F3F7     NOP
B3A8  C08F     MOVFF _RSDT1f_NoRespToLIN, 0x3F8
B3AA  F3F8     NOP
B3AC  C090     MOVFF _RSDT1f_OdpLIDN, 0x3F9
B3AE  F3F9     NOP
27:            }
B3B0  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/ftmul.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #ifdef _PIC18
9:             #define _Has_hardware_multiply 1
10:            #else
11:            #define _Has_hardware_multiply 0
12:            #endif
13:            
14:            #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
15:            #define _Has_large_call_stack 1
16:            #else
17:            #define _Has_large_call_stack 0
18:            #endif
19:            
20:            #include	"ftarith.h"
21:            
22:            #define	f1_as_plier	(*(unsigned short long *)&f1)
23:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
24:            
25:            // floating addition
26:            #ifdef _OLDLIB
27:            #define	f3_as_product		(*(unsigned short long *)&f3)
28:            float
29:            __ftmul(float f1, float f2)
30:            {
31:            	unsigned char	exp1, sign1, cntr;
32:            	float	f3;
33:            	
34:            	f3_as_product = 0;
35:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
36:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
37:            	if(cntr == 0 || exp1 == 0)
38:            		return f3;
39:            	exp1 += cntr-127-6;	// compute new exponent
40:            	cntr = 7;
41:            	do {
42:            		if(f1_as_plier & 1)
43:            			f3_as_product += f2_as_plicand;
44:            		f1_as_plier >>= 1;
45:            		f2_as_plicand <<= 1;
46:            	} while(--cntr != 0);
47:            	cntr = 9;
48:            	do {
49:            		if(f1_as_plier & 1)
50:            			f3_as_product += f2_as_plicand;
51:            		f1_as_plier >>= 1;
52:            		f3_as_product >>= 1;
53:            	} while(--cntr != 0);
54:            	__ftpack(&f3_as_product, exp1);
55:            	if(sign1)
56:            		f3_as_product |= 0x800000;
57:            	return f3;
58:            }
59:            #else
60:            #define	exp2	sign
61:            float
62:            __ftmul(float f1, float f2)
63:            {
64:            	unsigned char	exp, sign, cntr;
65:            	unsigned short long	f3_as_product;
66:            
67:            	if((exp = f1_as_plier >> 15) == 0)
83CE  C081     MOVFF _PFNf_set_ncw, _PFNf_tdzCW
83D0  F085     NOP
83D2  6B86     CLRF _PFNf_timZAS, BANKED
83D4  6B87     CLRF _PFNf_tmpZW, BANKED
83D6  3580     RLCF _PFNf_set_nco, W, BANKED
83D8  3785     RLCF _PFNf_tdzCW, F, BANKED
83DA  E301     BNC 0x83DE
83DC  8186     BSF _PFNf_timZAS, 0, BANKED
83DE  5185     MOVF _PFNf_tdzCW, W, BANKED
83E0  6F88     MOVWF _PFNf_toInit, BANKED
83E2  5188     MOVF _PFNf_toInit, W, BANKED
83E4  E101     BNZ 0x83E8
68:            		return 0.0;
83E6  D053     BRA PL708
69:            	if((exp2 = f2_as_plicand >> 15) == 0)
83E8  C084     MOVFF _PFNf_tdzCO, _PFNf_tdzCW
83EA  F085     NOP
83EC  6B86     CLRF _PFNf_timZAS, BANKED
83EE  6B87     CLRF _PFNf_tmpZW, BANKED
83F0  3583     RLCF _PFNf_str_ncw, W, BANKED
83F2  3785     RLCF _PFNf_tdzCW, F, BANKED
83F4  E301     BNC 0x83F8
83F6  8186     BSF _PFNf_timZAS, 0, BANKED
83F8  5185     MOVF _PFNf_tdzCW, W, BANKED
83FA  6F8D     MOVWF _PWMf_ENPWM2, BANKED
83FC  518D     MOVF _PWMf_ENPWM2, W, BANKED
83FE  E101     BNZ 0x8402
8400  D046     BRA PL708
70:            		return 0.0;
71:            	exp += exp2-127-6;	// compute new exponent
8402  518D     MOVF _PWMf_ENPWM2, W, BANKED
8404  0F7B     ADDLW 0x7B
8406  2788     ADDWF _PFNf_toInit, F, BANKED
72:            	sign = f1_as_plier >> 16;
8408  C081     MOVFF _PFNf_set_ncw, _PWMf_ENPWM2
840A  F08D     NOP
73:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
840C  5184     MOVF _PFNf_tdzCO, W, BANKED
840E  1B8D     XORWF _PWMf_ENPWM2, F, BANKED
74:            	sign &= 0x80;
8410  0E80     MOVLW 0x80
8412  178D     ANDWF _PWMf_ENPWM2, F, BANKED
75:            	f1_as_plier |= 0x8000UL;
8414  8F80     BSF _PFNf_set_nco, 7, BANKED
76:            	//f1_as_plier &= 0xFFFFUL;		// not required
77:            	f2_as_plicand |= 0x8000UL;
8416  8F83     BSF _PFNf_str_ncw, 7, BANKED
78:            	f2_as_plicand &= 0xFFFFUL;
8418  0E00     MOVLW 0x0
841A  1784     ANDWF _PFNf_tdzCO, F, BANKED
79:            	f3_as_product = 0;
841C  6B89     CLRF _PFNf_trbECO, BANKED
841E  6B8A     CLRF _PFNf_vnt, BANKED
8420  6B8B     CLRF _PFNf_zcfm, BANKED
80:            
81:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
82:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
83:            
84:            #define USE_SHRINK /* makes my test program smallest */
85:            
86:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
87:            /*
88:                     
89:            |seeeeeee|emmmmmmm|mmmmmmmm|
90:                     1.mmmmmmm mmmmmmmm
91:            
92:            a 16-bit multiply can be decomposed into the sum of four 8-bit multiplies
93:                   a  b
94:            *      c  d
95:            -----------
96:               ac| 0  0
97:                 |bc  0
98:                 |ad  0
99:            +    |   bd (we must not ignore this intermediate product
100:                        because it /can/ affect the high 16 bits of the result)
101:           ===========
102:            */
103:           	f1_as_plier &= 0xFFFFUL; /* required (see comment above) for this method */
104:           
105:                   f3_as_product  = ((unsigned int)LOWBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand)) >> 8;
106:                   f3_as_product += (unsigned int)LOWBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
107:                   f3_as_product += (unsigned int)HIGHBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand);
108:           #if defined(USE_MASKS)
109:                   f3_as_product += ((unsigned short long)
110:           			  ((unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand)))
111:           		<< 8;
112:           #elif defined(USE_SHRINK)
113:           	*((unsigned int*)(((unsigned char*)&f3_as_product)+1)) +=
114:           		(unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
115:           #else
116:           #error No method chosen
117:           #endif
118:           
119:           /*
120:           assuming normalized mantissa:
121:           smallest ac: 0x80 x 0x80 == 0x4000 .. shift down 7 bits
122:           largest ac:  0xff x 0xff == 0xfe01 .. shift down 8
123:            */
124:           	/* ensure result is normalized as expected by pack() */
125:           	if (f3_as_product & 0x800000u) {
126:           		f3_as_product >>= 1;
127:           		exp++;
128:           	}
129:           	f3_as_product >>= 1;
130:           
131:           #else
132:           	/* f1 & 0x8000 == 0x8000 */
133:           	/* f2 & 0x8000 == 0x8000 */
134:           	cntr = 7;
8422  0E07     MOVLW 0x7
8424  6F8C     MOVWF _PFNf_zima, BANKED
135:           	do {
136:           		if(f1_as_plier & 1)
8426  B17F     BTFSC _PFNf_set_fnserw, 0, BANKED
137:           			f3_as_product += f2_as_plicand;
8428  D82B     RCALL PL448
138:           		f1_as_plier >>= 1;
842A  90D8     BCF STATUS, 0, ACCESS
842C  3381     RRCF _PFNf_set_ncw, F, BANKED
842E  3380     RRCF _PFNf_set_nco, F, BANKED
8430  337F     RRCF _PFNf_set_fnserw, F, BANKED
139:           		f2_as_plicand <<= 1;
8432  90D8     BCF STATUS, 0, ACCESS
8434  3782     RLCF _PFNf_str_nco, F, BANKED
8436  3783     RLCF _PFNf_str_ncw, F, BANKED
8438  3784     RLCF _PFNf_tdzCO, F, BANKED
140:           	} while(--cntr != 0);
843A  2F8C     DECFSZ _PFNf_zima, F, BANKED
843C  D7F4     BRA 0x8426
141:           	/* f1 & 0x100 == 0x100 */
142:           	/* f2 & 0x400000 == 0x400000 */
143:           	cntr = 9;
843E  0E09     MOVLW 0x9
8440  6F8C     MOVWF _PFNf_zima, BANKED
144:           	do {
145:           		if(f1_as_plier & 1)
8442  B17F     BTFSC _PFNf_set_fnserw, 0, BANKED
8444  D81D     RCALL PL448
146:           			f3_as_product += f2_as_plicand;
147:           		f1_as_plier >>= 1;
8446  90D8     BCF STATUS, 0, ACCESS
8448  3381     RRCF _PFNf_set_ncw, F, BANKED
844A  3380     RRCF _PFNf_set_nco, F, BANKED
844C  337F     RRCF _PFNf_set_fnserw, F, BANKED
148:           		f3_as_product >>= 1;
844E  90D8     BCF STATUS, 0, ACCESS
8450  338B     RRCF _PFNf_zcfm, F, BANKED
8452  338A     RRCF _PFNf_vnt, F, BANKED
8454  3389     RRCF _PFNf_trbECO, F, BANKED
149:           	} while(--cntr != 0);
8456  2F8C     DECFSZ _PFNf_zima, F, BANKED
8458  D7F4     BRA 0x8442
150:           	/* f1 == 0 */
151:           	/* f2 & 0x400000 == 0x400000 */
152:           	/* because the last bit of f1 _was_ set,
153:           	   f3 & 0x200000 == 0x200000 and
154:           	   f3 & 0xc00000 == 0 */
155:           #endif
156:           	return __ftpack(f3_as_product, exp, sign);
845A  C089     MOVFF _PFNf_trbECO, _PFNf_prODP
845C  F074     NOP
845E  C08A     MOVFF _PFNf_vnt, _PFNf_prn_cs
8460  F075     NOP
8462  C08B     MOVFF _PFNf_zcfm, _PFNf_prn_in
8464  F076     NOP
8466  C088     MOVFF _PFNf_toInit, _PFNf_prn_pg
8468  F077     NOP
846A  C08D     MOVFF _PWMf_ENPWM2, _PFNf_prn_pp
846C  F078     NOP
846E  EC88     CALL 0x9710, 0
8470  F04B     NOP
8472  C074     MOVFF _PFNf_prODP, _PFNf_set_fnserw
8474  F07F     NOP
8476  C075     MOVFF _PFNf_prn_cs, _PFNf_set_nco
8478  F080     NOP
847A  C076     MOVFF _PFNf_prn_in, _PFNf_set_ncw
847C  F081     NOP
157:           }
847E  0012     RETURN 0
158:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/ftge.c  ----------------------------------
1:             #define	f1	(*(unsigned short long *)&ff1)
2:             #define	f2	(*(unsigned short long *)&ff2)
3:             bit
4:             __ftge(float ff1, float ff2)
5:             {
6:             	if(f1 &  0x800000UL)
A95C  AF82     BTFSS _PFNf_str_nco, 7, BANKED
A95E  D00A     BRA 0xA974
7:             		f1 = 0x800000UL - f1;
A960  D823     RCALL PL690
A962  5180     MOVF _PFNf_set_nco, W, BANKED
A964  5D86     SUBWF _PFNf_timZAS, W, BANKED
A966  6F80     MOVWF _PFNf_set_nco, BANKED
A968  5181     MOVF _PFNf_set_ncw, W, BANKED
A96A  5987     SUBWFB _PFNf_tmpZW, W, BANKED
A96C  6F81     MOVWF _PFNf_set_ncw, BANKED
A96E  5182     MOVF _PFNf_str_nco, W, BANKED
A970  5988     SUBWFB _PFNf_toInit, W, BANKED
A972  6F82     MOVWF _PFNf_str_nco, BANKED
8:             	if(f2 &  0x800000UL)
A974  AF85     BTFSS _PFNf_tdzCW, 7, BANKED
A976  D00A     BRA 0xA98C
A978  D817     RCALL PL690
9:             		f2 = 0x800000UL - f2;
A97A  5183     MOVF _PFNf_str_ncw, W, BANKED
A97C  5D86     SUBWF _PFNf_timZAS, W, BANKED
A97E  6F83     MOVWF _PFNf_str_ncw, BANKED
A980  5184     MOVF _PFNf_tdzCO, W, BANKED
A982  5987     SUBWFB _PFNf_tmpZW, W, BANKED
A984  6F84     MOVWF _PFNf_tdzCO, BANKED
A986  5185     MOVF _PFNf_tdzCW, W, BANKED
A988  5988     SUBWFB _PFNf_toInit, W, BANKED
A98A  6F85     MOVWF _PFNf_tdzCW, BANKED
10:            	f1 ^= 0x800000UL;
A98C  0E80     MOVLW 0x80
A98E  1B82     XORWF _PFNf_str_nco, F, BANKED
11:            	f2 ^= 0x800000UL;
A990  1B85     XORWF _PFNf_tdzCW, F, BANKED
12:            	return f1 >= f2;
A992  5183     MOVF _PFNf_str_ncw, W, BANKED
A994  5D80     SUBWF _PFNf_set_nco, W, BANKED
A996  5184     MOVF _PFNf_tdzCO, W, BANKED
A998  5981     SUBWFB _PFNf_set_ncw, W, BANKED
A99A  5185     MOVF _PFNf_tdzCW, W, BANKED
A99C  5982     SUBWFB _PFNf_str_nco, W, BANKED
A99E  E202     BC 0xA9A4
A9A0  90D8     BCF STATUS, 0, ACCESS
A9A2  0012     RETURN 0
A9A4  80D8     BSF STATUS, 0, ACCESS
13:            }
A9A6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/ftdiv.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            #ifdef _PIC18
19:            __ftdiv(float f1, float f2)
20:            #else
21:            __ftdiv(float f2, float f1)
22:            #endif
23:            {
24:            	unsigned char	exp1, exp2, sign1, sign2;
25:            	float	f3;
26:            	
27:            	f3_as_quot = 0;
28:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:            	if(exp1 == 0)
30:            		return f3;
31:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:            	if(exp2 == 0)
33:            		return f3;
34:            	exp1 -= exp2-127+8;	// compute new exponent
35:            	sign1 ^= sign2;
36:            	cntr = 16+8;
37:            	do {
38:            		f3_as_quot <<= 1;
39:            		if(f1_as_dividend >= f2_as_divisor) {
40:            			f1_as_dividend -= f2_as_divisor;
41:            			f3_as_quot |= 1;
42:            		}
43:            		f1_as_dividend <<= 1;
44:            	} while(--cntr != 0);
45:            	__ftpack(&f3_as_quot, exp1);
46:            	if(sign1)
47:            		f3_as_quot |= 0x800000;
48:            	return f3;
49:            }
50:            #else
51:            #define	exp2	sign
52:            float
53:            #ifdef _PIC18
54:            __ftdiv(float f1, float f2)
55:            #else
56:            __ftdiv(float f2, float f1)
57:            #endif
58:            {
59:            	unsigned char	exp, sign, cntr;
60:            	float	f3;
61:            	
62:            	// unpack the operands
63:            	if((exp = f1_as_dividend >> 15) == 0)
89C0  C09C     MOVFF _UAD1tf_TFEnd, _UADtf_RErrBUF
89C2  F0A0     NOP
89C4  6BA1     CLRF _UADtf_RErrREC, BANKED
89C6  6BA2     CLRF _UADtf_TData, BANKED
89C8  359B     RLCF _UAD1tf_TFData, W, BANKED
89CA  37A0     RLCF _UADtf_RErrBUF, F, BANKED
89CC  E301     BNC 0x89D0
89CE  81A1     BSF _UADtf_RErrREC, 0, BANKED
89D0  51A0     MOVF _UADtf_RErrBUF, W, BANKED
89D2  6FA4     MOVWF _UADtf_TEnd, BANKED
89D4  51A4     MOVF _UADtf_TEnd, W, BANKED
89D6  E101     BNZ 0x89DA
64:            		return 0.0;
89D8  D04A     BRA PL674
65:            	if((exp2 = f2_as_divisor >> 15) == 0)
89DA  C09F     MOVFF _UADtf_REnd, _UADtf_RErrBUF
89DC  F0A0     NOP
89DE  6BA1     CLRF _UADtf_RErrREC, BANKED
89E0  6BA2     CLRF _UADtf_TData, BANKED
89E2  359E     RLCF _UADtf_REXT, W, BANKED
89E4  37A0     RLCF _UADtf_RErrBUF, F, BANKED
89E6  E301     BNC 0x89EA
89E8  81A1     BSF _UADtf_RErrREC, 0, BANKED
89EA  51A0     MOVF _UADtf_RErrBUF, W, BANKED
89EC  6FA8     MOVWF sign, BANKED
89EE  51A8     MOVF sign, W, BANKED
89F0  E101     BNZ 0x89F4
89F2  D03D     BRA PL674
66:            		return 0.0;
67:            	f3_as_quot = 0;
89F4  6BA5     CLRF f3, BANKED
89F6  6BA6     CLRF sign, BANKED
89F8  6BA7     CLRF x, BANKED
68:            	exp -= exp2-127+8;	// compute new exponent
89FA  51A8     MOVF sign, W, BANKED
89FC  0F89     ADDLW 0x89
89FE  5FA4     SUBWF _UADtf_TEnd, F, BANKED
69:            	sign = f1_as_dividend >> 16;
8A00  C09C     MOVFF _UAD1tf_TFEnd, sign
8A02  F0A8     NOP
70:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
8A04  519F     MOVF _UADtf_REnd, W, BANKED
8A06  1BA8     XORWF sign, F, BANKED
71:            	sign &= 0x80;
8A08  0E80     MOVLW 0x80
8A0A  17A8     ANDWF sign, F, BANKED
72:            	f1_as_dividend |= 0x8000UL;
8A0C  8F9B     BSF _UAD1tf_TFData, 7, BANKED
73:            	f1_as_dividend &= 0xFFFFUL;
8A0E  6B9C     CLRF _UAD1tf_TFEnd, BANKED
74:            	f2_as_divisor |= 0x8000UL;
8A10  8F9E     BSF _UADtf_REXT, 7, BANKED
75:            	f2_as_divisor &= 0xFFFFUL;
8A12  6B9F     CLRF _UADtf_REnd, BANKED
76:            	cntr = 16+8;
8A14  0E18     MOVLW 0x18
8A16  6FA3     MOVWF _UADtf_TEXT, BANKED
77:            	do {
78:            		f3_as_quot <<= 1;
8A18  90D8     BCF STATUS, 0, ACCESS
8A1A  37A5     RLCF f3, F, BANKED
8A1C  37A6     RLCF sign, F, BANKED
8A1E  37A7     RLCF x, F, BANKED
79:            		if(f1_as_dividend >= f2_as_divisor) {
8A20  519D     MOVF _UADtf_RData, W, BANKED
8A22  5D9A     SUBWF _UAD1tf_RFExt, W, BANKED
8A24  519E     MOVF _UADtf_REXT, W, BANKED
8A26  599B     SUBWFB _UAD1tf_TFData, W, BANKED
8A28  519F     MOVF _UADtf_REnd, W, BANKED
8A2A  599C     SUBWFB _UAD1tf_TFEnd, W, BANKED
8A2C  E307     BNC 0x8A3C
80:            			f1_as_dividend -= f2_as_divisor;
8A2E  519D     MOVF _UADtf_RData, W, BANKED
8A30  5F9A     SUBWF _UAD1tf_RFExt, F, BANKED
8A32  519E     MOVF _UADtf_REXT, W, BANKED
8A34  5B9B     SUBWFB _UAD1tf_TFData, F, BANKED
8A36  519F     MOVF _UADtf_REnd, W, BANKED
8A38  5B9C     SUBWFB _UAD1tf_TFEnd, F, BANKED
81:            			f3_as_quot |= 1;
8A3A  81A5     BSF f3, 0, BANKED
82:            		}
83:            		f1_as_dividend <<= 1;
8A3C  90D8     BCF STATUS, 0, ACCESS
8A3E  379A     RLCF _UAD1tf_RFExt, F, BANKED
8A40  379B     RLCF _UAD1tf_TFData, F, BANKED
8A42  379C     RLCF _UAD1tf_TFEnd, F, BANKED
84:            	} while(--cntr != 0);
8A44  2FA3     DECFSZ _UADtf_TEXT, F, BANKED
8A46  D7E8     BRA 0x8A18
85:            	return __ftpack(f3_as_quot, exp, sign);
8A48  C0A5     MOVFF f3, _PFNf_prODP
8A4A  F074     NOP
8A4C  C0A6     MOVFF sign, _PFNf_prn_cs
8A4E  F075     NOP
8A50  C0A7     MOVFF x, _PFNf_prn_in
8A52  F076     NOP
8A54  C0A4     MOVFF _UADtf_TEnd, _PFNf_prn_pg
8A56  F077     NOP
8A58  C0A8     MOVFF sign, _PFNf_prn_pp
8A5A  F078     NOP
8A5C  EC88     CALL 0x9710, 0
8A5E  F04B     NOP
8A60  C074     MOVFF _PFNf_prODP, _UAD1tf_RFExt
8A62  F09A     NOP
8A64  C075     MOVFF _PFNf_prn_cs, _UAD1tf_TFData
8A66  F09B     NOP
8A68  C076     MOVFF _PFNf_prn_in, _UAD1tf_TFEnd
8A6A  F09C     NOP
86:            }
8A6C  0012     RETURN 0
87:            #endif	
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/ftadd.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
71AA  C090     MOVFF _RSDT1f_OdpLIDN, _RSDT1f_RRD_KNF
71AC  F094     NOP
71AE  0100     MOVLB 0x0
71B0  6B95     CLRF _RSDT1f_RRD_STD, BANKED
71B2  6B96     CLRF _RSDT1f_RespLIDN, BANKED
71B4  358F     RLCF _RSDT1f_NoRespToLIN, W, BANKED
71B6  3794     RLCF _RSDT1f_RRD_KNF, F, BANKED
71B8  E301     BNC 0x71BC
71BA  8195     BSF _RSDT1f_RRD_STD, 0, BANKED
71BC  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
71BE  6F99     MOVWF _UAD1tf_RFEnd, BANKED
91:            	exp2 = f2_as_mant2 >> 15;
71C0  C093     MOVFF _RSDT1f_RD_STD, _RSDT1f_RRD_KNF
71C2  F094     NOP
71C4  6B95     CLRF _RSDT1f_RRD_STD, BANKED
71C6  6B96     CLRF _RSDT1f_RespLIDN, BANKED
71C8  3592     RLCF _RSDT1f_RD_LIN, W, BANKED
71CA  3794     RLCF _RSDT1f_RRD_KNF, F, BANKED
71CC  E301     BNC 0x71D0
71CE  8195     BSF _RSDT1f_RRD_STD, 0, BANKED
71D0  5194     MOVF _RSDT1f_RRD_KNF, W, BANKED
71D2  6F98     MOVWF _UAD1tf_RFData, BANKED
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
71D4  5199     MOVF _UAD1tf_RFEnd, W, BANKED
71D6  E009     BZ 0x71EA
71D8  5198     MOVF _UAD1tf_RFData, W, BANKED
71DA  5D99     SUBWF _UAD1tf_RFEnd, W, BANKED
71DC  E20D     BC 0x71F8
71DE  5199     MOVF _UAD1tf_RFEnd, W, BANKED
71E0  5D98     SUBWF _UAD1tf_RFData, W, BANKED
71E2  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
71E4  0E18     MOVLW 0x18
71E6  6594     CPFSGT _RSDT1f_RRD_KNF, BANKED
71E8  D007     BRA 0x71F8
93:            		return f2;
71EA  C091     MOVFF _RSDT1f_RD_KNF, _RSDT1f_NewLIDN
71EC  F08E     NOP
71EE  C092     MOVFF _RSDT1f_RD_LIN, _RSDT1f_NoRespToLIN
71F0  F08F     NOP
71F2  C093     MOVFF _RSDT1f_RD_STD, _RSDT1f_OdpLIDN
71F4  F090     NOP
71F6  0012     RETURN 0
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
71F8  5198     MOVF _UAD1tf_RFData, W, BANKED
71FA  E009     BZ 0x720E
71FC  5199     MOVF _UAD1tf_RFEnd, W, BANKED
71FE  5D98     SUBWF _UAD1tf_RFData, W, BANKED
7200  E20D     BC 0x721C
7202  5198     MOVF _UAD1tf_RFData, W, BANKED
7204  5D99     SUBWF _UAD1tf_RFEnd, W, BANKED
7206  6F94     MOVWF _RSDT1f_RRD_KNF, BANKED
7208  0E18     MOVLW 0x18
720A  6594     CPFSGT _RSDT1f_RRD_KNF, BANKED
720C  D007     BRA 0x721C
95:            		return f1;
720E  C08E     MOVFF _RSDT1f_NewLIDN, _RSDT1f_NewLIDN
7210  F08E     NOP
7212  C08F     MOVFF _RSDT1f_NoRespToLIN, _RSDT1f_NoRespToLIN
7214  F08F     NOP
7216  C090     MOVFF _RSDT1f_OdpLIDN, _RSDT1f_OdpLIDN
7218  F090     NOP
721A  0012     RETURN 0
96:            	sign = 6;
721C  0E06     MOVLW 0x6
721E  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
97:            	if(f1_as_mant1 & 0x800000L)
7220  BF90     BTFSC _RSDT1f_OdpLIDN, 7, BANKED
98:            		sign |= 0x80;
7222  8F97     BSF _UAD1tf_RFBrSn, 7, BANKED
99:            	if(f2_as_mant2 & 0x800000L)
7224  BF93     BTFSC _RSDT1f_RD_STD, 7, BANKED
100:           		sign |= 0x40;
7226  8D97     BSF _UAD1tf_RFBrSn, 6, BANKED
101:           	f1_as_mant1 |= 0x8000UL;
7228  8F8F     BSF _RSDT1f_NoRespToLIN, 7, BANKED
102:           	f1_as_mant1 &= 0xFFFFUL;
722A  6B90     CLRF _RSDT1f_OdpLIDN, BANKED
103:           	f2_as_mant2 |= 0x8000UL;
722C  8F92     BSF _RSDT1f_RD_LIN, 7, BANKED
104:           	f2_as_mant2 &= 0xFFFFUL;
722E  6B93     CLRF _RSDT1f_RD_STD, BANKED
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
7230  5198     MOVF _UAD1tf_RFData, W, BANKED
7232  5D99     SUBWF _UAD1tf_RFEnd, W, BANKED
7234  E214     BC 0x725E
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
7236  90D8     BCF STATUS, 0, ACCESS
7238  3791     RLCF _RSDT1f_RD_KNF, F, BANKED
723A  3792     RLCF _RSDT1f_RD_LIN, F, BANKED
723C  3793     RLCF _RSDT1f_RD_STD, F, BANKED
111:           			exp2--;
723E  0798     DECF _UAD1tf_RFData, F, BANKED
112:           		} while(exp2 != exp1 && --sign & 7);
7240  5199     MOVF _UAD1tf_RFEnd, W, BANKED
7242  1998     XORWF _UAD1tf_RFData, W, BANKED
7244  E008     BZ 0x7256
7246  D853     RCALL PL552
7248  E006     BZ 0x7256
724A  D7F5     BRA 0x7236
113:           		while(exp1 != exp2) {
7256  5198     MOVF _UAD1tf_RFData, W, BANKED
7258  1999     XORWF _UAD1tf_RFEnd, W, BANKED
725A  E017     BZ 0x728A
725C  D7F7     BRA 0x724C
114:           			f1_as_mant1 >>= 1;
724C  90D8     BCF STATUS, 0, ACCESS
724E  3390     RRCF _RSDT1f_OdpLIDN, F, BANKED
7250  338F     RRCF _RSDT1f_NoRespToLIN, F, BANKED
7252  338E     RRCF _RSDT1f_NewLIDN, F, BANKED
115:           			exp1++;
7254  2B99     INCF _UAD1tf_RFEnd, F, BANKED
116:           		}
117:           	} else if(exp1 > exp2) {
725E  5199     MOVF _UAD1tf_RFEnd, W, BANKED
7260  5D98     SUBWF _UAD1tf_RFData, W, BANKED
7262  E213     BC 0x728A
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
7264  90D8     BCF STATUS, 0, ACCESS
7266  378E     RLCF _RSDT1f_NewLIDN, F, BANKED
7268  378F     RLCF _RSDT1f_NoRespToLIN, F, BANKED
726A  3790     RLCF _RSDT1f_OdpLIDN, F, BANKED
122:           			exp1--;
726C  0799     DECF _UAD1tf_RFEnd, F, BANKED
123:           		} while(exp2 != exp1 && --sign & 7);
726E  5199     MOVF _UAD1tf_RFEnd, W, BANKED
7270  1998     XORWF _UAD1tf_RFData, W, BANKED
7272  E008     BZ 0x7284
7274  D83C     RCALL PL552
7276  E006     BZ 0x7284
7278  D7F5     BRA 0x7264
124:           		while(exp1 != exp2) {
7284  5198     MOVF _UAD1tf_RFData, W, BANKED
7286  1999     XORWF _UAD1tf_RFEnd, W, BANKED
7288  E1F8     BNZ 0x727A
125:           			f2_as_mant2 >>= 1;
727A  90D8     BCF STATUS, 0, ACCESS
727C  3393     RRCF _RSDT1f_RD_STD, F, BANKED
727E  3392     RRCF _RSDT1f_RD_LIN, F, BANKED
7280  3391     RRCF _RSDT1f_RD_KNF, F, BANKED
126:           			exp2++;
7282  2B98     INCF _UAD1tf_RFData, F, BANKED
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
728A  AF97     BTFSS _UAD1tf_RFBrSn, 7, BANKED
728C  D007     BRA 0x729C
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
728E  1F8E     COMF _RSDT1f_NewLIDN, F, BANKED
7290  1F8F     COMF _RSDT1f_NoRespToLIN, F, BANKED
7292  1F90     COMF _RSDT1f_OdpLIDN, F, BANKED
132:           		f1_as_mant1++;
7294  2B8E     INCF _RSDT1f_NewLIDN, F, BANKED
7296  0E00     MOVLW 0x0
7298  238F     ADDWFC _RSDT1f_NoRespToLIN, F, BANKED
729A  2390     ADDWFC _RSDT1f_OdpLIDN, F, BANKED
133:           	}
134:           	if(sign & 0x40) {
729C  BD97     BTFSC _UAD1tf_RFBrSn, 6, BANKED
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
729E  D81F     RCALL PL422
137:           		f2_as_mant2++;
138:           	}
139:           	sign = 0;
72A0  6B97     CLRF _UAD1tf_RFBrSn, BANKED
140:           	f2_as_mant2 += f1_as_mant1;
72A2  518E     MOVF _RSDT1f_NewLIDN, W, BANKED
72A4  2791     ADDWF _RSDT1f_RD_KNF, F, BANKED
72A6  518F     MOVF _RSDT1f_NoRespToLIN, W, BANKED
72A8  2392     ADDWFC _RSDT1f_RD_LIN, F, BANKED
72AA  5190     MOVF _RSDT1f_OdpLIDN, W, BANKED
72AC  2393     ADDWFC _RSDT1f_RD_STD, F, BANKED
141:           	if(f2_as_mant2 & 0x800000UL) {
72AE  AF93     BTFSS _RSDT1f_RD_STD, 7, BANKED
72B0  D003     BRA 0x72B8
72B2  D815     RCALL PL422
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
143:           		f2_as_mant2++;
144:           		sign = 1;
72B4  0E01     MOVLW 0x1
72B6  6F97     MOVWF _UAD1tf_RFBrSn, BANKED
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
72B8  C091     MOVFF _RSDT1f_RD_KNF, _PFNf_prODP
72BA  F074     NOP
72BC  C092     MOVFF _RSDT1f_RD_LIN, _PFNf_prn_cs
72BE  F075     NOP
72C0  C093     MOVFF _RSDT1f_RD_STD, _PFNf_prn_in
72C2  F076     NOP
72C4  C099     MOVFF _UAD1tf_RFEnd, _PFNf_prn_pg
72C6  F077     NOP
72C8  C097     MOVFF _UAD1tf_RFBrSn, _PFNf_prn_pp
72CA  F078     NOP
72CC  EC88     CALL 0x9710, 0
72CE  F04B     NOP
72D0  C074     MOVFF _PFNf_prODP, _RSDT1f_NewLIDN
72D2  F08E     NOP
72D4  C075     MOVFF _PFNf_prn_cs, _RSDT1f_NoRespToLIN
72D6  F08F     NOP
72D8  C076     MOVFF _PFNf_prn_in, _RSDT1f_OdpLIDN
72DA  F090     NOP
147:           
148:           }
72DC  0012     RETURN 0
149:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/frexp.c  ---------------------------------
1:             /*	Frexp/ldexp in C */
2:             #include <math.h>
3:             #include <float.h>
4:             #include <errno.h>
5:             
6:             
7:             /* PIC32 definition */
8:             #ifdef __PICC32__
9:             #if	sizeof(double) == 4
10:            #define	EXCESS	126
11:            #define MAX_EXPONENT 255
12:            #define __STRUCT32
13:            typedef union both
14:            {
15:            	struct flt
16:            	{
17:            		unsigned 	mant:16;
18:            		unsigned	hmant:7;
19:            		unsigned	exp:8;
20:            		unsigned	sign:1;
21:            	}	flt;
22:            	double	fl;
23:            } both_t;
24:            #endif /* end 32-bit floating point */
25:            
26:            #endif // __PICC32__
27:            
28:            /* ARM-C definition */
29:            #if defined(__ARMC__)
30:            /* For 32-bit floating point */
31:            #if	sizeof(double) == 4
32:            #define	EXCESS	126
33:            #define MAX_EXPONENT 255
34:            #define __STRUCT32
35:            typedef union both
36:            {
37:            	struct flt
38:            	{
39:            		unsigned	sign:1;
40:            		unsigned	exp:8;
41:            		unsigned	hmant:7;
42:            		unsigned 	mant:16;
43:            	}	flt;
44:            	double	fl;
45:            } both_t;
46:            #endif /* end 32-bit floating point */
47:            #endif /* end ARM-C */
48:            
49:            /* PICC-18 definition */
50:            #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
51:            /* For 32-bit floating point */
52:            #if	sizeof(double) == 4
53:            #define	EXCESS	126
54:            #define MAX_EXPONENT 255
55:            #define __STRUCT32
56:            typedef union both
57:            {
58:            	struct flt
59:            	{
60:            		unsigned  char	mant[2];
61:            		unsigned	hmant:7;
62:            		unsigned	lexp:1;
63:            		unsigned	hexp:7;
64:            		unsigned	sign:1;
65:            	}	flt;
66:            	double	fl;
67:            } both_t;
68:            #endif /* end 32-bit floating point */
69:            #if	sizeof(double) == 3
70:            #define	EXCESS	126
71:            #define MAX_EXPONENT 255
72:            #define __STRUCT24
73:            typedef union both
74:            {
75:            	struct flt
76:            	{
77:            		unsigned char 	mant[1];
78:            		unsigned	hmant:7;
79:            		unsigned	lexp:1;
80:            		unsigned	hexp:7;
81:            		unsigned	sign:1;
82:            	}	flt;
83:            	double	fl;
84:            } both_t;
85:            #endif /* end 24-bit floating point */
86:            #endif /* end PICC-18-C / PICC PRO */
87:            
88:            /* dsPICC definition */
89:            #if defined(__DSPICC__)
90:            /* For 32-bit floating point */
91:            #if	sizeof(double) == 4
92:            #define	EXCESS	126
93:            #define MAX_EXPONENT 255
94:            #define __STRUCT32
95:            typedef union both
96:            {
97:            	struct flt
98:            	{
99:            		unsigned 	mant:16;
100:           		unsigned	sign:1;
101:           		unsigned	exp:8;
102:           		unsigned	hmant:7;
103:           	}	flt;
104:           	double	fl;
105:           } both_t;
106:           #endif /* end 32-bit floating point */
107:           #endif /* end dsPICC */
108:           
109:           /* PSOC definition */
110:           #if defined(_PSOC_)
111:           /* For 32-bit floating point */
112:           #if	sizeof(double) == 4
113:           #define	EXCESS	126
114:           #define MAX_EXPONENT 255
115:           #define __STRUCT32
116:           typedef union both
117:           {
118:           	struct flt
119:           	{
120:           		unsigned	sign:1;
121:           		unsigned	exp:8;
122:           		unsigned	hmant:7;
123:           		unsigned char	mant[2];
124:           	}	flt;
125:           	double	fl;
126:           } both_t;
127:           #endif /* end 32-bit floating point */
128:           
129:           #if	sizeof(double) == 3
130:           #define	EXCESS	126
131:           #define MAX_EXPONENT 255
132:           #define __STRUCT24
133:           typedef union both
134:           {
135:           	struct flt
136:           	{
137:           		unsigned	sign:1;
138:           		unsigned	exp:8;
139:           		unsigned	hmant:7;
140:           		unsigned char	mant[1];
141:           	}	flt;
142:           	double	fl;
143:           } both_t;
144:           #endif /* end 24-bit floating point */
145:           #endif /* end PSOC */
146:           
147:           
148:           /* MSP430 definition */
149:           #if defined(__MSP430C__)
150:           /* For 32-bit floating point */
151:           #if	sizeof(double) == 4
152:           #define	EXCESS	126
153:           #define MAX_EXPONENT 255
154:           #define __STRUCT32
155:           typedef union both
156:           {
157:           	struct flt
158:           	{
159:           		unsigned char	mant[2];
160:           		unsigned	hmant:7;
161:           		unsigned	exp:8;
162:           		unsigned	sign:1;
163:           	}	flt;
164:           	double	fl;
165:           } both_t;
166:           #endif /* end 32-bit floating point */
167:           #endif /* end MSP430 */
168:           
169:           /* Z80 definition */
170:           #if	z80
171:           #if	sizeof(double) == 4
172:           #define	EXCESS	64
173:           #define __STRUCT32
174:           typedef union both
175:           {
176:           	struct flt
177:           	{
178:           		unsigned char	mant[2];
179:           		unsigned	hmant:8;
180:           		unsigned	exp:7;
181:           		unsigned	sign:1;
182:           	}	flt;
183:           	double	fl;
184:           } both_t;
185:           #endif
186:           #endif	/* end Z80 */
187:           
188:           
189:           #if	sizeof(double) == 4 && !defined(__STRUCT32)
190:           #warning Using generic 32-bit structure definition. A compiler-specific one should be defined
191:           #define __STRUCT32
192:           #if	defined(_XA_) || defined(i8096) || defined(i8086)
193:           #define	LITTLE_ENDIAN
194:           #endif
195:           
196:           typedef union both
197:           {
198:           	struct flt
199:           	{
200:           #define	EXCESS	126
201:           #define MAX_EXPONENT 255
202:           #ifdef	LITTLE_ENDIAN
203:           		unsigned char	mant[2];
204:           		unsigned	hmant:7;
205:           		unsigned	exp:8;
206:           		unsigned	sign:1;
207:           #else
208:           		unsigned	sign:1;
209:           		unsigned	exp:8;
210:           		unsigned	hmant:7;
211:           		unsigned char	mant[2];
212:           #endif
213:           	}	flt;
214:           	double	fl;
215:           } both_t;
216:           
217:           #endif
218:           
219:           
220:           #if	sizeof(double) == 8 && !defined(__STRUCT64)
221:           #warning Using generic 64-bit structure definition. A compiler-specific one should be defined
222:           #define __STRUCT64
223:           #if	defined(_XA_) || defined(i8096) || defined(i8086)
224:           #define	LITTLE_ENDIAN
225:           #endif
226:           #define	EXCESS	1022
227:           #define MAX_EXPONENT 2047
228:           typedef union both
229:           {
230:           	struct flt
231:           	{
232:           #ifdef	LITTLE_ENDIAN
233:           		unsigned char	mant[6];
234:           		unsigned	hmant:4;
235:           		unsigned	exp:11;
236:           		unsigned	sign:1;
237:           #else
238:           		unsigned	sign:1;
239:           		unsigned	exp:11;
240:           		unsigned	hmant:4;
241:           		unsigned char	mant[6];
242:           #endif
243:           	}	flt;
244:           	double	fl;
245:           } both_t;
246:           #endif
247:           
248:           
249:           #if	!defined(__STRUCT32) && !defined(__STRUCT64) && !defined(__STRUCT24)
250:           #error No floating point structure definition created for this compiler
251:           #endif
252:           
253:           double
254:           frexp(double value, int * eptr)
255:           {
256:           	if (value == 0.0) {
A906  5174     MOVF _PFNf_prODP, W, BANKED
A908  1175     IORWF _PFNf_prn_cs, W, BANKED
A90A  1176     IORWF _PFNf_prn_in, W, BANKED
A90C  E104     BNZ 0xA916
257:           		*eptr = 0;
A90E  D821     RCALL PL436
A910  6ADE     CLRF POSTINC2, ACCESS
A912  6ADD     CLRF POSTDEC2, ACCESS
A914  0C00     RETLW 0x0
258:           		return 0.0;
259:           	}
260:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
261:           	*eptr = ((both_t *)&value)->flt.hexp << 1;
A916  5176     MOVF _PFNf_prn_in, W, BANKED
A918  0B7F     ANDLW 0x7F
A91A  6F79     MOVWF _PFNf_prn_res, BANKED
A91C  6B7A     CLRF _PFNf_res, BANKED
A91E  90D8     BCF STATUS, 0, ACCESS
A920  3779     RLCF _PFNf_prn_res, F, BANKED
A922  377A     RLCF _PFNf_res, F, BANKED
A924  D816     RCALL PL436
A926  C079     MOVFF _PFNf_prn_res, POSTINC2
A928  FFDE     NOP
A92A  C07A     MOVFF _PFNf_res, POSTDEC2
A92C  FFDD     NOP
262:           	*eptr |= ((both_t *)&value)->flt.lexp;
A92E  0E01     MOVLW 0x1
A930  AF75     BTFSS _PFNf_prn_cs, 7, BANKED
A932  0E00     MOVLW 0x0
A934  D80E     RCALL PL436
A936  12DE     IORWF POSTINC2, F, ACCESS
A938  0E00     MOVLW 0x0
A93A  12DD     IORWF POSTDEC2, F, ACCESS
A93C  D80A     RCALL PL436
263:           	*eptr -= EXCESS;
A93E  0E82     MOVLW 0x82
A940  26DE     ADDWF POSTINC2, F, ACCESS
A942  0EFF     MOVLW 0xFF
A944  22DD     ADDWFC POSTDEC2, F, ACCESS
264:           #else
265:           	*eptr = ((both_t *)&value)->flt.exp - EXCESS;
266:           #endif
267:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
268:           	((both_t *)&value)->flt.hexp = EXCESS >> 1;
A946  5176     MOVF _PFNf_prn_in, W, BANKED
A948  0B80     ANDLW 0x80
A94A  093F     IORLW 0x3F
A94C  6F76     MOVWF _PFNf_prn_in, BANKED
269:           	((both_t *)&value)->flt.lexp = EXCESS & 0x01;
A94E  9F75     BCF _PFNf_prn_cs, 7, BANKED
270:           #else
271:           	((both_t *)&value)->flt.exp = EXCESS;
272:           #endif
273:           	return value;
274:           }
A950  0012     RETURN 0
275:           
276:           double
277:           ldexp(double value, int newexp)
278:           {
279:           	if (value == 0.0)
280:           		return 0.0;
281:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
282:           	newexp += ((both_t *)&value)->flt.hexp << 1;
283:           	newexp += ((both_t *)&value)->flt.lexp;
284:           #else
285:           	newexp += ((both_t *)&value)->flt.exp;
286:           #endif
287:           	if (newexp < 0) {
288:           		errno = ERANGE;
289:           		return 0.0;
290:           	}
291:           	else if (newexp > MAX_EXPONENT) {
292:           		errno = ERANGE;
293:           		if (value < 0.0)
294:           			return -DBL_MAX;
295:           		else
296:           			return DBL_MAX;
297:           	}
298:           	else {
299:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
300:           		((both_t *)&value)->flt.hexp = newexp >> 1;
301:           		((both_t *)&value)->flt.lexp = newexp & 0x01;
302:           #else
303:           		((both_t *)&value)->flt.exp = newexp;
304:           #endif
305:           	}
306:           	return value;
307:           }
308:           
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/float.c  ---------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
9710  5177     MOVF _PFNf_prn_pg, W, BANKED
9712  E004     BZ 0x971C
9714  5174     MOVF _PFNf_prODP, W, BANKED
9716  1175     IORWF _PFNf_prn_cs, W, BANKED
9718  1176     IORWF _PFNf_prn_in, W, BANKED
971A  E106     BNZ 0x9728
65:            		return 0.0;
971C  6B74     CLRF _PFNf_prODP, BANKED
971E  6B75     CLRF _PFNf_prn_cs, BANKED
9720  6B76     CLRF _PFNf_prn_in, BANKED
9722  0012     RETURN 0
66:            	while(arg & 0xFE0000UL) {
9728  6B79     CLRF _PFNf_prn_res, BANKED
972A  6B7A     CLRF _PFNf_res, BANKED
972C  0EFE     MOVLW 0xFE
972E  1576     ANDWF _PFNf_prn_in, W, BANKED
9730  D82D     RCALL PL672
9732  E007     BZ 0x9742
9734  D7F7     BRA 0x9724
67:            		exp++;
9724  2B77     INCF _PFNf_prn_pg, F, BANKED
68:            		arg >>= 1;
9726  D82D     RCALL PL642
69:            	}
70:            	while(arg & 0xFF0000UL) {
9742  6B79     CLRF _PFNf_prn_res, BANKED
9744  6B7A     CLRF _PFNf_res, BANKED
9746  5176     MOVF _PFNf_prn_in, W, BANKED
9748  D821     RCALL PL672
974A  E006     BZ 0x9758
974C  D7F4     BRA 0x9736
71:            		exp++;
9736  2B77     INCF _PFNf_prn_pg, F, BANKED
72:            		(arg)++;
9738  2B74     INCF _PFNf_prODP, F, BANKED
973A  0E00     MOVLW 0x0
973C  2375     ADDWFC _PFNf_prn_cs, F, BANKED
973E  2376     ADDWFC _PFNf_prn_in, F, BANKED
9740  D820     RCALL PL642
73:            		arg >>= 1;
74:            	}
75:            	while(!(arg & 0x8000UL) && exp > 1) {
9758  BF75     BTFSC _PFNf_prn_cs, 7, BANKED
975A  D003     BRA 0x9762
975C  0E02     MOVLW 0x2
975E  6177     CPFSLT _PFNf_prn_pg, BANKED
9760  D7F6     BRA 0x974E
76:            		exp--;
974E  0777     DECF _PFNf_prn_pg, F, BANKED
77:            		arg <<= 1;
9750  90D8     BCF STATUS, 0, ACCESS
9752  3774     RLCF _PFNf_prODP, F, BANKED
9754  3775     RLCF _PFNf_prn_cs, F, BANKED
9756  3776     RLCF _PFNf_prn_in, F, BANKED
78:            	}
79:            	if(!(exp & 1))
9762  A177     BTFSS _PFNf_prn_pg, 0, BANKED
80:            		arg &= ~0x8000L;
9764  9F75     BCF _PFNf_prn_cs, 7, BANKED
81:            	exp >>= 1;
9766  90D8     BCF STATUS, 0, ACCESS
9768  3377     RRCF _PFNf_prn_pg, F, BANKED
82:            	arg |= (unsigned short long)exp << 16;
976A  5177     MOVF _PFNf_prn_pg, W, BANKED
976C  1376     IORWF _PFNf_prn_in, F, BANKED
83:            	if (sign)
976E  5178     MOVF _PFNf_prn_pp, W, BANKED
9770  E001     BZ 0x9774
84:            		arg |= 0x800000UL;
9772  8F76     BSF _PFNf_prn_in, 7, BANKED
85:               return *(float*)&arg;	
9774  C074     MOVFF _PFNf_prODP, _PFNf_prODP
9776  F074     NOP
9778  C075     MOVFF _PFNf_prn_cs, _PFNf_prn_cs
977A  F075     NOP
977C  C076     MOVFF _PFNf_prn_in, _PFNf_prn_in
977E  F076     NOP
86:            }
9780  0012     RETURN 0
87:            
88:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/awtoft.c  --------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert signed int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __awtoft(signed int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = (signed short long)c;
23:            	if(c < 0)
24:            		f1_as_mant1 = -f1_as_mant1;
25:            	__ftpack(&f1_as_mant1, 127+15);
26:            	if(c < 0)
27:            		f1 = -f1;
28:            	return f1;
29:            }
30:            #else
31:            float
32:            __awtoft(signed int c)
33:            {
34:            	unsigned char sign;
35:            
36:            	sign = 0;
B422  6B7F     CLRF _PFNf_set_fnserw, BANKED
37:            	if (c < 0) {
B424  AF7D     BTFSS _PFNf_set_aleg, 7, BANKED
B426  D006     BRA 0xB434
38:            		c = -c;
B428  6D7C     NEGF _PFNf_setKey, BANKED
B42A  1F7D     COMF _PFNf_set_aleg, F, BANKED
B42C  B0D8     BTFSC STATUS, 0, ACCESS
B42E  2B7D     INCF _PFNf_set_aleg, F, BANKED
39:            		sign = 1;
B430  0E01     MOVLW 0x1
B432  6F7F     MOVWF _PFNf_set_fnserw, BANKED
40:            	}
41:            	return __ftpack((unsigned int)c, 127+15, sign);
B434  C07C     MOVFF _PFNf_setKey, _PFNf_prODP
B436  F074     NOP
B438  C07D     MOVFF _PFNf_set_aleg, _PFNf_prn_cs
B43A  F075     NOP
B43C  6B76     CLRF _PFNf_prn_in, BANKED
B43E  0E8E     MOVLW 0x8E
B440  6F77     MOVWF _PFNf_prn_pg, BANKED
B442  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_pp
B444  F078     NOP
B446  EC88     CALL 0x9710, 0
B448  F04B     NOP
B44A  C074     MOVFF _PFNf_prODP, _PFNf_setKey
B44C  F07C     NOP
B44E  C075     MOVFF _PFNf_prn_cs, _PFNf_set_aleg
B450  F07D     NOP
B452  C076     MOVFF _PFNf_prn_in, _PFNf_set_eco
B454  F07E     NOP
42:            }
B456  0012     RETURN 0
43:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/awdiv.c  ---------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
9D86  6B79     CLRF _PFNf_prn_res, BANKED
15:            	if(divisor < 0) {
9D88  AF77     BTFSS _PFNf_prn_pg, 7, BANKED
9D8A  D006     BRA 0x9D98
16:            		divisor = -divisor;
9D8C  6D76     NEGF _PFNf_prn_in, BANKED
9D8E  1F77     COMF _PFNf_prn_pg, F, BANKED
9D90  B0D8     BTFSC STATUS, 0, ACCESS
9D92  2B77     INCF _PFNf_prn_pg, F, BANKED
17:            		sign = 1;
9D94  0E01     MOVLW 0x1
9D96  6F79     MOVWF _PFNf_prn_res, BANKED
18:            	}
19:            	if(dividend < 0) {
9D98  AF75     BTFSS _PFNf_prn_cs, 7, BANKED
9D9A  D006     BRA 0x9DA8
20:            		dividend = -dividend;
9D9C  6D74     NEGF _PFNf_prODP, BANKED
9D9E  1F75     COMF _PFNf_prn_cs, F, BANKED
9DA0  B0D8     BTFSC STATUS, 0, ACCESS
9DA2  2B75     INCF _PFNf_prn_cs, F, BANKED
21:            		sign ^= 1;
9DA4  0E01     MOVLW 0x1
9DA6  1B79     XORWF _PFNf_prn_res, F, BANKED
22:            	}
23:            	quotient = 0;
9DA8  6B7A     CLRF _PFNf_res, BANKED
9DAA  6B7B     CLRF _PFNf_rozruch, BANKED
24:            	if(divisor != 0) {
9DAC  5176     MOVF _PFNf_prn_in, W, BANKED
9DAE  1177     IORWF _PFNf_prn_pg, W, BANKED
9DB0  E01B     BZ 0x9DE8
25:            		counter = 1;
9DB2  0E01     MOVLW 0x1
9DB4  6F78     MOVWF _PFNf_prn_pp, BANKED
26:            		while((divisor & 0x8000U) == 0) {
9DB6  D004     BRA 0x9DC0
9DC0  AF77     BTFSS _PFNf_prn_pg, 7, BANKED
9DC2  D7FA     BRA 0x9DB8
27:            			divisor <<= 1;
9DB8  90D8     BCF STATUS, 0, ACCESS
9DBA  3776     RLCF _PFNf_prn_in, F, BANKED
9DBC  3777     RLCF _PFNf_prn_pg, F, BANKED
28:            			counter++;
9DBE  2B78     INCF _PFNf_prn_pp, F, BANKED
29:            		}
30:            		do {
31:            			quotient <<= 1;
9DC4  90D8     BCF STATUS, 0, ACCESS
9DC6  377A     RLCF _PFNf_res, F, BANKED
9DC8  377B     RLCF _PFNf_rozruch, F, BANKED
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
9DCA  5176     MOVF _PFNf_prn_in, W, BANKED
9DCC  5D74     SUBWF _PFNf_prODP, W, BANKED
9DCE  5177     MOVF _PFNf_prn_pg, W, BANKED
9DD0  5975     SUBWFB _PFNf_prn_cs, W, BANKED
9DD2  E305     BNC 0x9DDE
33:            				dividend -= divisor;
9DD4  5176     MOVF _PFNf_prn_in, W, BANKED
9DD6  5F74     SUBWF _PFNf_prODP, F, BANKED
9DD8  5177     MOVF _PFNf_prn_pg, W, BANKED
9DDA  5B75     SUBWFB _PFNf_prn_cs, F, BANKED
34:            				quotient |= 1;
9DDC  817A     BSF _PFNf_res, 0, BANKED
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
9DDE  90D8     BCF STATUS, 0, ACCESS
9DE0  3377     RRCF _PFNf_prn_pg, F, BANKED
9DE2  3376     RRCF _PFNf_prn_in, F, BANKED
37:            		} while(--counter != 0);
9DE4  2F78     DECFSZ _PFNf_prn_pp, F, BANKED
9DE6  D7EE     BRA 0x9DC4
38:            	}
39:            	if(sign)
9DE8  5179     MOVF _PFNf_prn_res, W, BANKED
9DEA  E004     BZ 0x9DF4
40:            		quotient = -quotient;
9DEC  6D7A     NEGF _PFNf_res, BANKED
9DEE  1F7B     COMF _PFNf_rozruch, F, BANKED
9DF0  B0D8     BTFSC STATUS, 0, ACCESS
9DF2  2B7B     INCF _PFNf_rozruch, F, BANKED
41:            	return quotient;
9DF4  C07A     MOVFF _PFNf_res, _PFNf_prODP
9DF6  F074     NOP
9DF8  C07B     MOVFF _PFNf_rozruch, _PFNf_prn_cs
9DFA  F075     NOP
42:            }
9DFC  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/altoft.c  --------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.	
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert signed int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __altoft(signed long int c)
17:            {
18:            	float	f1;
19:            	unsigned char	exp, sign;
20:            	
21:            	if(c == 0)
22:            		return 0.0;
23:            	sign = 0;
24:            	if(c < 0) {
25:            		c = -c;
26:            		sign = 1;
27:            	}
28:            	exp = 127+15;
29:            	// normalize 32 bits to 24 first
30:            	while(c & ~0xFFFFFFUL) {
31:            		*(unsigned long int *)&c >>= 1;
32:            		exp++;
33:            	}
34:            	f1_as_mant1 = c;
35:            	__ftpack(&f1_as_mant1, exp);
36:            	if(sign)
37:            		f1 = -f1;
38:            	return f1;
39:            }
40:            #else
41:            float
42:            __altoft(signed long int c)
43:            {
44:            	unsigned char exp, sign;
45:            	sign = 0;
A4FC  6BA6     CLRF sign, BANKED
46:            	exp = 127+15;
A4FE  0E8E     MOVLW 0x8E
A500  6FA5     MOVWF f3, BANKED
47:            	if (c < 0) {
A502  AFA0     BTFSS _UADtf_RErrBUF, 7, BANKED
A504  D011     BRA 0xA528
48:            		c = -c;
A506  1FA0     COMF _UADtf_RErrBUF, F, BANKED
A508  1F9F     COMF _UADtf_REnd, F, BANKED
A50A  1F9E     COMF _UADtf_REXT, F, BANKED
A50C  6D9D     NEGF _UADtf_RData, BANKED
A50E  0E00     MOVLW 0x0
A510  239E     ADDWFC _UADtf_REXT, F, BANKED
A512  239F     ADDWFC _UADtf_REnd, F, BANKED
A514  23A0     ADDWFC _UADtf_RErrBUF, F, BANKED
49:            		sign = 1;
A516  0E01     MOVLW 0x1
A518  6FA6     MOVWF sign, BANKED
A51A  D006     BRA 0xA528
50:            	}
51:            	// normalize 32 bits to 24 first
52:            	while(c & ~0xFFFFFFUL) {
A528  6BA1     CLRF _UADtf_RErrREC, BANKED
A52A  6BA2     CLRF _UADtf_TData, BANKED
A52C  6BA3     CLRF _UADtf_TEXT, BANKED
A52E  51A0     MOVF _UADtf_RErrBUF, W, BANKED
A530  6FA4     MOVWF _UADtf_TEnd, BANKED
A532  51A1     MOVF _UADtf_RErrREC, W, BANKED
A534  11A2     IORWF _UADtf_TData, W, BANKED
A536  11A3     IORWF _UADtf_TEXT, W, BANKED
A538  11A4     IORWF _UADtf_TEnd, W, BANKED
A53A  E1F0     BNZ 0xA51C
53:            		*(unsigned long int *)&c >>= 1;
A51C  90D8     BCF STATUS, 0, ACCESS
A51E  33A0     RRCF _UADtf_RErrBUF, F, BANKED
A520  339F     RRCF _UADtf_REnd, F, BANKED
A522  339E     RRCF _UADtf_REXT, F, BANKED
A524  339D     RRCF _UADtf_RData, F, BANKED
54:            		exp++;
A526  2BA5     INCF f3, F, BANKED
55:            	}
56:            	return __ftpack((unsigned short long)c, exp, sign); 
A53C  C09D     MOVFF _UADtf_RData, _PFNf_prODP
A53E  F074     NOP
A540  C09E     MOVFF _UADtf_REXT, _PFNf_prn_cs
A542  F075     NOP
A544  C09F     MOVFF _UADtf_REnd, _PFNf_prn_in
A546  F076     NOP
A548  C0A5     MOVFF f3, _PFNf_prn_pg
A54A  F077     NOP
A54C  C0A6     MOVFF sign, _PFNf_prn_pp
A54E  F078     NOP
A550  EC88     CALL 0x9710, 0
A552  F04B     NOP
A554  C074     MOVFF _PFNf_prODP, _UADtf_RData
A556  F09D     NOP
A558  C075     MOVFF _PFNf_prn_cs, _UADtf_REXT
A55A  F09E     NOP
A55C  C076     MOVFF _PFNf_prn_in, _UADtf_REnd
A55E  F09F     NOP
57:            }
A560  0012     RETURN 0
58:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/aldiv.c  ---------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __aldiv(signed long int divisor, signed long int dividend)
7:             #else
8:             __aldiv(signed long int dividend, signed long int divisor)
9:             #endif
10:            {
11:            	signed long int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
861E  6B7D     CLRF _PFNf_set_aleg, BANKED
15:            	if(divisor < 0) {
8620  AF7B     BTFSS _PFNf_rozruch, 7, BANKED
8622  D00A     BRA 0x8638
16:            		divisor = -divisor;
8624  1F7B     COMF _PFNf_rozruch, F, BANKED
8626  1F7A     COMF _PFNf_res, F, BANKED
8628  1F79     COMF _PFNf_prn_res, F, BANKED
862A  6D78     NEGF _PFNf_prn_pp, BANKED
862C  0E00     MOVLW 0x0
862E  2379     ADDWFC _PFNf_prn_res, F, BANKED
8630  237A     ADDWFC _PFNf_res, F, BANKED
8632  237B     ADDWFC _PFNf_rozruch, F, BANKED
17:            		sign = 1;
8634  0E01     MOVLW 0x1
8636  6F7D     MOVWF _PFNf_set_aleg, BANKED
18:            	}
19:            	if(dividend < 0) {
8638  AF77     BTFSS _PFNf_prn_pg, 7, BANKED
863A  D00A     BRA 0x8650
20:            		dividend = -dividend;
863C  1F77     COMF _PFNf_prn_pg, F, BANKED
863E  1F76     COMF _PFNf_prn_in, F, BANKED
8640  1F75     COMF _PFNf_prn_cs, F, BANKED
8642  6D74     NEGF _PFNf_prODP, BANKED
8644  0E00     MOVLW 0x0
8646  2375     ADDWFC _PFNf_prn_cs, F, BANKED
8648  2376     ADDWFC _PFNf_prn_in, F, BANKED
864A  2377     ADDWFC _PFNf_prn_pg, F, BANKED
21:            		sign ^= 1;
864C  0E01     MOVLW 0x1
864E  1B7D     XORWF _PFNf_set_aleg, F, BANKED
22:            	}
23:            	quotient = 0;
8650  6B7E     CLRF _PFNf_set_eco, BANKED
8652  6B7F     CLRF _PFNf_set_fnserw, BANKED
8654  6B80     CLRF _PFNf_set_nco, BANKED
8656  6B81     CLRF _PFNf_set_ncw, BANKED
24:            	if(divisor != 0) {
8658  5178     MOVF _PFNf_prn_pp, W, BANKED
865A  1179     IORWF _PFNf_prn_res, W, BANKED
865C  117A     IORWF _PFNf_res, W, BANKED
865E  117B     IORWF _PFNf_rozruch, W, BANKED
8660  E029     BZ 0x86B4
25:            		counter = 1;
8662  0E01     MOVLW 0x1
8664  6F7C     MOVWF _PFNf_setKey, BANKED
26:            		while((divisor & 0x80000000UL) == 0) {
8666  D006     BRA 0x8674
8674  AF7B     BTFSS _PFNf_rozruch, 7, BANKED
8676  D7F8     BRA 0x8668
27:            			divisor <<= 1;
8668  90D8     BCF STATUS, 0, ACCESS
866A  3778     RLCF _PFNf_prn_pp, F, BANKED
866C  3779     RLCF _PFNf_prn_res, F, BANKED
866E  377A     RLCF _PFNf_res, F, BANKED
8670  377B     RLCF _PFNf_rozruch, F, BANKED
28:            			counter++;
8672  2B7C     INCF _PFNf_setKey, F, BANKED
29:            		}
30:            		do {
31:            			quotient <<= 1;
8678  90D8     BCF STATUS, 0, ACCESS
867A  377E     RLCF _PFNf_set_eco, F, BANKED
867C  377F     RLCF _PFNf_set_fnserw, F, BANKED
867E  3780     RLCF _PFNf_set_nco, F, BANKED
8680  3781     RLCF _PFNf_set_ncw, F, BANKED
32:            			if((unsigned long)divisor <= (unsigned long)dividend) {
8682  5178     MOVF _PFNf_prn_pp, W, BANKED
8684  5D74     SUBWF _PFNf_prODP, W, BANKED
8686  5179     MOVF _PFNf_prn_res, W, BANKED
8688  5975     SUBWFB _PFNf_prn_cs, W, BANKED
868A  517A     MOVF _PFNf_res, W, BANKED
868C  5976     SUBWFB _PFNf_prn_in, W, BANKED
868E  517B     MOVF _PFNf_rozruch, W, BANKED
8690  5977     SUBWFB _PFNf_prn_pg, W, BANKED
8692  E309     BNC 0x86A6
33:            				dividend -= divisor;
8694  5178     MOVF _PFNf_prn_pp, W, BANKED
8696  5F74     SUBWF _PFNf_prODP, F, BANKED
8698  5179     MOVF _PFNf_prn_res, W, BANKED
869A  5B75     SUBWFB _PFNf_prn_cs, F, BANKED
869C  517A     MOVF _PFNf_res, W, BANKED
869E  5B76     SUBWFB _PFNf_prn_in, F, BANKED
86A0  517B     MOVF _PFNf_rozruch, W, BANKED
86A2  5B77     SUBWFB _PFNf_prn_pg, F, BANKED
34:            				quotient |= 1;
86A4  817E     BSF _PFNf_set_eco, 0, BANKED
35:            			}
36:            			*(unsigned long int *)&divisor >>= 1;
86A6  90D8     BCF STATUS, 0, ACCESS
86A8  337B     RRCF _PFNf_rozruch, F, BANKED
86AA  337A     RRCF _PFNf_res, F, BANKED
86AC  3379     RRCF _PFNf_prn_res, F, BANKED
86AE  3378     RRCF _PFNf_prn_pp, F, BANKED
37:            		} while(--counter != 0);
86B0  2F7C     DECFSZ _PFNf_setKey, F, BANKED
86B2  D7E2     BRA 0x8678
38:            	}
39:            	if(sign)
86B4  517D     MOVF _PFNf_set_aleg, W, BANKED
86B6  E008     BZ 0x86C8
40:            		quotient = -quotient;
86B8  1F81     COMF _PFNf_set_ncw, F, BANKED
86BA  1F80     COMF _PFNf_set_nco, F, BANKED
86BC  1F7F     COMF _PFNf_set_fnserw, F, BANKED
86BE  6D7E     NEGF _PFNf_set_eco, BANKED
86C0  0E00     MOVLW 0x0
86C2  237F     ADDWFC _PFNf_set_fnserw, F, BANKED
86C4  2380     ADDWFC _PFNf_set_nco, F, BANKED
86C6  2381     ADDWFC _PFNf_set_ncw, F, BANKED
41:            	return quotient;
86C8  C07E     MOVFF _PFNf_set_eco, _PFNf_prODP
86CA  F074     NOP
86CC  C07F     MOVFF _PFNf_set_fnserw, _PFNf_prn_cs
86CE  F075     NOP
86D0  C080     MOVFF _PFNf_set_nco, _PFNf_prn_in
86D2  F076     NOP
86D4  C081     MOVFF _PFNf_set_ncw, _PFNf_prn_pg
86D6  F077     NOP
42:            }
86D8  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.38/sources/common/Umul16.c  --------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
BA7C  5174     MOVF _PFNf_prODP, W, BANKED
BA7E  0376     MULWF _PFNf_prn_in, BANKED
BA80  CFF3     MOVFF PROD, _PFNf_prn_pp
BA82  F078     NOP
BA84  CFF4     MOVFF PRODH, _PFNf_prn_res
BA86  F079     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
BA88  5174     MOVF _PFNf_prODP, W, BANKED
BA8A  0377     MULWF _PFNf_prn_pg, BANKED
BA8C  50F3     MOVF PROD, W, ACCESS
BA8E  2779     ADDWF _PFNf_prn_res, F, BANKED
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
BA90  5175     MOVF _PFNf_prn_cs, W, BANKED
BA92  0376     MULWF _PFNf_prn_in, BANKED
BA94  50F3     MOVF PROD, W, ACCESS
BA96  2779     ADDWF _PFNf_prn_res, F, BANKED
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
BA98  C078     MOVFF _PFNf_prn_pp, _PFNf_prODP
BA9A  F074     NOP
BA9C  C079     MOVFF _PFNf_prn_res, _PFNf_prn_cs
BA9E  F075     NOP
53:            }
BAA0  0012     RETURN 0
