     1: /*rgl.c*/
     2: /*---------------------------------------------------------------------------------*/
     3: #include <pic18.h>
     4: #include "global.h"                             //parametry globalne
     5: #include "rgl.h"                                //parametry lokalne
     6: #include "main.tp.h"
     7: #include "pomiar.h"
     8: #include "pwm.h"
     9: #include "konfig.h"
    10: 
    11: 
    12: extern DataCO DtCO;
    13: extern DataCW DtCW;
    14: extern DtPWM PWM;
    15: extern DtKONF DtKNF;
    16: extern tpMAIN M;
    17: DtRgl rgl; 
    18: 
    19: extern unsigned char x;
    20: 
    21: //************************************************************
    22: //Procedura modulacji
    23: void Moduluj(void)
    24: {
    25:         unsigned int wpw;
    26:         unsigned char wpp;
    27: 
    28:         switch(DtKNF.tpkt)                      //rodzaj kotla
    29:         {
    30:                 case _BITERM:                   //kociol bitermiczny (miniterm)
    31:                 {
    32:                         if(M._pob_CO)           //obieg CO
    33:                         {
    34:                                 PWM.MAXPWM=PWM.MMAXCO; //maksymalna nastawa modulatora
    35:                                 StartCO();                      //parametry startowe dla CO
    36:                                 ReadDataCO();           //wprowadzenie danych wejsciowych dla CO
    37:                                 ModToCO();                      //zmien obieg na CO
    38:                                 ModZgCO();                      //pierwsze przyblizenie
    39:                                 ModDkCO();                      //drugie przyblizenie
    40:                                 if(RTdS(_RTMOD)>_TOKM)
    41:                                 {
    42:                                         StartRTdS(_RTMOD);
    43:                                         IncConstCOCW(); //oblicza czas przez ktory temp CO = const
    44:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
    45:                                         ModPruCO();             //trzecie przyblizenie
    46:                                 }
    47:                                 ModPrzCO();                     //reakcja superwizyjna
    48:                                 PropOPT();
    49:                         }
    50:                         else
    51:                         if(M._pob_CW)                   //obieg CW
    52:                         {
    53:                                 StartMCW();                     //parametry startowe dla CW
    54:                                 ReadDataCW();           //wprowadzenie danych wejsciowych dla CW
    55:                                 ModToCW();                      //zmien obieg na CW
    56:                                 ModZgCW();                      //pierwsze przyblizenie
    57:                                 ModDkCW();                      //drugie przyblizenie
    58:                                 if(RTdS(_RTMOD)>_TOKM)
    59:                                 {
    60:                                         StartRTdS(_RTMOD);
    61:                                         IncConstCOCW(); //oblicza czas przez ktory temp CW = const      
    62:                                         IncMaxCW();             //inkrementacja maksymalnej wartosci mocy na palniku
    63:                                         ModPruCW();             //trzecie przyblizenie
    64:                                 }
    65:                                 ModPrzCW();                     //reakcja superwizyjna
    66:                                 PropCO();                       //zabezpieczenie od przegrzania w obwodzie CO                           StartMCW2();            //parametry startowe dla CW
    67:                         }
    68:                         break;
    69:                 }
    70:                 case _MONOTERM:                         //kociol z wymiennikiem plytowym
    71:                 case _MONOHB:                           //kociol z hydroblokiem
    72:                 {
    73:                         if(M._pob_CO)                   //obieg CO
    74:                         {
    75:                                 PWM.MAXPWM=PWM.MMAXCO;//maksymalna nastawa modulatora
    76:                                 StartCO2();                     //parametry startowe dla CO
    77:                                 ReadDataCO2();          //wprowadzenie danych wejsciowych dla CO
    78:                                 ModToCO2();                     //zmien obieg na CO
    79:                                 ModZgCO();                      //pierwsze przyblizenie
    80:                                 ModDkCO();                      //drugie przyblizenie
    81:                                 if(RTdS(_RTMOD)>_TOKM)
    82:                                 {
    83:                                         StartRTdS(_RTMOD);
    84:                                         IncConstCO2();  //oblicza czas przez ktory temp CO = const
    85:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
    86:                                         ModPruCO();             //trzecie przyblizenie
    87:                                 }
    88:                         
    89:                                 ModPrzCO();                     //reakcja superwizyjna
    90:                                 PropOPT();
    91:                         }
    92:                         else
    93:                         if(M._pob_CW)                   //obieg CW
    94:                         {
    95:                                 StartMCW2();            //parametry startowe dla CW
    96:                                 ReadDataCW2();          //wprowadzenie danych wejsciowych dla CW
    97:                                 ModToCW2();                     //zmien obieg na CW
    98:                                 ModZgCW2();                     //pierwsze przyblizenie
    99:                                 ModDkCW2();                     //drugie przyblizenie
   100:                                 if(RTdS(_RTMOD)>_TOKM)
   101:                                 {
   102:                                         StartRTdS(_RTMOD);
   103:                                         IncConstCW2();  //oblicza czas przez ktory temp CW = const      
   104:                                         IncMaxCW2();    //inkrementacja maksymalnej wartosci mocy na palniku
   105:                                         ModPruCW2();    //trzecie przyblizenie
   106:                                 }
   107:                                 ModPrzCW2();            //reakcja superwizyjna
   108:                                 PropCO2();                      //zabezpieczenie od przegrzania w obwodzie CO
   109:                         }
   110:                         break;
   111:                 }
   112:                 case _UNICO:
   113:                 case _ZASOBNIK:                         //kociol zasobnikowy
   114:                 {
   115:                         if(M._pob_CO)                   //obieg CO
   116:                         {
   117:                                 PWM.MAXPWM=PWM.MMAXCO;//maksymalna nastawa modulatora
   118:                                 StartMCO3();            //parametry startowe dla CO
   119:                                 ReadDataCO2();          //wprowadzenie danych wejsciowych dla CO
   120:                                 ModToCO3();                     //zmien obieg na CO
   121:                                 ModZgCO();                      //pierwsze przyblizenie
   122:                                 ModDkCO();                      //drugie przyblizenie
   123:                                 if(RTdS(_RTMOD)>_TOKM)
   124:                                 {
   125:                                         StartRTdS(_RTMOD);
   126:                                         IncConstCO2();  //oblicza czas przez ktory temp CO = const
   127:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
   128:                                         ModPruCO();             //trzecie przyblizenie
   129:                                 }
   130:                         
   131:                                 ModPrzCO();                     //reakcja superwizyjna
   132:                                 PropOPT();
   133:                         }
   134:                         else
   135:                         if(M._pob_CW||M._pob_AL)        //obieg CW
   136:                         {
   137:                                 PWM.MAXPWM=PWM.MMAXCW;//maksymalna nastawa modulatora
   138:                                 StartMCO3();            //parametry startowe dla CO
   139:                                 ReadDataCO2();          //wprowadzenie danych wejsciowych dla CO
   140:                                 ModToCW3();                     //zmien obieg na CO
   141:                                 ModZgCO();                      //pierwsze przyblizenie
   142:                                 ModDkCO();                      //drugie przyblizenie
   143:                                 if(RTdS(_RTMOD)>_TOKM)
   144:                                 {
   145:                                         StartRTdS(_RTMOD);
   146:                                         IncConstCO2();  //oblicza czas przez ktory temp CO = const
   147:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
   148:                                         ModPruCO();             //trzecie przyblizenie
   149:                                 }
   150:                         
   151:                                 ModPrzCO();                     //reakcja superwizyjna
   152:                                 PropOPT();
   153:                         }
   154:                         break;
   155:                 }
   156:                 case _BITERM2:                  //kociol bitermiczny (maxiterm)
   157:                 {
   158:                         if(M._pob_CO)           //obieg CO
   159:                         {
   160:                                 PWM.MAXPWM=PWM.MMAXCO; //maksymalna nastawa modulatora
   161:                                 StartCO4();                     //parametry startowe dla CO
   162:                                 ReadDataCO4();          //wprowadzenie danych wejsciowych dla CO
   163:                                 ModToCO4();                     //zmien obieg na CO
   164:                                 ModZgCO();                      //pierwsze przyblizenie
   165:                                 ModDkCO();                      //drugie przyblizenie
   166:                                 if(RTdS(_RTMOD)>_TOKM)
   167:                                 {
   168:                                         StartRTdS(_RTMOD);
   169:                                         IncConstCOCW4();//oblicza czas przez ktory temp CO = const
   170:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
   171:                                         ModPruCO();             //trzecie przyblizenie
   172:                                 }
   173:                                 ModPrzCO();                     //reakcja superwizyjna
   174:                                 PropOPT();
   175:                         }
   176:                         else
   177:                         if(M._pob_CW)                   //obieg CW
   178:                         {
   179:                                 StartMCW4();                    //parametry startowe dla CW
   180:                                 ReadDataCW4();          //wprowadzenie danych wejsciowych dla CW
   181:                                 ModToCW4();                     //zmien obieg na CW
   182:                                 ModZgCW4();                     //pierwsze przyblizenie
   183:                                 ModDkCW4();                     //drugie przyblizenie
   184:                                 if(RTdS(_RTMOD)>_TOKM)
   185:                                 {
   186:                                         StartRTdS(_RTMOD);
   187:                                         IncConstCOCW4();        //oblicza czas przez ktory temp CW = const      
   188:                                         IncMaxCW4();            //inkrementacja maksymalnej wartosci mocy na palniku
   189:                                         ModPruCW4();            //trzecie przyblizenie
   190:                                 }
   191:                                 ModPrzCW4();                    //reakcja superwizyjna
   192:                                 PropCO4();                      //zabezpieczenie od przegrzania w obwodzie CO                           StartMCW2();            //parametry startowe dla CW
   193:                         }
   194:                         break;
   195:                 }
   196:                 default:                //domyslny monotermiczny
   197:                 {
   198:                         if(M._pob_CO)                   //obieg CO
   199:                         {
   200:                                 PWM.MAXPWM=PWM.MMAXCO;//maksymalna nastawa modulatora
   201:                                 StartCO2();                     //parametry startowe dla CO
   202:                                 ReadDataCO2();          //wprowadzenie danych wejsciowych dla CO
   203:                                 ModToCO2();                     //zmien obieg na CO
   204:                                 ModZgCO();                      //pierwsze przyblizenie
   205:                                 ModDkCO();                      //drugie przyblizenie
   206:                                 if(RTdS(_RTMOD)>_TOKM)
   207:                                 {
   208:                                         StartRTdS(_RTMOD);
   209:                                         IncConstCO2();  //oblicza czas przez ktory temp CO = const
   210:                                         IncMaxCO();             //inkrementacja maksymalnej wartosci mocy na palniku
   211:                                         ModPruCO();             //trzecie przyblizenie
   212:                                 }
   213:                         
   214:                                 ModPrzCO();                     //reakcja superwizyjna
   215:                                 PropOPT();
   216:                         }
   217:                         else
   218:                         if(M._pob_CW)                   //obieg CW
   219:                         {
   220:                                 StartMCW2();            //parametry startowe dla CW
   221:                                 ReadDataCW2();          //wprowadzenie danych wejsciowych dla CW
   222:                                 ModToCW2();                     //zmien obieg na CW
   223:                                 ModZgCW2();                     //pierwsze przyblizenie
   224:                                 ModDkCW2();                     //drugie przyblizenie
   225:                                 if(RTdS(_RTMOD)>_TOKM)
   226:                                 {
   227:                                         StartRTdS(_RTMOD);
   228:                                         IncConstCW2();  //oblicza czas przez ktory temp CW = const      
   229:                                         IncMaxCW2();    //inkrementacja maksymalnej wartosci mocy na palniku
   230:                                         ModPruCW2();    //trzecie przyblizenie
   231:                                 }
   232:                                 ModPrzCW2();            //reakcja superwizyjna
   233:                                 PropCO2();                      //zabezpieczenie od przegrzania w obwodzie CO
   234:                         }
   235:                         break;
   236:                 }               
   237:         }
   238: }
   239: //************************************************************
   240: //------------------------------------------------------------
   241: //------------------------------------------------------------
   242: //------dowolny wymiennik - obieg CO
   243: //------------------------------------------------------------
   244: //------------------------------------------------------------                                                          
   245: //-------------------------------------------------------------
   246: //parametry startowe dla CO - kociol 1 funkcyjny.
   247: void StartMCO1F(void)
   248: {
   249:         unsigned char k;
   250:         
   251:         if(rgl.btco&&!rgl.btcw) return; //praca w obiegu CO?    
   252:         if(rgl.btco&&rgl.btcw)                  //zmiana obiegu CO na CW?
   253:         {
   254:                 rgl.btcw=0;
   255:                 if(!Tnizsza(0))
   256:                 {
   257:                         k=10;
   258:                         if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
   259:                         else rgl.srp-=k;
   260:                 }
   261:         }
   262:         else //rozpoczecie pracy w obiegu CO lub CW
   263:         {
   264:                 StartRTdS(_RTMOD);
   265:                 DtCO.dDCO=0;
   266:                 DtCO.indCO=0;
   267:                 rgl.fz=0;
   268:                 rgl.med_up=0;
   269:                 rgl.fast_up=0;
   270:                 //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
   271:                 if(PWM.MMAXCO>PWM.FIRSTPB)
   272:                 {
   273:                         rgl.xmod=PWM.FIRSTPB;
   274:                 }
   275:                 else
   276:                 {
   277:                         rgl.xmod=PWM.MMAXCO;
   278:                 }
   279: //              if(!PWM.tpGZ) rgl.xmod=I80_MOD;
   280: //              else rgl.xmod=I80_PMOD;
   281:                 rgl.srp=0;
   282:                 rgl.ytmp=0;
   283:                 rgl.nmod=0;             //wyjdz z trybu nmod
   284:                 rgl.btcw=0;
   285:                 rgl.btco=1;
   286:                 rgl.del1s=0;
   287:                 rgl.deln1=0;
   288:                 rgl.inv_mod=0;
   289:         }
   290: }
   291: //-------------------------------------------------------------
   292: //pierwsze przyblizenie
   293: void ModZgCO(void)
   294: {
   295:         signed long m;
   296:         unsigned char p;
   297: 
   298:         //faza2
   299:         if(rgl.fz)                                              //aktualnie faza 2?
   300:         {
   301:                 if(Tnizsza(10))                         //przygotowanie do przejscia do fazy 1
   302:                 {
   303:                         rgl.xmod=PWM.BufPWM;
   304:                         rgl.srp=0;
   305:                         rgl.ytmp=0;     
   306:                 }
   307:                 else return;
   308:         }
   309:         //faza1
   310:         if((!Tnizsza(5)&&Tmaleje(0))||(!Tnizsza(2)&&Tstoi()))           //warunek przejscia do fazy 2
   311:         {
   312:                 rgl.fz=1;
   313:                 rgl.srp=PWM.BufPWM;
   314:                 rgl.xmod=PWM.BufPWM;
   315:                 if(rgl.xmod>PWM.MGMOD)
   316:                 {
   317:                         rgl.srp=PWM.MGMOD;
   318:                         rgl.xmod=PWM.MGMOD;
   319:                 }
   320:                 return;
   321:         }
   322:         if(rgl.xmod>=PWM.MDMOD) m=(rgl.xmod-PWM.MDMOD)*10;
   323:         else m=0;
   324:         m=m/(DtCO.MAD_CO-DtCO.DAD_CO);  //DAD_CO-MAD_CO
   325:         m=m*(DtCO.AC_CO-DtCO.DAD_CO);   //DAD_CO-AC_CO  
   326:         if(m<0) m=0;
   327:         m=m/10+PWM.MDMOD;
   328:         if(m>0xff)                                              //przepelnienie 
   329:         {
   330:                 rgl.fz=0;                                       //przejscie do fazy1 przy aktywnej fazie2
   331:                 rgl.tmp_pwm=rgl.xmod;
   332:                 return;
   333:         }
   334:         if(rgl.fz&&(rgl.xmod>m))
   335:                 rgl.srp=(rgl.xmod-m);           //przygotowanie lagodnego przejscia do fazy 1
   336:         m+=rgl.srp;
   337:         if(m>rgl.xmod) p=rgl.xmod;
   338:         else p=m;
   339:         rgl.fz=0;                                               //przejscie do fazy1 przy aktywnej fazie2
   340:         rgl.tmp_pwm=p;
   341: }                                                               
   342: //-------------------------------------------------------------
   343: //drugie przyblizenie (tylko dla fazy 1)
   344: void ModDkCO(void)
   345: {
   346:         signed long m;  
   347:         signed char ada;
   348:         unsigned char k,p;
   349:         
   350:         if(!rgl.fz)     return;                                 //wyjscie jesli aktualnie faza 1
   351:         ada=DtCO.AC_CO-DtCO.DAD_CO;
   352:         k=5;
   353:         if(Twyzsza(0)) k=6;                     //6             //(Tco>Tnst)?
   354:         m=rgl.srp+k*ada;
   355:         if(m>rgl.xmod) p=rgl.xmod;
   356:         else
   357:         if(m<PWM.MDMOD) p=PWM.MDMOD;
   358:         else p=m;
   359:         rgl.tmp_pwm=p;
   360: }                                                               
   361: //-------------------------------------------------------------                                         
   362: //trzecie przyblizenie
   363: //nowa wartosc punktu rownowagi srp.
   364: //wykonywane co krok czasowy
   365: void ModPruCO(void)
   366: {
   367:         static unsigned char l;
   368:         unsigned char tmp,k;
   369:         signed char ada;
   370:         if(!rgl.fz)     //aktualnie faza 1?
   371:         {
   372:                 if(Tmaleje(0)||rgl.ytmp>2)                                              //(Tco maleje)lub(Tco=CONST(>=3sek))?
   373:                 {
   374:                         rgl.ytmp=0;
   375:                         if(PWM.BufPWM>rgl.xmod) return;
   376:                         tmp=rgl.xmod-PWM.BufPWM;
   377:                         k=6;
   378:                         if(k>tmp) k=tmp;
   379:                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   380:                         else rgl.srp+=k;
   381:                 }
   382:                 return;
   383:         }
   384:         else //aktualnie faza 2
   385:         {
   386:                 if(!Trowna())                                                                   //(Tco<>Tnst) ?
   387:                 {               
   388:                         if(DtCO.DAD_CO>DtCO.AC_CO)                                      //Tco>Tnst ?
   389:                         {
   390:                                 if(Tmaleje(0)) return;                                  //(Tco maleje)?
   391:                                 if(l>=2)
   392:                                 {
   393:                                         k=1;
   394:                                         l=0;
   395:                                 }
   396:                                 else
   397:                                 {
   398:                                         k=0;
   399:                                         l++;
   400:                                 }
   401:                                 if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
   402:                                 else rgl.srp-=k;
   403:                                 if(rgl.srp>PWM.MAXPWM) rgl.srp=PWM.MAXPWM;
   404:                                 if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
   405:                                 return;                                 
   406:                         }
   407:                         else                                                                            //Tco<Tnst
   408:                         {
   409:                                 if(Trosnie(0)) return;                                  //(Tco rosnie)?
   410:                                 if(l>=1)
   411:                                 {
   412:                                         k=1;
   413:                                         l=0;
   414:                                 }
   415:                                 else
   416:                                 {
   417:                                         k=0;
   418:                                         l++;
   419:                                 }       
   420:                                 if(PWM.MAXPWM>PWM.MGMOD)
   421:                                 {
   422:                                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   423:                                         else rgl.srp+=k;
   424:                                 }
   425:                                 else
   426:                                 {
   427:                                         if(rgl.srp+k>PWM.MAXPWM) rgl.srp=PWM.MAXPWM;
   428:                                         else rgl.srp+=k;
   429:                                 }
   430:                                 if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
   431:                         }
   432:                 }else l=0;
   433:         }
   434: }
   435: //-------------------------------------------------------------                                                         
   436: //inkrementacja maksymalnej wartosci mocy na palniku
   437: //wykonywane co krok czasowy
   438: void IncMaxCO(void)
   439: {
   440:         unsigned char k;
   441:         
   442:         if(Trosnie(1)) return;                                                          //(Tco rosnie szybciej niz 1K/sek)?     
   443:         //kontrolowany narost mocy
   444:         k=6;
   445:         if(!rgl.fz)                                                                                     //faza 1 ?
   446:         {
   447:                 if(rgl.xmod+k>_MG2_MOD) rgl.xmod=_MG2_MOD;
   448:                 else rgl.xmod+=k;
   449:                 if(rgl.xmod>PWM.MAXPWM) rgl.xmod=PWM.MAXPWM;            
   450:         }
   451:         else                                                                                            //faza 2
   452:         {
   453:                 if(PWM.MAXPWM>PWM.MGMOD)
   454:                 {
   455:                         if(rgl.xmod+k>PWM.MGMOD) rgl.xmod=PWM.MGMOD;
   456:                         else rgl.xmod+=k;
   457:                 }
   458:                 else
   459:                 {
   460:                         if(rgl.xmod+k>PWM.MAXPWM) rgl.xmod=PWM.MAXPWM;
   461:                         else rgl.xmod+=k;
   462:                 }
   463:         }
   464: }
   465: //-------------------------------------------------------------                                                         
   466: //reakcja superwizyjna
   467: void ModPrzCO(void)
   468: {
   469:         unsigned char k;
   470:         
   471:         if(!rgl.nmod)                                   //nie jest w trybie nmod?
   472:         {
   473:                 if(Twyzsza(3))                          //Tcw-Tnst>3 ?
   474:                 {
   475:                         rgl.nmod=1;                             //wejdz w tryb nmod
   476:                         k=20;
   477:                         if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
   478:                         else rgl.srp-=k;
   479:                 }
   480:         }
   481:         else                                                    //jest w trybie nmod?
   482:         {
   483:                 if(!Twyzsza(2))                         
   484:                                         rgl.nmod=0;             //wyjdz z trybu nmod
   485:         }
   486: }
   487: //-------------------------------------------------------------                                                 
   488: //Proporcjonalne OPEN-T 
   489: void PropOPT(void)
   490: {
   491:         if(rgl.nmod)                            //aktywny tryb nmod?
   492:         {
   493:                 WriteOPWM(PWM.MDMOD);
   494:                 //PWM.BufPWM=PWM.MDMOD; //wymus minimum plomienia
   495:         }
   496:         else
   497:         {
   498:                 WriteOPWM(rgl.tmp_pwm);
   499:                 //PWM.BufPWM=rgl.tmp_pwm;
   500:         }
   501: }
   502: //************************************************************
   503: //------------------------------------------------------------
   504: //------------------------------------------------------------
   505: //------wymiennik bitermiczny (miniterm) - obieg CW
   506: //------------------------------------------------------------
   507: //------------------------------------------------------------
   508: //------------------------------------------------------------
   509: //parametry startowe dla CO
   510: void StartCO(void)
   511: {
   512:         unsigned char k;
   513:         
   514:         if(rgl.btco||rgl.btcw) return; //praca w dowolnym obiegu CO?    
   515:         StartRTdS(_RTMOD);
   516:         DtCO.dDCO=0;
   517:         DtCO.indCO=0;
   518:         DtCW.dDCW=0;
   519:         DtCW.indCW=0;
   520:         rgl.fz=0;
   521:         rgl.med_up=0;
   522:         rgl.fast_up=0;
   523:         //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
   524:         if(PWM.MMAXCO>PWM.FIRSTPB)
   525:         {
   526:                 rgl.xmod=PWM.FIRSTPB;
   527:         }
   528:         else
   529:         {
   530:                 rgl.xmod=PWM.MMAXCO;
   531:         }
   532:         rgl.srp=0;
   533:         rgl.ytmp=0;
   534:         rgl.nmod=0;             //wyjdz z trybu nmod
   535:         rgl.del1s=0;
   536:         rgl.inv_mod=0;
   537: }
   538: //-------------------------------------------------------------
   539: //parametry startowe dla CW
   540: void StartMCW(void)
   541: {
   542:         if(rgl.btco||rgl.btcw) return; //rozpoczecie pracy modulatora?
   543:         StartRTdS(_RTMOD);
   544:         DtCO.dDCO=0;
   545:         DtCW.dDCW=0;
   546:         DtCO.indCO=0;
   547:         DtCW.indCW=0;
   548:         rgl.fz=0;
   549:         rgl.med_up=0;
   550:         rgl.fast_up=0;
   551:         FirstPCW();
   552:         rgl.srp=0;
   553:         rgl.ytmp=0;
   554:         rgl.nmod=0;
   555:         rgl.del1s=0;
   556:         rgl.inv_mod=0;
   557: }
   558: //-------------------------------------------------------------
   559: //pierwsze pobudzenie dla CW
   560: void FirstPCW(void)
   561: {
   562:         if(PWM.MMAXCW>PWM.MDMOD)
   563:         {
   564:                 rgl.xmod=PWM.MDMOD;
   565:         }
   566:         else
   567:         {
   568:                 rgl.xmod=PWM.MMAXCW;
   569:         }
   570: }
   571: //-------------------------------------------------------------
   572: //zeruj parametry modulatora po zmianie obiegu
   573: void ClrMod(void)
   574: {
   575:         rgl.fz=0;
   576:         rgl.med_up=0;
   577:         rgl.fast_up=0;
   578:         rgl.xmod=PWM.BufPWM;
   579:         rgl.srp=0;
   580:         rgl.ytmp=0;
   581:         rgl.nmod=0;
   582:         rgl.del1s=0;
   583:         rgl.inv_mod=0;
   584: }
   585: //-------------------------------------------------------------
   586: //zmien obieg na CW
   587: void ModToCW(void)
   588: {
   589:         rgl.btcw=1;
   590:         if(rgl.btco)
   591:         {
   592:                 rgl.btco=0;
   593:                 ClrMod();
   594:         }
   595: }
   596: //-------------------------------------------------------------
   597: //zmien obieg na CO
   598: void ModToCO(void)
   599: {
   600:         rgl.btco=1;
   601:         if(rgl.btcw)
   602:         {
   603:                 rgl.btcw=0;
   604:                 ClrMod();
   605:         }
   606: }
   607: //-------------------------------------------------------------
   608: //oblicza czas przez ktory temp=const
   609: void IncConstCOCW(void)
   610: {
   611:         if(Tstoi()) rgl.ytmp++;
   612:         else rgl.ytmp=0;
   613: }
   614: //-------------------------------------------------------------
   615: //wprowadzenie danych wejsciowych-CO
   616: void ReadDataCO(void)
   617: {
   618:         rgl.x_t=DtCO.DCO;
   619:         rgl.x_dt=DtCO.dDCO;
   620: }
   621: //-------------------------------------------------------------
   622: //wprowadzenie danych wejsciowych-CW
   623: void ReadDataCW(void)
   624: {
   625:         rgl.x_t=DtCW.DCW;
   626:         rgl.x_f=DtCO.DCO;
   627:         rgl.x_dt=DtCW.dDCW;
   628:         rgl.x_df=DtCO.dDCO;
   629: }
   630: //-------------------------------------------------------------
   631: //pierwsze przyblizenie
   632: void ModZgCW(void)
   633: {
   634:         signed long m;
   635:         unsigned char p;
   636:         if(rgl.fz)                                              //aktualnie faza 2?
   637:         {
   638:                 if(Tnizsza(2))                          //przygotowanie do przejscia do fazy 1
   639:                 {
   640:                         rgl.xmod=PWM.BufPWM;
   641:                         rgl.srp=0;
   642:                         rgl.ytmp=0;     
   643:                         rgl.nmod=0;
   644:                         rgl.del1s=0;
   645:                 }
   646:                 else return;
   647:         }
   648:         if(Twyzsza(0)&&Tstoi())                         //warunek przejscia do fazy 2
   649:         {
   650:                 rgl.fz=1;
   651:                 rgl.fast_up=0;
   652:                 rgl.med_up=0;
   653:                 rgl.srp=PWM.BufPWM;
   654:                 rgl.xmod=PWM.BufPWM;
   655:                 if(rgl.xmod>PWM.MGMOD)
   656:                 {
   657:                         rgl.srp=PWM.MGMOD;
   658:                         rgl.xmod=PWM.MGMOD;
   659:                 }
   660:                 return;
   661:         }
   662:         if(rgl.xmod>=PWM.MDMOD) m=(rgl.xmod-PWM.MDMOD)*10;
   663:         else m=0;
   664:         m=m/(DtCW.MAD_CW-DtCW.DAD_CW);  //DAD_CW-MAD_CW
   665:         m=m*(DtCW.AC_CW-DtCW.DAD_CW);   //DAD_CW-AC_CW  
   666:         if(m<0) m=0;
   667:         m=m/10+PWM.MDMOD;
   668:         if(m>0xff)                                              //przepelnienie 
   669:         {
   670:                 rgl.fz=0;                                       //przejscie do fazy1 przy aktywnej fazie2
   671:                 rgl.tmp_pwm=rgl.xmod;
   672:                 return;
   673:         }
   674:         if(rgl.fz&&(rgl.xmod>m))
   675:                 rgl.srp=(rgl.xmod-m);           //przygotowanie lagodnego przejscia do fazy 1
   676:         m+=rgl.srp;
   677:         if(m>rgl.xmod) p=rgl.xmod;
   678:         else p=m;
   679:         rgl.fz=0;                                               //przejscie do fazy1 przy aktywnej fazie2
   680:         rgl.tmp_pwm=p;
   681: }
   682: //-------------------------------------------------------------
   683: //drugie przyblizenie (tylko dla fazy 1)
   684: void ModDkCW(void)
   685: {
   686:         signed long m;  
   687:         signed char ada;
   688:         unsigned char k,p;
   689:         
   690:         if(!rgl.fz)     return;                                 //wyjscie jesli aktualnie faza 1
   691:         ada=DtCW.AC_CW-DtCW.DAD_CW;
   692:         if(Trowna()) return;                            //Tcw!=Tnst?
   693:         if(Tnizsza(0))                                          //Tcw<Tnst?
   694:         {
   695:                 if(!Trosnie(0))                                 //(Tcw=CONST) lub (Tcw maleje) ?
   696:                 {
   697:                         k=1;
   698:                         if(Tnizsza(1)) k=3;                     //Tnst-Tcw>=2?
   699:                 }
   700:         }
   701:         else                                                            //Tcw>Tnst?
   702:         {
   703:                 if(!Tmaleje(0))                                 //(Tcw=CONST) lub (Tcw rosnie) ?
   704:                 {
   705:                         k=1;
   706:                         if(Twyzsza(1)) k=2;                     //Tcw-Tnst>=2?
   707:                 }
   708:         }
   709:         m=rgl.srp+k*ada;
   710:         if(m>rgl.xmod) p=rgl.xmod;
   711:         else
   712:         if(m<PWM.MDMOD) p=PWM.MDMOD;
   713:         else p=m;
   714:         rgl.tmp_pwm=p;
   715: }
   716: //-------------------------------------------------------------
   717: //trzecie przyblizenie
   718: //nowa wartosc punktu rownowagi srp.
   719: //wykonywane co krok czasowy
   720: void ModPruCW(void)
   721: {
   722:         static unsigned char l,m,o,p,q,r,s;
   723:         unsigned char tmp;
   724:         signed char ada,k;
   725:         if(!rgl.fz)                                                                                     //aktualnie faza 1?
   726:         {
   727:                 l=0;
   728:                 m=0;
   729:                 o=0;
   730:                 p=0;
   731:                 if(q<255) q++;                                                                  //licznik sekund 
   732:                 if(s<255) s++;                                                                  //licznik sekund 
   733:                 if(DtCW._newPCW) s=0;                                                   //zmieniono nastawe?
   734:                 if(Tnizsza(0))                                                                  //Tcw<Tnst?
   735:                 {
   736:                         if(!Tnizsza(10))                                                        //Tnst-Tcw<=10 ?
   737:                         {
   738:                                 k=0;
   739:                                 if(Tstoi()&&s>=1)
   740:                                 {
   741:                                         s=0;
   742:                                         k=2;
   743:                                 }
   744:                                 if(Trosnie(1)&&s>=1)    //szybki narost temperatury
   745:                                 {
   746:                                         s=0;
   747:                                         k=10;
   748:                                         if(Trosnie(2)) k=8;     //b.szybki narost temperatury?
   749:                                 }
   750:                                 else
   751:                                 rgl.ytmp=0;
   752:                                 if(PWM.BufPWM>rgl.xmod) return;
   753:                                 tmp=rgl.xmod-PWM.BufPWM;
   754:                                 if(k>tmp) k=tmp;
   755:                                 if(PWM.MMAXCW>PWM.MGMOD)
   756:                                 {
   757:                                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   758:                                         else rgl.srp+=k;
   759:                                 }
   760:                                 else
   761:                                 {
   762:                                         if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
   763:                                         else rgl.srp+=k;
   764:                                 }
   765:                                 return;
   766:                         }
   767:                         else return;
   768:                 }
   769:                 else return;
   770:         }
   771:         else //aktualnie faza 2
   772:         {
   773:                 q=0;
   774:                 r=0;
   775:                 s=0;
   776:                 if(m<255) m++;                          //licznik sekund dla spadku temp CO
   777:                 if(p<255) p++;                          //licznik sekund dla spadku temp CO
   778:                 if(o<255) o++;                          //licznik sekund dla narostu temp CO
   779:                 if(DtCW.DAD_CW>DtCW.AC_CW)      //Tcw>Tnst ?
   780:                 {
   781:                         k=0;
   782:                         if(Trosnie(0)&&m>=2)
   783:                         {       
   784:                                 p=0;
   785:                                 o=0;
   786:                                 l=0;
   787:                                 m=0;
   788:                                 k=2;    //3             
   789:                         }
   790:                         else
   791:                         if(Twyzsza(1))                          //gdy jest powyzej zakresu nastawa+1
   792:                         {
   793:                                 if(Tstoi())
   794:                                 {
   795:                                         if(l>=2)
   796:                                         {
   797:                                                 k=1;
   798:                                                 if(Twyzsza(3)) k=2;
   799:                                                 l=0;
   800:                                         }
   801:                                         else
   802:                                         {
   803:                                                 k=0;
   804:                                                 l++;
   805:                                         }
   806:                                 }
   807:                         } else l=0;
   808:                         if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
   809:                         else rgl.srp-=k;
   810:                         if(rgl.srp>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
   811:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
   812:                         return;
   813:                 }
   814:                 else                                                                            //Tcw<Tnst
   815:                 {
   816:                         k=0;
   817:                         if(Tmaleje(0)&&m>=2)
   818:                         {       
   819:                                 p=0;
   820:                                 o=0;
   821:                                 l=0;
   822:                                 m=0;
   823:                                 k=1;            //2                     
   824:                                 //if(Tnizsza(0)) k=3;                           //3
   825:                         }
   826:                         else
   827:                         if(Tnizsza(1))
   828:                         {               
   829:                                 if(Tstoi())
   830:                                 {
   831:                                         if(l>=3)
   832:                                         {
   833:                                                 k=2;
   834:                                                 l=0;
   835:                                         }
   836:                                         else
   837:                                         {
   838:                                                 k=0;
   839:                                                 l++;
   840:                                         }
   841:                                 }
   842:                         }else l=0;
   843:                         if(PWM.MMAXCW>PWM.MGMOD)
   844:                         {
   845:                                 if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   846:                                 else rgl.srp+=k;
   847:                         }
   848:                         else
   849:                         {
   850:                                 if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
   851:                                 else rgl.srp+=k;
   852:                         }
   853:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
   854:                         return;
   855:                 }
   856:         }
   857: }
   858: 
   859: //------------------------------------------------------------
   860: //inkrementacja maksymalnej wartosci mocy na palniku
   861: //wykonywane co krok czasowy
   862: void IncMaxCW(void)
   863: {
   864:         unsigned char k;
   865:         
   866:         //decyzja o wejsciu w tryb INVMOD
   867:         //kontrola maksimum mocy dla fazy 2
   868:         if(rgl.fz)                                                                                      //faza 2 ?
   869:         {
   870:                 if(PWM.MMAXCW>PWM.MGMOD)
   871:                 {
   872:                         if(rgl.xmod>PWM.MGMOD) rgl.xmod=PWM.MGMOD;
   873:                 }
   874:                 else
   875:                 {
   876:                         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
   877:                 }
   878:                 return;
   879:         }
   880:         //jednorazowa modyfikacja wartosci srp ze wzgledu na szybkosc 
   881:         //narostu temperatury
   882:         if(Trosnie(2)&&!rgl.med_up)             //(Tcw rosnie szybciej niz 3K/sek)?     
   883:         {
   884:                 rgl.med_up=1;
   885:                 k=5;                                            //10
   886:                 if(PWM.MMAXCW>PWM.MGMOD)
   887:                 {
   888:                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   889:                         else rgl.srp+=k;
   890:                 }
   891:                 else
   892:                 {
   893:                         if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
   894:                         else rgl.srp+=k;
   895:                 }
   896:         }
   897:         if(Trosnie(3)&&!rgl.fast_up)    //(Tcw rosnie szybciej niz 4K/sek)?     
   898:         {
   899:                 rgl.fast_up=1;
   900:                 k=8;                                            //12
   901:                 if(PWM.MMAXCW>PWM.MGMOD)
   902:                 {
   903:                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
   904:                         else rgl.srp+=k;
   905:                 }
   906:                 else
   907:                 {
   908:                         if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
   909:                         else rgl.srp+=k;
   910:                 }
   911:         }
   912: 
   913:         //kontrolowany narost mocy
   914:         if(Trosnie(1)) return;                  //(Tcw rosnie szybciej niz 1K/sek)?
   915:         k=5;
   916:         if(rgl.xmod+k>_MG2_MOD) rgl.xmod=_MG2_MOD;
   917:         else rgl.xmod+=k;
   918:         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
   919: }
   920: //------------------------------------------------------------
   921: //reakcja superwizyjna
   922: void ModPrzCW(void)
   923: {
   924:         if(!rgl.nmod)                                   //nie jest w trybie nmod?
   925:         {
   926:                 if(rgl.fz)                                      //faza 2 ?
   927:                 {
   928:                         if(!Tmaleje(0))                 //(Tcw nie maleje ?)
   929:                         {
   930:                                 if(Twyzsza(4))          //Tcw-Tnst>4 ?
   931:                                 {
   932:                                         if(rgl.srp-15<PWM.MDMOD) rgl.srp=PWM.MDMOD;
   933:                                         else rgl.srp-=15;
   934:                                         rgl.nmod=1;             //wejdz w tryb nmod
   935:                                         return;
   936:                                 }
   937:                                 else return;
   938:                         }
   939:                         else return;
   940:                 }
   941:                 else return;
   942:         }
   943:         else                                                    //jest w trybie nmod?
   944:         {
   945:                 if(Tmaleje(0))                          //(Tcw maleje ?)
   946:                                         rgl.nmod=0;             //wyjdz z trybu nmod
   947:         }
   948: }
   949: //------------------------------------------------------------
   950: //Zabezpieczenie od przegrzania w obwodzie CO                   
   951: void PropCO(void)
   952: {
   953:         if(!rgl.nmod)                                   //nie jest w trybie nmod?
   954:         {
   955:                 if(!DtCO._err_CO)                       //awaria czujnika temperatury CO?
   956:                 {
   957:                         if(rgl.x_f==3)                                          //=86C ? 
   958:                         {
   959:                                 if(rgl.tmp_pwm>PWM.MGMOD)               
   960:                                 rgl.tmp_pwm=PWM.MGMOD;                  //=MGMOD
   961:                         }
   962:                         else 
   963:                         if(rgl.x_f==2)                                          //=87C ? 
   964:                         {
   965:                                 if(rgl.tmp_pwm>PWM.PROP1)
   966:                                 rgl.tmp_pwm=PWM.PROP1;  //-1/7
   967:                         }
   968:                         else
   969:                         if(rgl.x_f==1)                                          //=88C ? 
   970:                         {
   971:                                 if(rgl.tmp_pwm>PWM.PROP2)
   972:                                 rgl.tmp_pwm=PWM.PROP2;  //-2/7
   973:                         }
   974:                         else
   975:                         if(rgl.x_f<=0)                                          //>=89C ?
   976:                         {
   977:                                 if(rgl.tmp_pwm>PWM.PROP3)
   978:                                 rgl.tmp_pwm=PWM.PROP3;  //-3/7
   979:                         }
   980:                 }
   981:                 WriteOPWM(rgl.tmp_pwm);
   982:         }
   983:         else WriteOPWM(PWM.MDMOD);//PWM.BufPWM=PWM.MDMOD;                       //wymus minimum plomienia
   984: }
   985: //************************************************************
   986: //------------------------------------------------------------
   987: //------------------------------------------------------------
   988: //------wymiennik bitermiczny (maksiterm) - obieg CW
   989: //------------------------------------------------------------
   990: //------------------------------------------------------------
   991: //------------------------------------------------------------
   992: //parametry startowe dla CO
   993: void StartCO4(void)
   994: {
   995:         unsigned char k;
   996:         
   997:         if(rgl.btco||rgl.btcw) return; //praca w dowolnym obiegu CO?    
   998:         StartRTdS(_RTMOD);
   999:         DtCO.dDCO=0;
  1000:         DtCO.indCO=0;
  1001:         DtCW.dDCW=0;
  1002:         DtCW.indCW=0;
  1003:         rgl.fz=0;
  1004:         rgl.med_up=0;
  1005:         rgl.fast_up=0;
  1006:         //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
  1007:         if(PWM.MMAXCO>PWM.FIRSTPB)
  1008:         {
  1009:                 rgl.xmod=PWM.FIRSTPB;
  1010:         }
  1011:         else
  1012:         {
  1013:                 rgl.xmod=PWM.MMAXCO;
  1014:         }
  1015:         rgl.srp=0;
  1016:         rgl.ytmp=0;
  1017:         rgl.nmod=0;             //wyjdz z trybu nmod
  1018:         rgl.del1s=0;
  1019:         rgl.inv_mod=0;
  1020: }
  1021: //-------------------------------------------------------------
  1022: //parametry startowe dla CW
  1023: void StartMCW4(void)
  1024: {
  1025:         if(rgl.btco||rgl.btcw) return; //rozpoczecie pracy modulatora?
  1026:         StartRTdS(_RTMOD);
  1027:         DtCO.dDCO=0;
  1028:         DtCW.dDCW=0;
  1029:         DtCO.indCO=0;
  1030:         DtCW.indCW=0;
  1031:         rgl.fz=0;
  1032:         rgl.med_up=0;
  1033:         rgl.fast_up=0;
  1034:         //FirstPCW4();
  1035:         rgl.srp=0;
  1036:         rgl.ytmp=0;
  1037:         rgl.nmod=0;
  1038:         rgl.del1s=0;
  1039:         rgl.inv_mod=0;
  1040:         rgl.xmod=PWM.MDMOD;
  1041: }
  1042: //-------------------------------------------------------------
  1043: //pierwsze pobudzenie dla CW
  1044: void FirstPCW4(void)
  1045: {
  1046:         if(PWM.MMAXCW>PWM.MGMOD)
  1047:         {
  1048:                 if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
  1049:                 else rgl.xmod=PWM.FIRSTPB;
  1050:         }
  1051:         else
  1052:         {
  1053:                 if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
  1054:                 else 
  1055:                 {
  1056:                         if(PWM.MMAXCW>PWM.FIRSTPB) rgl.xmod=PWM.FIRSTPB;
  1057:                         else rgl.xmod=PWM.MMAXCW;
  1058:                 }
  1059:         }
  1060: }
  1061: //-------------------------------------------------------------
  1062: //zeruj parametry modulatora po zmianie obiegu
  1063: void ClrMod4(void)
  1064: {
  1065:         rgl.fz=0;
  1066:         rgl.med_up=0;
  1067:         rgl.fast_up=0;
  1068:         rgl.xmod=PWM.BufPWM;
  1069:         rgl.srp=0;
  1070:         rgl.ytmp=0;
  1071:         rgl.nmod=0;
  1072:         rgl.del1s=0;
  1073:         rgl.inv_mod=0;
  1074: }
  1075: //-------------------------------------------------------------
  1076: //zmien obieg na CW
  1077: void ModToCW4(void)
  1078: {
  1079:         rgl.btcw=1;
  1080:         if(rgl.btco)
  1081:         {
  1082:                 rgl.btco=0;
  1083:                 ClrMod4();
  1084:         }
  1085: }
  1086: //-------------------------------------------------------------
  1087: //zmien obieg na CO
  1088: void ModToCO4(void)
  1089: {
  1090:         rgl.btco=1;
  1091:         if(rgl.btcw)
  1092:         {
  1093:                 rgl.btcw=0;
  1094:                 ClrMod4();
  1095:         }
  1096: }
  1097: //-------------------------------------------------------------
  1098: //oblicza czas przez ktory temp=const
  1099: void IncConstCOCW4(void)
  1100: {
  1101:         if(Tstoi()) rgl.ytmp++;
  1102:         else rgl.ytmp=0;
  1103: }
  1104: //-------------------------------------------------------------
  1105: //wprowadzenie danych wejsciowych-CO
  1106: void ReadDataCO4(void)
  1107: {
  1108:         rgl.x_t=DtCO.DCO;
  1109:         rgl.x_dt=DtCO.dDCO;
  1110: }
  1111: //-------------------------------------------------------------
  1112: //wprowadzenie danych wejsciowych-CW
  1113: void ReadDataCW4(void)
  1114: {
  1115:         rgl.x_t=DtCW.DCW;
  1116:         rgl.x_f=DtCO.DCO;
  1117:         rgl.x_dt=DtCW.dDCW;
  1118:         rgl.x_df=DtCO.dDCO;
  1119: }
  1120: //-------------------------------------------------------------
  1121: //pierwsze przyblizenie
  1122: void ModZgCW4(void)
  1123: {
  1124:         signed long m;
  1125:         unsigned char p;
  1126:         static unsigned char pop;
  1127: 
  1128:         if(Tnizsza(10)) 
  1129:         {
  1130:                 pop=0;                                          //20wartosc poprawki na przesterowanie
  1131:                 //FirstPCW4();
  1132:         }
  1133:         if(rgl.fz)                                              //aktualnie faza 2?
  1134:         {
  1135:                 if(Tnizsza(2))                          //Tnizsza(2)przygotowanie do przejscia do fazy 1
  1136:                 {
  1137:                         rgl.xmod=PWM.BufPWM;
  1138:                         rgl.srp=0;
  1139:                         rgl.ytmp=0;     
  1140:                         rgl.del1s=0;
  1141:                         pop=0;
  1142:                 }
  1143:                 else return;
  1144:         }
  1145:         if(!Tnizsza(1))                                 //warunek przejscia do fazy 2
  1146:         {
  1147:                 rgl.fz=1;
  1148:                 rgl.fast_up=0;
  1149:                 rgl.med_up=0;
  1150:                 rgl.srp=PWM.BufPWM+pop;
  1151:                 rgl.xmod=PWM.BufPWM+pop;
  1152:                 pop=0;
  1153:                 if(PWM.MMAXCW>PWM.MGMOD)
  1154:                 {
  1155:                         if(rgl.xmod>PWM.MGMOD)
  1156:                         {
  1157:                                 rgl.srp=PWM.MGMOD;
  1158:                                 rgl.xmod=PWM.MGMOD;
  1159:                         }
  1160:                 }
  1161:                 else
  1162:                 {
  1163:                         if(rgl.xmod>PWM.MMAXCW)
  1164:                         {
  1165:                                 rgl.srp=PWM.MMAXCW;
  1166:                                 rgl.xmod=PWM.MMAXCW;
  1167:                         }
  1168:                 }
  1169:                 return;
  1170:         }
  1171:         if(rgl.xmod>=PWM.MDMOD) m=(rgl.xmod-PWM.MDMOD)*10;
  1172:         else m=0;
  1173:         m=m/(DtCW.MAD_CW-DtCW.DAD_CW);  //DAD_CW-MAD_CW
  1174:         m=m*(DtCW.AC_CW-DtCW.DAD_CW);   //DAD_CW-AC_CW  
  1175:         if(m<0) m=0;
  1176:         m=m/10+PWM.MDMOD;
  1177:         if(m>0xff)                                              //przepelnienie 
  1178:         {
  1179:                 rgl.fz=0;                                       //przejscie do fazy1 przy aktywnej fazie2
  1180:                 rgl.tmp_pwm=rgl.xmod;
  1181:                 return;
  1182:         }
  1183:         if(rgl.fz&&(rgl.xmod>m))
  1184:                 rgl.srp=(rgl.xmod-m);           //przygotowanie lagodnego przejscia do fazy 1
  1185:         m+=rgl.srp;
  1186:         if(m>rgl.xmod) p=rgl.xmod;
  1187:         else p=m;
  1188:         rgl.fz=0;                                               //przejscie do fazy1 przy aktywnej fazie2
  1189:         rgl.tmp_pwm=p;
  1190: }
  1191: //-------------------------------------------------------------
  1192: //drugie przyblizenie (tylko dla fazy 2)
  1193: void ModDkCW4(void)
  1194: {
  1195:         signed long m;  
  1196:         signed char ada;
  1197:         unsigned char k,p;
  1198:         
  1199:         if(!rgl.fz)     return;                                 //wyjscie jesli aktualnie faza 1
  1200:         ada=DtCW.AC_CW-DtCW.DAD_CW;
  1201:         k=2;                                                                    //9
  1202:         if(ada<0) k=1;                                                  //8
  1203:         m=rgl.srp+k*ada;
  1204:         if(m>rgl.xmod) p=rgl.xmod;
  1205:         else
  1206:         if(m<PWM.MDMOD) p=PWM.MDMOD;
  1207:         else p=m;
  1208:         rgl.tmp_pwm=p;
  1209: }
  1210: //-------------------------------------------------------------
  1211: //trzecie przyblizenie
  1212: //nowa wartosc punktu rownowagi srp.
  1213: //wykonywane co krok czasowy
  1214: void ModPruCW4(void)
  1215: {
  1216:         static unsigned char l,m,o,p,q,r,s;
  1217:         unsigned char tmp;
  1218:         signed char ada,k;
  1219:         if(!rgl.fz)                                                                                     //aktualnie faza 1?
  1220:         {
  1221:                 l=0;
  1222:                 m=0;
  1223:                 o=0;
  1224:                 p=0;
  1225:                 if(q<255) q++;                                                                  //licznik sekund 
  1226:                 if(s<255) s++;                                                                  //licznik sekund 
  1227:                 if(DtCW._newPCW) s=0;                                                   //zmieniono nastawe?
  1228:                 if(Tnizsza(0))                                                                  //Tcw<Tnst?
  1229:                 {
  1230:                         if(!Tnizsza(10))                                                        //Tnst-Tcw<=10 ?
  1231:                         {
  1232:                                 k=0;
  1233:                                 if(Tstoi()&&s>=1)
  1234:                                 {
  1235:                                         s=0;
  1236:                                         k=2;
  1237:                                 }
  1238:                                 if(Trosnie(1)&&s>=1)    //szybki narost temperatury
  1239:                                 {
  1240:                                         s=0;
  1241:                                         k=10;
  1242:                                         if(Trosnie(2)) k=8;     //b.szybki narost temperatury?
  1243:                                 }
  1244:                                 else
  1245:                                 rgl.ytmp=0;
  1246:                                 if(PWM.BufPWM>rgl.xmod) return;
  1247:                                 tmp=rgl.xmod-PWM.BufPWM;
  1248:                                 if(k>tmp) k=tmp;
  1249:                                 if(PWM.MMAXCW>PWM.MGMOD)
  1250:                                 {
  1251:                                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
  1252:                                         else rgl.srp+=k;
  1253:                                 }
  1254:                                 else
  1255:                                 {
  1256:                                         if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1257:                                         else rgl.srp+=k;
  1258:                                 }
  1259:                                 return;
  1260:                         }
  1261:                         else return;
  1262:                 }
  1263:                 else return;
  1264:         }
  1265:         else //aktualnie faza 2
  1266:         {
  1267:                 q=0;
  1268:                 r=0;
  1269:                 s=0;
  1270:                 if(m<255) m++;                          //licznik sekund dla spadku temp CO
  1271:                 if(p<255) p++;                          //licznik sekund dla spadku temp CO
  1272:                 if(o<255) o++;                          //licznik sekund dla narostu temp CO
  1273:                 if(DtCW.DAD_CW>DtCW.AC_CW)      //Tcw>Tnst ?
  1274:                 {
  1275:                         k=0;
  1276:                         if(Trosnie(0)&&m>=2)
  1277:                         {       
  1278:                                 p=0;
  1279:                                 o=0;
  1280:                                 l=0;
  1281:                                 m=0;
  1282:                                 k=2;    //3             
  1283:                         }
  1284:                         else
  1285:                         if(Twyzsza(1))                          //gdy jest powyzej zakresu nastawa+1
  1286:                         {
  1287:                                 if(Tstoi())
  1288:                                 {
  1289:                                         if(l>=2)
  1290:                                         {
  1291:                                                 k=1;
  1292:                                                 if(Twyzsza(3)) k=2;
  1293:                                                 l=0;
  1294:                                         }
  1295:                                         else
  1296:                                         {
  1297:                                                 k=0;
  1298:                                                 l++;
  1299:                                         }
  1300:                                 }
  1301:                         } else l=0;
  1302:                         if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
  1303:                         else rgl.srp-=k;
  1304:                         if(rgl.srp>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1305:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
  1306:                         return;
  1307:                 }
  1308:                 else                                                                            //Tcw<Tnst
  1309:                 {
  1310:                         k=0;
  1311:                         if(Tmaleje(0)&&m>=2)
  1312:                         {       
  1313:                                 p=0;
  1314:                                 o=0;
  1315:                                 l=0;
  1316:                                 m=0;
  1317:                                 k=1;            //2                     
  1318:                                 //if(Tnizsza(0)) k=3;                           //3
  1319:                         }
  1320:                         else
  1321:                         if(Tnizsza(1))
  1322:                         {               
  1323:                                 if(Tstoi())
  1324:                                 {
  1325:                                         if(l>=3)
  1326:                                         {
  1327:                                                 k=2;
  1328:                                                 l=0;
  1329:                                         }
  1330:                                         else
  1331:                                         {
  1332:                                                 k=0;
  1333:                                                 l++;
  1334:                                         }
  1335:                                 }
  1336:                         }else l=0;
  1337:                         if(PWM.MMAXCW>PWM.MGMOD)
  1338:                         {
  1339:                                 if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
  1340:                                 else rgl.srp+=k;
  1341:                         }
  1342:                         else
  1343:                         {
  1344:                                 if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1345:                                 else rgl.srp+=k;
  1346:                         }
  1347:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
  1348:                         return;
  1349:                 }
  1350:         }
  1351: }
  1352: //------------------------------------------------------------
  1353: //inkrementacja maksymalnej wartosci mocy na palniku
  1354: //wykonywane co krok czasowy
  1355: void IncMaxCW4(void)
  1356: {
  1357:         unsigned char k;
  1358:         
  1359:         //kontrola maksimum mocy dla fazy 2
  1360:         if(rgl.fz)                                                                              //faza 2 ?
  1361:         {
  1362:                 if(PWM.MMAXCW>PWM.MGMOD)
  1363:                 {
  1364:                         if(rgl.xmod>PWM.MGMOD) rgl.xmod=PWM.MGMOD;
  1365:                 }
  1366:                 else
  1367:                 {
  1368:                         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
  1369:                 }
  1370:                 return;
  1371:         }
  1372: 
  1373:         //kontrolowany narost mocy dla fazy 1
  1374:         if(Trosnie(1)) return;                          //(Tcw lub Tco rosnie szybciej niz 1K/sek)?
  1375:         k=5;
  1376:         if(rgl.xmod+k>_MG2_MOD) rgl.xmod=_MG2_MOD;
  1377:         else rgl.xmod+=k;
  1378:         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
  1379: }
  1380: //------------------------------------------------------------
  1381: //reakcja superwizyjna
  1382: void ModPrzCW4(void)
  1383: {
  1384:         static unsigned char trb=0;
  1385:         unsigned int p;
  1386:         
  1387:         p=(rgl.tmp_pwm-PWM.MDMOD)*100;
  1388:         p=p/(PWM.MGMOD-PWM.MDMOD);
  1389: 
  1390:         if(!rgl.nmod)                                                                   //nie jest w trybie nmod?
  1391:         {
  1392:                 trb=0;
  1393:                 if(p<=35)
  1394:                 {
  1395:                         if(!Tmaleje(0)&&Twyzsza(3))                                     //(Tcw nie maleje ?)
  1396:                         {
  1397:                                         trb=1;
  1398:                                         rgl.nmod=1;                                                     //wejdz w tryb nmod
  1399:                         }
  1400:                 }
  1401:                 else
  1402:                 {
  1403:                         if(!Tmaleje(0))                 //(Tcw nie maleje ?)
  1404:                         {
  1405:                                 if(Twyzsza(5))          //Tcw-Tnst>4 ?
  1406:                                 {
  1407:                                         if(rgl.srp-3<PWM.MDMOD) rgl.srp=PWM.MDMOD;
  1408:                                         else rgl.srp-=3;
  1409:                                         trb=2;
  1410:                                         rgl.nmod=1;             //wejdz w tryb nmod
  1411:                                         return;
  1412:                                 }
  1413:                         }
  1414:                         else return;
  1415:                 }
  1416:         }
  1417:         else                                                                                    //jest w trybie nmod?
  1418:         {
  1419:                 switch(trb)
  1420:                 {
  1421:                         case 1:
  1422:                         {
  1423:                                 if(!Twyzsza(3))
  1424:                                 {
  1425:                                         if(Tnizsza(3)||Tstoi()||Tmaleje(0))
  1426:                                         {
  1427:                                                 trb=0;
  1428:                                                 rgl.nmod=0;                                     //jezeli Tcw maleje wyjdz z trybu nmod
  1429:                                         }
  1430:                                 }
  1431:                                 break;
  1432:                         }
  1433:                         case 2:
  1434:                         {
  1435:                                 if(Tmaleje(0)||!Twyzsza(4))                             //(Tcw maleje ?)
  1436:                                 {
  1437:                                         trb=0;
  1438:                                         rgl.nmod=0;             //wyjdz z trybu nmod
  1439:                                         return;
  1440:                                 }
  1441:                                 break;
  1442:                         }
  1443:                 }
  1444:         }
  1445: }
  1446: //------------------------------------------------------------
  1447: //Zabezpieczenie od przegrzania w obwodzie CO                   
  1448: void PropCO4(void)
  1449: {
  1450:         if(!rgl.nmod)                                   //nie jest w trybie nmod?
  1451:         {
  1452:                 if(!DtCO._err_CO)                       //awaria czujnika temperatury CO?
  1453:                 {
  1454:                         if(rgl.x_f==3)                                          //=86C ? 
  1455:                         {
  1456:                                 if(rgl.tmp_pwm>PWM.MGMOD)               
  1457:                                 rgl.tmp_pwm=PWM.MGMOD;                  //=MGMOD
  1458:                         }
  1459:                         else 
  1460:                         if(rgl.x_f==2)                                          //=87C ? 
  1461:                         {
  1462:                                 if(rgl.tmp_pwm>PWM.PROP1)
  1463:                                 rgl.tmp_pwm=PWM.PROP1;  //-1/7
  1464:                         }
  1465:                         else
  1466:                         if(rgl.x_f==1)                                          //=88C ? 
  1467:                         {
  1468:                                 if(rgl.tmp_pwm>PWM.PROP2)
  1469:                                 rgl.tmp_pwm=PWM.PROP2;  //-2/7
  1470:                         }
  1471:                         else
  1472:                         if(rgl.x_f<=0)                                          //>=89C ?
  1473:                         {
  1474:                                 if(rgl.tmp_pwm>PWM.PROP3)
  1475:                                 rgl.tmp_pwm=PWM.PROP3;  //-3/7
  1476:                         }
  1477:                 }
  1478:                 WriteOPWM(rgl.tmp_pwm);
  1479:         }
  1480:         else WriteOPWM(PWM.MDMOD);                              //wymus minimum plomienia
  1481: }
  1482: //************************************************************
  1483: //------------------------------------------------------------
  1484: //------------------------------------------------------------
  1485: //------wymiennik plytowy - obieg CW
  1486: //------------------------------------------------------------
  1487: //------------------------------------------------------------
  1488: //------------------------------------------------------------
  1489: //parametry startowe dla CO
  1490: void StartCO2(void)
  1491: {
  1492:         unsigned char k;
  1493:         
  1494:         if(rgl.btco||rgl.btcw) return; //praca w dowolnym obiegu CO?    
  1495:         StartRTdS(_RTMOD);
  1496:         DtCO.dDCO=0;
  1497:         DtCO.indCO=0;
  1498:         DtCW.dDCW=0;
  1499:         DtCW.indCW=0;
  1500:         rgl.fz=0;
  1501:         rgl.med_up=0;
  1502:         rgl.fast_up=0;
  1503:         //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
  1504:         //if(!PWM.tpGZ) rgl.xmod=I80_MOD;
  1505:         //else rgl.xmod=I80_PMOD;
  1506:         if(PWM.MMAXCO>PWM.FIRSTPB)
  1507:         {
  1508:                 rgl.xmod=PWM.FIRSTPB;
  1509:         }
  1510:         else
  1511:         {
  1512:                 rgl.xmod=PWM.MMAXCO;
  1513:         }
  1514: /*
  1515:         if(!PWM.tpGZ)
  1516:         {
  1517:                 if(PWM.MMAXCO>I80_MOD)
  1518:                 {
  1519:                         rgl.xmod=I80_MOD;
  1520:                 }
  1521:                 else
  1522:                 {
  1523:                         rgl.xmod=PWM.MMAXCO;
  1524:                 }
  1525:         }
  1526:         else
  1527:         {
  1528:                 if(PWM.MMAXCO>I80_PMOD)
  1529:                 {
  1530:                         rgl.xmod=I80_PMOD;
  1531:                 }
  1532:                 else
  1533:                 {
  1534:                         rgl.xmod=PWM.MMAXCO;
  1535:                 }
  1536:         }
  1537: */
  1538:         rgl.srp=0;
  1539:         rgl.ytmp=0;
  1540:         rgl.nmod=0;             //wyjdz z trybu nmod
  1541:         rgl.del1s=0;
  1542:         rgl.deln1=0;
  1543:         rgl.inv_mod=0;
  1544: }
  1545: //-------------------------------------------------------------
  1546: //parametry startowe dla CW
  1547: void StartMCW2(void)
  1548: {
  1549:         if(rgl.btco||rgl.btcw) return; //rozpoczecie pracy modulatora?
  1550:         StartRTdS(_RTMOD);
  1551:         DtCO.dDCO=0;
  1552:         DtCW.dDCW=0;
  1553:         DtCO.indCO=0;
  1554:         DtCW.indCW=0;
  1555:         rgl.fz=0;
  1556:         FirstPCW2();
  1557:         rgl.srp=0;
  1558:         rgl.ytmp=0;
  1559:         rgl.del1s=0;
  1560: }
  1561: //------------------------------------------------------------- 
  1562: //pierwsze pobudzenie dla CW
  1563: void FirstPCW2(void)
  1564: {
  1565:         if(PWM.MMAXCW>PWM.MGMOD)
  1566:         {
  1567:                 if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
  1568:                 else rgl.xmod=PWM.FIRSTPB;
  1569:         }
  1570:         else
  1571:         {
  1572:                 if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
  1573:                 else 
  1574:                 {
  1575:                         if(PWM.MMAXCW>PWM.FIRSTPB) rgl.xmod=PWM.FIRSTPB;
  1576:                         else rgl.xmod=PWM.MMAXCW;
  1577:                 }
  1578:         }
  1579: /*      if(!PWM.tpGZ)
  1580:         {
  1581:                 if(PWM.MMAXCW>PWM.MGMOD)
  1582:                 {
  1583:                         if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
  1584:                         else rgl.xmod=PWM.FIRSTPB;
  1585:                 }
  1586:                 else
  1587:                 {
  1588:                         if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
  1589:                         else 
  1590:                         {
  1591:                                 if(PWM.MMAXCW>PWM.FIRSTPB) rgl.xmod=PWM.FIRSTPB;
  1592:                                 else rgl.xmod=PWM.MMAXCW;
  1593:                         }
  1594:                 }
  1595:         }
  1596:         else
  1597:         {
  1598:                 if(PWM.MMAXCW>PWM.MGMOD)
  1599:                 {
  1600:                         if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
  1601:                         else rgl.xmod=I80_PMOD;
  1602:                 }
  1603:                 else
  1604:                 {
  1605:                         if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
  1606:                         else 
  1607:                         {
  1608:                                 if(PWM.MMAXCW>I80_PMOD) rgl.xmod=I80_PMOD;
  1609:                                 else rgl.xmod=PWM.MMAXCW;
  1610:                         }
  1611:                 }
  1612:         }
  1613: */
  1614: }
  1615: //-------------------------------------------------------------
  1616: //zeruj parametry modulatora po zmianie obiegu
  1617: void ClrMod2(void)
  1618: {
  1619:         rgl.fz=0;
  1620:         rgl.xmod=PWM.BufPWM;
  1621:         rgl.srp=0;
  1622:         rgl.ytmp=0;
  1623:         rgl.del1s=0;
  1624: }
  1625: //-------------------------------------------------------------
  1626: //zmien obieg na CW
  1627: void ModToCW2(void)
  1628: {
  1629:         rgl.btcw=1;
  1630:         if(rgl.btco)
  1631:         {
  1632:                 rgl.btco=0;
  1633:                 ClrMod2();
  1634:         }
  1635: }
  1636: //-------------------------------------------------------------
  1637: //zmien obieg na CO
  1638: void ModToCO2(void)
  1639: {
  1640:         rgl.btco=1;
  1641:         if(rgl.btcw)
  1642:         {
  1643:                 rgl.btcw=0;
  1644:                 ClrMod2();
  1645:         }
  1646: }
  1647: //-------------------------------------------------------------
  1648: //oblicza czas przez ktory temp=const
  1649: void IncConstCW2(void)
  1650: {
  1651:         if(!TFrosnie(0))
  1652:         {
  1653:                 if(Tstoi()) rgl.ytmp++;
  1654:                 else rgl.ytmp=0;
  1655:         }
  1656:         else rgl.ytmp=0;
  1657: }
  1658: //-------------------------------------------------------------
  1659: void IncConstCO2(void)
  1660: {
  1661:         if(Tstoi()) rgl.ytmp++;
  1662:         else rgl.ytmp=0;
  1663: }
  1664: //------------------------------------------------------------- 
  1665: //wprowadzenie danych wejsciowych-CO
  1666: void ReadDataCO2(void)
  1667: {
  1668:         rgl.x_t=DtCO.DCO;
  1669:         rgl.x_dt=DtCO.dDCO;
  1670: }
  1671: //-------------------------------------------------------------
  1672: //wprowadzenie danych wejsciowych-CW
  1673: void ReadDataCW2(void)
  1674: {
  1675:         rgl.x_t=DtCW.DCW;
  1676:         rgl.x_f=DtCO.DCO;
  1677:         rgl.x_dt=DtCW.dDCW;
  1678:         rgl.x_df=DtCO.dDCO;
  1679: }
  1680: //-------------------------------------------------------------
  1681: //pierwsze przyblizenie
  1682: void ModZgCW2(void)
  1683: {
  1684:         signed long m;
  1685:         unsigned char p;
  1686:         static unsigned char pop;
  1687: 
  1688:         if(Tnizsza(10)) 
  1689:         {
  1690:                 pop=20;                                         //wartosc poprawki na przesterowanie
  1691:                 FirstPCW2();
  1692:         }
  1693:         if(rgl.fz)                                              //aktualnie faza 2?
  1694:         {
  1695:                 if(Tnizsza(2))                          //Tnizsza(2)przygotowanie do przejscia do fazy 1
  1696:                 {
  1697:                         rgl.xmod=PWM.BufPWM;
  1698:                         rgl.srp=0;
  1699:                         rgl.ytmp=0;     
  1700:                         rgl.del1s=0;
  1701:                         pop=0;
  1702:                 }
  1703:                 else return;
  1704:         }
  1705:         if(!Tnizsza(1))                                 //warunek przejscia do fazy 2
  1706:         {
  1707:                 rgl.fz=1;
  1708:                 rgl.fast_up=0;
  1709:                 rgl.med_up=0;
  1710:                 rgl.srp=PWM.BufPWM+pop;
  1711:                 rgl.xmod=PWM.BufPWM+pop;
  1712:                 pop=0;
  1713:                 if(PWM.MMAXCW>PWM.MGMOD)
  1714:                 {
  1715:                         if(rgl.xmod>PWM.MGMOD)
  1716:                         {
  1717:                                 rgl.srp=PWM.MGMOD;
  1718:                                 rgl.xmod=PWM.MGMOD;
  1719:                         }
  1720:                 }
  1721:                 else
  1722:                 {
  1723:                         if(rgl.xmod>PWM.MMAXCW)
  1724:                         {
  1725:                                 rgl.srp=PWM.MMAXCW;
  1726:                                 rgl.xmod=PWM.MMAXCW;
  1727:                         }
  1728:                 }
  1729:                 return;
  1730:         }
  1731:         if(rgl.xmod>=PWM.MDMOD) m=(rgl.xmod-PWM.MDMOD)*10;
  1732:         else m=0;
  1733:         m=m/(DtCW.MAD_CW-DtCW.DAD_CW);  //DAD_CW-MAD_CW
  1734:         m=m*(DtCW.AC_CW-DtCW.DAD_CW);   //DAD_CW-AC_CW  
  1735:         if(m<0) m=0;
  1736:         m=m/10+PWM.MDMOD;
  1737:         if(m>0xff)                                              //przepelnienie 
  1738:         {
  1739:                 rgl.fz=0;                                       //przejscie do fazy1 przy aktywnej fazie2
  1740:                 rgl.tmp_pwm=rgl.xmod;
  1741:                 return;
  1742:         }
  1743:         if(rgl.fz&&(rgl.xmod>m))
  1744:                 rgl.srp=(rgl.xmod-m);           //przygotowanie lagodnego przejscia do fazy 1
  1745:         m+=rgl.srp;
  1746:         if(m>rgl.xmod) p=rgl.xmod;
  1747:         else p=m;
  1748:         rgl.fz=0;                                               //przejscie do fazy1 przy aktywnej fazie2
  1749:         rgl.tmp_pwm=p;
  1750: }
  1751: //-------------------------------------------------------------
  1752: //drugie przyblizenie (tylko dla fazy 2)
  1753: void ModDkCW2(void)
  1754: {
  1755:         signed long m;  
  1756:         signed char ada;
  1757:         unsigned char k,p;
  1758:         
  1759:         if(!rgl.fz)     return;                                 //wyjscie jesli aktualnie faza 1
  1760:         ada=DtCW.AC_CW-DtCW.DAD_CW;
  1761:         k=9;                                                                    //9
  1762:         if(ada<0) k=8;                                                  //8
  1763:         m=rgl.srp+k*ada;
  1764:         if(m>rgl.xmod) p=rgl.xmod;
  1765:         else
  1766:         if(m<PWM.MDMOD) p=PWM.MDMOD;
  1767:         else p=m;
  1768:         rgl.tmp_pwm=p;
  1769: }
  1770: //-------------------------------------------------------------
  1771: //trzecie przyblizenie
  1772: //nowa wartosc punktu rownowagi srp.
  1773: //wykonywane co krok czasowy
  1774: void ModPruCW2(void)
  1775: {
  1776:         static unsigned char l,m,o,p,q,r,s;
  1777:         unsigned char tmp;
  1778:         signed char ada,k;
  1779:         if(!rgl.fz)                                                                                     //aktualnie faza 1?
  1780:         {
  1781:                 l=0;
  1782:                 m=0;
  1783:                 o=0;
  1784:                 p=0;
  1785:                 if(q<255) q++;                                                                  //licznik sekund 
  1786:                 if(s<255) s++;                                                                  //licznik sekund 
  1787:                 if(DtCW._newPCW) s=0;                                                   //zmieniono nastawe?
  1788:                 if(Tnizsza(0))                                                                  //Tcw<Tnst?
  1789:                 {
  1790:                         if(!Tnizsza(10))                                                        //Tnst-Tcw<=10 ?
  1791:                         {
  1792:                                 k=0;
  1793:                                 if((Trosnie(1)||TFrosnie(1))&&s>=1)     //szybki narost temperatury
  1794:                                 {
  1795:                                         s=0;
  1796:                                         k=10;
  1797:                                         if(Trosnie(2)||TFrosnie(2)) k=8;        //b.szybki narost temperatury?
  1798:                                 }
  1799:                                 else
  1800:                                 if(TFmaleje(0)&&q>=1)
  1801:                                 {
  1802:                                         q=0;
  1803:                                         k=6;
  1804:                                 }else
  1805:                                 if(TFstoi())
  1806:                                 {
  1807:                                         if(r>=1)
  1808:                                         {
  1809:                                                 k=6;
  1810:                                                 r=0;
  1811:                                         }
  1812:                                         else
  1813:                                         {
  1814:                                                 k=0;
  1815:                                                 r++;
  1816:                                         }
  1817:                                 }
  1818:                                 rgl.ytmp=0;
  1819:                                 if(PWM.BufPWM>rgl.xmod) return;
  1820:                                 tmp=rgl.xmod-PWM.BufPWM;
  1821:                                 if(k>tmp) k=tmp;
  1822:                                 //if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
  1823:                                 //else rgl.srp+=k;
  1824:                                 if(PWM.MMAXCW>PWM.MGMOD)
  1825:                                 {
  1826:                                         if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
  1827:                                         else rgl.srp+=k;
  1828:                                 }
  1829:                                 else
  1830:                                 {
  1831:                                         if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1832:                                         else rgl.srp+=k;
  1833:                                 }
  1834:                                 return;
  1835:                         }
  1836:                         else return;
  1837:                 }
  1838:                 else return;
  1839:         }
  1840:         else //aktualnie faza 2
  1841:         {
  1842:                 q=0;
  1843:                 r=0;
  1844:                 s=0;
  1845:                 if(m<255) m++;                          //licznik sekund dla spadku temp CO
  1846:                 if(p<255) p++;                          //licznik sekund dla spadku temp CO
  1847:                 if(o<255) o++;                          //licznik sekund dla narostu temp CO
  1848:                 if(DtCW.DAD_CW>DtCW.AC_CW)                                      //Tcw>Tnst ?
  1849:                 {
  1850:                         k=0;
  1851:                         if(TFmaleje(0)&&!Twyzsza(0)&&p>=2)              //(Tmaleje(0)||TFmaleje(0)
  1852:                         {
  1853:                                 p=0;
  1854:                                 o=0;
  1855:                                 l=0;
  1856:                                 m=0;
  1857:                                 k=-1;                                                           //1
  1858:                         }
  1859:                         else
  1860:                         if(TFrosnie(0)&&o>=2)
  1861:                         {       
  1862:                                 o=0;
  1863:                                 p=0;
  1864:                                 l=0;
  1865:                                 m=0;                    
  1866:                                 k=2;                                    //3
  1867:                                 if(Trowna()) k=1;
  1868:                         }
  1869:                         else
  1870:                         if(Trosnie(0)&&m>=2)
  1871:                         {       
  1872:                                 p=0;
  1873:                                 o=0;
  1874:                                 l=0;
  1875:                                 m=0;
  1876:                                 k=3;    //2             
  1877:                         }
  1878:                         else
  1879:                         if(Twyzsza(1))                          //gdy jest powyzej zakresu nastawa+1
  1880:                         {
  1881:                                 if(Tstoi()&&TFstoi())
  1882:                                 {
  1883:                                         if(l>=2)
  1884:                                         {
  1885:                                                 k=1;
  1886:                                                 if(Twyzsza(3)) k=2;
  1887:                                                 l=0;
  1888:                                         }
  1889:                                         else
  1890:                                         {
  1891:                                                 k=0;
  1892:                                                 l++;
  1893:                                         }
  1894:                                 }
  1895:                         } else l=0;
  1896:                         if(rgl.srp-k<PWM.MDMOD) rgl.srp=PWM.MDMOD;
  1897:                         else rgl.srp-=k;
  1898:                         if(rgl.srp>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1899:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
  1900:                         return;
  1901:                 }
  1902:                 else                                                                            //Tcw<Tnst
  1903:                 {
  1904:                         k=0;
  1905:                         if(TFrosnie(0)&&o>=2)                                           //(Trosnie(0)||TFrosnie(0))
  1906:                         {
  1907:                                 o=0;
  1908:                                 p=0;
  1909:                                 l=0;
  1910:                                 m=0;
  1911:                                 k=-3;
  1912:                                 if(Trowna()) k=-2;
  1913:                         }
  1914:                         else
  1915:                         if(TFmaleje(0)&&p>=2)
  1916:                         {       
  1917:                                 p=0;
  1918:                                 o=0;
  1919:                                 l=0;
  1920:                                 m=0;                    
  1921:                                 k=2;                            //3
  1922:                                 if(Trowna()) k=1;
  1923:                         }
  1924:                         else
  1925:                         if(Tmaleje(0)&&m>=2)
  1926:                         {       
  1927:                                 p=0;
  1928:                                 o=0;
  1929:                                 l=0;
  1930:                                 m=0;
  1931:                                 k=2;                    
  1932:                                 if(Tnizsza(0)) k=3;                             //3
  1933:                         }
  1934:                         else
  1935:                         if(Tnizsza(1))
  1936:                         {               
  1937:                                 if(Tstoi()&&TFstoi())
  1938:                                 {
  1939:                                         if(l>=3)
  1940:                                         {
  1941:                                                 k=2;
  1942:                                                 l=0;
  1943:                                         }
  1944:                                         else
  1945:                                         {
  1946:                                                 k=0;
  1947:                                                 l++;
  1948:                                         }
  1949:                                 }
  1950:                         } else l=0;
  1951:                         if(PWM.MMAXCW>PWM.MGMOD)
  1952:                         {
  1953:                                 if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
  1954:                                 else rgl.srp+=k;
  1955:                         }
  1956:                         else
  1957:                         {
  1958:                                 if(rgl.srp+k>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
  1959:                                 else rgl.srp+=k;
  1960:                         }
  1961:                         if(rgl.xmod<rgl.srp) rgl.xmod=rgl.srp;
  1962:                         return;
  1963:                 }
  1964:         }
  1965: }
  1966: //-------------------------------------------------------------
  1967: //inkrementacja maksymalnej wartosci mocy na palniku
  1968: //wykonywane co krok czasowy
  1969: void IncMaxCW2(void)
  1970: {
  1971:         unsigned char k;
  1972:         
  1973:         //kontrola maksimum mocy dla fazy 2
  1974:         if(rgl.fz)                                                                              //faza 2 ?
  1975:         {
  1976:                 if(PWM.MMAXCW>PWM.MGMOD)
  1977:                 {
  1978:                         if(rgl.xmod>PWM.MGMOD) rgl.xmod=PWM.MGMOD;
  1979:                 }
  1980:                 else
  1981:                 {
  1982:                         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
  1983:                 }
  1984:                 return;
  1985:         }
  1986:         //kontrolowany narost mocy dla fazy 1
  1987:         if(Trosnie(1)||TFrosnie(1)) return;                             //(Tcw lub Tco rosnie szybciej niz 1K/sek)?
  1988:         k=5;
  1989:         if(rgl.xmod+k>_MG2_MOD) rgl.xmod=_MG2_MOD;
  1990:         else rgl.xmod+=k;
  1991:         if(rgl.xmod>PWM.MMAXCW) rgl.xmod=PWM.MMAXCW;
  1992: }
  1993: //-------------------------------------------------------------
  1994: //reakcja superwizyjna
  1995: void ModPrzCW2(void)
  1996: {
  1997:         if(!rgl.nmod)                                                                   //nie jest w trybie nmod?
  1998:         {
  1999:                 if(!Tmaleje(0)&&Twyzsza(3))                                                             //(Tcw nie maleje ?)
  2000:                 {
  2001:                                 rgl.nmod=1;                                                     //wejdz w tryb nmod
  2002:                 }
  2003:         }
  2004:         else                                                                                    //jest w trybie nmod?
  2005:         {
  2006:                 if(!Twyzsza(3))
  2007:                 {
  2008:                         if(Tmaleje(0)) rgl.nmod=0;                                      //jezeli Tcw maleje wyjdz z trybu nmod
  2009:                         if(Tstoi()&&TFmaleje(0)) rgl.nmod=0;            //(Tcw stoi i Tco maleje) wyjdz z trybu nmod
  2010:                         if(Tnizsza(3)) rgl.nmod=0;                                      
  2011:                 }
  2012:         }
  2013: }
  2014: //------------------------------------------------------------
  2015: //Zabezpieczenie od przegrzania w obwodzie CO                   
  2016: void PropCO2(void)
  2017: {
  2018:         if(!rgl.nmod)                                   //nie jest w trybie nmod?
  2019:         {
  2020:                 if(rgl.x_f==3)                                          //=86C ? 
  2021:                 {
  2022:                         if(rgl.tmp_pwm>PWM.MGMOD)               
  2023:                         rgl.tmp_pwm=PWM.MGMOD;                  //=MGMOD
  2024:                 }
  2025:                 else 
  2026:                 if(rgl.x_f==2)                                          //=87C ? 
  2027:                 {
  2028:                         if(rgl.tmp_pwm>PWM.PROP1)
  2029:                         rgl.tmp_pwm=PWM.PROP1;  //-1/7
  2030:                 }
  2031:                 else
  2032:                 if(rgl.x_f==1)                                          //=88C ? 
  2033:                 {
  2034:                         if(rgl.tmp_pwm>PWM.PROP2)
  2035:                         rgl.tmp_pwm=PWM.PROP2;  //-2/7
  2036:                 }
  2037:                 else
  2038:                 if(rgl.x_f<=0)                                          //>=89C ?
  2039:                 {
  2040:                         if(rgl.tmp_pwm>PWM.PROP3)
  2041:                         rgl.tmp_pwm=PWM.PROP3;  //-3/7
  2042:                 }
  2043:                 WriteOPWM(rgl.tmp_pwm);
  2044:                 //PWM.BufPWM=rgl.tmp_pwm;
  2045:         }
  2046:         else WriteOPWM(PWM.MDMOD);//PWM.BufPWM=PWM.MDMOD;                       //wymus minimum plomienia
  2047: }
  2048: //************************************************************
  2049: //------------------------------------------------------------
  2050: //------------------------------------------------------------
  2051: //------Minimax z zasobnikiem, Unico
  2052: //------------------------------------------------------------
  2053: //------------------------------------------------------------                                                          
  2054: //-------------------------------------------------------------
  2055: //-------------------------------------------------------------
  2056: //zmien obieg na CW
  2057: void ModToCW3(void)
  2058: {
  2059:         rgl.btcw=1;
  2060:         if(rgl.btco)    //aktywny jest obieg CO?
  2061:         {
  2062:                 rgl.btco=0;
  2063:                 //wstepne obnizenie mocy palnika
  2064:                 if(!Tnizsza(0))
  2065:                 {
  2066:                         if(rgl.srp-10<PWM.MDMOD) rgl.srp=PWM.MDMOD;
  2067:                         else rgl.srp-=10;
  2068:                 }
  2069:         }
  2070: }
  2071: //-------------------------------------------------------------
  2072: //zmien obieg na CO
  2073: void ModToCO3(void)
  2074: {
  2075:         rgl.btco=1;
  2076:         rgl.btcw=0;
  2077: }
  2078: //-------------------------------------------------------------
  2079: //parametry startowe - kociol z zasobnikiem.
  2080: void StartMCO3(void)
  2081: {
  2082:         if(rgl.btco||rgl.btcw) return; //praca w dowolnym obiegu CO?    
  2083:         StartRTdS(_RTMOD);
  2084:         DtCO.dDCO=0;
  2085:         DtCO.indCO=0;
  2086:         rgl.fz=0;
  2087:         rgl.med_up=0;
  2088:         rgl.fast_up=0;
  2089:         //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
  2090:         if(PWM.MAXPWM>PWM.FIRSTPB)
  2091:         {
  2092:                 rgl.xmod=PWM.FIRSTPB;
  2093:         }
  2094:         else
  2095:         {
  2096:                 rgl.xmod=PWM.MAXPWM;
  2097:         }
  2098:         rgl.srp=0;
  2099:         rgl.ytmp=0;
  2100:         rgl.nmod=0;                                             //wyjdz z trybu nmod
  2101:         rgl.btcw=0;
  2102:         rgl.btco=1;
  2103:         rgl.del1s=0;
  2104:         rgl.deln1=0;
  2105:         rgl.inv_mod=0;
  2106: }
  2107: //************************************************************
  2108: //------------------------------------------------------------
  2109: //------------------------------------------------------------
  2110: //------------------------------------------------------------
  2111: //------------------------------------------------------------
  2112: //zwraca wartosc 1 przy stwierdzonym wzroscie temperatury
  2113: //(w obiegu CW)
  2114: //dla t=0 zwraca wartosc jeden przy dowolnym wzroscie temp.
  2115: //dla t>0 zwraca wartosc jeden przy wroscie > od t [C/sek].
  2116: bit Trosnie(const unsigned char t)
  2117: {
  2118:         return (rgl.x_dt>t);
  2119: }
  2120: //------------------------------------------------------------
  2121: //zwraca wartosc 1 przy stwierdzonym spadku temperatury
  2122: //(w obiegu CW)
  2123: //dla t=0 zwraca wartosc jeden przy dowolnym spadku temp.
  2124: //dla t>0 zwraca wartosc jeden przy spadku > od t [C/sek].
  2125: bit Tmaleje(const unsigned char t)
  2126: {
  2127:         return (rgl.x_dt<(-1*t));
  2128: }
  2129: //------------------------------------------------------------
  2130: //zwraca wartosc 1 jezeli temperatura sie nie zmienia
  2131: //(w obiegu CW)
  2132: bit Tstoi(void)
  2133: {
  2134:         return !rgl.x_dt;
  2135: }
  2136: 
  2137: //------------------------------------------------------------
  2138: //zwraca wartosc 1 temperatura jes nizsza od nastawy o wartosc parametru t
  2139: //(w obiegu CW)
  2140: //dla t=0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy.
  2141: //dla t>0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy o >= t.
  2142: bit Tnizsza(const unsigned char t)
  2143: {
  2144:         return (rgl.x_t>t);
  2145: }
  2146: //------------------------------------------------------------
  2147: //zwraca wartosc 1 temperatura jes nizsza od nastawy o wartosc parametru t
  2148: //(w obiegu CW)
  2149: //dla t=0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy.
  2150: //dla t>0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy o >= t.
  2151: bit Twyzsza(const unsigned char t)
  2152: {
  2153:         return (rgl.x_t<(-1*t));
  2154: }
  2155: //------------------------------------------------------------
  2156: //zwraca wartosc 1 jezeli temperatura = nastawa.
  2157: //(w obiegu CW)
  2158: bit Trowna(void)
  2159: {
  2160:         return !rgl.x_t;
  2161: }
  2162: //------------------------------------------------------------
  2163: //zwraca wartosc 1 przy stwierdzonym wzroscie temperatury
  2164: //(w obiegu CO)
  2165: //dla t=0 zwraca wartosc jeden przy dowolnym wzroscie temp.
  2166: //dla t>0 zwraca wartosc jeden przy wroscie > od t [C/sek].
  2167: bit TFrosnie(const unsigned char t)
  2168: {
  2169:         return (rgl.x_df>t);
  2170: }
  2171: //------------------------------------------------------------
  2172: //zwraca wartosc 1 przy stwierdzonym spadku temperatury
  2173: //(w obiegu CO)
  2174: //dla t=0 zwraca wartosc jeden przy dowolnym spadku temp.
  2175: //dla t>0 zwraca wartosc jeden przy spadku > od t [C/sek].
  2176: bit TFmaleje(const unsigned char t)
  2177: {
  2178:         return (rgl.x_df<(-1*t));
  2179: }
  2180: //------------------------------------------------------------
  2181: //zwraca wartosc 1 jezeli temperatura sie nie zmienia
  2182: //(w obiegu CO)
  2183: bit TFstoi(void)
  2184: {
  2185:         return !rgl.x_df;
  2186: }
  2187: //------------------------------------------------------------
  2188: //Restart procedury modulatora
  2189: void RestartMod(void)
  2190: {
  2191:         rgl.btco=0;
  2192:         rgl.btcw=0;
  2193:         rgl.fz=0;
  2194:         rgl.med_up=0;
  2195:         rgl.fast_up=0;
  2196:         rgl.nmod=0;
  2197:         rgl.del1s=0;
  2198:         rgl.deln1=0;
  2199:         rgl.inv_mod=0;
  2200: }
