Disassembly Listing for T02LED
Generated From:
C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/T02LED.X/dist/default/production/T02LED.X.production.elf
2015-09-21 10:14:28

---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/wsw.c  -----------------------------------
1:             /*---------------------------------------------------------------------------------*/
2:             /*wsw.c*/
3:             /*obsluga 2 cyfrowego wyswietlacza typu LED z czterema diodami sygnalizacyjnymi*/
4:             /*format wyswietlania typu ITALY*/
5:             /*
6:             UWAGA:
7:             1.Do modyfikacji danych wyswietlanych na kolejnych pozycjach tablicy priorytetow
8:             wyswietlania, nalezy stosowac funkcje:
9:             -SetData(...
10:            -SetStatus(...
11:            Funkcja SetStatus() daje ponadto mozliwosc modyfikacji stanu diod sygnalizacyjnych
12:            automatycznie przez aktywn¹ pozycje tablicy priorytetow wyswietlania.
13:            2.Aby zmienic stan diod sygnalizacyjnych niezaleznie od tablicy priorytetow wyswietlania
14:            nalezy bezwzglednie stosowac funkcje:
15:            -Swsdid(...
16:            -Rwsdid(...
17:            3.Z dowolna pozycja tablicy priorytetow wyswietlania zwiazana moze byc kolejka wyswietlania.
18:            Kolejka wyswietlania steruje sie za pomoc¹ funkcji:
19:            -GetPos(...
20:            -SetPoz(...
21:            -ResetPoz(...
22:            -ResetKol(...
23:            -RestartKol(...
24:            -AllKolToFirstPoz(...
25:             */
26:            /*---------------------------------------------------------------------------------*/
27:            #include <pic18.h>
28:            #include "global.h"				//parametry globalne
29:            #include "wsw.h"				//parametry lokalne
30:            /*---------------------------------------------------------------------------------*/
31:            #if NPWD!=0
32:            volatile WPack PWD[NPWD]; //tablica priorytetow wyswietlania PWD[n] (n=0 - najwyzszy priorytet)
33:            #endif
34:            #if NdPWD!=0
35:            volatile WPack DWD[NdPWD]; //tablica danych modyfikowanych dynamicznie wystepujacych wylacznie w kolejkach
36:            #endif
37:            
38:            volatile static WPack WswData; //dana z informacja o sposobie formatowania
39:            volatile static LedPack LedData; //dana po formatowaniu bezposrednio wysylana na wyswietlacz
40:            
41:            #if SER_WSW!=0 					//aktywny interfejs szeregowy?
42:            volatile static bit mux; //znacznik aktywnej cyfry
43:            volatile static unsigned char wbty[2]; //bajty rejestrow szeregowych wyswietlacza
44:            volatile static unsigned char wsdid; //slowo wysterowania kolenych diod sygnalizacyjnych
45:            //static unsigned char Dmask;		//maska rezerwacji diod sygnalizacyjnych dla potrzeb kolejki
46:            #endif
47:            /*---------------------------------------------------------------------------------*/
48:            
49:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
50:            void InitWsw(void)
51:            {
52:                unsigned char i;
53:            
54:            #if SER_WSW!=0		//aktywny interfejs szeregowy?
55:                _DTA = 0;
B92E  9284     BCF PORTE, 1, ACCESS
56:                _CLK = 0;
B930  9484     BCF PORTE, 2, ACCESS
57:                _STR = 0;
B932  9084     BCF PORTE, 0, ACCESS
58:            #if WKATODA==0
59:                wbty[0] = 0xff;
B934  0100     MOVLB 0x0
B936  69C5     SETF wbty, BANKED
60:                wbty[1] = 0xff;
B938  69C6     SETF 0xC6, BANKED
61:                wsdid = 0x00;
B93A  0100     MOVLB 0x0
B93C  6BCE     CLRF wsdid, BANKED
62:            #else
63:                wsdid = 0x00;
64:                wbty[0] = 0x00;
65:                wbty[1] = 0x00;
66:                wsdid = 0x0f;
67:            #endif
68:            #endif
69:            
70:                for(i = 0; i < NPWD - 1; i++) PWD[i].St.focus = 0;
B93E  6BE6     CLRF counter, BANKED
B940  0E08     MOVLW 0x8
B942  0100     MOVLB 0x0
B944  65E6     CPFSGT counter, BANKED
B946  D001     BRA 0xB94A
B948  D00D     BRA 0xB964
B94A  0100     MOVLB 0x0
B94C  51E6     MOVF counter, W, BANKED
B94E  0D04     MULLW 0x4
B950  0E44     MOVLW 0x44
B952  24F3     ADDWF PROD, W, ACCESS
B954  6ED9     MOVWF FSR2, ACCESS
B956  0E02     MOVLW 0x2
B958  20F4     ADDWFC PRODH, W, ACCESS
B95A  6EDA     MOVWF FSR2H, ACCESS
B95C  90DF     BCF INDF2, 0, ACCESS
B95E  0100     MOVLB 0x0
B960  2BE6     INCF counter, F, BANKED
B962  D7EE     BRA 0xB940
71:                //**********************
72:                //W tym miejscu nalezy wstepnie skonfigurowac wyswietlacz:
73:                //- ustawic format danych dla pozycji tablicy PWD nie zajmowanych przez kolejki
74:                //- ustawic format danych dla poszczegolnych pozycji tablicy DWD
75:                //--------
76:                //format zmiennych podstawowych umieszczonych w tablicy priorytetow wyswietlania
77:                SetStatus(&PWD[3], tDEC, tALL); //temp WG (dyzurna)
B964  0E50     MOVLW 0x50
B966  0100     MOVLB 0x0
B968  6FDE     MOVWF __pcstackBANK0, BANKED
B96A  0E02     MOVLW 0x2
B96C  6FDF     MOVWF pco, BANKED
B96E  0E40     MOVLW 0x40
B970  6FE1     MOVWF GIE_BIT_VAL, BANKED
B972  6BE0     CLRF bdat, BANKED
B974  0EFF     MOVLW 0xFF
B976  69E3     SETF a, BANKED
B978  69E2     SETF divisor, BANKED
B97A  ECE7     CALL 0x7BCE, 0
B97C  F03D     NOP
78:                SetStatus(&PWD[4], tDEC, tALL); //temp WU (dyzurna)
B97E  0E54     MOVLW 0x54
B980  0100     MOVLB 0x0
B982  6FDE     MOVWF __pcstackBANK0, BANKED
B984  0E02     MOVLW 0x2
B986  6FDF     MOVWF pco, BANKED
B988  0E40     MOVLW 0x40
B98A  6FE1     MOVWF GIE_BIT_VAL, BANKED
B98C  6BE0     CLRF bdat, BANKED
B98E  0EFF     MOVLW 0xFF
B990  69E3     SETF a, BANKED
B992  69E2     SETF divisor, BANKED
B994  ECE7     CALL 0x7BCE, 0
B996  F03D     NOP
79:                SetStatus(&PWD[5], tHEX, tALL); //stan OFF
B998  0E58     MOVLW 0x58
B99A  0100     MOVLB 0x0
B99C  6FDE     MOVWF __pcstackBANK0, BANKED
B99E  0E02     MOVLW 0x2
B9A0  6FDF     MOVWF pco, BANKED
B9A2  0E20     MOVLW 0x20
B9A4  6FE1     MOVWF GIE_BIT_VAL, BANKED
B9A6  6BE0     CLRF bdat, BANKED
B9A8  0EFF     MOVLW 0xFF
B9AA  69E3     SETF a, BANKED
B9AC  69E2     SETF divisor, BANKED
B9AE  ECE7     CALL 0x7BCE, 0
B9B0  F03D     NOP
80:                SetStatus(&PWD[6], tDEC | tKROPKA1, tALL); //cisnienie WG
B9B2  0E5C     MOVLW 0x5C
B9B4  0100     MOVLB 0x0
B9B6  6FDE     MOVWF __pcstackBANK0, BANKED
B9B8  0E02     MOVLW 0x2
B9BA  6FDF     MOVWF pco, BANKED
B9BC  0E44     MOVLW 0x44
B9BE  6FE1     MOVWF GIE_BIT_VAL, BANKED
B9C0  6BE0     CLRF bdat, BANKED
B9C2  0EFF     MOVLW 0xFF
B9C4  69E3     SETF a, BANKED
B9C6  69E2     SETF divisor, BANKED
B9C8  ECE7     CALL 0x7BCE, 0
B9CA  F03D     NOP
81:                SetStatus(&PWD[7], tDEC, tALL); //temp. WU
B9CC  0E60     MOVLW 0x60
B9CE  0100     MOVLB 0x0
B9D0  6FDE     MOVWF __pcstackBANK0, BANKED
B9D2  0E02     MOVLW 0x2
B9D4  6FDF     MOVWF pco, BANKED
B9D6  0E40     MOVLW 0x40
B9D8  6FE1     MOVWF GIE_BIT_VAL, BANKED
B9DA  6BE0     CLRF bdat, BANKED
B9DC  0EFF     MOVLW 0xFF
B9DE  69E3     SETF a, BANKED
B9E0  69E2     SETF divisor, BANKED
B9E2  ECE7     CALL 0x7BCE, 0
B9E4  F03D     NOP
82:                SetStatus(&PWD[8], tDEC, tALL); //temp. WG (najnizszy priorytet)
B9E6  0E64     MOVLW 0x64
B9E8  0100     MOVLB 0x0
B9EA  6FDE     MOVWF __pcstackBANK0, BANKED
B9EC  0E02     MOVLW 0x2
B9EE  6FDF     MOVWF pco, BANKED
B9F0  0E40     MOVLW 0x40
B9F2  6FE1     MOVWF GIE_BIT_VAL, BANKED
B9F4  6BE0     CLRF bdat, BANKED
B9F6  0EFF     MOVLW 0xFF
B9F8  69E3     SETF a, BANKED
B9FA  69E2     SETF divisor, BANKED
B9FC  ECE7     CALL 0x7BCE, 0
B9FE  F03D     NOP
83:                //w pozostalych umieszczone sa kolejki wyswietlania....
84:                //--------
85:                //zmienne dynamiczne wyst. wylacznie w kolejkach
86:                //format zmiennych
87:            
88:            }
BA00  0012     RETURN 0
89:            //-------------------------------------------------------------------
90:            //UWAGA: DALSZA CZESC DOTYCZY WYLACZNIE KOLEJEK WYSWIETLANIA						
91:            //***************************************************************************************
92:            #if NKOL!=0
93:            //PODSTAWOWE DANE KOLEJEK
94:            //***************************************************************************************
95:            //Kolejka KL0:
96:            //Tablica wskaznikow do danych na kolejnych pozycjach kolejek ktore maja zostac wyswietlone
97:            //Jezeli wskaznik = 0 dana pozycji pobierana jest z tablicy /KWrtPoz/ a jej format okreslony
98:            //jest w tablicy /KFrmPoz/.
99:            
100:           //kod awaryjny
101:           const KAdrPoz KL0_AP[NKL0] = {
102:               DWD,
103:               DWD + 1
104:           };
105:           //wartosci parametrow
106:           const KAdrPoz KL1_AP[NKL1] = {
107:               DWD + 2,
108:               DWD + 3
109:           };
110:           //nastawa WU/WG
111:           const KAdrPoz KL2_AP[NKL2] = {
112:               DWD + 4,
113:               DWD + 5
114:           };
115:           //kolejka procedur awaryjnych
116:           const KAdrPoz KL3_AP[NKL3] = {
117:               DWD + 6,
118:               DWD + 7
119:           };
120:           //**********************
121:           //Dane wyswietlane na kolejnych pozycjach kolejek. Dla kazdej pozycji skladaja sie na nie koleno:
122:           //[wartosc starszej cyfry(ignorowane gdy dec=1 lub hex=1),wartosc wyswietlana (dla dec=1 lub hex=1)
123:           //lub wartosc mlodszej cyfry (dla dec=0 oraz hex=0),czas jaki ma byc wyswietlana pozycja]
124:           //UWAGA: Jezeli ta sama pozycja w tablicy KAdrPoz ma wartosc rozna od 0 brany jest pod uwage tylko ostatni
125:           //parametr czasu przez jaki ma byc wyswietlana pozycja (reszta odczytywana jest pod adresem podanym w tablicy KAdrPoz).
126:           
127:           //*kolejka kodow awaryjnych						
128:           const KWrtPoz KL0_WP[NKL0] = {
129:               0, 0, 8, //6
130:               0, 0, 8
131:           };
132:           //wartosci parametrow
133:           const KWrtPoz KL1_WP[NKL1] = {
134:               0, 0, 6,
135:               0, 0, 6
136:           };
137:           //nastawa WU/WG							
138:           const KWrtPoz KL2_WP[NKL2] = {
139:               0, 0, 6,
140:               0, 0, 6
141:           };
142:           //kolejka procedur awaryjnych							
143:           const KWrtPoz KL3_WP[NKL3] = {
144:               0, 0, 30,
145:               0, 0, 20
146:           };
147:           //**********************
148:           //Format danych na kolejnych pozycjach kolejki. Na format pozycji skladaja sie kolejno:
149:           //[*,dec,hex,autoOFF,kropka0,kropka1,wygas0,wygas1]
150:           //UWAGA: Jezeli ta sama pozycja w tablicy KAdrPoz ma wartosc rozna od 0 powyzsze parametry 
151:           //nie sa brane pod uwage (odczytywane sa pod adresem podanym w tablicy KAdrPoz)
152:           
153:           //*kod bledu
154:           const KFrmPoz KL0_FP[NKL0] = {
155:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //nie brany pod uwage - dana umieszczona w DWD
156:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
157:           };
158:           //wartosci parametrow
159:           const KFrmPoz KL1_FP[NKL1] = {
160:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //nie brany pod uwage - dana umieszczona w DWD
161:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
162:           };
163:           //*nastawa WU/WG
164:           const KFrmPoz KL2_FP[NKL2] = {
165:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //nie brany pod uwage - dana umieszczona w DWD+1
166:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
167:           };
168:           //kolejka procedur awaryjnych
169:           const KFrmPoz KL3_FP[NKL3] = {
170:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //nie brany pod uwage - dana umieszczona w DWD+1
171:               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
172:           };
173:           //**********************
174:           //Dane okreslajace dla kazdej pozycji kolejki czy ma byc wyswietlana
175:           
176:           //*kod bledu
177:           //Jezeli zadna pozycja nie jest ustawiona na 1 to kolejka nie jest aktywna
178:           static KFocus KL0_FC[NKL0] = {
179:               0,
180:               0
181:           };
182:           //wartosci parametrow
183:           static KFocus KL1_FC[NKL1] = {
184:               0,
185:               0
186:           };
187:           //nastawa WU/WG
188:           static KFocus KL2_FC[NKL2] = {
189:               0,
190:               0
191:           };
192:           //kolejka procedur awaryjnych
193:           static KFocus KL3_FC[NKL3] = {
194:               0,
195:               0
196:           };
197:           //**********************
198:           //Adres pod ktory maja trafiac dane kolejki (najczesciej pozycja tablicy priorytetow wyswietlania PWD),
199:           //,czas ekspozycji kolejki (0 - ekspozycja ciagla),maska rezerwacji diod sygnalizacyjnych dla potrzeb kolejki
200:           
201:           const KOutput KL0_OUT = {PWD, 0, 0}; //kolejka kodow bledu trafia pod adres najwyzszego priorytetu, czas ekspozycji - ciagly,
202:           const KOutput KL1_OUT = {PWD + 1, 0, 0}; //kolejka wartosci parametru trafia pod adres priorytetu 2, czas ekspozycji - ciagly,
203:           const KOutput KL2_OUT = {PWD + 2, 4, 0}; //nastawa wyswietlana przez okreslony czas - priorytet 3, czas ekspozycji 4 sek.,
204:           const KOutput KL3_OUT = {PWD + 3, 0, 0}; //kolejka procedur awaryjnych
205:           //**********************														
206:           //Adresy danych skladajacych sie na kolejke 
207:           
208:           const Kolejka KL0 = {KL0_AP, KL0_WP, KL0_FP, KL0_FC, &KL0_OUT};
209:           const Kolejka KL1 = {KL1_AP, KL1_WP, KL1_FP, KL1_FC, &KL1_OUT};
210:           const Kolejka KL2 = {KL2_AP, KL2_WP, KL2_FP, KL2_FC, &KL2_OUT};
211:           const Kolejka KL3 = {KL3_AP, KL3_WP, KL3_FP, KL3_FC, &KL3_OUT};
212:           //***************************************************************************************
213:           //TABLICA OBSLUGI WSZYSTKICH KOLEJEK
214:           //NKOL - liczba kolejek
215:           //**********************
216:           //Podstawowe dane kolejki: adres kolejki, liczba pozycji kolejki
217:           const KGlobal Klj[NKOL] = {
218:               &KL0, NKL0,
219:               &KL1, NKL1,
220:               &KL2, NKL2,
221:               &KL3, NKL3
222:           };
223:           #endif
224:           //-------------------------------------------------------------------
225:           //-------------------------------------------------------------------							
226:           //PROCEDURY PUBLICZNE
227:           //-------------------------------------------------------------------
228:           /*Bezwarunkowe wygaszenie wyswietlacza*/
229:           //void WswOff(void)
230:           
231:           /*Wyjscie z bezwarunkowego wygaszenia wyswietlacza*/
232:           //void WswOn(void)
233:           
234:           /*Wyprowadzenie danej na wyswietlacz*/
235:           //void SetData(WPack *wData,unsigned char wdt1, unsigned char wdt0);
236:           
237:           /*Okreslenie formatu danej wysylanej na wyswietlacz*/
238:           //void SetStatus(WPack *wData,unsigned char wst,unsigned char mask);
239:           
240:           /*Aktywacja pozycji kolejki*/
241:           //void SetPoz(unsigned char nrkol,unsigned char nrpoz);
242:           
243:           /*Deaktywacja pozycji kolejki*/
244:           //void ResetPoz(unsigned char nrkol,unsigned char nrpoz);
245:           
246:           /*Deaktuwacja wszystkich pozycji kolejki*/
247:           //void ResetKol(unsigned char nrkol);
248:           
249:           /*Restart kolejki*/
250:           //void RestartKol(unsigned char nrkol);
251:           
252:           
253:           /*---------------------------------------------------------------------------------*/
254:           /*-----------------------------PROTECTED DATA--------------------------------------*/
255:           #if NKOL!=0
256:           static KIndeks KInd[NKOL];
257:           static KTime KTim[NKOL];
258:           #endif
259:           //-------------------------------------------------------------------
260:           //Tablica zamiany danej hex/dec na odpowiadajacy jej kod 7LED
261:           #if LTABLE==0
262:           const unsigned char Znak[16] = {//format danych dla wsp. anody
263:               0b11000000, //0
264:               0b11111001, //1
265:               0b10100100, //2
266:               0b10110000, //3
267:               0b10011001, //4
268:               0b10010010, //5
269:               0b10000010, //6
270:               0b11111000, //7
271:               0b10000000, //8
272:               0b10010000, //9
273:               0b10001000, //A
274:               0b10000011, //b
275:               0b11000110, //C
276:               0b10100001, //d
277:               0b10000110, //E
278:               0b10001110, //F
279:           };
280:           #endif
281:           //-------------------------------------------------------------------
282:           //Tablica zamiany danej hex/dec na odpowiadajacy jej kod 7LED
283:           #if LTABLE==1
284:           const unsigned char Znak[16] = {//format danych dla wsp. anody
285:               0b01010000, //0
286:               0b11111001, //1
287:               0b00110010, //2
288:               0b00110001, //3
289:               0b10011001, //4
290:               0b00010101, //5
291:               0b00010100, //6
292:               0b01111001, //7
293:               0b00010000, //8
294:               0b00010001, //9
295:               0b00011000, //A
296:               0b10010100, //b
297:               0b01010110, //C
298:               0b10110000, //d
299:               0b00010110, //E
300:               0b00011110, //F
301:           };
302:           #endif
303:           //-------------------------------------------------------------------
304:           //-------------------------------------------------------------------
305:           //Przygotowanie i wyslanie danej na wyswietlacz
306:           //Funkcja wywolywana w przerwaniu co 10ms.
307:           
308:           void RefreshWSW(void)
309:           {
310:           #if NKOL!=0	
311:               KolProc(); //obsluga kolejki wyswietlania
F298  EC62     CALL 0x10C4, 0
F29A  F008     NOP
312:           #endif
313:               SetPrWswData(); //pobranie danej PWD[n]i zapis do WswData
F29C  EC5B     CALL 0xDAB6, 0
F29E  F06D     NOP
314:               FormatWswData(); //konwersja wartosci WswData na LedData
F2A0  EC1C     CALL 0xAE38, 0
F2A2  F057     NOP
315:               PrintWswData(); //wyslanie danej LedData na wyswietlacz
F2A4  ECBE     CALL 0xB77C, 0
F2A6  F05B     NOP
316:           }
F2A8  0012     RETURN 0
317:           /*--------------------------------------------------------------*/
318:           //Proc. obslugi kolejek wyswietlania. Focus w tablicy priorytetow PWD jest przyznawany/odbierany
319:           //automatycznie jezeli przynajmniej jedna pozycja kolejki jest aktywna.
320:           #if NKOL!=0
321:           
322:           void KolProc(void)
323:           {
324:               unsigned char i, j, k, l, nC;
325:           
326:               for(j = 0; j < NKOL; j++)
10C4  0E00     MOVLW 0x0
10C6  6E24     MOVWF _DtCWf_err_CW, ACCESS
10C8  0E03     MOVLW 0x3
10CA  6424     CPFSGT _DtCWf_err_CW, ACCESS
10CC  D002     BRA 0x10D2
10CE  0C03     RETLW 0x3
10D0  0012     RETURN 0
1A42  2A24     INCF _DtCWf_err_CW, F, ACCESS
1A44  0E03     MOVLW 0x3
1A46  6424     CPFSGT _DtCWf_err_CW, ACCESS
1A48  EF69     GOTO 0x10D2
1A4A  F008     NOP
1A4C  0C03     RETLW 0x3
327:               {
328:                   nC = (*(*Klj[j].KL).KOut).nCykli;
10D2  5024     MOVF _DtCWf_err_CW, W, ACCESS
10D4  0D03     MULLW 0x3
10D6  0E45     MOVLW 0x45
10D8  24F3     ADDWF PROD, W, ACCESS
10DA  6EF6     MOVWF TBLPTR, ACCESS
10DC  0E10     MOVLW 0x10
10DE  20F4     ADDWFC PRODH, W, ACCESS
10E0  6EF7     MOVWF TBLPTRH, ACCESS
10E2  0009     TBLRD*+
10E4  CFF5     MOVFF TABLAT, _DtCOf_resPCO
10E6  F016     NOP
10E8  0009     TBLRD*+
10EA  CFF5     MOVFF TABLAT, _DtCOf_su_CO
10EC  F017     NOP
10EE  0E08     MOVLW 0x8
10F0  2616     ADDWF _DtCOf_resPCO, F, ACCESS
10F2  0E00     MOVLW 0x0
10F4  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
10F6  C016     MOVFF _DtCOf_resPCO, TBLPTR
10F8  FFF6     NOP
10FA  C017     MOVFF _DtCOf_su_CO, TBLPTRH
10FC  FFF7     NOP
10FE  0009     TBLRD*+
1100  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
1102  F018     NOP
1104  0009     TBLRD*+
1106  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1108  F019     NOP
110A  0E02     MOVLW 0x2
110C  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
110E  0E00     MOVLW 0x0
1110  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
1112  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1114  FFF6     NOP
1116  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1118  FFF7     NOP
111A  0008     TBLRD*
111C  CFF5     MOVFF TABLAT, _DtCWf_ad_CW
111E  F021     NOP
329:                   if((KInd[j].reset) || (nC && KTim[j].cykl >= nC)) //wylaczenie/minal czas ekspozycji kolejki?
1120  5024     MOVF _DtCWf_err_CW, W, ACCESS
1122  0D01     MULLW 0x1
1124  0E41     MOVLW 0x41
1126  24F3     ADDWF PROD, W, ACCESS
1128  6ED9     MOVWF FSR2, ACCESS
112A  0E01     MOVLW 0x1
112C  20F4     ADDWFC PRODH, W, ACCESS
112E  6EDA     MOVWF FSR2H, ACCESS
1130  B2DF     BTFSC INDF2, 1, ACCESS
1132  D011     BRA 0x1156
1134  5021     MOVF _DtCWf_ad_CW, W, ACCESS
1136  E05D     BZ 0x11F2
1138  5024     MOVF _DtCWf_err_CW, W, ACCESS
113A  0D03     MULLW 0x3
113C  0E02     MOVLW 0x2
113E  26F3     ADDWF PROD, F, ACCESS
1140  0E00     MOVLW 0x0
1142  22F4     ADDWFC PRODH, F, ACCESS
1144  0E38     MOVLW 0x38
1146  24F3     ADDWF PROD, W, ACCESS
1148  6ED9     MOVWF FSR2, ACCESS
114A  0E02     MOVLW 0x2
114C  20F4     ADDWFC PRODH, W, ACCESS
114E  6EDA     MOVWF FSR2H, ACCESS
1150  5021     MOVF _DtCWf_ad_CW, W, ACCESS
1152  5CDE     SUBWF POSTINC2, W, ACCESS
1154  E34E     BNC 0x11F2
330:                   { //dla kolejek z ogr. czasem eksp. po uplynieciu czasu deaktywowane sa wszystkie pozycje kol.
331:                       KTim[j].cykl = 0;
1156  5024     MOVF _DtCWf_err_CW, W, ACCESS
1158  0D03     MULLW 0x3
115A  0E02     MOVLW 0x2
115C  26F3     ADDWF PROD, F, ACCESS
115E  0E00     MOVLW 0x0
1160  22F4     ADDWFC PRODH, F, ACCESS
1162  0E38     MOVLW 0x38
1164  24F3     ADDWF PROD, W, ACCESS
1166  6ED9     MOVWF FSR2, ACCESS
1168  0E02     MOVLW 0x2
116A  20F4     ADDWFC PRODH, W, ACCESS
116C  6EDA     MOVWF FSR2H, ACCESS
116E  6ADF     CLRF INDF2, ACCESS
332:                       KInd[j].reset = 0;
1170  5024     MOVF _DtCWf_err_CW, W, ACCESS
1172  0D01     MULLW 0x1
1174  0E41     MOVLW 0x41
1176  24F3     ADDWF PROD, W, ACCESS
1178  6ED9     MOVWF FSR2, ACCESS
117A  0E01     MOVLW 0x1
117C  20F4     ADDWFC PRODH, W, ACCESS
117E  6EDA     MOVWF FSR2H, ACCESS
1180  0101     MOVLB 0x1
1182  92DF     BCF INDF2, 1, ACCESS
333:                       for(i = 0; i < Klj[j].nPzc; i++) (*Klj[j].KL).KFc[i].focus = 0;
1184  6A23     CLRF _DtCWf_cold_CW, ACCESS
1186  D023     BRA 0x11CE
1188  5024     MOVF _DtCWf_err_CW, W, ACCESS
118A  0D03     MULLW 0x3
118C  0E45     MOVLW 0x45
118E  24F3     ADDWF PROD, W, ACCESS
1190  6EF6     MOVWF TBLPTR, ACCESS
1192  0E10     MOVLW 0x10
1194  20F4     ADDWFC PRODH, W, ACCESS
1196  6EF7     MOVWF TBLPTRH, ACCESS
1198  0009     TBLRD*+
119A  CFF5     MOVFF TABLAT, _DtCOf_resPCO
119C  F016     NOP
119E  0009     TBLRD*+
11A0  CFF5     MOVFF TABLAT, _DtCOf_su_CO
11A2  F017     NOP
11A4  0E06     MOVLW 0x6
11A6  2616     ADDWF _DtCOf_resPCO, F, ACCESS
11A8  0E00     MOVLW 0x0
11AA  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
11AC  C016     MOVFF _DtCOf_resPCO, TBLPTR
11AE  FFF6     NOP
11B0  C017     MOVFF _DtCOf_su_CO, TBLPTRH
11B2  FFF7     NOP
11B4  5023     MOVF _DtCWf_cold_CW, W, ACCESS
11B6  0D01     MULLW 0x1
11B8  50F3     MOVF PROD, W, ACCESS
11BA  0009     TBLRD*+
11BC  24F5     ADDWF TABLAT, W, ACCESS
11BE  6ED9     MOVWF FSR2, ACCESS
11C0  50F4     MOVF PRODH, W, ACCESS
11C2  0009     TBLRD*+
11C4  20F5     ADDWFC TABLAT, W, ACCESS
11C6  6EDA     MOVWF FSR2H, ACCESS
11C8  90DF     BCF INDF2, 0, ACCESS
11CA  2A23     INCF _DtCWf_cold_CW, F, ACCESS
11CC  D000     BRA 0x11CE
11CE  5024     MOVF _DtCWf_err_CW, W, ACCESS
11D0  0D03     MULLW 0x3
11D2  0E02     MOVLW 0x2
11D4  26F3     ADDWF PROD, F, ACCESS
11D6  0E00     MOVLW 0x0
11D8  22F4     ADDWFC PRODH, F, ACCESS
11DA  0E45     MOVLW 0x45
11DC  24F3     ADDWF PROD, W, ACCESS
11DE  6EF6     MOVWF TBLPTR, ACCESS
11E0  0E10     MOVLW 0x10
11E2  20F4     ADDWFC PRODH, W, ACCESS
11E4  6EF7     MOVWF TBLPTRH, ACCESS
11E6  0009     TBLRD*+
11E8  50F5     MOVF TABLAT, W, ACCESS
11EA  5C23     SUBWF _DtCWf_cold_CW, W, ACCESS
11EC  E202     BC 0x11F2
11EE  D7CC     BRA 0x1188
11F0  D000     BRA 0x11F2
334:                   }
335:                   if(KInd[j].restart && nC) //start kolejki z okreslonym czasem eksp.?
11F2  5024     MOVF _DtCWf_err_CW, W, ACCESS
11F4  0D01     MULLW 0x1
11F6  0E41     MOVLW 0x41
11F8  24F3     ADDWF PROD, W, ACCESS
11FA  6ED9     MOVWF FSR2, ACCESS
11FC  0E01     MOVLW 0x1
11FE  20F4     ADDWFC PRODH, W, ACCESS
1200  6EDA     MOVWF FSR2H, ACCESS
1202  0101     MOVLB 0x1
1204  A0DF     BTFSS INDF2, 0, ACCESS
1206  D046     BRA 0x1294
1208  5021     MOVF _DtCWf_ad_CW, W, ACCESS
120A  E044     BZ 0x1294
336:                   {
337:                       KTim[j].cykl = 0;
120C  5024     MOVF _DtCWf_err_CW, W, ACCESS
120E  0D03     MULLW 0x3
1210  0E02     MOVLW 0x2
1212  26F3     ADDWF PROD, F, ACCESS
1214  0E00     MOVLW 0x0
1216  22F4     ADDWFC PRODH, F, ACCESS
1218  0E38     MOVLW 0x38
121A  24F3     ADDWF PROD, W, ACCESS
121C  6ED9     MOVWF FSR2, ACCESS
121E  0E02     MOVLW 0x2
1220  20F4     ADDWFC PRODH, W, ACCESS
1222  6EDA     MOVWF FSR2H, ACCESS
1224  6ADF     CLRF INDF2, ACCESS
338:                       for(i = 0; i < Klj[j].nPzc; i++) (*Klj[j].KL).KFc[i].focus = 1; //dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.
1226  6A23     CLRF _DtCWf_cold_CW, ACCESS
1228  D023     BRA 0x1270
122A  5024     MOVF _DtCWf_err_CW, W, ACCESS
122C  0D03     MULLW 0x3
122E  0E45     MOVLW 0x45
1230  24F3     ADDWF PROD, W, ACCESS
1232  6EF6     MOVWF TBLPTR, ACCESS
1234  0E10     MOVLW 0x10
1236  20F4     ADDWFC PRODH, W, ACCESS
1238  6EF7     MOVWF TBLPTRH, ACCESS
123A  0009     TBLRD*+
123C  CFF5     MOVFF TABLAT, _DtCOf_resPCO
123E  F016     NOP
1240  0009     TBLRD*+
1242  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1244  F017     NOP
1246  0E06     MOVLW 0x6
1248  2616     ADDWF _DtCOf_resPCO, F, ACCESS
124A  0E00     MOVLW 0x0
124C  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
124E  C016     MOVFF _DtCOf_resPCO, TBLPTR
1250  FFF6     NOP
1252  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1254  FFF7     NOP
1256  5023     MOVF _DtCWf_cold_CW, W, ACCESS
1258  0D01     MULLW 0x1
125A  50F3     MOVF PROD, W, ACCESS
125C  0009     TBLRD*+
125E  24F5     ADDWF TABLAT, W, ACCESS
1260  6ED9     MOVWF FSR2, ACCESS
1262  50F4     MOVF PRODH, W, ACCESS
1264  0009     TBLRD*+
1266  20F5     ADDWFC TABLAT, W, ACCESS
1268  6EDA     MOVWF FSR2H, ACCESS
126A  80DF     BSF INDF2, 0, ACCESS
126C  2A23     INCF _DtCWf_cold_CW, F, ACCESS
126E  D000     BRA 0x1270
1270  5024     MOVF _DtCWf_err_CW, W, ACCESS
1272  0D03     MULLW 0x3
1274  0E02     MOVLW 0x2
1276  26F3     ADDWF PROD, F, ACCESS
1278  0E00     MOVLW 0x0
127A  22F4     ADDWFC PRODH, F, ACCESS
127C  0E45     MOVLW 0x45
127E  24F3     ADDWF PROD, W, ACCESS
1280  6EF6     MOVWF TBLPTR, ACCESS
1282  0E10     MOVLW 0x10
1284  20F4     ADDWFC PRODH, W, ACCESS
1286  6EF7     MOVWF TBLPTRH, ACCESS
1288  0009     TBLRD*+
128A  50F5     MOVF TABLAT, W, ACCESS
128C  5C23     SUBWF _DtCWf_cold_CW, W, ACCESS
128E  E202     BC 0x1294
1290  D7CC     BRA 0x122A
1292  D000     BRA 0x1294
339:                   }
340:                   if(KInd[j].restart || !((*(*(*Klj[j].KL).KOut).CAdr).St.focus)) //kolejka nieaktywna lub restart kolejki?
1294  5024     MOVF _DtCWf_err_CW, W, ACCESS
1296  0D01     MULLW 0x1
1298  0E41     MOVLW 0x41
129A  24F3     ADDWF PROD, W, ACCESS
129C  6ED9     MOVWF FSR2, ACCESS
129E  0E01     MOVLW 0x1
12A0  20F4     ADDWFC PRODH, W, ACCESS
12A2  6EDA     MOVWF FSR2H, ACCESS
12A4  0101     MOVLB 0x1
12A6  B0DF     BTFSC INDF2, 0, ACCESS
12A8  D028     BRA 0x12FA
12AA  5024     MOVF _DtCWf_err_CW, W, ACCESS
12AC  0D03     MULLW 0x3
12AE  0E45     MOVLW 0x45
12B0  24F3     ADDWF PROD, W, ACCESS
12B2  6EF6     MOVWF TBLPTR, ACCESS
12B4  0E10     MOVLW 0x10
12B6  20F4     ADDWFC PRODH, W, ACCESS
12B8  6EF7     MOVWF TBLPTRH, ACCESS
12BA  0009     TBLRD*+
12BC  CFF5     MOVFF TABLAT, _DtCOf_resPCO
12BE  F016     NOP
12C0  0009     TBLRD*+
12C2  CFF5     MOVFF TABLAT, _DtCOf_su_CO
12C4  F017     NOP
12C6  0E08     MOVLW 0x8
12C8  2616     ADDWF _DtCOf_resPCO, F, ACCESS
12CA  0E00     MOVLW 0x0
12CC  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
12CE  C016     MOVFF _DtCOf_resPCO, TBLPTR
12D0  FFF6     NOP
12D2  C017     MOVFF _DtCOf_su_CO, TBLPTRH
12D4  FFF7     NOP
12D6  0009     TBLRD*+
12D8  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
12DA  F018     NOP
12DC  0009     TBLRD*+
12DE  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
12E0  F019     NOP
12E2  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
12E4  FFF6     NOP
12E6  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
12E8  FFF7     NOP
12EA  0009     TBLRD*+
12EC  CFF5     MOVFF TABLAT, FSR2
12EE  FFD9     NOP
12F0  0009     TBLRD*+
12F2  CFF5     MOVFF TABLAT, FSR2H
12F4  FFDA     NOP
12F6  B0DF     BTFSC INDF2, 0, ACCESS
12F8  D030     BRA 0x135A
341:                   {
342:                       KInd[j].restart = 0;
12FA  5024     MOVF _DtCWf_err_CW, W, ACCESS
12FC  0D01     MULLW 0x1
12FE  0E41     MOVLW 0x41
1300  24F3     ADDWF PROD, W, ACCESS
1302  6ED9     MOVWF FSR2, ACCESS
1304  0E01     MOVLW 0x1
1306  20F4     ADDWFC PRODH, W, ACCESS
1308  6EDA     MOVWF FSR2H, ACCESS
130A  0101     MOVLB 0x1
130C  90DF     BCF INDF2, 0, ACCESS
343:           #if RSNFRS!=0
344:                       if(!nC)
130E  5021     MOVF _DtCWf_ad_CW, W, ACCESS
1310  E124     BNZ 0x135A
345:                       {
346:                           KInd[j].indeks = 0;
1312  5024     MOVF _DtCWf_err_CW, W, ACCESS
1314  0D01     MULLW 0x1
1316  0E41     MOVLW 0x41
1318  24F3     ADDWF PROD, W, ACCESS
131A  6ED9     MOVWF FSR2, ACCESS
131C  0E01     MOVLW 0x1
131E  20F4     ADDWFC PRODH, W, ACCESS
1320  6EDA     MOVWF FSR2H, ACCESS
1322  94DF     BCF INDF2, 2, ACCESS
1324  96DF     BCF INDF2, 3, ACCESS
1326  98DF     BCF INDF2, 4, ACCESS
1328  9ADF     BCF INDF2, 5, ACCESS
132A  9CDF     BCF INDF2, 6, ACCESS
132C  9EDF     BCF INDF2, 7, ACCESS
347:                           KTim[j].ncS = 0;
132E  5024     MOVF _DtCWf_err_CW, W, ACCESS
1330  0D03     MULLW 0x3
1332  0E38     MOVLW 0x38
1334  24F3     ADDWF PROD, W, ACCESS
1336  6ED9     MOVWF FSR2, ACCESS
1338  0E02     MOVLW 0x2
133A  20F4     ADDWFC PRODH, W, ACCESS
133C  6EDA     MOVWF FSR2H, ACCESS
133E  6ADF     CLRF INDF2, ACCESS
348:                           KTim[j].ndS = 0;
1340  5024     MOVF _DtCWf_err_CW, W, ACCESS
1342  0D03     MULLW 0x3
1344  2AF3     INCF PROD, F, ACCESS
1346  0E00     MOVLW 0x0
1348  22F4     ADDWFC PRODH, F, ACCESS
134A  0E38     MOVLW 0x38
134C  24F3     ADDWF PROD, W, ACCESS
134E  6ED9     MOVWF FSR2, ACCESS
1350  0E02     MOVLW 0x2
1352  20F4     ADDWFC PRODH, W, ACCESS
1354  6EDA     MOVWF FSR2H, ACCESS
1356  6ADF     CLRF INDF2, ACCESS
349:                       }
1358  D000     BRA 0x135A
350:           #else
351:                       KInd[j].indeks = 0;
352:                       KTim[j].ncS = 0;
353:                       KTim[j].ndS = 0;
354:           #endif
355:                   }
356:                   (*(*(*Klj[j].KL).KOut).CAdr).St.focus = 0; //wstepna deaktywacja calej kolejki w tablicy priorytetow wyswietlania PWD
135A  5024     MOVF _DtCWf_err_CW, W, ACCESS
135C  0D03     MULLW 0x3
135E  0E45     MOVLW 0x45
1360  24F3     ADDWF PROD, W, ACCESS
1362  6EF6     MOVWF TBLPTR, ACCESS
1364  0E10     MOVLW 0x10
1366  20F4     ADDWFC PRODH, W, ACCESS
1368  6EF7     MOVWF TBLPTRH, ACCESS
136A  0009     TBLRD*+
136C  CFF5     MOVFF TABLAT, _DtCOf_resPCO
136E  F016     NOP
1370  0009     TBLRD*+
1372  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1374  F017     NOP
1376  0E08     MOVLW 0x8
1378  2616     ADDWF _DtCOf_resPCO, F, ACCESS
137A  0E00     MOVLW 0x0
137C  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
137E  C016     MOVFF _DtCOf_resPCO, TBLPTR
1380  FFF6     NOP
1382  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1384  FFF7     NOP
1386  0009     TBLRD*+
1388  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
138A  F018     NOP
138C  0009     TBLRD*+
138E  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1390  F019     NOP
1392  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1394  FFF6     NOP
1396  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1398  FFF7     NOP
139A  0009     TBLRD*+
139C  CFF5     MOVFF TABLAT, FSR2
139E  FFD9     NOP
13A0  0009     TBLRD*+
13A2  CFF5     MOVFF TABLAT, FSR2H
13A4  FFDA     NOP
13A6  90DF     BCF INDF2, 0, ACCESS
357:                   for(i = KInd[j].indeks; i < Klj[j].nPzc; i++) //autoaktywacja kolejki nastapi przy aktywnej conajmniej jednej pozycji w kol.
13A8  5024     MOVF _DtCWf_err_CW, W, ACCESS
13AA  0D01     MULLW 0x1
13AC  0E41     MOVLW 0x41
13AE  24F3     ADDWF PROD, W, ACCESS
13B0  6ED9     MOVWF FSR2, ACCESS
13B2  0E01     MOVLW 0x1
13B4  20F4     ADDWFC PRODH, W, ACCESS
13B6  6EDA     MOVWF FSR2H, ACCESS
13B8  0101     MOVLB 0x1
13BA  30DF     RRCF INDF2, W, ACCESS
13BC  32E8     RRCF WREG, F, ACCESS
13BE  0B3F     ANDLW 0x3F
13C0  6E23     MOVWF _DtCWf_cold_CW, ACCESS
13C2  D32E     BRA 0x1A20
1A1C  2A23     INCF _DtCWf_cold_CW, F, ACCESS
1A1E  D000     BRA 0x1A20
1A20  5024     MOVF _DtCWf_err_CW, W, ACCESS
1A22  0D03     MULLW 0x3
1A24  0E02     MOVLW 0x2
1A26  26F3     ADDWF PROD, F, ACCESS
1A28  0E00     MOVLW 0x0
1A2A  22F4     ADDWFC PRODH, F, ACCESS
1A2C  0E45     MOVLW 0x45
1A2E  24F3     ADDWF PROD, W, ACCESS
1A30  6EF6     MOVWF TBLPTR, ACCESS
1A32  0E10     MOVLW 0x10
1A34  20F4     ADDWFC PRODH, W, ACCESS
1A36  6EF7     MOVWF TBLPTRH, ACCESS
1A38  0009     TBLRD*+
1A3A  50F5     MOVF TABLAT, W, ACCESS
1A3C  5C23     SUBWF _DtCWf_cold_CW, W, ACCESS
1A3E  E201     BC 0x1A42
1A40  D4C1     BRA 0x13C4
358:                   {
359:                       //poszukuj kolejke o aktywnej przynajmniej jednej pozycji
360:                       if(!(*Klj[j].KL).KFc[i].focus) //pozycja nieaktywna?
13C4  5024     MOVF _DtCWf_err_CW, W, ACCESS
13C6  0D03     MULLW 0x3
13C8  0E45     MOVLW 0x45
13CA  24F3     ADDWF PROD, W, ACCESS
13CC  6EF6     MOVWF TBLPTR, ACCESS
13CE  0E10     MOVLW 0x10
13D0  20F4     ADDWFC PRODH, W, ACCESS
13D2  6EF7     MOVWF TBLPTRH, ACCESS
13D4  0009     TBLRD*+
13D6  CFF5     MOVFF TABLAT, _DtCOf_resPCO
13D8  F016     NOP
13DA  0009     TBLRD*+
13DC  CFF5     MOVFF TABLAT, _DtCOf_su_CO
13DE  F017     NOP
13E0  0E06     MOVLW 0x6
13E2  2616     ADDWF _DtCOf_resPCO, F, ACCESS
13E4  0E00     MOVLW 0x0
13E6  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
13E8  C016     MOVFF _DtCOf_resPCO, TBLPTR
13EA  FFF6     NOP
13EC  C017     MOVFF _DtCOf_su_CO, TBLPTRH
13EE  FFF7     NOP
13F0  5023     MOVF _DtCWf_cold_CW, W, ACCESS
13F2  0D01     MULLW 0x1
13F4  50F3     MOVF PROD, W, ACCESS
13F6  0009     TBLRD*+
13F8  24F5     ADDWF TABLAT, W, ACCESS
13FA  6ED9     MOVWF FSR2, ACCESS
13FC  50F4     MOVF PRODH, W, ACCESS
13FE  0009     TBLRD*+
1400  20F5     ADDWFC TABLAT, W, ACCESS
1402  6EDA     MOVWF FSR2H, ACCESS
1404  B0DF     BTFSC INDF2, 0, ACCESS
1406  D033     BRA 0x146E
361:                       {
362:                           if(i >= Klj[j].nPzc - 1)
1408  6816     SETF _DtCOf_resPCO, ACCESS
140A  6817     SETF _DtCOf_su_CO, ACCESS
140C  5024     MOVF _DtCWf_err_CW, W, ACCESS
140E  0D03     MULLW 0x3
1410  0E02     MOVLW 0x2
1412  26F3     ADDWF PROD, F, ACCESS
1414  0E00     MOVLW 0x0
1416  22F4     ADDWFC PRODH, F, ACCESS
1418  0E45     MOVLW 0x45
141A  24F3     ADDWF PROD, W, ACCESS
141C  6EF6     MOVWF TBLPTR, ACCESS
141E  0E10     MOVLW 0x10
1420  20F4     ADDWFC PRODH, W, ACCESS
1422  6EF7     MOVWF TBLPTRH, ACCESS
1424  0008     TBLRD*
1426  50F5     MOVF TABLAT, W, ACCESS
1428  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
142A  6A19     CLRF _DtCOf_su_SRW_CO, ACCESS
142C  5016     MOVF _DtCOf_resPCO, W, ACCESS
142E  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
1430  5017     MOVF _DtCOf_su_CO, W, ACCESS
1432  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
1434  5023     MOVF _DtCWf_cold_CW, W, ACCESS
1436  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1438  6A1B     CLRF _DtCSf_error, ACCESS
143A  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
143C  5C1A     SUBWF _DtCOf_zroPCO, W, ACCESS
143E  501B     MOVF _DtCSf_error, W, ACCESS
1440  0A80     XORLW 0x80
1442  6E1C     MOVWF _DtCSf_hi, ACCESS
1444  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
1446  0A80     XORLW 0x80
1448  581C     SUBWFB _DtCSf_hi, W, ACCESS
144A  E201     BC 0x144E
144C  D2E7     BRA 0x1A1C
363:                           {
364:                               KInd[j].indeks = 0;
144E  5024     MOVF _DtCWf_err_CW, W, ACCESS
1450  0D01     MULLW 0x1
1452  0E41     MOVLW 0x41
1454  24F3     ADDWF PROD, W, ACCESS
1456  6ED9     MOVWF FSR2, ACCESS
1458  0E01     MOVLW 0x1
145A  20F4     ADDWFC PRODH, W, ACCESS
145C  6EDA     MOVWF FSR2H, ACCESS
145E  94DF     BCF INDF2, 2, ACCESS
1460  96DF     BCF INDF2, 3, ACCESS
1462  98DF     BCF INDF2, 4, ACCESS
1464  9ADF     BCF INDF2, 5, ACCESS
1466  9CDF     BCF INDF2, 6, ACCESS
1468  9EDF     BCF INDF2, 7, ACCESS
365:                               if(nC) KTim[j].cykl++;
146A  D2C8     BRA 0x19FC
366:                           }
367:                           continue;
146C  D2D7     BRA 0x1A1C
368:                       }
369:                       //znaleziono kolejke o aktywnej przynajmniej jednej pozycji
370:                       KInd[j].indeks = i; //zapamietaj nr aktualnie wyswietlanej pozycji
146E  C023     MOVFF _DtCWf_cold_CW, _DtCOf_resPCO
1470  F016     NOP
1472  5024     MOVF _DtCWf_err_CW, W, ACCESS
1474  0D01     MULLW 0x1
1476  0E41     MOVLW 0x41
1478  24F3     ADDWF PROD, W, ACCESS
147A  6ED9     MOVWF FSR2, ACCESS
147C  0E01     MOVLW 0x1
147E  20F4     ADDWFC PRODH, W, ACCESS
1480  6EDA     MOVWF FSR2H, ACCESS
1482  4616     RLNCF _DtCOf_resPCO, F, ACCESS
1484  4616     RLNCF _DtCOf_resPCO, F, ACCESS
1486  50DF     MOVF INDF2, W, ACCESS
1488  1816     XORWF _DtCOf_resPCO, W, ACCESS
148A  0B03     ANDLW 0x3
148C  1816     XORWF _DtCOf_resPCO, W, ACCESS
148E  0101     MOVLB 0x1
1490  6EDF     MOVWF INDF2, ACCESS
371:           #if DKLPNC!=0
372:                       //deaktywuj wszystkie pozycje kolejek o nizszym priorytecie i ograniczonym czasie ekspozycji kolejki
373:                       for(k = j + 1; k < NKOL; k++)
1492  2824     INCF _DtCWf_err_CW, W, ACCESS
1494  6E22     MOVWF _DtCWf_ad_DZ_CW, ACCESS
1496  0E03     MOVLW 0x3
1498  6422     CPFSGT _DtCWf_ad_DZ_CW, ACCESS
149A  D001     BRA 0x149E
149C  D06C     BRA 0x1576
1572  2A22     INCF _DtCWf_ad_DZ_CW, F, ACCESS
1574  D790     BRA 0x1496
374:                           if((*(*Klj[k].KL).KOut).nCykli) //okreslony czas ekspozycji?
149E  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
14A0  0D03     MULLW 0x3
14A2  0E45     MOVLW 0x45
14A4  24F3     ADDWF PROD, W, ACCESS
14A6  6EF6     MOVWF TBLPTR, ACCESS
14A8  0E10     MOVLW 0x10
14AA  20F4     ADDWFC PRODH, W, ACCESS
14AC  6EF7     MOVWF TBLPTRH, ACCESS
14AE  0009     TBLRD*+
14B0  CFF5     MOVFF TABLAT, _DtCOf_resPCO
14B2  F016     NOP
14B4  0009     TBLRD*+
14B6  CFF5     MOVFF TABLAT, _DtCOf_su_CO
14B8  F017     NOP
14BA  0E08     MOVLW 0x8
14BC  2616     ADDWF _DtCOf_resPCO, F, ACCESS
14BE  0E00     MOVLW 0x0
14C0  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
14C2  C016     MOVFF _DtCOf_resPCO, TBLPTR
14C4  FFF6     NOP
14C6  C017     MOVFF _DtCOf_su_CO, TBLPTRH
14C8  FFF7     NOP
14CA  0009     TBLRD*+
14CC  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
14CE  F018     NOP
14D0  0009     TBLRD*+
14D2  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
14D4  F019     NOP
14D6  0E02     MOVLW 0x2
14D8  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
14DA  0E00     MOVLW 0x0
14DC  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
14DE  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
14E0  FFF6     NOP
14E2  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
14E4  FFF7     NOP
14E6  0008     TBLRD*
14E8  50F5     MOVF TABLAT, W, ACCESS
14EA  E043     BZ 0x1572
375:                           {
376:                               for(l = 0; l < Klj[k].nPzc; l++) (*Klj[k].KL).KFc[l].focus = 0; //wylacz wszystkie pozycje kolejki
14EC  6A20     CLRF _DtCSf_work, ACCESS
14EE  D023     BRA 0x1536
14F0  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
14F2  0D03     MULLW 0x3
14F4  0E45     MOVLW 0x45
14F6  24F3     ADDWF PROD, W, ACCESS
14F8  6EF6     MOVWF TBLPTR, ACCESS
14FA  0E10     MOVLW 0x10
14FC  20F4     ADDWFC PRODH, W, ACCESS
14FE  6EF7     MOVWF TBLPTRH, ACCESS
1500  0009     TBLRD*+
1502  CFF5     MOVFF TABLAT, _DtCOf_resPCO
1504  F016     NOP
1506  0009     TBLRD*+
1508  CFF5     MOVFF TABLAT, _DtCOf_su_CO
150A  F017     NOP
150C  0E06     MOVLW 0x6
150E  2616     ADDWF _DtCOf_resPCO, F, ACCESS
1510  0E00     MOVLW 0x0
1512  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
1514  C016     MOVFF _DtCOf_resPCO, TBLPTR
1516  FFF6     NOP
1518  C017     MOVFF _DtCOf_su_CO, TBLPTRH
151A  FFF7     NOP
151C  5020     MOVF _DtCSf_work, W, ACCESS
151E  0D01     MULLW 0x1
1520  50F3     MOVF PROD, W, ACCESS
1522  0009     TBLRD*+
1524  24F5     ADDWF TABLAT, W, ACCESS
1526  6ED9     MOVWF FSR2, ACCESS
1528  50F4     MOVF PRODH, W, ACCESS
152A  0009     TBLRD*+
152C  20F5     ADDWFC TABLAT, W, ACCESS
152E  6EDA     MOVWF FSR2H, ACCESS
1530  90DF     BCF INDF2, 0, ACCESS
1532  2A20     INCF _DtCSf_work, F, ACCESS
1534  D000     BRA 0x1536
1536  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
1538  0D03     MULLW 0x3
153A  0E02     MOVLW 0x2
153C  26F3     ADDWF PROD, F, ACCESS
153E  0E00     MOVLW 0x0
1540  22F4     ADDWFC PRODH, F, ACCESS
1542  0E45     MOVLW 0x45
1544  24F3     ADDWF PROD, W, ACCESS
1546  6EF6     MOVWF TBLPTR, ACCESS
1548  0E10     MOVLW 0x10
154A  20F4     ADDWFC PRODH, W, ACCESS
154C  6EF7     MOVWF TBLPTRH, ACCESS
154E  0009     TBLRD*+
1550  50F5     MOVF TABLAT, W, ACCESS
1552  5C20     SUBWF _DtCSf_work, W, ACCESS
1554  E3CD     BNC 0x14F0
377:                               KTim[k].cykl = 0;
1556  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
1558  0D03     MULLW 0x3
155A  0E02     MOVLW 0x2
155C  26F3     ADDWF PROD, F, ACCESS
155E  0E00     MOVLW 0x0
1560  22F4     ADDWFC PRODH, F, ACCESS
1562  0E38     MOVLW 0x38
1564  24F3     ADDWF PROD, W, ACCESS
1566  6ED9     MOVWF FSR2, ACCESS
1568  0E02     MOVLW 0x2
156A  20F4     ADDWFC PRODH, W, ACCESS
156C  6EDA     MOVWF FSR2H, ACCESS
156E  6ADF     CLRF INDF2, ACCESS
1570  D000     BRA 0x1572
378:                           }
379:           #endif
380:           #if RSAKLP!=0
381:                       //zatrzymanie wszystkich kolejek (o nizszym priorytecie od obecnie wyswietlanej) na pierwszej pozycji (autorestart)
382:                       for(k = j + 1; k < NKOL; k++)
1576  2824     INCF _DtCWf_err_CW, W, ACCESS
1578  6E22     MOVWF _DtCWf_ad_DZ_CW, ACCESS
157A  0E03     MOVLW 0x3
157C  6422     CPFSGT _DtCWf_ad_DZ_CW, ACCESS
157E  D001     BRA 0x1582
1580  D025     BRA 0x15CC
15C8  2A22     INCF _DtCWf_ad_DZ_CW, F, ACCESS
15CA  D7D7     BRA 0x157A
383:                       {
384:                           KInd[k].indeks = 0;
1582  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
1584  0D01     MULLW 0x1
1586  0E41     MOVLW 0x41
1588  24F3     ADDWF PROD, W, ACCESS
158A  6ED9     MOVWF FSR2, ACCESS
158C  0E01     MOVLW 0x1
158E  20F4     ADDWFC PRODH, W, ACCESS
1590  6EDA     MOVWF FSR2H, ACCESS
1592  94DF     BCF INDF2, 2, ACCESS
1594  96DF     BCF INDF2, 3, ACCESS
1596  98DF     BCF INDF2, 4, ACCESS
1598  9ADF     BCF INDF2, 5, ACCESS
159A  9CDF     BCF INDF2, 6, ACCESS
159C  9EDF     BCF INDF2, 7, ACCESS
385:                           KTim[k].ncS = 0;
159E  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
15A0  0D03     MULLW 0x3
15A2  0E38     MOVLW 0x38
15A4  24F3     ADDWF PROD, W, ACCESS
15A6  6ED9     MOVWF FSR2, ACCESS
15A8  0E02     MOVLW 0x2
15AA  20F4     ADDWFC PRODH, W, ACCESS
15AC  6EDA     MOVWF FSR2H, ACCESS
15AE  6ADF     CLRF INDF2, ACCESS
386:                           KTim[k].ndS = 0;
15B0  5022     MOVF _DtCWf_ad_DZ_CW, W, ACCESS
15B2  0D03     MULLW 0x3
15B4  2AF3     INCF PROD, F, ACCESS
15B6  0E00     MOVLW 0x0
15B8  22F4     ADDWFC PRODH, F, ACCESS
15BA  0E38     MOVLW 0x38
15BC  24F3     ADDWF PROD, W, ACCESS
15BE  6ED9     MOVWF FSR2, ACCESS
15C0  0E02     MOVLW 0x2
15C2  20F4     ADDWFC PRODH, W, ACCESS
15C4  6EDA     MOVWF FSR2H, ACCESS
15C6  6ADF     CLRF INDF2, ACCESS
387:                       }
388:           #endif
389:                       //realizacja czasu ekspozycji pojedynczej pozycji kolejki
390:                       (*(*(*Klj[j].KL).KOut).CAdr).St.focus = 1; //autoaktywacja kolejki - aktywna conajmniej jedna pozycja w kol.
15CC  5024     MOVF _DtCWf_err_CW, W, ACCESS
15CE  0D03     MULLW 0x3
15D0  0E45     MOVLW 0x45
15D2  24F3     ADDWF PROD, W, ACCESS
15D4  6EF6     MOVWF TBLPTR, ACCESS
15D6  0E10     MOVLW 0x10
15D8  20F4     ADDWFC PRODH, W, ACCESS
15DA  6EF7     MOVWF TBLPTRH, ACCESS
15DC  0009     TBLRD*+
15DE  CFF5     MOVFF TABLAT, _DtCOf_resPCO
15E0  F016     NOP
15E2  0009     TBLRD*+
15E4  CFF5     MOVFF TABLAT, _DtCOf_su_CO
15E6  F017     NOP
15E8  0E08     MOVLW 0x8
15EA  2616     ADDWF _DtCOf_resPCO, F, ACCESS
15EC  0E00     MOVLW 0x0
15EE  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
15F0  C016     MOVFF _DtCOf_resPCO, TBLPTR
15F2  FFF6     NOP
15F4  C017     MOVFF _DtCOf_su_CO, TBLPTRH
15F6  FFF7     NOP
15F8  0009     TBLRD*+
15FA  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
15FC  F018     NOP
15FE  0009     TBLRD*+
1600  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1602  F019     NOP
1604  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1606  FFF6     NOP
1608  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
160A  FFF7     NOP
160C  0009     TBLRD*+
160E  CFF5     MOVFF TABLAT, FSR2
1610  FFD9     NOP
1612  0009     TBLRD*+
1614  CFF5     MOVFF TABLAT, FSR2H
1616  FFDA     NOP
1618  80DF     BSF INDF2, 0, ACCESS
391:                       //#if SER_WSW!=0
392:                       //Dmask=(*(*Klj[j].KL).KOut).DMask;
393:                       //#endif
394:                       if(KTim[j].ndS < (*Klj[j].KL).KWP[i].delay) //jeszcze nie uplynal czas ekspozycji pozycji?
161A  5024     MOVF _DtCWf_err_CW, W, ACCESS
161C  0D03     MULLW 0x3
161E  2AF3     INCF PROD, F, ACCESS
1620  0E00     MOVLW 0x0
1622  22F4     ADDWFC PRODH, F, ACCESS
1624  0E38     MOVLW 0x38
1626  24F3     ADDWF PROD, W, ACCESS
1628  6ED9     MOVWF FSR2, ACCESS
162A  0E02     MOVLW 0x2
162C  20F4     ADDWFC PRODH, W, ACCESS
162E  6EDA     MOVWF FSR2H, ACCESS
1630  50DF     MOVF INDF2, W, ACCESS
1632  6E16     MOVWF _DtCOf_resPCO, ACCESS
1634  5024     MOVF _DtCWf_err_CW, W, ACCESS
1636  0D03     MULLW 0x3
1638  0E45     MOVLW 0x45
163A  24F3     ADDWF PROD, W, ACCESS
163C  6EF6     MOVWF TBLPTR, ACCESS
163E  0E10     MOVLW 0x10
1640  20F4     ADDWFC PRODH, W, ACCESS
1642  6EF7     MOVWF TBLPTRH, ACCESS
1644  0009     TBLRD*+
1646  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1648  F017     NOP
164A  0009     TBLRD*+
164C  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
164E  F018     NOP
1650  0E02     MOVLW 0x2
1652  2617     ADDWF _DtCOf_su_CO, F, ACCESS
1654  0E00     MOVLW 0x0
1656  2218     ADDWFC _DtCOf_su_DZ_CO, F, ACCESS
1658  C017     MOVFF _DtCOf_su_CO, TBLPTR
165A  FFF6     NOP
165C  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTRH
165E  FFF7     NOP
1660  0009     TBLRD*+
1662  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1664  F019     NOP
1666  0009     TBLRD*+
1668  CFF5     MOVFF TABLAT, _DtCOf_zroPCO
166A  F01A     NOP
166C  5023     MOVF _DtCWf_cold_CW, W, ACCESS
166E  0D03     MULLW 0x3
1670  50F3     MOVF PROD, W, ACCESS
1672  2619     ADDWF _DtCOf_su_SRW_CO, F, ACCESS
1674  50F4     MOVF PRODH, W, ACCESS
1676  221A     ADDWFC _DtCOf_zroPCO, F, ACCESS
1678  0E02     MOVLW 0x2
167A  2619     ADDWF _DtCOf_su_SRW_CO, F, ACCESS
167C  0E00     MOVLW 0x0
167E  221A     ADDWFC _DtCOf_zroPCO, F, ACCESS
1680  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTR
1682  FFF6     NOP
1684  C01A     MOVFF _DtCOf_zroPCO, TBLPTRH
1686  FFF7     NOP
1688  0008     TBLRD*
168A  50F5     MOVF TABLAT, W, ACCESS
168C  5C16     SUBWF _DtCOf_resPCO, W, ACCESS
168E  E301     BNC 0x1692
1690  D17D     BRA 0x198C
395:                       {
396:                           KTim[j].ncS++;
1692  5024     MOVF _DtCWf_err_CW, W, ACCESS
1694  0D03     MULLW 0x3
1696  0E38     MOVLW 0x38
1698  24F3     ADDWF PROD, W, ACCESS
169A  6ED9     MOVWF FSR2, ACCESS
169C  0E02     MOVLW 0x2
169E  20F4     ADDWFC PRODH, W, ACCESS
16A0  6EDA     MOVWF FSR2H, ACCESS
16A2  2ADF     INCF INDF2, F, ACCESS
397:                           if(KTim[j].ncS >= 10)
16A4  5024     MOVF _DtCWf_err_CW, W, ACCESS
16A6  0D03     MULLW 0x3
16A8  0E38     MOVLW 0x38
16AA  24F3     ADDWF PROD, W, ACCESS
16AC  6ED9     MOVWF FSR2, ACCESS
16AE  0E02     MOVLW 0x2
16B0  20F4     ADDWFC PRODH, W, ACCESS
16B2  6EDA     MOVWF FSR2H, ACCESS
16B4  0E09     MOVLW 0x9
16B6  64DF     CPFSGT INDF2, ACCESS
16B8  D016     BRA 0x16E6
398:                           {
399:                               KTim[j].ncS = 0;
16BA  5024     MOVF _DtCWf_err_CW, W, ACCESS
16BC  0D03     MULLW 0x3
16BE  0E38     MOVLW 0x38
16C0  24F3     ADDWF PROD, W, ACCESS
16C2  6ED9     MOVWF FSR2, ACCESS
16C4  0E02     MOVLW 0x2
16C6  20F4     ADDWFC PRODH, W, ACCESS
16C8  6EDA     MOVWF FSR2H, ACCESS
16CA  6ADF     CLRF INDF2, ACCESS
400:                               KTim[j].ndS++; //odliczaj czas ekspozycji
16CC  5024     MOVF _DtCWf_err_CW, W, ACCESS
16CE  0D03     MULLW 0x3
16D0  2AF3     INCF PROD, F, ACCESS
16D2  0E00     MOVLW 0x0
16D4  22F4     ADDWFC PRODH, F, ACCESS
16D6  0E38     MOVLW 0x38
16D8  24F3     ADDWF PROD, W, ACCESS
16DA  6ED9     MOVWF FSR2, ACCESS
16DC  0E02     MOVLW 0x2
16DE  20F4     ADDWFC PRODH, W, ACCESS
16E0  6EDA     MOVWF FSR2H, ACCESS
16E2  2ADF     INCF INDF2, F, ACCESS
16E4  D000     BRA 0x16E6
401:                           }
402:                           if((*Klj[j].KL).KAP[i].PAdr == 0) //nie podano adresu zmiennej dynamicznej?
16E6  5024     MOVF _DtCWf_err_CW, W, ACCESS
16E8  0D03     MULLW 0x3
16EA  0E45     MOVLW 0x45
16EC  24F3     ADDWF PROD, W, ACCESS
16EE  6EF6     MOVWF TBLPTR, ACCESS
16F0  0E10     MOVLW 0x10
16F2  20F4     ADDWFC PRODH, W, ACCESS
16F4  6EF7     MOVWF TBLPTRH, ACCESS
16F6  0009     TBLRD*+
16F8  CFF5     MOVFF TABLAT, _DtCOf_resPCO
16FA  F016     NOP
16FC  0009     TBLRD*+
16FE  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1700  F017     NOP
1702  C016     MOVFF _DtCOf_resPCO, TBLPTR
1704  FFF6     NOP
1706  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1708  FFF7     NOP
170A  0009     TBLRD*+
170C  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
170E  F018     NOP
1710  0009     TBLRD*+
1712  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1714  F019     NOP
1716  5023     MOVF _DtCWf_cold_CW, W, ACCESS
1718  0D02     MULLW 0x2
171A  50F3     MOVF PROD, W, ACCESS
171C  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
171E  50F4     MOVF PRODH, W, ACCESS
1720  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
1722  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1724  FFF6     NOP
1726  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1728  FFF7     NOP
172A  0009     TBLRD*+
172C  50F5     MOVF TABLAT, W, ACCESS
172E  0009     TBLRD*+
1730  10F5     IORWF TABLAT, W, ACCESS
1732  E001     BZ 0x1736
1734  D0AB     BRA 0x188C
403:                           {
404:                               (*(*(*Klj[j].KL).KOut).CAdr).St = (*Klj[j].KL).KFP[i].PFrm; //zapisz w tablicy PWD pod pozycja odpowiadajaca kolejce dana do wyswietlenia
1736  5024     MOVF _DtCWf_err_CW, W, ACCESS
1738  0D03     MULLW 0x3
173A  0E45     MOVLW 0x45
173C  24F3     ADDWF PROD, W, ACCESS
173E  6EF6     MOVWF TBLPTR, ACCESS
1740  0E10     MOVLW 0x10
1742  20F4     ADDWFC PRODH, W, ACCESS
1744  6EF7     MOVWF TBLPTRH, ACCESS
1746  0009     TBLRD*+
1748  CFF5     MOVFF TABLAT, _DtCOf_resPCO
174A  F016     NOP
174C  0009     TBLRD*+
174E  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1750  F017     NOP
1752  0E08     MOVLW 0x8
1754  2616     ADDWF _DtCOf_resPCO, F, ACCESS
1756  0E00     MOVLW 0x0
1758  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
175A  C016     MOVFF _DtCOf_resPCO, TBLPTR
175C  FFF6     NOP
175E  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1760  FFF7     NOP
1762  0009     TBLRD*+
1764  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
1766  F018     NOP
1768  0009     TBLRD*+
176A  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
176C  F019     NOP
176E  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1770  FFF6     NOP
1772  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1774  FFF7     NOP
1776  0009     TBLRD*+
1778  CFF5     MOVFF TABLAT, FSR2
177A  FFD9     NOP
177C  0009     TBLRD*+
177E  CFF5     MOVFF TABLAT, FSR2H
1780  FFDA     NOP
1782  5024     MOVF _DtCWf_err_CW, W, ACCESS
1784  0D03     MULLW 0x3
1786  0E45     MOVLW 0x45
1788  24F3     ADDWF PROD, W, ACCESS
178A  6EF6     MOVWF TBLPTR, ACCESS
178C  0E10     MOVLW 0x10
178E  20F4     ADDWFC PRODH, W, ACCESS
1790  6EF7     MOVWF TBLPTRH, ACCESS
1792  0009     TBLRD*+
1794  CFF5     MOVFF TABLAT, _DtCOf_zroPCO
1796  F01A     NOP
1798  0009     TBLRD*+
179A  CFF5     MOVFF TABLAT, _DtCSf_error
179C  F01B     NOP
179E  0E04     MOVLW 0x4
17A0  261A     ADDWF _DtCOf_zroPCO, F, ACCESS
17A2  0E00     MOVLW 0x0
17A4  221B     ADDWFC _DtCSf_error, F, ACCESS
17A6  C01A     MOVFF _DtCOf_zroPCO, TBLPTR
17A8  FFF6     NOP
17AA  C01B     MOVFF _DtCSf_error, TBLPTRH
17AC  FFF7     NOP
17AE  0009     TBLRD*+
17B0  CFF5     MOVFF TABLAT, _DtCSf_hi
17B2  F01C     NOP
17B4  0009     TBLRD*+
17B6  CFF5     MOVFF TABLAT, _DtCSf_lo
17B8  F01D     NOP
17BA  5023     MOVF _DtCWf_cold_CW, W, ACCESS
17BC  0D02     MULLW 0x2
17BE  50F3     MOVF PROD, W, ACCESS
17C0  261C     ADDWF _DtCSf_hi, F, ACCESS
17C2  50F4     MOVF PRODH, W, ACCESS
17C4  221D     ADDWFC _DtCSf_lo, F, ACCESS
17C6  C01C     MOVFF _DtCSf_hi, TBLPTR
17C8  FFF6     NOP
17CA  C01D     MOVFF _DtCSf_lo, TBLPTRH
17CC  FFF7     NOP
17CE  0009     TBLRD*+
17D0  CFF5     MOVFF TABLAT, POSTINC2
17D2  FFDE     NOP
17D4  0008     TBLRD*
17D6  CFF5     MOVFF TABLAT, POSTDEC2
17D8  FFDD     NOP
405:                               (*(*(*Klj[j].KL).KOut).CAdr).Dt = (*Klj[j].KL).KWP[i].PWrt;
17DA  5024     MOVF _DtCWf_err_CW, W, ACCESS
17DC  0D03     MULLW 0x3
17DE  0E45     MOVLW 0x45
17E0  24F3     ADDWF PROD, W, ACCESS
17E2  6EF6     MOVWF TBLPTR, ACCESS
17E4  0E10     MOVLW 0x10
17E6  20F4     ADDWFC PRODH, W, ACCESS
17E8  6EF7     MOVWF TBLPTRH, ACCESS
17EA  0009     TBLRD*+
17EC  CFF5     MOVFF TABLAT, _DtCOf_resPCO
17EE  F016     NOP
17F0  0009     TBLRD*+
17F2  CFF5     MOVFF TABLAT, _DtCOf_su_CO
17F4  F017     NOP
17F6  0E08     MOVLW 0x8
17F8  2616     ADDWF _DtCOf_resPCO, F, ACCESS
17FA  0E00     MOVLW 0x0
17FC  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
17FE  C016     MOVFF _DtCOf_resPCO, TBLPTR
1800  FFF6     NOP
1802  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1804  FFF7     NOP
1806  0009     TBLRD*+
1808  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
180A  F018     NOP
180C  0009     TBLRD*+
180E  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1810  F019     NOP
1812  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1814  FFF6     NOP
1816  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1818  FFF7     NOP
181A  0009     TBLRD*+
181C  CFF5     MOVFF TABLAT, _DtCOf_zroPCO
181E  F01A     NOP
1820  0009     TBLRD*+
1822  CFF5     MOVFF TABLAT, _DtCSf_error
1824  F01B     NOP
1826  0E02     MOVLW 0x2
1828  241A     ADDWF _DtCOf_zroPCO, W, ACCESS
182A  6ED9     MOVWF FSR2, ACCESS
182C  0E00     MOVLW 0x0
182E  201B     ADDWFC _DtCSf_error, W, ACCESS
1830  6EDA     MOVWF FSR2H, ACCESS
1832  5024     MOVF _DtCWf_err_CW, W, ACCESS
1834  0D03     MULLW 0x3
1836  0E45     MOVLW 0x45
1838  24F3     ADDWF PROD, W, ACCESS
183A  6EF6     MOVWF TBLPTR, ACCESS
183C  0E10     MOVLW 0x10
183E  20F4     ADDWFC PRODH, W, ACCESS
1840  6EF7     MOVWF TBLPTRH, ACCESS
1842  0009     TBLRD*+
1844  CFF5     MOVFF TABLAT, _DtCSf_hi
1846  F01C     NOP
1848  0009     TBLRD*+
184A  CFF5     MOVFF TABLAT, _DtCSf_lo
184C  F01D     NOP
184E  0E02     MOVLW 0x2
1850  261C     ADDWF _DtCSf_hi, F, ACCESS
1852  0E00     MOVLW 0x0
1854  221D     ADDWFC _DtCSf_lo, F, ACCESS
1856  C01C     MOVFF _DtCSf_hi, TBLPTR
1858  FFF6     NOP
185A  C01D     MOVFF _DtCSf_lo, TBLPTRH
185C  FFF7     NOP
185E  0009     TBLRD*+
1860  CFF5     MOVFF TABLAT, _DtCSf_no
1862  F01E     NOP
1864  0009     TBLRD*+
1866  CFF5     MOVFF TABLAT, _DtCSf_no_mont
1868  F01F     NOP
186A  5023     MOVF _DtCWf_cold_CW, W, ACCESS
186C  0D03     MULLW 0x3
186E  50F3     MOVF PROD, W, ACCESS
1870  261E     ADDWF _DtCSf_no, F, ACCESS
1872  50F4     MOVF PRODH, W, ACCESS
1874  221F     ADDWFC _DtCSf_no_mont, F, ACCESS
1876  C01E     MOVFF _DtCSf_no, TBLPTR
1878  FFF6     NOP
187A  C01F     MOVFF _DtCSf_no_mont, TBLPTRH
187C  FFF7     NOP
187E  0009     TBLRD*+
1880  CFF5     MOVFF TABLAT, POSTINC2
1882  FFDE     NOP
1884  0008     TBLRD*
1886  CFF5     MOVFF TABLAT, POSTDEC2
1888  FFDD     NOP
406:                           }
188A  D057     BRA 0x193A
407:                           else (*(*(*Klj[j].KL).KOut).CAdr) = *((*Klj[j].KL).KAP[i].PAdr); //w przeciwnym przypadku pobierz dana z adresu zmiennej dynamicznej
188C  5024     MOVF _DtCWf_err_CW, W, ACCESS
188E  0D03     MULLW 0x3
1890  0E45     MOVLW 0x45
1892  24F3     ADDWF PROD, W, ACCESS
1894  6EF6     MOVWF TBLPTR, ACCESS
1896  0E10     MOVLW 0x10
1898  20F4     ADDWFC PRODH, W, ACCESS
189A  6EF7     MOVWF TBLPTRH, ACCESS
189C  0009     TBLRD*+
189E  CFF5     MOVFF TABLAT, _DtCOf_resPCO
18A0  F016     NOP
18A2  0009     TBLRD*+
18A4  CFF5     MOVFF TABLAT, _DtCOf_su_CO
18A6  F017     NOP
18A8  C016     MOVFF _DtCOf_resPCO, TBLPTR
18AA  FFF6     NOP
18AC  C017     MOVFF _DtCOf_su_CO, TBLPTRH
18AE  FFF7     NOP
18B0  0009     TBLRD*+
18B2  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
18B4  F018     NOP
18B6  0009     TBLRD*+
18B8  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
18BA  F019     NOP
18BC  5023     MOVF _DtCWf_cold_CW, W, ACCESS
18BE  0D02     MULLW 0x2
18C0  50F3     MOVF PROD, W, ACCESS
18C2  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
18C4  50F4     MOVF PRODH, W, ACCESS
18C6  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
18C8  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
18CA  FFF6     NOP
18CC  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
18CE  FFF7     NOP
18D0  0009     TBLRD*+
18D2  CFF5     MOVFF TABLAT, FSR2
18D4  FFD9     NOP
18D6  0009     TBLRD*+
18D8  CFF5     MOVFF TABLAT, FSR2H
18DA  FFDA     NOP
18DC  5024     MOVF _DtCWf_err_CW, W, ACCESS
18DE  0D03     MULLW 0x3
18E0  0E45     MOVLW 0x45
18E2  24F3     ADDWF PROD, W, ACCESS
18E4  6EF6     MOVWF TBLPTR, ACCESS
18E6  0E10     MOVLW 0x10
18E8  20F4     ADDWFC PRODH, W, ACCESS
18EA  6EF7     MOVWF TBLPTRH, ACCESS
18EC  0009     TBLRD*+
18EE  CFF5     MOVFF TABLAT, _DtCOf_zroPCO
18F0  F01A     NOP
18F2  0009     TBLRD*+
18F4  CFF5     MOVFF TABLAT, _DtCSf_error
18F6  F01B     NOP
18F8  0E08     MOVLW 0x8
18FA  261A     ADDWF _DtCOf_zroPCO, F, ACCESS
18FC  0E00     MOVLW 0x0
18FE  221B     ADDWFC _DtCSf_error, F, ACCESS
1900  C01A     MOVFF _DtCOf_zroPCO, TBLPTR
1902  FFF6     NOP
1904  C01B     MOVFF _DtCSf_error, TBLPTRH
1906  FFF7     NOP
1908  0009     TBLRD*+
190A  CFF5     MOVFF TABLAT, _DtCSf_hi
190C  F01C     NOP
190E  0009     TBLRD*+
1910  CFF5     MOVFF TABLAT, _DtCSf_lo
1912  F01D     NOP
1914  C01C     MOVFF _DtCSf_hi, TBLPTR
1916  FFF6     NOP
1918  C01D     MOVFF _DtCSf_lo, TBLPTRH
191A  FFF7     NOP
191C  0009     TBLRD*+
191E  CFF5     MOVFF TABLAT, FSR1
1920  FFE1     NOP
1922  0009     TBLRD*+
1924  CFF5     MOVFF TABLAT, FSR1H
1926  FFE2     NOP
1928  CFDE     MOVFF POSTINC2, POSTINC1
192A  FFE6     NOP
192C  CFDE     MOVFF POSTINC2, POSTINC1
192E  FFE6     NOP
1930  CFDE     MOVFF POSTINC2, POSTINC1
1932  FFE6     NOP
1934  CFDE     MOVFF POSTINC2, POSTINC1
1936  FFE6     NOP
1938  D000     BRA 0x193A
408:                           (*(*(*Klj[j].KL).KOut).CAdr).St.focus = 1; //odtworzenie nadpisanego bitu autoaktywacji
193A  5024     MOVF _DtCWf_err_CW, W, ACCESS
193C  0D03     MULLW 0x3
193E  0E45     MOVLW 0x45
1940  24F3     ADDWF PROD, W, ACCESS
1942  6EF6     MOVWF TBLPTR, ACCESS
1944  0E10     MOVLW 0x10
1946  20F4     ADDWFC PRODH, W, ACCESS
1948  6EF7     MOVWF TBLPTRH, ACCESS
194A  0009     TBLRD*+
194C  CFF5     MOVFF TABLAT, _DtCOf_resPCO
194E  F016     NOP
1950  0009     TBLRD*+
1952  CFF5     MOVFF TABLAT, _DtCOf_su_CO
1954  F017     NOP
1956  0E08     MOVLW 0x8
1958  2616     ADDWF _DtCOf_resPCO, F, ACCESS
195A  0E00     MOVLW 0x0
195C  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
195E  C016     MOVFF _DtCOf_resPCO, TBLPTR
1960  FFF6     NOP
1962  C017     MOVFF _DtCOf_su_CO, TBLPTRH
1964  FFF7     NOP
1966  0009     TBLRD*+
1968  CFF5     MOVFF TABLAT, _DtCOf_su_DZ_CO
196A  F018     NOP
196C  0009     TBLRD*+
196E  CFF5     MOVFF TABLAT, _DtCOf_su_SRW_CO
1970  F019     NOP
1972  C018     MOVFF _DtCOf_su_DZ_CO, TBLPTR
1974  FFF6     NOP
1976  C019     MOVFF _DtCOf_su_SRW_CO, TBLPTRH
1978  FFF7     NOP
197A  0009     TBLRD*+
197C  CFF5     MOVFF TABLAT, FSR2
197E  FFD9     NOP
1980  0009     TBLRD*+
1982  CFF5     MOVFF TABLAT, FSR2H
1984  FFDA     NOP
1986  80DF     BSF INDF2, 0, ACCESS
409:                           break;
1988  D05C     BRA 0x1A42
410:                       }
198A  D048     BRA 0x1A1C
411:                       else
412:                       {
413:                           KTim[j].ncS = 0;
198C  5024     MOVF _DtCWf_err_CW, W, ACCESS
198E  0D03     MULLW 0x3
1990  0E38     MOVLW 0x38
1992  24F3     ADDWF PROD, W, ACCESS
1994  6ED9     MOVWF FSR2, ACCESS
1996  0E02     MOVLW 0x2
1998  20F4     ADDWFC PRODH, W, ACCESS
199A  6EDA     MOVWF FSR2H, ACCESS
199C  6ADF     CLRF INDF2, ACCESS
414:                           KTim[j].ndS = 0; //wyzeruj czas ekspozycji
199E  5024     MOVF _DtCWf_err_CW, W, ACCESS
19A0  0D03     MULLW 0x3
19A2  2AF3     INCF PROD, F, ACCESS
19A4  0E00     MOVLW 0x0
19A6  22F4     ADDWFC PRODH, F, ACCESS
19A8  0E38     MOVLW 0x38
19AA  24F3     ADDWF PROD, W, ACCESS
19AC  6ED9     MOVWF FSR2, ACCESS
19AE  0E02     MOVLW 0x2
19B0  20F4     ADDWFC PRODH, W, ACCESS
19B2  6EDA     MOVWF FSR2H, ACCESS
19B4  6ADF     CLRF INDF2, ACCESS
415:                           if(KInd[j].indeks >= Klj[j].nPzc - 1)
19B6  6816     SETF _DtCOf_resPCO, ACCESS
19B8  6817     SETF _DtCOf_su_CO, ACCESS
19BA  5024     MOVF _DtCWf_err_CW, W, ACCESS
19BC  0D03     MULLW 0x3
19BE  0E02     MOVLW 0x2
19C0  26F3     ADDWF PROD, F, ACCESS
19C2  0E00     MOVLW 0x0
19C4  22F4     ADDWFC PRODH, F, ACCESS
19C6  0E45     MOVLW 0x45
19C8  24F3     ADDWF PROD, W, ACCESS
19CA  6EF6     MOVWF TBLPTR, ACCESS
19CC  0E10     MOVLW 0x10
19CE  20F4     ADDWFC PRODH, W, ACCESS
19D0  6EF7     MOVWF TBLPTRH, ACCESS
19D2  0008     TBLRD*
19D4  50F5     MOVF TABLAT, W, ACCESS
19D6  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
19D8  6A19     CLRF _DtCOf_su_SRW_CO, ACCESS
19DA  5016     MOVF _DtCOf_resPCO, W, ACCESS
19DC  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
19DE  5017     MOVF _DtCOf_su_CO, W, ACCESS
19E0  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
19E2  5024     MOVF _DtCWf_err_CW, W, ACCESS
19E4  0D01     MULLW 0x1
19E6  0E41     MOVLW 0x41
19E8  24F3     ADDWF PROD, W, ACCESS
19EA  6ED9     MOVWF FSR2, ACCESS
19EC  0E01     MOVLW 0x1
19EE  20F4     ADDWFC PRODH, W, ACCESS
19F0  6EDA     MOVWF FSR2H, ACCESS
19F2  0101     MOVLB 0x1
19F4  30DF     RRCF INDF2, W, ACCESS
19F6  32E8     RRCF WREG, F, ACCESS
19F8  0B3F     ANDLW 0x3F
19FA  D51D     BRA 0x1436
416:                           {
417:                               KInd[j].indeks = 0;
418:                               if(nC) KTim[j].cykl++;
19FC  5021     MOVF _DtCWf_ad_CW, W, ACCESS
19FE  E00E     BZ 0x1A1C
1A00  5024     MOVF _DtCWf_err_CW, W, ACCESS
1A02  0D03     MULLW 0x3
1A04  0E02     MOVLW 0x2
1A06  26F3     ADDWF PROD, F, ACCESS
1A08  0E00     MOVLW 0x0
1A0A  22F4     ADDWFC PRODH, F, ACCESS
1A0C  0E38     MOVLW 0x38
1A0E  24F3     ADDWF PROD, W, ACCESS
1A10  6ED9     MOVWF FSR2, ACCESS
1A12  0E02     MOVLW 0x2
1A14  20F4     ADDWFC PRODH, W, ACCESS
1A16  6EDA     MOVWF FSR2H, ACCESS
1A18  2ADF     INCF INDF2, F, ACCESS
419:                           }
420:                       }
1A1A  D000     BRA 0x1A1C
421:                   }
422:               }
423:           }
1A4E  0012     RETURN 0
424:           #endif
425:           /*--------------------------------------------------------------*/
426:           //Pobranie danej do wyswietlenia (poczynajac od najwyzszego priorytetu pierwsza
427:           //z ustawiona flaga focus).
428:           //Kolejno 0 - najwyzszy priorytet,...,(NPWD-1) - najnizszy priorytet
429:           
430:           void SetPrWswData(void)
431:           {
432:               unsigned char i;
433:               for(i = 0; i < NPWD - 1; i++)
DAB6  6A16     CLRF _DtCOf_resPCO, ACCESS
DAB8  D01E     BRA 0xDAF6
DABA  D020     BRA 0xDAFC
DAF4  2A16     INCF _DtCOf_resPCO, F, ACCESS
DAF6  0E08     MOVLW 0x8
DAF8  6416     CPFSGT _DtCOf_resPCO, ACCESS
DAFA  D7E0     BRA 0xDABC
434:               {
435:                   if(PWD[i].St.focus) //ustawiona flaga focus?
DABC  5016     MOVF _DtCOf_resPCO, W, ACCESS
DABE  0D04     MULLW 0x4
DAC0  0E44     MOVLW 0x44
DAC2  24F3     ADDWF PROD, W, ACCESS
DAC4  6ED9     MOVWF FSR2, ACCESS
DAC6  0E02     MOVLW 0x2
DAC8  20F4     ADDWFC PRODH, W, ACCESS
DACA  6EDA     MOVWF FSR2H, ACCESS
DACC  0102     MOVLB 0x2
DACE  A0DF     BTFSS INDF2, 0, ACCESS
DAD0  D011     BRA 0xDAF4
436:                   {
437:                       WswData = PWD[i];
DAD2  5016     MOVF _DtCOf_resPCO, W, ACCESS
DAD4  0D04     MULLW 0x4
DAD6  0E44     MOVLW 0x44
DAD8  24F3     ADDWF PROD, W, ACCESS
DADA  6ED9     MOVWF FSR2, ACCESS
DADC  0E02     MOVLW 0x2
DADE  20F4     ADDWFC PRODH, W, ACCESS
DAE0  6EDA     MOVWF FSR2H, ACCESS
DAE2  CFDE     MOVFF POSTINC2, WswData
DAE4  F0BB     NOP
DAE6  CFDE     MOVFF POSTINC2, 0xBC
DAE8  F0BC     NOP
DAEA  CFDE     MOVFF POSTINC2, 0xBD
DAEC  F0BD     NOP
DAEE  CFDE     MOVFF POSTINC2, 0xBE
DAF0  F0BE     NOP
438:                       return;
DAF2  0012     RETURN 0
439:                   };
440:               }
441:               WswData = PWD[NPWD - 1]; //wyswietl dana o najnizszym priorytecie
DAFC  C268     MOVFF 0x268, WswData
DAFE  F0BB     NOP
DB00  C269     MOVFF 0x269, 0xBC
DB02  F0BC     NOP
DB04  C26A     MOVFF 0x26A, 0xBD
DB06  F0BD     NOP
DB08  C26B     MOVFF 0x26B, 0xBE
DB0A  F0BE     NOP
442:           }
DB0C  0012     RETURN 0
443:           /*--------------------------------------------------------------*/
444:           void Swbty(unsigned char dtd);
445:           void Rwbty(unsigned char dtd);
446:           //Przygotowanie danej do wyswietlenia
447:           
448:           void FormatWswData(void)
449:           {
450:               //	unsigned char nrbty;
451:           
452:               if(WswData.St.hex) //konwersja hex na kod led
AE38  0100     MOVLB 0x0
AE3A  A5BB     BTFSS WswData, 2, BANKED
AE3C  D017     BRA 0xAE6C
453:               {
454:                   LedData.dLed1 = Znak[(WswData.Dt.Data0 & 0xF0) >> 4];
AE3E  39BE     SWAPF 0xBE, W, BANKED
AE40  0B0F     ANDLW 0xF
AE42  6E1E     MOVWF _DtCSf_no, ACCESS
AE44  6A1F     CLRF _DtCSf_no_mont, ACCESS
AE46  0E35     MOVLW 0x35
AE48  241E     ADDWF _DtCSf_no, W, ACCESS
AE4A  6EF6     MOVWF TBLPTR, ACCESS
AE4C  0E10     MOVLW 0x10
AE4E  201F     ADDWFC _DtCSf_no_mont, W, ACCESS
AE50  6EF7     MOVWF TBLPTRH, ACCESS
AE52  0008     TBLRD*
AE54  CFF5     MOVFF TABLAT, 0xC3
AE56  F0C3     NOP
455:                   LedData.dLed0 = Znak[WswData.Dt.Data0 & 0x0F];
AE58  51BE     MOVF 0xBE, W, BANKED
AE5A  0B0F     ANDLW 0xF
AE5C  6E1E     MOVWF _DtCSf_no, ACCESS
AE5E  6A1F     CLRF _DtCSf_no_mont, ACCESS
AE60  0E35     MOVLW 0x35
AE62  241E     ADDWF _DtCSf_no, W, ACCESS
AE64  6EF6     MOVWF TBLPTR, ACCESS
AE66  0E10     MOVLW 0x10
AE68  201F     ADDWFC _DtCSf_no_mont, W, ACCESS
AE6A  D026     BRA 0xAEB8
456:               }
457:               else
458:                   if(WswData.St.dec) //konwersja dec na kod led
AE6C  0100     MOVLB 0x0
AE6E  A3BB     BTFSS WswData, 1, BANKED
AE70  D028     BRA 0xAEC2
459:               {
460:                   if(WswData.Dt.Data0 > 99) WswData.Dt.Data0 = 99;
AE72  0E63     MOVLW 0x63
AE74  65BE     CPFSGT 0xBE, BANKED
AE76  D002     BRA 0xAE7C
AE78  6FBE     MOVWF 0xBE, BANKED
AE7A  D000     BRA 0xAE7C
461:                   LedData.dLed1 = Znak[WswData.Dt.Data0 / 10];
AE7C  C0BE     MOVFF 0xBE, _DtCOf_resPCO
AE7E  F016     NOP
AE80  6A17     CLRF _DtCOf_su_CO, ACCESS
AE82  6A19     CLRF _DtCOf_su_SRW_CO, ACCESS
AE84  0E0A     MOVLW 0xA
AE86  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
AE88  ECF2     CALL 0xC9E4, 0
AE8A  F064     NOP
AE8C  0E35     MOVLW 0x35
AE8E  2416     ADDWF _DtCOf_resPCO, W, ACCESS
AE90  6EF6     MOVWF TBLPTR, ACCESS
AE92  0E10     MOVLW 0x10
AE94  2017     ADDWFC _DtCOf_su_CO, W, ACCESS
AE96  6EF7     MOVWF TBLPTRH, ACCESS
AE98  0008     TBLRD*
AE9A  CFF5     MOVFF TABLAT, 0xC3
AE9C  F0C3     NOP
462:                   LedData.dLed0 = Znak[WswData.Dt.Data0 % 10];
AE9E  C0BE     MOVFF 0xBE, _DtCOf_resPCO
AEA0  F016     NOP
AEA2  6A17     CLRF _DtCOf_su_CO, ACCESS
AEA4  6A19     CLRF _DtCOf_su_SRW_CO, ACCESS
AEA6  0E0A     MOVLW 0xA
AEA8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
AEAA  ECB9     CALL 0xCF72, 0
AEAC  F067     NOP
AEAE  0E35     MOVLW 0x35
AEB0  2416     ADDWF _DtCOf_resPCO, W, ACCESS
AEB2  6EF6     MOVWF TBLPTR, ACCESS
AEB4  0E10     MOVLW 0x10
AEB6  2017     ADDWFC _DtCOf_su_CO, W, ACCESS
AEB8  6EF7     MOVWF TBLPTRH, ACCESS
AEBA  0008     TBLRD*
AEBC  CFF5     MOVFF TABLAT, 0xC4
AEBE  F0C4     NOP
463:               }
AEC0  D005     BRA 0xAECC
464:               else
465:               {
466:                   LedData.dLed1 = WswData.Dt.Data1; //bezposrednio dane w kodzie LED
AEC2  C0BD     MOVFF 0xBD, 0xC3
AEC4  F0C3     NOP
467:                   LedData.dLed0 = WswData.Dt.Data0;
AEC6  C0BE     MOVFF 0xBE, 0xC4
AEC8  F0C4     NOP
AECA  D000     BRA 0xAECC
468:               }
469:               if(WswData.St.autoOFF && (LedData.dLed1 == Znak[0])) //auto wygaszenie starszej cyfry gdy == 0
AECC  0100     MOVLB 0x0
AECE  A7BB     BTFSS WswData, 3, BANKED
AED0  D009     BRA 0xAEE4
AED2  0E35     MOVLW 0x35
AED4  6EF6     MOVWF TBLPTR, ACCESS
AED6  0E10     MOVLW 0x10
AED8  6EF7     MOVWF TBLPTRH, ACCESS
AEDA  0008     TBLRD*
AEDC  50F5     MOVF TABLAT, W, ACCESS
AEDE  63C3     CPFSEQ 0xC3, BANKED
AEE0  D001     BRA 0xAEE4
470:                   LedData.dLed1 = BLACK;
AEE2  69C3     SETF 0xC3, BANKED
471:               if(WswData.St.kropka0) //zapalenie mlodszej kropki
AEE4  0100     MOVLB 0x0
AEE6  A9BB     BTFSS WswData, 4, BANKED
AEE8  D004     BRA 0xAEF2
472:                   LedData.dLed0 = LedData.dLed0 & KROPKA;
AEEA  51C4     MOVF 0xC4, W, BANKED
AEEC  0BEF     ANDLW 0xEF
AEEE  6FC4     MOVWF 0xC4, BANKED
AEF0  D000     BRA 0xAEF2
473:               if(WswData.St.kropka1) //zapalenie starszej kropki
AEF2  0100     MOVLB 0x0
AEF4  ABBB     BTFSS WswData, 5, BANKED
AEF6  D004     BRA 0xAF00
474:                   LedData.dLed1 = LedData.dLed1 & KROPKA;
AEF8  51C3     MOVF 0xC3, W, BANKED
AEFA  0BEF     ANDLW 0xEF
AEFC  6FC3     MOVWF 0xC3, BANKED
AEFE  D000     BRA 0xAF00
475:               if(WswData.St.wygas0 || LedData.setOff) //wygaszenie mlodszej cyfry
AF00  0100     MOVLB 0x0
AF02  BDBB     BTFSC WswData, 6, BANKED
AF04  D002     BRA 0xAF0A
AF06  A1C2     BTFSS LedData, 0, BANKED
AF08  D002     BRA 0xAF0E
476:                   LedData.dLed0 = BLACK;
AF0A  0100     MOVLB 0x0
AF0C  69C4     SETF 0xC4, BANKED
477:               if(WswData.St.wygas1 || LedData.setOff) //wygaszenie starszej cyfry
AF0E  0100     MOVLB 0x0
AF10  BFBB     BTFSC WswData, 7, BANKED
AF12  D002     BRA 0xAF18
AF14  A1C2     BTFSS LedData, 0, BANKED
AF16  D002     BRA 0xAF1C
478:                   LedData.dLed1 = BLACK;
AF18  0100     MOVLB 0x0
AF1A  69C3     SETF 0xC3, BANKED
479:           #if SER_WSW!=0
480:               if(LedData.setOff) //wygasic wyswietlacz?
AF1C  0100     MOVLB 0x0
AF1E  A1C2     BTFSS LedData, 0, BANKED
AF20  D003     BRA 0xAF28
481:               {
482:           #if WKATODA==0
483:                   //wspolna anoda
484:                   wbty[_NRDIODE] |= 0x0f;
AF22  0E0F     MOVLW 0xF
AF24  13C6     IORWF 0xC6, F, BANKED
485:           #else
486:                   //wspolna katoda
487:                   wbty[_NRDIODE] &= 0xf0;
488:           #endif	
489:               }
AF26  0C0F     RETLW 0xF
490:               else
491:                   if(WswData.St.wbdid && (WswData.St.sdiode || WswData.St.rdiode))
AF28  0100     MOVLB 0x0
AF2A  39BC     SWAPF 0xBC, W, BANKED
AF2C  0B0F     ANDLW 0xF
AF2E  E013     BZ 0xAF56
AF30  B5BC     BTFSC 0xBC, 2, BANKED
AF32  D002     BRA 0xAF38
AF34  A7BC     BTFSS 0xBC, 3, BANKED
AF36  D00F     BRA 0xAF56
492:               {
493:                   //zastosuj ogolne slowo wysterowania diod
494:                   //zmodyfikowane informacja zapisana w wybranym poziomie priorytetu wyswietlania
495:                   if(WswData.St.sdiode) Swbty(WswData.St.wbdid); //zapal wybrane diody
AF38  0100     MOVLB 0x0
AF3A  A5BC     BTFSS 0xBC, 2, BANKED
AF3C  D004     BRA 0xAF46
AF3E  39BC     SWAPF 0xBC, W, BANKED
AF40  0B0F     ANDLW 0xF
AF42  EF78     GOTO 0xEEF0
AF44  F077     NOP
496:                   else
497:                       if(WswData.St.rdiode) Rwbty(WswData.St.wbdid); //wygas wybrane diody
AF46  0100     MOVLB 0x0
AF48  A7BC     BTFSS 0xBC, 3, BANKED
AF4A  0012     RETURN 0
AF4C  39BC     SWAPF 0xBC, W, BANKED
AF4E  0B0F     ANDLW 0xF
AF50  EC89     CALL 0xEF12, 0
AF52  F077     NOP
498:               }
AF54  0012     RETURN 0
499:               else
500:               {
501:                   //zastosuj ogolne slowo wysterowania diod
502:           #if WKATODA==0
503:                   //wspolna anoda
504:                   wbty[_NRDIODE] |= 0x0f;
AF56  0E0F     MOVLW 0xF
AF58  0100     MOVLB 0x0
AF5A  13C6     IORWF 0xC6, F, BANKED
505:                   wbty[_NRDIODE] &= ~(wsdid);
AF5C  1DCE     COMF wsdid, W, BANKED
AF5E  17C6     ANDWF 0xC6, F, BANKED
506:           #else
507:                   //wspolna katoda
508:                   wbty[_NRDIODE] &= 0xf0;
509:                   wbty[_NRDIODE] |= wsdid;
510:           #endif
511:               }
AF60  0012     RETURN 0
512:           #endif
513:           }
AF62  0012     RETURN 0
514:           /*--------------------------------------------------------------*/
515:           
516:           //Wyslanie danej na wyswietlacz
517:           
518:           void PrintWswData(void)
519:           {
520:           #if SER_WSW!=0								//aktywny interfejs szeregowy wyswietlacza?
521:               unsigned char i, j, k;
522:           #endif
523:           #if WKATODA!=0								//wspolna katoda?
524:               LedData.dLed0 = ~LedData.dLed0;
525:               LedData.dLed1 = ~LedData.dLed1;
526:           #endif
527:           #if SER_WSW==0								//aktywny interfejs szeregowy wyswietlacza?
528:               //Interfejs rownolegly
529:           #if WSWAP==0							//zamienic cyfry miejscami?
530:               if(MUX)
531:                   PORT_WSW = LedData.dLed0;
532:               else
533:                   PORT_WSW = LedData.dLed1;
534:           #else
535:               if(MUX)
536:                   PORT_WSW = LedData.dLed1;
537:               else
538:                   PORT_WSW = LedData.dLed0;
539:           #endif
540:           #else
541:               //Interfejs szeregowy (wysylanie bajtow do rejestrow bit po bicie.)
542:               mux = !mux;
B77C  7C14     BTG UADtf_RData, 6, ACCESS
543:           #if WSWAP==0							//zamienic cyfry miejscami?
544:               if(mux)
B77E  AC14     BTFSS UADtf_RData, 6, ACCESS
B780  D003     BRA 0xB788
545:                   wbty[0] = LedData.dLed0;
B782  C0C4     MOVFF 0xC4, wbty
B784  F0C5     NOP
B786  D002     BRA 0xB78C
546:               else
547:                   wbty[0] = LedData.dLed1;
B788  C0C3     MOVFF 0xC3, wbty
B78A  F0C5     NOP
548:           #else
549:               if(mux)
550:                   wbty[0] = LedData.dLed1;
551:               else
552:                   wbty[0] = LedData.dLed0;
553:           #endif
554:               if(mux) wbty[NWBTY - 1] |= (1 << SMUX);
B78C  AC14     BTFSS UADtf_RData, 6, ACCESS
B78E  D003     BRA 0xB796
B790  0100     MOVLB 0x0
B792  89C6     BSF 0xC6, 4, BANKED
B794  D003     BRA 0xB79C
555:               else wbty[NWBTY - 1] &= ~(1 << SMUX);
B796  0100     MOVLB 0x0
B798  99C6     BCF 0xC6, 4, BANKED
B79A  D000     BRA 0xB79C
556:               for(k = 0; k < NWBTY; k++)
B79C  6A1D     CLRF _DtCSf_lo, ACCESS
B79E  0E01     MOVLW 0x1
B7A0  641D     CPFSGT _DtCSf_lo, ACCESS
B7A2  D001     BRA 0xB7A6
B7A4  D049     BRA 0xB838
B834  2A1D     INCF _DtCSf_lo, F, ACCESS
B836  D7B3     BRA 0xB79E
557:               {
558:                   for(j = 0; j < NRBIT; j++)
B7A6  6A1C     CLRF _DtCSf_hi, ACCESS
B7A8  0E07     MOVLW 0x7
B7AA  641C     CPFSGT _DtCSf_hi, ACCESS
B7AC  D001     BRA 0xB7B0
B7AE  D042     BRA 0xB834
B830  2A1C     INCF _DtCSf_hi, F, ACCESS
B832  D7BA     BRA 0xB7A8
559:                   {
560:                       _DTA = (wbty[NWBTY - 1 - k]&(1 << (NRBIT - 1 - j))) ? 1 : 0;
B7B0  501D     MOVF _DtCSf_lo, W, ACCESS
B7B2  6E16     MOVWF _DtCOf_resPCO, ACCESS
B7B4  6A17     CLRF _DtCOf_su_CO, ACCESS
B7B6  2A16     INCF _DtCOf_resPCO, F, ACCESS
B7B8  0E00     MOVLW 0x0
B7BA  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
B7BC  1E16     COMF _DtCOf_resPCO, F, ACCESS
B7BE  1E17     COMF _DtCOf_su_CO, F, ACCESS
B7C0  4A16     INFSNZ _DtCOf_resPCO, F, ACCESS
B7C2  2A17     INCF _DtCOf_su_CO, F, ACCESS
B7C4  0E02     MOVLW 0x2
B7C6  2616     ADDWF _DtCOf_resPCO, F, ACCESS
B7C8  0E00     MOVLW 0x0
B7CA  2217     ADDWFC _DtCOf_su_CO, F, ACCESS
B7CC  0EC5     MOVLW 0xC5
B7CE  2416     ADDWF _DtCOf_resPCO, W, ACCESS
B7D0  6ED9     MOVWF FSR2, ACCESS
B7D2  0E00     MOVLW 0x0
B7D4  2017     ADDWFC _DtCOf_su_CO, W, ACCESS
B7D6  6EDA     MOVWF FSR2H, ACCESS
B7D8  50DF     MOVF INDF2, W, ACCESS
B7DA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
B7DC  281C     INCF _DtCSf_hi, W, ACCESS
B7DE  0800     SUBLW 0x0
B7E0  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
B7E2  0E08     MOVLW 0x8
B7E4  2619     ADDWF _DtCOf_su_SRW_CO, F, ACCESS
B7E6  0E01     MOVLW 0x1
B7E8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
B7EA  2A19     INCF _DtCOf_su_SRW_CO, F, ACCESS
B7EC  D002     BRA 0xB7F2
B7EE  90D8     BCF STATUS, 0, ACCESS
B7F0  361A     RLCF _DtCOf_zroPCO, F, ACCESS
B7F2  2E19     DECFSZ _DtCOf_su_SRW_CO, F, ACCESS
B7F4  D7FC     BRA 0xB7EE
B7F6  501A     MOVF _DtCOf_zroPCO, W, ACCESS
B7F8  1418     ANDWF _DtCOf_su_DZ_CO, W, ACCESS
B7FA  E003     BZ 0xB802
B7FC  6A1B     CLRF _DtCSf_error, ACCESS
B7FE  2A1B     INCF _DtCSf_error, F, ACCESS
B800  D001     BRA 0xB804
B802  6A1B     CLRF _DtCSf_error, ACCESS
B804  461B     RLNCF _DtCSf_error, F, ACCESS
B806  5084     MOVF PORTE, W, ACCESS
B808  181B     XORWF _DtCSf_error, W, ACCESS
B80A  0BFD     ANDLW 0xFD
B80C  181B     XORWF _DtCSf_error, W, ACCESS
B80E  6E84     MOVWF PORTE, ACCESS
561:                       //bit wyslany - ustaw sygnal zegara
562:                       for(i = 0; i < RTIMW; i++); //zwloka
B810  6A1E     CLRF _DtCSf_no, ACCESS
B812  D002     BRA 0xB818
B814  D004     BRA 0xB81E
B816  2A1E     INCF _DtCSf_no, F, ACCESS
B818  0E09     MOVLW 0x9
B81A  641E     CPFSGT _DtCSf_no, ACCESS
B81C  D7FC     BRA 0xB816
563:                       _CLK = 1;
B81E  8484     BSF PORTE, 2, ACCESS
564:                       for(i = 0; i < RTIMW; i++); //zwloka
B820  6A1E     CLRF _DtCSf_no, ACCESS
B822  D002     BRA 0xB828
B824  D004     BRA 0xB82E
B826  2A1E     INCF _DtCSf_no, F, ACCESS
B828  0E09     MOVLW 0x9
B82A  641E     CPFSGT _DtCSf_no, ACCESS
B82C  D7FC     BRA 0xB826
565:                       _CLK = 0;
B82E  9484     BCF PORTE, 2, ACCESS
566:                   }
567:               }
568:               //wszystkie bajty wyslane - ustaw sygnal strobe
569:               for(i = 0; i < RTIMW; i++); //zwloka
B838  6A1E     CLRF _DtCSf_no, ACCESS
B83A  D002     BRA 0xB840
B83C  D004     BRA 0xB846
B83E  2A1E     INCF _DtCSf_no, F, ACCESS
B840  0E09     MOVLW 0x9
B842  641E     CPFSGT _DtCSf_no, ACCESS
B844  D7FC     BRA 0xB83E
570:               _STR = 1;
B846  8084     BSF PORTE, 0, ACCESS
571:               for(i = 0; i < RTIMW; i++); //zwloka
B848  6A1E     CLRF _DtCSf_no, ACCESS
B84A  D002     BRA 0xB850
B84C  D004     BRA 0xB856
B84E  2A1E     INCF _DtCSf_no, F, ACCESS
B850  0E09     MOVLW 0x9
B852  641E     CPFSGT _DtCSf_no, ACCESS
B854  D7FC     BRA 0xB84E
572:               _STR = 0;
B856  9084     BCF PORTE, 0, ACCESS
573:           #endif		 						
574:           }
B858  0012     RETURN 0
575:           /*--------------------------------------------------------------*/
576:           /*--------------------------------------------------------------*/
577:           #if SER_WSW!=0
578:           //Ustawia/zeruje dowolny bit rejestru wyswietlacza
579:           //nrbty - numer bajtu rejastru wyswietlacza
580:           //nrbit - numer bitu w bajcie (nrbty) rejestru wyswietlacza
581:           //bt - stan jaki ma przyjac bit
582:           
583:           void SetWbtyBit(unsigned char nrbty, unsigned char nrbit, const unsigned char bt)
584:           {
585:               if(nrbty >= NWBTY) nrbty = NWBTY - 1;
586:               if(bt) wbty[nrbty] |= 1 << nrbit;
587:               else wbty[nrbty] &= ~(1 << nrbit);
588:           }
589:           
590:           //zapala wybrana diode
591:           
592:           void Swbty(unsigned char dtd)
EEF0  6E17     MOVWF _DtCOf_su_CO, ACCESS
593:           {
594:               unsigned char mask;
595:               dtd = dtd & 0x0f;
EEF2  5017     MOVF _DtCOf_su_CO, W, ACCESS
EEF4  0B0F     ANDLW 0xF
EEF6  6E17     MOVWF _DtCOf_su_CO, ACCESS
596:               mask = ~(wsdid & dtd);
EEF8  0100     MOVLB 0x0
EEFA  51CE     MOVF wsdid, W, BANKED
EEFC  1417     ANDWF _DtCOf_su_CO, W, ACCESS
EEFE  0AFF     XORLW 0xFF
EF00  6E16     MOVWF _DtCOf_resPCO, ACCESS
597:           
598:           #if WKATODA==0
599:               //wspolna anoda
600:               wbty[_NRDIODE] |= 0x0f;
EF02  0E0F     MOVLW 0xF
EF04  13C6     IORWF 0xC6, F, BANKED
601:               wbty[_NRDIODE] &= ~(dtd | (wsdid & mask));
EF06  51CE     MOVF wsdid, W, BANKED
EF08  1416     ANDWF _DtCOf_resPCO, W, ACCESS
EF0A  1017     IORWF _DtCOf_su_CO, W, ACCESS
EF0C  0AFF     XORLW 0xFF
EF0E  17C6     ANDWF 0xC6, F, BANKED
602:           #else
603:               //wspolna katoda
604:               wbty[_NRDIODE] &= 0xf0;
605:               wbty[_NRDIODE] &= ~((~dtd)&(wsdid & mask));
606:           #endif
607:           }
EF10  0012     RETURN 0
608:           //wygasza wybrana diode
609:           
610:           void Rwbty(unsigned char dtd)
EF12  6E17     MOVWF _DtCOf_su_CO, ACCESS
611:           {
612:               unsigned char mask;
613:           
614:               dtd = dtd & 0x0f;
EF14  5017     MOVF _DtCOf_su_CO, W, ACCESS
EF16  0B0F     ANDLW 0xF
EF18  6E17     MOVWF _DtCOf_su_CO, ACCESS
615:               mask = ~(wsdid & dtd);
EF1A  0100     MOVLB 0x0
EF1C  51CE     MOVF wsdid, W, BANKED
EF1E  1417     ANDWF _DtCOf_su_CO, W, ACCESS
EF20  0AFF     XORLW 0xFF
EF22  6E16     MOVWF _DtCOf_resPCO, ACCESS
616:           #if WKATODA==0
617:               //wspolna anoda
618:               wbty[_NRDIODE] |= 0x0f;
EF24  0E0F     MOVLW 0xF
EF26  13C6     IORWF 0xC6, F, BANKED
619:               wbty[_NRDIODE] &= ~((~dtd)&(wsdid & mask));
EF28  1C17     COMF _DtCOf_su_CO, W, ACCESS
EF2A  15CE     ANDWF wsdid, W, BANKED
EF2C  1416     ANDWF _DtCOf_resPCO, W, ACCESS
EF2E  0AFF     XORLW 0xFF
EF30  17C6     ANDWF 0xC6, F, BANKED
620:           #else
621:               //wspolna katoda
622:               wbty[_NRDIODE] &= 0xf0;
623:               wbty[_NRDIODE] &= ~(dtd | (wsdid & mask));
624:           #endif
625:           }
EF32  0012     RETURN 0
626:           //ustawia bit globalnego slowa wysterowania diod
627:           
628:           void Swsdid(unsigned char dtd)
F262  0100     MOVLB 0x0
F264  6FDE     MOVWF __pcstackBANK0, BANKED
629:           {
630:               dtd = dtd & 0x0f;
F266  0100     MOVLB 0x0
F268  51DE     MOVF __pcstackBANK0, W, BANKED
F26A  0B0F     ANDLW 0xF
F26C  6FDE     MOVWF __pcstackBANK0, BANKED
631:               wsdid |= dtd;
F26E  51DE     MOVF __pcstackBANK0, W, BANKED
F270  13CE     IORWF wsdid, F, BANKED
632:           }
F272  0012     RETURN 0
633:           //zeruje bit globalnego slowa wysterowania diod
634:           
635:           void Rwsdid(unsigned char dtd)
F274  0100     MOVLB 0x0
F276  6FDE     MOVWF __pcstackBANK0, BANKED
636:           {
637:               dtd = dtd & 0x0f;
F278  0100     MOVLB 0x0
F27A  51DE     MOVF __pcstackBANK0, W, BANKED
F27C  0B0F     ANDLW 0xF
F27E  6FDE     MOVWF __pcstackBANK0, BANKED
638:               wsdid &= ~(dtd);
F280  1DDE     COMF __pcstackBANK0, W, BANKED
F282  17CE     ANDWF wsdid, F, BANKED
639:           }
F284  0012     RETURN 0
640:           #endif
641:           /*--------------------------------------------------------------*/
642:           /*--------------------------------------------------------------*/
643:           //Bezwarunkowe wygaszenie wyswietlacza
644:           
645:           void WswOff(void)
646:           {
647:               LedData.setOff = 1;
F41E  0100     MOVLB 0x0
F420  81C2     BSF LedData, 0, BANKED
648:           }
F422  0012     RETURN 0
649:           //Wyjscie z bezwarunkowego wygaszenia wyswietlacza
650:           
651:           void WswOn(void)
652:           {
653:               LedData.setOff = 0;
F412  0100     MOVLB 0x0
F414  91C2     BCF LedData, 0, BANKED
654:           }
F416  0012     RETURN 0
655:           /*--------------------------------------------------------------*/
656:           /*--------------------------------------------------------------*/
657:           //Wprowadzenie danej pod wskazany adres (typ WPack)
658:           //np. SetData(&PWD[2],0,35);
659:           
660:           void SetData(volatile WPack *wData, const unsigned char wdt1, const unsigned char wdt0)
661:           {
662:               (*wData).Dt.Data1 = wdt1;
EE44  0100     MOVLB 0x0
EE46  EE20     LFSR 2, 0x2
EE48  F002     NOP
EE4A  51DE     MOVF __pcstackBANK0, W, BANKED
EE4C  26D9     ADDWF FSR2, F, ACCESS
EE4E  51DF     MOVF pco, W, BANKED
EE50  22DA     ADDWFC FSR2H, F, ACCESS
EE52  C0E0     MOVFF bdat, INDF2
EE54  FFDF     NOP
663:               (*wData).Dt.Data0 = wdt0;
EE56  EE20     LFSR 2, 0x3
EE58  F003     NOP
EE5A  51DE     MOVF __pcstackBANK0, W, BANKED
EE5C  26D9     ADDWF FSR2, F, ACCESS
EE5E  51DF     MOVF pco, W, BANKED
EE60  22DA     ADDWFC FSR2H, F, ACCESS
EE62  C0E1     MOVFF GIE_BIT_VAL, INDF2
EE64  FFDF     NOP
664:           }
EE66  0012     RETURN 0
665:           //Okreslenie formatu danej pod wskazanym adresem (typ WPack)
666:           //Pod uwage brane sa tylko pozycje okreslone w danej mask,z tych
667:           //ustawiane sa pozycje okreslone w danej wst pozostale sa zerowane.
668:           //np. SetStatus(&PWD[2],DEC,ALL);
669:           
670:           void SetStatus(volatile WPack *wData, const unsigned int wst, const unsigned int mask)
671:           {
672:               if(mask & 0b1000000000000000)(*wData).St.focus = (wst & 0b1000000000000000) ? 1 : 0;
7BCE  0100     MOVLB 0x0
7BD0  AFE3     BTFSS a, 7, BANKED
7BD2  D012     BRA 0x7BF8
7BD4  AFE1     BTFSS GIE_BIT_VAL, 7, BANKED
7BD6  D003     BRA 0x7BDE
7BD8  6BE4     CLRF k, BANKED
7BDA  2BE4     INCF k, F, BANKED
7BDC  D002     BRA 0x7BE2
7BDE  0100     MOVLB 0x0
7BE0  6BE4     CLRF k, BANKED
7BE2  C0DE     MOVFF __pcstackBANK0, FSR2
7BE4  FFD9     NOP
7BE6  C0DF     MOVFF pco, FSR2H
7BE8  FFDA     NOP
7BEA  50DF     MOVF INDF2, W, ACCESS
7BEC  0100     MOVLB 0x0
7BEE  19E4     XORWF k, W, BANKED
7BF0  0BFE     ANDLW 0xFE
7BF2  19E4     XORWF k, W, BANKED
7BF4  6EDF     MOVWF INDF2, ACCESS
7BF6  D000     BRA 0x7BF8
673:               if(mask & 0b0100000000000000)(*wData).St.dec = (wst & 0b0100000000000000) ? 1 : 0;
7BF8  0100     MOVLB 0x0
7BFA  ADE3     BTFSS a, 6, BANKED
7BFC  D013     BRA 0x7C24
7BFE  ADE1     BTFSS GIE_BIT_VAL, 6, BANKED
7C00  D003     BRA 0x7C08
7C02  6BE4     CLRF k, BANKED
7C04  2BE4     INCF k, F, BANKED
7C06  D002     BRA 0x7C0C
7C08  0100     MOVLB 0x0
7C0A  6BE4     CLRF k, BANKED
7C0C  C0DE     MOVFF __pcstackBANK0, FSR2
7C0E  FFD9     NOP
7C10  C0DF     MOVFF pco, FSR2H
7C12  FFDA     NOP
7C14  0100     MOVLB 0x0
7C16  47E4     RLNCF k, F, BANKED
7C18  50DF     MOVF INDF2, W, ACCESS
7C1A  19E4     XORWF k, W, BANKED
7C1C  0BFD     ANDLW 0xFD
7C1E  19E4     XORWF k, W, BANKED
7C20  6EDF     MOVWF INDF2, ACCESS
7C22  D000     BRA 0x7C24
674:               if(mask & 0b0010000000000000)(*wData).St.hex = (wst & 0b0010000000000000) ? 1 : 0;
7C24  0100     MOVLB 0x0
7C26  ABE3     BTFSS a, 5, BANKED
7C28  D014     BRA 0x7C52
7C2A  ABE1     BTFSS GIE_BIT_VAL, 5, BANKED
7C2C  D003     BRA 0x7C34
7C2E  6BE4     CLRF k, BANKED
7C30  2BE4     INCF k, F, BANKED
7C32  D002     BRA 0x7C38
7C34  0100     MOVLB 0x0
7C36  6BE4     CLRF k, BANKED
7C38  C0DE     MOVFF __pcstackBANK0, FSR2
7C3A  FFD9     NOP
7C3C  C0DF     MOVFF pco, FSR2H
7C3E  FFDA     NOP
7C40  0100     MOVLB 0x0
7C42  47E4     RLNCF k, F, BANKED
7C44  47E4     RLNCF k, F, BANKED
7C46  50DF     MOVF INDF2, W, ACCESS
7C48  19E4     XORWF k, W, BANKED
7C4A  0BFB     ANDLW 0xFB
7C4C  19E4     XORWF k, W, BANKED
7C4E  6EDF     MOVWF INDF2, ACCESS
7C50  D000     BRA 0x7C52
675:               if(mask & 0b0001000000000000)(*wData).St.autoOFF = (wst & 0b0001000000000000) ? 1 : 0;
7C52  0100     MOVLB 0x0
7C54  A9E3     BTFSS a, 4, BANKED
7C56  D015     BRA 0x7C82
7C58  A9E1     BTFSS GIE_BIT_VAL, 4, BANKED
7C5A  D003     BRA 0x7C62
7C5C  6BE4     CLRF k, BANKED
7C5E  2BE4     INCF k, F, BANKED
7C60  D002     BRA 0x7C66
7C62  0100     MOVLB 0x0
7C64  6BE4     CLRF k, BANKED
7C66  C0DE     MOVFF __pcstackBANK0, FSR2
7C68  FFD9     NOP
7C6A  C0DF     MOVFF pco, FSR2H
7C6C  FFDA     NOP
7C6E  0100     MOVLB 0x0
7C70  47E4     RLNCF k, F, BANKED
7C72  47E4     RLNCF k, F, BANKED
7C74  47E4     RLNCF k, F, BANKED
7C76  50DF     MOVF INDF2, W, ACCESS
7C78  19E4     XORWF k, W, BANKED
7C7A  0BF7     ANDLW 0xF7
7C7C  19E4     XORWF k, W, BANKED
7C7E  6EDF     MOVWF INDF2, ACCESS
7C80  D000     BRA 0x7C82
676:               if(mask & 0b0000100000000000)(*wData).St.kropka0 = (wst & 0b0000100000000000) ? 1 : 0;
7C82  0100     MOVLB 0x0
7C84  A7E3     BTFSS a, 3, BANKED
7C86  D013     BRA 0x7CAE
7C88  A7E1     BTFSS GIE_BIT_VAL, 3, BANKED
7C8A  D003     BRA 0x7C92
7C8C  6BE4     CLRF k, BANKED
7C8E  2BE4     INCF k, F, BANKED
7C90  D002     BRA 0x7C96
7C92  0100     MOVLB 0x0
7C94  6BE4     CLRF k, BANKED
7C96  C0DE     MOVFF __pcstackBANK0, FSR2
7C98  FFD9     NOP
7C9A  C0DF     MOVFF pco, FSR2H
7C9C  FFDA     NOP
7C9E  0100     MOVLB 0x0
7CA0  3BE4     SWAPF k, F, BANKED
7CA2  50DF     MOVF INDF2, W, ACCESS
7CA4  19E4     XORWF k, W, BANKED
7CA6  0BEF     ANDLW 0xEF
7CA8  19E4     XORWF k, W, BANKED
7CAA  6EDF     MOVWF INDF2, ACCESS
7CAC  D000     BRA 0x7CAE
677:               if(mask & 0b0000010000000000)(*wData).St.kropka1 = (wst & 0b0000010000000000) ? 1 : 0;
7CAE  0100     MOVLB 0x0
7CB0  A5E3     BTFSS a, 2, BANKED
7CB2  D014     BRA 0x7CDC
7CB4  A5E1     BTFSS GIE_BIT_VAL, 2, BANKED
7CB6  D003     BRA 0x7CBE
7CB8  6BE4     CLRF k, BANKED
7CBA  2BE4     INCF k, F, BANKED
7CBC  D002     BRA 0x7CC2
7CBE  0100     MOVLB 0x0
7CC0  6BE4     CLRF k, BANKED
7CC2  C0DE     MOVFF __pcstackBANK0, FSR2
7CC4  FFD9     NOP
7CC6  C0DF     MOVFF pco, FSR2H
7CC8  FFDA     NOP
7CCA  0100     MOVLB 0x0
7CCC  3BE4     SWAPF k, F, BANKED
7CCE  47E4     RLNCF k, F, BANKED
7CD0  50DF     MOVF INDF2, W, ACCESS
7CD2  19E4     XORWF k, W, BANKED
7CD4  0BDF     ANDLW 0xDF
7CD6  19E4     XORWF k, W, BANKED
7CD8  6EDF     MOVWF INDF2, ACCESS
7CDA  D000     BRA 0x7CDC
678:               if(mask & 0b0000001000000000)(*wData).St.wygas0 = (wst & 0b0000001000000000) ? 1 : 0;
7CDC  0100     MOVLB 0x0
7CDE  A3E3     BTFSS a, 1, BANKED
7CE0  D015     BRA 0x7D0C
7CE2  A3E1     BTFSS GIE_BIT_VAL, 1, BANKED
7CE4  D003     BRA _TXIE
7CE6  6BE4     CLRF k, BANKED
7CE8  2BE4     INCF k, F, BANKED
7CEA  D002     BRA _TMR1IF
7CEC  0100     MOVLB 0x0
7CEE  6BE4     CLRF k, BANKED
7CF0  C0DE     MOVFF __pcstackBANK0, FSR2
7CF2  FFD9     NOP
7CF4  C0DF     MOVFF pco, FSR2H
7CF6  FFDA     NOP
7CF8  0100     MOVLB 0x0
7CFA  3BE4     SWAPF k, F, BANKED
7CFC  47E4     RLNCF k, F, BANKED
7CFE  47E4     RLNCF k, F, BANKED
7D00  50DF     MOVF INDF2, W, ACCESS
7D02  19E4     XORWF k, W, BANKED
7D04  0BBF     ANDLW 0xBF
7D06  19E4     XORWF k, W, BANKED
7D08  6EDF     MOVWF INDF2, ACCESS
7D0A  D000     BRA 0x7D0C
679:               if(mask & 0b0000000100000000)(*wData).St.wygas1 = (wst & 0b0000000100000000) ? 1 : 0;
7D0C  0100     MOVLB 0x0
7D0E  A1E3     BTFSS a, 0, BANKED
7D10  D014     BRA 0x7D3A
7D12  A1E1     BTFSS GIE_BIT_VAL, 0, BANKED
7D14  D003     BRA 0x7D1C
7D16  6BE4     CLRF k, BANKED
7D18  2BE4     INCF k, F, BANKED
7D1A  D002     BRA 0x7D20
7D1C  0100     MOVLB 0x0
7D1E  6BE4     CLRF k, BANKED
7D20  C0DE     MOVFF __pcstackBANK0, FSR2
7D22  FFD9     NOP
7D24  C0DF     MOVFF pco, FSR2H
7D26  FFDA     NOP
7D28  0100     MOVLB 0x0
7D2A  33E4     RRCF k, F, BANKED
7D2C  33E4     RRCF k, F, BANKED
7D2E  50DF     MOVF INDF2, W, ACCESS
7D30  19E4     XORWF k, W, BANKED
7D32  0B7F     ANDLW 0x7F
7D34  19E4     XORWF k, W, BANKED
7D36  6EDF     MOVWF INDF2, ACCESS
7D38  D000     BRA 0x7D3A
680:               if(mask & 0b0000000010000000)(*wData).St.led0 = (wst & 0b0000000010000000) ? 1 : 0;
7D3A  0100     MOVLB 0x0
7D3C  AFE2     BTFSS divisor, 7, BANKED
7D3E  D014     BRA 0x7D68
7D40  AFE0     BTFSS bdat, 7, BANKED
7D42  D003     BRA 0x7D4A
7D44  6BE4     CLRF k, BANKED
7D46  2BE4     INCF k, F, BANKED
7D48  D002     BRA 0x7D4E
7D4A  0100     MOVLB 0x0
7D4C  6BE4     CLRF k, BANKED
7D4E  0100     MOVLB 0x0
7D50  EE20     LFSR 2, 0x1
7D52  F001     NOP
7D54  51DE     MOVF __pcstackBANK0, W, BANKED
7D56  26D9     ADDWF FSR2, F, ACCESS
7D58  51DF     MOVF pco, W, BANKED
7D5A  22DA     ADDWFC FSR2H, F, ACCESS
7D5C  50DF     MOVF INDF2, W, ACCESS
7D5E  19E4     XORWF k, W, BANKED
7D60  0BFE     ANDLW 0xFE
7D62  19E4     XORWF k, W, BANKED
7D64  6EDF     MOVWF INDF2, ACCESS
7D66  D000     BRA 0x7D68
681:               if(mask & 0b0000000001000000)(*wData).St.led1 = (wst & 0b0000000001000000) ? 1 : 0;
7D68  0100     MOVLB 0x0
7D6A  ADE2     BTFSS divisor, 6, BANKED
7D6C  D015     BRA 0x7D98
7D6E  ADE0     BTFSS bdat, 6, BANKED
7D70  D003     BRA 0x7D78
7D72  6BE4     CLRF k, BANKED
7D74  2BE4     INCF k, F, BANKED
7D76  D002     BRA 0x7D7C
7D78  0100     MOVLB 0x0
7D7A  6BE4     CLRF k, BANKED
7D7C  0100     MOVLB 0x0
7D7E  EE20     LFSR 2, 0x1
7D80  F001     NOP
7D82  51DE     MOVF __pcstackBANK0, W, BANKED
7D84  26D9     ADDWF FSR2, F, ACCESS
7D86  51DF     MOVF pco, W, BANKED
7D88  22DA     ADDWFC FSR2H, F, ACCESS
7D8A  47E4     RLNCF k, F, BANKED
7D8C  50DF     MOVF INDF2, W, ACCESS
7D8E  19E4     XORWF k, W, BANKED
7D90  0BFD     ANDLW 0xFD
7D92  19E4     XORWF k, W, BANKED
7D94  6EDF     MOVWF INDF2, ACCESS
7D96  D000     BRA 0x7D98
682:               if(mask & 0b0000000000100000)(*wData).St.sdiode = (wst & 0b0000000000100000) ? 1 : 0;
7D98  0100     MOVLB 0x0
7D9A  ABE2     BTFSS divisor, 5, BANKED
7D9C  D016     BRA 0x7DCA
7D9E  ABE0     BTFSS bdat, 5, BANKED
7DA0  D003     BRA 0x7DA8
7DA2  6BE4     CLRF k, BANKED
7DA4  2BE4     INCF k, F, BANKED
7DA6  D002     BRA 0x7DAC
7DA8  0100     MOVLB 0x0
7DAA  6BE4     CLRF k, BANKED
7DAC  0100     MOVLB 0x0
7DAE  EE20     LFSR 2, 0x1
7DB0  F001     NOP
7DB2  51DE     MOVF __pcstackBANK0, W, BANKED
7DB4  26D9     ADDWF FSR2, F, ACCESS
7DB6  51DF     MOVF pco, W, BANKED
7DB8  22DA     ADDWFC FSR2H, F, ACCESS
7DBA  47E4     RLNCF k, F, BANKED
7DBC  47E4     RLNCF k, F, BANKED
7DBE  50DF     MOVF INDF2, W, ACCESS
7DC0  19E4     XORWF k, W, BANKED
7DC2  0BFB     ANDLW 0xFB
7DC4  19E4     XORWF k, W, BANKED
7DC6  6EDF     MOVWF INDF2, ACCESS
7DC8  D000     BRA 0x7DCA
683:               if(mask & 0b0000000000010000)(*wData).St.rdiode = (wst & 0b0000000000010000) ? 1 : 0;
7DCA  0100     MOVLB 0x0
7DCC  A9E2     BTFSS divisor, 4, BANKED
7DCE  D017     BRA 0x7DFE
7DD0  A9E0     BTFSS bdat, 4, BANKED
7DD2  D003     BRA 0x7DDA
7DD4  6BE4     CLRF k, BANKED
7DD6  2BE4     INCF k, F, BANKED
7DD8  D002     BRA 0x7DDE
7DDA  0100     MOVLB 0x0
7DDC  6BE4     CLRF k, BANKED
7DDE  0100     MOVLB 0x0
7DE0  EE20     LFSR 2, 0x1
7DE2  F001     NOP
7DE4  51DE     MOVF __pcstackBANK0, W, BANKED
7DE6  26D9     ADDWF FSR2, F, ACCESS
7DE8  51DF     MOVF pco, W, BANKED
7DEA  22DA     ADDWFC FSR2H, F, ACCESS
7DEC  47E4     RLNCF k, F, BANKED
7DEE  47E4     RLNCF k, F, BANKED
7DF0  47E4     RLNCF k, F, BANKED
7DF2  50DF     MOVF INDF2, W, ACCESS
7DF4  19E4     XORWF k, W, BANKED
7DF6  0BF7     ANDLW 0xF7
7DF8  19E4     XORWF k, W, BANKED
7DFA  6EDF     MOVWF INDF2, ACCESS
7DFC  D000     BRA 0x7DFE
684:               //jezeli aktywne jest polecenie zapalenia/wygaszenia diody i slowo wskazujace diody jest niezerowe
685:               if(mask & 0b0000000000001111)
7DFE  0E0F     MOVLW 0xF
7E00  0100     MOVLB 0x0
7E02  15E2     ANDWF divisor, W, BANKED
7E04  6FE4     MOVWF k, BANKED
7E06  6BE5     CLRF k, BANKED
7E08  51E4     MOVF k, W, BANKED
7E0A  11E5     IORWF k, W, BANKED
7E0C  B4D8     BTFSC STATUS, 2, ACCESS
7E0E  0012     RETURN 0
686:                   if(((*wData).St.sdiode || (*wData).St.rdiode) && (wst & 0b0000000000001111))
7E10  EE20     LFSR 2, 0x1
7E12  F001     NOP
7E14  51DE     MOVF __pcstackBANK0, W, BANKED
7E16  26D9     ADDWF FSR2, F, ACCESS
7E18  51DF     MOVF pco, W, BANKED
7E1A  22DA     ADDWFC FSR2H, F, ACCESS
7E1C  B4DF     BTFSC INDF2, 2, ACCESS
7E1E  D008     BRA _SSPM0
7E20  EE20     LFSR 2, 0x1
7E22  F001     NOP
7E24  51DE     MOVF __pcstackBANK0, W, BANKED
7E26  26D9     ADDWF FSR2, F, ACCESS
7E28  51DF     MOVF pco, W, BANKED
7E2A  22DA     ADDWFC FSR2H, F, ACCESS
7E2C  A6DF     BTFSS INDF2, 3, ACCESS
7E2E  0012     RETURN 0
7E30  0E0F     MOVLW 0xF
7E32  0100     MOVLB 0x0
7E34  15E0     ANDWF bdat, W, BANKED
7E36  6FE4     MOVWF k, BANKED
7E38  6BE5     CLRF k, BANKED
7E3A  51E4     MOVF k, W, BANKED
7E3C  11E5     IORWF k, W, BANKED
7E3E  B4D8     BTFSC STATUS, 2, ACCESS
7E40  0012     RETURN 0
687:                   {
688:                       (*wData).St.wbdid = (wst & 0b0000000000001111);
7E42  C0E0     MOVFF bdat, k
7E44  F0E4     NOP
7E46  0E0F     MOVLW 0xF
7E48  17E4     ANDWF k, F, BANKED
7E4A  EE20     LFSR 2, 0x1
7E4C  F001     NOP
7E4E  51DE     MOVF __pcstackBANK0, W, BANKED
7E50  26D9     ADDWF FSR2, F, ACCESS
7E52  51DF     MOVF pco, W, BANKED
7E54  22DA     ADDWFC FSR2H, F, ACCESS
7E56  3BE4     SWAPF k, F, BANKED
7E58  50DF     MOVF INDF2, W, ACCESS
7E5A  19E4     XORWF k, W, BANKED
7E5C  0B0F     ANDLW 0xF
7E5E  19E4     XORWF k, W, BANKED
7E60  6EDF     MOVWF INDF2, ACCESS
689:                   }
7E62  0012     RETURN 0
690:           }
7E64  0012     RETURN 0
691:           //-----------------------------------------------------
692:           //-----------------------------------------------------
693:           #if NKOL!=0
694:           //Zwraca stan pozycji nrpoz w kolejce nrkol
695:           
696:           bit GetPoz(const unsigned char nrkol, const unsigned char nrpoz)
697:           {
698:               if((nrkol >= NKOL) || (nrpoz >= Klj[nrkol].nPzc)) asm("RESET"); //obsluga sytuacji wyjatkowej
699:               return(*Klj[nrkol].KL).KFc[nrpoz].focus;
700:           }
701:           //Aktywacja pozycji nrpoz w kolejce nrkol
702:           
703:           void SetPoz(const unsigned char nrkol, const unsigned char nrpoz)
C958  0100     MOVLB 0x0
C95A  6FE1     MOVWF GIE_BIT_VAL, BANKED
704:           {
705:               if((nrkol >= NKOL) || (nrpoz >= Klj[nrkol].nPzc)) asm("RESET"); //obsluga sytuacji wyjatkowej
C95C  0E04     MOVLW 0x4
C95E  0100     MOVLB 0x0
C960  61E1     CPFSLT GIE_BIT_VAL, BANKED
C962  D010     BRA 0xC984
C964  51E1     MOVF GIE_BIT_VAL, W, BANKED
C966  0D03     MULLW 0x3
C968  0E02     MOVLW 0x2
C96A  26F3     ADDWF PROD, F, ACCESS
C96C  0E00     MOVLW 0x0
C96E  22F4     ADDWFC PRODH, F, ACCESS
C970  0E45     MOVLW 0x45
C972  24F3     ADDWF PROD, W, ACCESS
C974  6EF6     MOVWF TBLPTR, ACCESS
C976  0E10     MOVLW 0x10
C978  20F4     ADDWFC PRODH, W, ACCESS
C97A  6EF7     MOVWF TBLPTRH, ACCESS
C97C  0009     TBLRD*+
C97E  50F5     MOVF TABLAT, W, ACCESS
C980  5DDE     SUBWF __pcstackBANK0, W, BANKED
C982  E302     BNC 0xC988
C984  00FF     RESET
C986  D000     BRA 0xC988
706:               (*Klj[nrkol].KL).KFc[nrpoz].focus = 1;
C988  0100     MOVLB 0x0
C98A  51E1     MOVF GIE_BIT_VAL, W, BANKED
C98C  0D03     MULLW 0x3
C98E  0E45     MOVLW 0x45
C990  24F3     ADDWF PROD, W, ACCESS
C992  6EF6     MOVWF TBLPTR, ACCESS
C994  0E10     MOVLW 0x10
C996  20F4     ADDWFC PRODH, W, ACCESS
C998  6EF7     MOVWF TBLPTRH, ACCESS
C99A  0009     TBLRD*+
C99C  CFF5     MOVFF TABLAT, pco
C99E  F0DF     NOP
C9A0  0009     TBLRD*+
C9A2  CFF5     MOVFF TABLAT, bdat
C9A4  F0E0     NOP
C9A6  0E06     MOVLW 0x6
C9A8  27DF     ADDWF pco, F, BANKED
C9AA  0E00     MOVLW 0x0
C9AC  23E0     ADDWFC bdat, F, BANKED
C9AE  C0DF     MOVFF pco, TBLPTR
C9B0  FFF6     NOP
C9B2  C0E0     MOVFF bdat, TBLPTRH
C9B4  FFF7     NOP
C9B6  51DE     MOVF __pcstackBANK0, W, BANKED
C9B8  0D01     MULLW 0x1
C9BA  50F3     MOVF PROD, W, ACCESS
C9BC  0009     TBLRD*+
C9BE  24F5     ADDWF TABLAT, W, ACCESS
C9C0  6ED9     MOVWF FSR2, ACCESS
C9C2  50F4     MOVF PRODH, W, ACCESS
C9C4  0009     TBLRD*+
C9C6  20F5     ADDWFC TABLAT, W, ACCESS
C9C8  6EDA     MOVWF FSR2H, ACCESS
C9CA  80DF     BSF INDF2, 0, ACCESS
707:               KInd[nrkol].reset = 0; //jezeli wczesniej ustawiono flage resetu kolejki - nalezy ja wyzerowac
C9CC  0100     MOVLB 0x0
C9CE  51E1     MOVF GIE_BIT_VAL, W, BANKED
C9D0  0D01     MULLW 0x1
C9D2  0E41     MOVLW 0x41
C9D4  24F3     ADDWF PROD, W, ACCESS
C9D6  6ED9     MOVWF FSR2, ACCESS
C9D8  0E01     MOVLW 0x1
C9DA  20F4     ADDWFC PRODH, W, ACCESS
C9DC  6EDA     MOVWF FSR2H, ACCESS
C9DE  0101     MOVLB 0x1
C9E0  92DF     BCF INDF2, 1, ACCESS
708:           }
C9E2  0012     RETURN 0
709:           //Deaktywacja pozycji nrpoz w kolejce nrkol
710:           
711:           void ResetPoz(const unsigned char nrkol, const unsigned char nrpoz)
712:           {
713:               if((nrkol >= NKOL) || (nrpoz >= Klj[nrkol].nPzc)) asm("RESET"); //obsluga sytuacji wyjatkowej
714:               (*Klj[nrkol].KL).KFc[nrpoz].focus = 0;
715:           }
716:           //Deaktywacja wszystkich pozycji kolejki nr nrkol
717:           
718:           void ResetKol(const unsigned char nrkol)
EDAC  0100     MOVLB 0x0
EDAE  6FDE     MOVWF __pcstackBANK0, BANKED
719:           {
720:               if(nrkol >= NKOL) asm("RESET"); //obsluga sytuacji wyjatkowej
EDB0  0E03     MOVLW 0x3
EDB2  0100     MOVLB 0x0
EDB4  65DE     CPFSGT __pcstackBANK0, BANKED
EDB6  D002     BRA 0xEDBC
EDB8  00FF     RESET
EDBA  D000     BRA 0xEDBC
721:               KInd[nrkol].reset = 1;
EDBC  0100     MOVLB 0x0
EDBE  51DE     MOVF __pcstackBANK0, W, BANKED
EDC0  0D01     MULLW 0x1
EDC2  0E41     MOVLW 0x41
EDC4  24F3     ADDWF PROD, W, ACCESS
EDC6  6ED9     MOVWF FSR2, ACCESS
EDC8  0E01     MOVLW 0x1
EDCA  20F4     ADDWFC PRODH, W, ACCESS
EDCC  6EDA     MOVWF FSR2H, ACCESS
EDCE  0101     MOVLB 0x1
EDD0  82DF     BSF INDF2, 1, ACCESS
722:           }
EDD2  0012     RETURN 0
723:           //Start/Restart kolejki nr nrkol
724:           //(dla kolejek z ogr. czasem eksp. przy starcie aktywowane sa wszystkie pozycje kol.)
725:           
726:           void RestartKol(const unsigned char nrkol)
ED84  0100     MOVLB 0x0
ED86  6FDE     MOVWF __pcstackBANK0, BANKED
727:           {
728:               if(nrkol >= NKOL) asm("RESET"); //obsluga sytuacji wyjatkowej
ED88  0E03     MOVLW 0x3
ED8A  0100     MOVLB 0x0
ED8C  65DE     CPFSGT __pcstackBANK0, BANKED
ED8E  D002     BRA 0xED94
ED90  00FF     RESET
ED92  D000     BRA 0xED94
729:               KInd[nrkol].restart = 1;
ED94  0100     MOVLB 0x0
ED96  51DE     MOVF __pcstackBANK0, W, BANKED
ED98  0D01     MULLW 0x1
ED9A  0E41     MOVLW 0x41
ED9C  24F3     ADDWF PROD, W, ACCESS
ED9E  6ED9     MOVWF FSR2, ACCESS
EDA0  0E01     MOVLW 0x1
EDA2  20F4     ADDWFC PRODH, W, ACCESS
EDA4  6EDA     MOVWF FSR2H, ACCESS
EDA6  0101     MOVLB 0x1
EDA8  80DF     BSF INDF2, 0, ACCESS
730:           }
EDAA  0012     RETURN 0
731:           //Ustawia wszystkie kolejki na pierwsze pozycje
732:           
733:           void AllKolToFirstPoz(void)
734:           {
735:               unsigned char j;
736:               for(j = 0; j < NKOL; j++)
D5A6  0E00     MOVLW 0x0
D5A8  0100     MOVLB 0x0
D5AA  6FDE     MOVWF __pcstackBANK0, BANKED
D5AC  0E03     MOVLW 0x3
D5AE  0100     MOVLB 0x0
D5B0  65DE     CPFSGT __pcstackBANK0, BANKED
D5B2  D002     BRA 0xD5B8
D5B4  0C03     RETLW 0x3
D5B6  0012     RETURN 0
D600  0100     MOVLB 0x0
D602  2BDE     INCF __pcstackBANK0, F, BANKED
D604  0E03     MOVLW 0x3
D606  0100     MOVLB 0x0
D608  65DE     CPFSGT __pcstackBANK0, BANKED
D60A  D7D6     BRA 0xD5B8
D60C  0C03     RETLW 0x3
737:               {
738:                   KInd[j].indeks = 0;
D5B8  0100     MOVLB 0x0
D5BA  51DE     MOVF __pcstackBANK0, W, BANKED
D5BC  0D01     MULLW 0x1
D5BE  0E41     MOVLW 0x41
D5C0  24F3     ADDWF PROD, W, ACCESS
D5C2  6ED9     MOVWF FSR2, ACCESS
D5C4  0E01     MOVLW 0x1
D5C6  20F4     ADDWFC PRODH, W, ACCESS
D5C8  6EDA     MOVWF FSR2H, ACCESS
D5CA  94DF     BCF INDF2, 2, ACCESS
D5CC  96DF     BCF INDF2, 3, ACCESS
D5CE  98DF     BCF INDF2, 4, ACCESS
D5D0  9ADF     BCF INDF2, 5, ACCESS
D5D2  9CDF     BCF INDF2, 6, ACCESS
D5D4  9EDF     BCF INDF2, 7, ACCESS
739:                   KTim[j].ncS = 0;
D5D6  51DE     MOVF __pcstackBANK0, W, BANKED
D5D8  0D03     MULLW 0x3
D5DA  0E38     MOVLW 0x38
D5DC  24F3     ADDWF PROD, W, ACCESS
D5DE  6ED9     MOVWF FSR2, ACCESS
D5E0  0E02     MOVLW 0x2
D5E2  20F4     ADDWFC PRODH, W, ACCESS
D5E4  6EDA     MOVWF FSR2H, ACCESS
D5E6  6ADF     CLRF INDF2, ACCESS
740:                   KTim[j].ndS = 0;
D5E8  51DE     MOVF __pcstackBANK0, W, BANKED
D5EA  0D03     MULLW 0x3
D5EC  2AF3     INCF PROD, F, ACCESS
D5EE  0E00     MOVLW 0x0
D5F0  22F4     ADDWFC PRODH, F, ACCESS
D5F2  0E38     MOVLW 0x38
D5F4  24F3     ADDWF PROD, W, ACCESS
D5F6  6ED9     MOVWF FSR2, ACCESS
D5F8  0E02     MOVLW 0x2
D5FA  20F4     ADDWFC PRODH, W, ACCESS
D5FC  6EDA     MOVWF FSR2H, ACCESS
D5FE  6ADF     CLRF INDF2, ACCESS
741:               }
742:           }
D60E  0012     RETURN 0
743:           #endif
744:           //-----------------------------------------------------
745:           //-----------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/uart9b.c  --------------------------------
1:             /*uart9b.c*/
2:             //Funkcje obslugi RS232 w trybie 9 bit z adresowaniem.
3:             //Interfejs oparty na ukladzie MAX487
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"			//parametry globalne
7:             #include "uart9b.h"			//parametry lokalne
8:             
9:             //extern unsigned char xxy,zzz,vvv;
10:            volatile UARTData UADt;
11:            volatile unsigned char bufTUART[_NRS_TBF]; //bufor roboczy modulu UART
12:            volatile unsigned char bufRUART[_NRS_RBF]; //bufor roboczy modulu UART
13:            volatile near unsigned char RSerial;
14:            /*---------------------------------------------------------------------------------*/
15:            /*---------------------------------------------------------------------------------*/
16:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
17:            void StartUSARTRC(void);
18:            unsigned char SetNDatCHK(const unsigned char Data);
19:            unsigned char VerifyNDatCHK(const unsigned char Data);
20:            
21:            void InitUart(void)
22:            {
23:                //unsigned char rc;
24:                //6 wyjscie portu C ustawic jako wyjscie (0)
25:                //7 wyjscie portu C ustawic jako wejscie (1)
26:            
27:                CSRC = 0; //asynch mode
E7C2  9EAC     BCF TXSTA, 7, ACCESS
28:                RX9 = 1; //odbior 9 bitowy
E7C4  8CAB     BSF RCSTA, 6, ACCESS
29:                SPBRG = _SPBRG; //baud rate
E7C6  0ECF     MOVLW 0xCF
E7C8  6EAF     MOVWF SPBRG, ACCESS
30:                SYNC = _SYNC; //tryb asynchroniczny/synchroniczny
E7CA  98AC     BCF TXSTA, 4, ACCESS
31:                BRGH = _BRGH; //predkosc generatora Baud Rate
E7CC  94AC     BCF TXSTA, 2, ACCESS
32:                ADDEN = 1; //z adresowaniem
E7CE  86AB     BSF RCSTA, 3, ACCESS
33:                TX9 = 1; //nadawanie 9 bitowe
E7D0  8CAC     BSF TXSTA, 6, ACCESS
34:                RCIP = 1; //wysoki priorytet przerwania
E7D2  8A9F     BSF IPR1, 5, ACCESS
35:                RCIE = 1; //aktywne przerwanie dla odbioru
E7D4  8A9D     BSF PIE1, 5, ACCESS
36:                TXIP = 1; //wysoki priorytet przerwania
E7D6  889F     BSF IPR1, 4, ACCESS
37:                TXEN = 1; //aktywacja modulu transmisji
E7D8  8AAC     BSF TXSTA, 5, ACCESS
38:                SPEN = 1; //aktywacja portu szeregowego
E7DA  8EAB     BSF RCSTA, 7, ACCESS
39:                CREN = 1; //aktywacja odbioru
E7DC  88AB     BSF RCSTA, 4, ACCESS
40:            
41:                //UWAGA: GIEL=1 oraz GIEH=1
42:                UADtf_RData = 0;
E7DE  9014     BCF UADtf_RData, 0, ACCESS
43:                UADtf_RErrREC = 0;
E7E0  9614     BCF UADtf_RData, 3, ACCESS
44:                UADtf_RErrBUF = 0;
E7E2  9414     BCF UADtf_RData, 2, ACCESS
45:            
46:                UADtf_TData = 0;
E7E4  9814     BCF UADtf_RData, 4, ACCESS
47:                UADt.RNData = 0;
E7E6  0100     MOVLB 0x0
E7E8  6BB8     CLRF 0xB8, BANKED
48:                UADt.TNData = 0;
E7EA  6BB9     CLRF 0xB9, BANKED
49:            
50:                UADtf_REnd = 0;
E7EC  9214     BCF UADtf_RData, 1, ACCESS
51:                UADtf_TEnd = 0;
E7EE  9A14     BCF UADtf_RData, 5, ACCESS
52:                UADt.indeks = 0;
E7F0  0E00     MOVLW 0x0
E7F2  0100     MOVLB 0x0
E7F4  6BB7     CLRF UADt, BANKED
53:                //rc=RCREG;
54:                TXIE = 0;
E7F6  989D     BCF PIE1, 4, ACCESS
55:            }
E7F8  0012     RETURN 0
56:            //------------------------------------------------------------------------------------	
57:            //Procedura odczytu odebranego bajtu danych /wykonaywana w przerwaniu generowanym przy odbiorze danych/
58:            //W buforze zapisywane sa wszystkie odebrane bajty poczawszy od bajtu adresu.
59:            
60:            void IntUSARTRC(void)
61:            {
62:                if(ADDEN && RX9D) //RX9D - ustawiony 9 ty bit? (znacznik adresu)
C2BA  B6AB     BTFSC RCSTA, 3, ACCESS
C2BC  A0AB     BTFSS RCSTA, 0, ACCESS
C2BE  D019     BRA 0xC2F2
63:                {
64:                    RSerial = RCREG;
C2C0  CFAE     MOVFF RCREG, RSerial
C2C2  F0CC     NOP
65:                    if(RSerial == _MY_ADDR) //parawidlowy adres?
C2C4  0E02     MOVLW 0x2
C2C6  0100     MOVLB 0x0
C2C8  19CC     XORWF RSerial, W, BANKED
C2CA  A4D8     BTFSS STATUS, 2, ACCESS
C2CC  0012     RETURN 0
66:                    {
67:                        ADDEN = 0; //wylacz detekcje adresu
C2CE  96AB     BCF RCSTA, 3, ACCESS
68:                        UADt.indeks = 0; //wyzeruj indeks
C2D0  0100     MOVLB 0x0
C2D2  6BB7     CLRF UADt, BANKED
69:                        bufRUART[UADt.indeks++] = RSerial; //zapisz adres w buforze pod 0 indeksem
C2D4  0100     MOVLB 0x0
C2D6  51B7     MOVF UADt, W, BANKED
C2D8  0D01     MULLW 0x1
C2DA  0E0C     MOVLW 0xC
C2DC  24F3     ADDWF PROD, W, ACCESS
C2DE  6ED9     MOVWF FSR2, ACCESS
C2E0  0E03     MOVLW 0x3
C2E2  20F4     ADDWFC PRODH, W, ACCESS
C2E4  6EDA     MOVWF FSR2H, ACCESS
C2E6  C0CC     MOVFF RSerial, INDF2
C2E8  FFDF     NOP
C2EA  0100     MOVLB 0x0
C2EC  2BB7     INCF UADt, F, BANKED
70:                        UADtf_RData = 1; //sygnalizuj aktywny odbior danych
C2EE  8014     BSF UADtf_RData, 0, ACCESS
71:                    }
72:                    return; //wyjdz z przerwania
C2F0  0012     RETURN 0
73:                }
74:                RSerial = RCREG;
C2F2  CFAE     MOVFF RCREG, RSerial
C2F4  F0CC     NOP
75:                if(UADt.indeks < _NRS_RBF) //mozliwe przepelnienienie bufora odbioru?
C2F6  0E23     MOVLW 0x23
C2F8  0100     MOVLB 0x0
C2FA  61B7     CPFSLT UADt, BANKED
C2FC  D02B     BRA 0xC354
76:                {
77:                    bufRUART[UADt.indeks++] = RSerial;
C2FE  51B7     MOVF UADt, W, BANKED
C300  0D01     MULLW 0x1
C302  0E0C     MOVLW 0xC
C304  24F3     ADDWF PROD, W, ACCESS
C306  6ED9     MOVWF FSR2, ACCESS
C308  0E03     MOVLW 0x3
C30A  20F4     ADDWFC PRODH, W, ACCESS
C30C  6EDA     MOVWF FSR2H, ACCESS
C30E  C0CC     MOVFF RSerial, INDF2
C310  FFDF     NOP
C312  0100     MOVLB 0x0
C314  2BB7     INCF UADt, F, BANKED
78:                    UADt.RNData = bufRUART[1];
C316  C30D     MOVFF 0x30D, 0xB8
C318  F0B8     NOP
79:                    if(VerifyNDatCHK(UADt.RNData)) //kontroluj poprawnosc danej
C31A  0100     MOVLB 0x0
C31C  51B8     MOVF 0xB8, W, BANKED
C31E  ECF1     CALL 0xF1E2, 0
C320  F078     NOP
C322  0900     IORLW 0x0
C324  E012     BZ 0xC34A
80:                    {
81:            
82:                        UADt.RNData = UADt.RNData & 0b00011111;
C326  0100     MOVLB 0x0
C328  51B8     MOVF 0xB8, W, BANKED
C32A  0B1F     ANDLW 0x1F
C32C  6FB8     MOVWF 0xB8, BANKED
83:                        if(UADt.RNData > _NRS_RBF) UADt.RNData = _NRS_RBF;
C32E  0E23     MOVLW 0x23
C330  65B8     CPFSGT 0xB8, BANKED
C332  D002     BRA 0xC338
C334  6FB8     MOVWF 0xB8, BANKED
C336  D000     BRA 0xC338
84:                        if(UADt.indeks >= UADt.RNData) //ostatni bajt?
C338  0100     MOVLB 0x0
C33A  51B8     MOVF 0xB8, W, BANKED
C33C  5DB7     SUBWF UADt, W, BANKED
C33E  A0D8     BTFSS STATUS, 0, ACCESS
C340  0012     RETURN 0
85:                        {
86:                            ADDEN = 1; //zalacz detekcje adresu
C342  86AB     BSF RCSTA, 3, ACCESS
87:                            UADtf_RData = 0; //sygnalizuj deaktywacje odbioru danych
C344  9014     BCF UADtf_RData, 0, ACCESS
88:                            UADtf_REnd = 1; //ustaw znacznik odbioru kompletnej paczki danych
C346  8214     BSF UADtf_RData, 1, ACCESS
89:                        }
90:                    }
C348  0012     RETURN 0
91:                    else
92:                    {
93:                        ADDEN = 1; //uaktywnij detekcje adresu
C34A  86AB     BSF RCSTA, 3, ACCESS
94:                        UADtf_RData = 0; //sygnalizuj deaktywacje odbioru danych
C34C  9014     BCF UADtf_RData, 0, ACCESS
95:                        UADtf_REnd = 0; //usun znacznik odbioru kompletnej paczki danych
C34E  9214     BCF UADtf_RData, 1, ACCESS
96:                        UADtf_RErrBUF = 1; //sygnalizuj blad zbyt duzej ilosci danych
C350  8414     BSF UADtf_RData, 2, ACCESS
97:                    }
98:                }
C352  0012     RETURN 0
99:                else //w przypadku bledu przeplnienia przerwij odbior
100:               {
101:                   ADDEN = 1; //uaktywnij detekcje adresu
C354  86AB     BSF RCSTA, 3, ACCESS
102:                   UADtf_RData = 0; //sygnalizuj deaktywacje odbioru danych
C356  9014     BCF UADtf_RData, 0, ACCESS
103:                   UADtf_REnd = 0; //usun znacznik odbioru kompletnej paczki danych
C358  9214     BCF UADtf_RData, 1, ACCESS
104:                   UADtf_RErrBUF = 1; //sygnalizuj blad zbyt duzej ilosci danych
C35A  8414     BSF UADtf_RData, 2, ACCESS
C35C  0012     RETURN 0
105:           
106:               }
107:           }
C35E  0012     RETURN 0
108:           
109:           //------------------------------------------------------------------------------------
110:           //Aktywacja modulu odbioru danych
111:           //Gdzie: nData - ogolna liczba odbieranych bajtow (wlaczywszy adres)
112:           
113:           void StartUSARTRC(void)
114:           {
115:               UADtf_REnd = 0; //wyzeruj znacznik konca odbioru
116:               ADDEN = 1;
117:               CREN = 1;
118:           }
119:           //Deaktywacja modulu odbioru danych
120:           /*void StopUSARTRC(void)
121:           {
122:                   CREN=0;
123:                   UADtf_REnd=0;							//usun znacznik odbioru kompletnej paczki danych
124:                   UADtf_RData=0;							//sygnalizuj deaktywacje odbioru danych
125:           }*/
126:           //------------------------------------------------------------------------------------
127:           //------------------------------------------------------------------------------------
128:           //Transmisja danych /procedura wykonywana w przerwaniu/
129:           //Wysylane sa wszystkie bajty poczawszy od adresu odbiornika
130:           
131:           void IntUSARTTR(void)
132:           {
133:               if(!UADt.indeks) TX9D = 1; //dla zerowego indeksu ustaw znacznik adresu
DBBA  0100     MOVLB 0x0
DBBC  51B7     MOVF UADt, W, BANKED
DBBE  E102     BNZ 0xDBC4
DBC0  80AC     BSF TXSTA, 0, ACCESS
DBC2  D002     BRA 0xDBC8
134:               else TX9D = 0; //dla pozostalych danych usun znacznik adresu
DBC4  90AC     BCF TXSTA, 0, ACCESS
DBC6  D000     BRA 0xDBC8
135:               if(UADt.TNData > _NRS_TBF) UADt.TNData = _NRS_TBF;
DBC8  0E23     MOVLW 0x23
DBCA  0100     MOVLB 0x0
DBCC  65B9     CPFSGT 0xB9, BANKED
DBCE  D002     BRA 0xDBD4
DBD0  6FB9     MOVWF 0xB9, BANKED
DBD2  D000     BRA 0xDBD4
136:               if(UADt.indeks > _NRS_TBF - 1) UADt.indeks = _NRS_TBF - 1;
DBD4  0E22     MOVLW 0x22
DBD6  0100     MOVLB 0x0
DBD8  65B7     CPFSGT UADt, BANKED
DBDA  D002     BRA 0xDBE0
DBDC  6FB7     MOVWF UADt, BANKED
DBDE  D000     BRA 0xDBE0
137:               TXREG = bufTUART[UADt.indeks++]; //rozpoczyna transmisje
DBE0  0100     MOVLB 0x0
DBE2  51B7     MOVF UADt, W, BANKED
DBE4  0D01     MULLW 0x1
DBE6  0E2F     MOVLW 0x2F
DBE8  24F3     ADDWF PROD, W, ACCESS
DBEA  6ED9     MOVWF FSR2, ACCESS
DBEC  0E03     MOVLW 0x3
DBEE  20F4     ADDWFC PRODH, W, ACCESS
DBF0  6EDA     MOVWF FSR2H, ACCESS
DBF2  50DF     MOVF INDF2, W, ACCESS
DBF4  6EAD     MOVWF TXREG, ACCESS
DBF6  0100     MOVLB 0x0
DBF8  2BB7     INCF UADt, F, BANKED
138:               if(UADt.indeks < UADt.TNData) UADtf_TData = 1; //ustaw znacznik transmisji danych
DBFA  0100     MOVLB 0x0
DBFC  51B9     MOVF 0xB9, W, BANKED
DBFE  5DB7     SUBWF UADt, W, BANKED
DC00  E202     BC 0xDC06
DC02  8814     BSF UADtf_RData, 4, ACCESS
DC04  0012     RETURN 0
139:               else
140:               {
141:                   UADtf_TData = 0; //usun znacznik transmisji danych
DC06  9814     BCF UADtf_RData, 4, ACCESS
142:                   UADtf_TEnd = 1; //ustaw znacznik zakonczenia transmisji danych
DC08  8A14     BSF UADtf_RData, 5, ACCESS
143:                   TXIE = 0; //deaktywacja transmisji
DC0A  989D     BCF PIE1, 4, ACCESS
DC0C  0012     RETURN 0
144:               }
145:           }
DC0E  0012     RETURN 0
146:           //------------------------------------------------------------------------------------
147:           //Aktywacja modulu odbioru danych
148:           //Gdzie: nData - ogolna liczba wysylanych bajtow (wlaczywszy adres)
149:           
150:           void StartUSARTTR(void)
151:           {
152:               if(TXIE) return; //trwa transmisja danych?
153:               UADt.TNData = (bufTUART[1]&0b00011111); //liczba wysylanych bajtow
154:               if(UADt.TNData > _NRS_TBF) UADt.TNData = _NRS_TBF;
155:               UADt.indeks = 0; //indeks = 0 - pierwszy bajt oznaczony jako adres
156:               UADtf_TEnd = 0; //wyzeruj znacznik konca odbioru
157:               TXIE = 1; //aktywacja transmisji
158:           }
159:           //Deaktywacja modulu odbioru danych
160:           
161:           void StopUSARTTR(void)
162:           {
163:               TXIE = 0; //deaktywacja transmisji
164:               UADtf_TData = 0; //usun znacznik transmisji danych
165:               UADtf_TEnd = 0; //wyzeruj znacznik konca odbioru
166:           
167:           }
168:           //------------------------------------------------------------------------------------
169:           //------------------------------------------------------------------------------------
170:           //Wyzerowanie bufora odbiornika
171:           
172:           void ClrRSRBuf(void)
173:           {
174:               unsigned char i;
175:               for(i = 0; i < _NRS_RBF; i++) bufRUART[i] = 0;
176:           }
177:           //------------------------------------------------------------------------------------
178:           //Wyzerowanie bufora nadajnika
179:           
180:           void ClrRSTBuf(void)
181:           {
182:               unsigned char i;
183:               for(i = 0; i < _NRS_TBF; i++) bufTUART[i] = 0;
184:           }
185:           //------------------------------------------------------------------------------------
186:           //Zapis danych do bufora nadajnika
187:           
188:           void SetRSTBuf(const unsigned char indeks, const unsigned char data)
189:           {
190:               if(indeks < _NRS_TBF) bufTUART[indeks] = data;
191:               else bufTUART[_NRS_TBF - 1] = data;
192:           
193:           }
194:           //------------------------------------------------------------------------------------
195:           //Odczyt danych z bufora odbiornika
196:           
197:           unsigned char GetRSRBuf(const unsigned char indeks)
198:           {
199:               if(indeks < _NRS_RBF) return bufRUART[indeks];
200:               else return bufRUART[_NRS_RBF - 1];
201:           }
202:           //------------------------------------------------------------------------------------
203:           //Oblicza CHK z nData bajtow bufora bf (bufor danych musi zawierac przynajmniej 2 elementy)
204:           //Gdzie bf - adres pierwszego bajtu, nData - liczba bajtow z ktorych liczone bedzie CHK
205:           
206:           unsigned char LiczRSCHK(volatile unsigned char *bf, const unsigned char nData)
207:           {
208:               unsigned char i, chk;
209:               chk = 0;
210:               for(i = 0; i < nData; i++) chk += (*(bf + i) + i)^0xAA;
211:               return chk;
212:           }
213:           //------------------------------------------------------------------------------------
214:           //Oblicza CHK i zapisuje na ostatniej pozycji bufora danych do wysylki
215:           //nData - ogolna liczba wysylanych bajtow (lacznie z adresem i bajtem CHK)
216:           
217:           void SetRSCHK(unsigned char nData)
218:           {
219:               if(nData > _NRS_TBF) nData = _NRS_TBF;
220:               if(!nData) nData = _NRS_TBF;
221:               UADt.CHK = LiczRSCHK(bufTUART, nData - 1); //liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
222:               bufTUART[nData - 1] = UADt.CHK; //zapisz w buforze danych do wysylki (na ostatniej pozycji) obliczona wartosc CHK
223:           }
224:           //------------------------------------------------------------------------------------
225:           //Funkcja przeznaczona dla sytuacji gdy po wyslaniu paczki danych spodziewamu sie otrzymac odpowiedz w postaci dwoch bajtow:
226:           //adresu i bajtu potwierdzenia. 
227:           //Funkcja zwraca wartosc 1 gdy bajt potwierdzenia = 0xff wynik pozytywny.
228:           
229:           unsigned char VerifyRSACK(void)
230:           {
231:               if(bufRUART[2] == 0xff) return 1; //porownuje drugi odebrany bajt z obliczonym wczesniej CHK dla paczki wysylanych danych
232:               return 0;
233:           }
234:           //------------------------------------------------------------------------------------
235:           //Oblicza CHK z odebranych danych (pominawszy ostani bajt) i porownuje otrzymany wynik z ostatnim odebranym bajtem
236:           //nData - ogolna liczba odebranych bajtow (lacznie z adresem i bajtem CHK)
237:           //Funkcja zwraca wartosc 1 gdy porownanie ma wynik pozytywny.
238:           
239:           unsigned char VerifyRSCHK(unsigned char nData)
240:           {
241:               if(nData > _NRS_RBF) nData = _NRS_RBF;
242:               if(!nData) nData = _NRS_RBF;
243:               if(bufRUART[nData - 1] == LiczRSCHK(bufRUART, nData - 1)) return 1; //liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
244:               return 0; //i porownuje z ostatnim odebranym bajtem.
245:           }
246:           //------------------------------------------------------------------------------------
247:           //Odczyt obliczonej wartosci CHK (rejestracja CHK odbywa sie za pomoca procedury SetRSCHK(nData)
248:           
249:           unsigned char GetRSCHK(void)
250:           {
251:               return UADt.CHK;
252:           }
253:           //------------------------------------------------------------------------------------
254:           //Oblicza CHK dla liczby danych i zapisuje na trzech najstarszych bitach
255:           
256:           unsigned char SetNDatCHK(const unsigned char Data)
EA96  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
257:           {
258:               unsigned char a, b, d;
259:               d = Data & 0b00011111;
EA98  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
EA9A  0B1F     ANDLW 0x1F
EA9C  6E1B     MOVWF _DtCSf_error, ACCESS
260:               a = d & 0b00000111;
EA9E  501B     MOVF _DtCSf_error, W, ACCESS
EAA0  0B07     ANDLW 0x7
EAA2  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
261:               b = 0b00000100 | (d >> 3);
EAA4  381B     SWAPF _DtCSf_error, W, ACCESS
EAA6  46E8     RLNCF WREG, F, ACCESS
EAA8  0B1F     ANDLW 0x1F
EAAA  0904     IORLW 0x4
EAAC  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
262:               return d | ((a^b) << 5);
EAAE  1819     XORWF _DtCOf_su_SRW_CO, W, ACCESS
EAB0  6E16     MOVWF _DtCOf_resPCO, ACCESS
EAB2  0E05     MOVLW 0x5
EAB4  6E17     MOVWF _DtCOf_su_CO, ACCESS
EAB6  90D8     BCF STATUS, 0, ACCESS
EAB8  3616     RLCF _DtCOf_resPCO, F, ACCESS
EABA  2E17     DECFSZ _DtCOf_su_CO, F, ACCESS
EABC  D7FC     BRA 0xEAB6
EABE  5016     MOVF _DtCOf_resPCO, W, ACCESS
EAC0  101B     IORWF _DtCSf_error, W, ACCESS
EAC2  0012     RETURN 0
263:           }
EAC4  0012     RETURN 0
264:           //Weryfikacja wartosci CHK dla liczby danych
265:           
266:           unsigned char VerifyNDatCHK(const unsigned char Data)
F1E2  6E1C     MOVWF _DtCSf_hi, ACCESS
267:           {
268:               if(SetNDatCHK(Data) == Data) return 1; //liczy CHK z pominieciem ostatniego bajtu (bajt przeznaczony na zapis obliczonego CHK.)
F1E4  501C     MOVF _DtCSf_hi, W, ACCESS
F1E6  EC4B     CALL 0xEA96, 0
F1E8  F075     NOP
F1EA  181C     XORWF _DtCSf_hi, W, ACCESS
F1EC  E102     BNZ 0xF1F2
F1EE  0E01     MOVLW 0x1
F1F0  0012     RETURN 0
269:               return 0; //i porownuje z ostatnim odebranym bajtem.
F1F2  0C00     RETLW 0x0
270:           }
F1F4  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/timer1.c  --------------------------------
1:             /*--------------------------------------------------------------*/
2:             /*timer1.c*/
3:             /*obsluga i konfiguracja modulu Timer1*/
4:             /*--------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"					//parametry globalne
7:             #include "timer1.h"					//parametry lokalne
8:             
9:             /*--------------------------------------------------------------*/
10:            /*-----------------------------PROTECTED DATA-------------------*/
11:            
12:            const unsigned int RldT1 = _RLT1; //wartosc poczatkowa timera
13:            
14:            /*--------------------------------------------------------------*/
15:            //konfiguracja modulu Timer1
16:            
17:            void InitTimer1(void)
18:            {
19:                //----------------------
20:                //wartosc poczatkowa dla Timer1
21:                TMR1H = (unsigned char)(RldT1 >> 8);
E400  0E51     MOVLW 0x51
E402  6EF6     MOVWF TBLPTR, ACCESS
E404  0E10     MOVLW 0x10
E406  6EF7     MOVWF TBLPTRH, ACCESS
E408  0009     TBLRD*+
E40A  CFF5     MOVFF TABLAT, __pcstackBANK0
E40C  F0DE     NOP
E40E  0009     TBLRD*+
E410  CFF5     MOVFF TABLAT, pco
E412  F0DF     NOP
E414  C0DF     MOVFF pco, __pcstackBANK0
E416  F0DE     NOP
E418  0100     MOVLB 0x0
E41A  6BDF     CLRF pco, BANKED
E41C  51DE     MOVF __pcstackBANK0, W, BANKED
E41E  6ECF     MOVWF TMR1H, ACCESS
22:                TMR1L = (unsigned char)(RldT1 & 0xFF);
E420  0E51     MOVLW 0x51
E422  6EF6     MOVWF TBLPTR, ACCESS
E424  0E10     MOVLW 0x10
E426  6EF7     MOVWF TBLPTRH, ACCESS
E428  0008     TBLRD*
E42A  CFF5     MOVFF TABLAT, TMR1
E42C  FFCE     NOP
23:                //----------------------
24:                //Intrerrupt
25:                TMR1IF = 0; //PIR tmr1 overflow interrupt flag bit
E42E  909E     BCF PIR1, 0, ACCESS
26:                TMR1IE = 1; //PIE tmr1 overflow interrupt enable bit
E430  809D     BSF PIE1, 0, ACCESS
27:                TMR1IP = 1; //IPR tmr1 overflow interrupt is a high priority
E432  809F     BSF IPR1, 0, ACCESS
28:                //----------------------
29:                //T1CON
30:                T1RD16 = 1; //16 -bt Read/Write mode enable bt
E434  8ECD     BSF T1CON, 7, ACCESS
31:            
32:                //Prescaler
33:            #if _PRE==1
34:                T1CKPS1 = 0; //timer1 input clock prescale select bt
35:                T1CKPS0 = 0;
36:            #endif	
37:            #if _PRE==2
38:                T1CKPS1 = 0;
E436  9ACD     BCF T1CON, 5, ACCESS
39:                T1CKPS0 = 1;
E438  88CD     BSF T1CON, 4, ACCESS
40:            #endif
41:            #if _PRE==4
42:                T1CKPS1 = 1;
43:                T1CKPS0 = 0;
44:            #endif	
45:            #if _PRE==8
46:                T1CKPS1 = 1;
47:                T1CKPS0 = 1;
48:            #endif
49:                TMR1CS = 0; //internal clock
E43A  92CD     BCF T1CON, 1, ACCESS
50:                TMR1ON = 1; //enables timer1
E43C  80CD     BSF T1CON, 0, ACCESS
51:                //----------------------
52:            }
E43E  0012     RETURN 0
53:            /*--------------------------------------------------------------*/
54:            //wartosc poczatkowa dla Timer1
55:            
56:            void ReloadTimer1(void)
57:            {
58:                TMR1H = (unsigned char)(RldT1 >> 8);
EBDC  0E51     MOVLW 0x51
EBDE  6EF6     MOVWF TBLPTR, ACCESS
EBE0  0E10     MOVLW 0x10
EBE2  6EF7     MOVWF TBLPTRH, ACCESS
EBE4  0009     TBLRD*+
EBE6  CFF5     MOVFF TABLAT, _DtCOf_resPCO
EBE8  F016     NOP
EBEA  0009     TBLRD*+
EBEC  CFF5     MOVFF TABLAT, _DtCOf_su_CO
EBEE  F017     NOP
EBF0  C017     MOVFF _DtCOf_su_CO, _DtCOf_resPCO
EBF2  F016     NOP
EBF4  6A17     CLRF _DtCOf_su_CO, ACCESS
EBF6  5016     MOVF _DtCOf_resPCO, W, ACCESS
EBF8  6ECF     MOVWF TMR1H, ACCESS
59:                TMR1L = (unsigned char)(RldT1 & 0xFF);
EBFA  0E51     MOVLW 0x51
EBFC  6EF6     MOVWF TBLPTR, ACCESS
EBFE  0E10     MOVLW 0x10
EC00  6EF7     MOVWF TBLPTRH, ACCESS
EC02  0008     TBLRD*
EC04  CFF5     MOVFF TABLAT, TMR1
EC06  FFCE     NOP
60:            }
EC08  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/rtimer.c  --------------------------------
1:             /*--------------------------------------------------------------*/
2:             /*rtime.c*/
3:             /*zestaw zegarow czasu rzeczywistego*/
4:             /*typy danych i parametry konfiguracyjne zdefiniowano w pliku rtimer.h*/
5:             /*--------------------------------------------------------------*/
6:             #include <pic18.h>
7:             #include "global.h"			//parametry globalne
8:             #include "rtimer.h"			//parametry lokalne
9:             
10:            //(!) Timery zarezerwowane dla nast. plikow projektu
11:            //RTdS(0)		pwron.c
12:            //RTdS(1)		keypad.c
13:            //RTS(0)		konfig.c, main.c(rozruch)
14:            
15:            /*---------------------------------------------------------------------------------*/
16:            /*-----------------------------PROTECTED DATA--------------------------------------*/
17:            
18:            #if (_NRT_M)||(_NRT_G)||(_NRT_S)
19:            volatile static near RTcomm CommRT;
20:            #endif
21:            #if _NRT_cS
22:            volatile near RTcSekundy cSk[_NRT_cS];
23:            #endif
24:            #if _NRT_dS
25:            volatile near RTdSekundy dSk[_NRT_dS];
26:            #endif
27:            #if _NRT_S
28:            volatile near RTsekundy Sk[_NRT_S];
29:            #endif
30:            #if _NRT_M
31:            volatile near RTminuty Mn[_NRT_M];
32:            #endif
33:            #if _NRT_G
34:            volatile near RTgodziny Gd[_NRT_G];
35:            #endif
36:            
37:            /*--------------------------------------------------------------*/
38:            /*Funkcje obslugi timerow centy sekund*/
39:            #if _NRT_cS
40:            
41:            void StartRTcS(const unsigned char Index)
42:            {
43:                if(Index > _NRT_cS - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
44:                cSk[Index] = 0;
45:            }
46:            
47:            unsigned char RTcS(const unsigned char Index)
48:            {
49:                if(Index > _NRT_cS - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
50:                return cSk[Index];
51:            }
52:            #endif
53:            /*--------------------------------------------------------------*/
54:            /*Funkcje obslugi timerow decy sekund*/
55:            #if _NRT_dS
56:            
57:            void StartRTdS(const unsigned char Index)
E540  0100     MOVLB 0x0
E542  6FDE     MOVWF __pcstackBANK0, BANKED
58:            {
59:                if(Index > _NRT_dS - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
E544  0E0B     MOVLW 0xB
E546  0100     MOVLB 0x0
E548  65DE     CPFSGT __pcstackBANK0, BANKED
E54A  D002     BRA 0xE550
E54C  00FF     RESET
E54E  D000     BRA 0xE550
60:                dSk[Index].cS = 0;
E550  0100     MOVLB 0x0
E552  51DE     MOVF __pcstackBANK0, W, BANKED
E554  0D02     MULLW 0x2
E556  0E20     MOVLW 0x20
E558  24F3     ADDWF PROD, W, ACCESS
E55A  6ED9     MOVWF FSR2, ACCESS
E55C  0E02     MOVLW 0x2
E55E  20F4     ADDWFC PRODH, W, ACCESS
E560  6EDA     MOVWF FSR2H, ACCESS
E562  6ADF     CLRF INDF2, ACCESS
61:                dSk[Index].dS = 0;
E564  51DE     MOVF __pcstackBANK0, W, BANKED
E566  0D02     MULLW 0x2
E568  2AF3     INCF PROD, F, ACCESS
E56A  0E00     MOVLW 0x0
E56C  22F4     ADDWFC PRODH, F, ACCESS
E56E  0E20     MOVLW 0x20
E570  24F3     ADDWF PROD, W, ACCESS
E572  6ED9     MOVWF FSR2, ACCESS
E574  0E02     MOVLW 0x2
E576  20F4     ADDWFC PRODH, W, ACCESS
E578  6EDA     MOVWF FSR2H, ACCESS
E57A  0E00     MOVLW 0x0
E57C  6ADF     CLRF INDF2, ACCESS
62:            }
E57E  0012     RETURN 0
63:            
64:            unsigned char RTdS(const unsigned char Index)
EBAE  0100     MOVLB 0x0
EBB0  6FDE     MOVWF __pcstackBANK0, BANKED
65:            {
66:                if(Index > _NRT_dS - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
EBB2  0E0B     MOVLW 0xB
EBB4  0100     MOVLB 0x0
EBB6  65DE     CPFSGT __pcstackBANK0, BANKED
EBB8  D002     BRA 0xEBBE
EBBA  00FF     RESET
EBBC  D000     BRA 0xEBBE
67:                return dSk[Index].dS;
EBBE  0100     MOVLB 0x0
EBC0  51DE     MOVF __pcstackBANK0, W, BANKED
EBC2  0D02     MULLW 0x2
EBC4  2AF3     INCF PROD, F, ACCESS
EBC6  0E00     MOVLW 0x0
EBC8  22F4     ADDWFC PRODH, F, ACCESS
EBCA  0E20     MOVLW 0x20
EBCC  24F3     ADDWF PROD, W, ACCESS
EBCE  6ED9     MOVWF FSR2, ACCESS
EBD0  0E02     MOVLW 0x2
EBD2  20F4     ADDWFC PRODH, W, ACCESS
EBD4  6EDA     MOVWF FSR2H, ACCESS
EBD6  50DF     MOVF INDF2, W, ACCESS
EBD8  0012     RETURN 0
68:            }
0008  CFFA     MOVFF PCLATH, _DtCWf_su_CW
EBDA  0012     RETURN 0
69:            #endif
70:            /*--------------------------------------------------------------*/
71:            /*Funkcje obslugi timerow sekund*/
72:            #if _NRT_S
73:            
74:            void StartRTS(const unsigned char Index)
E4C0  0100     MOVLB 0x0
E4C2  6FDE     MOVWF __pcstackBANK0, BANKED
75:            {
76:                if(Index > _NRT_S - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
E4C4  0E0F     MOVLW 0xF
E4C6  0100     MOVLB 0x0
E4C8  65DE     CPFSGT __pcstackBANK0, BANKED
E4CA  D002     BRA 0xE4D0
E4CC  00FF     RESET
E4CE  D000     BRA 0xE4D0
77:                Sk[Index].dS = 0;
E4D0  0100     MOVLB 0x0
E4D2  51DE     MOVF __pcstackBANK0, W, BANKED
E4D4  0D02     MULLW 0x2
E4D6  0E00     MOVLW 0x0
E4D8  24F3     ADDWF PROD, W, ACCESS
E4DA  6ED9     MOVWF FSR2, ACCESS
E4DC  0E02     MOVLW 0x2
E4DE  20F4     ADDWFC PRODH, W, ACCESS
E4E0  6EDA     MOVWF FSR2H, ACCESS
E4E2  6ADF     CLRF INDF2, ACCESS
78:                Sk[Index].S = 0;
E4E4  51DE     MOVF __pcstackBANK0, W, BANKED
E4E6  0D02     MULLW 0x2
E4E8  2AF3     INCF PROD, F, ACCESS
E4EA  0E00     MOVLW 0x0
E4EC  22F4     ADDWFC PRODH, F, ACCESS
E4EE  0E00     MOVLW 0x0
E4F0  24F3     ADDWF PROD, W, ACCESS
E4F2  6ED9     MOVWF FSR2, ACCESS
E4F4  0E02     MOVLW 0x2
E4F6  20F4     ADDWFC PRODH, W, ACCESS
E4F8  6EDA     MOVWF FSR2H, ACCESS
E4FA  0E00     MOVLW 0x0
E4FC  6ADF     CLRF INDF2, ACCESS
79:            }
E4FE  0012     RETURN 0
80:            
81:            unsigned char RTS(const unsigned char Index)
EB52  0100     MOVLB 0x0
EB54  6FDE     MOVWF __pcstackBANK0, BANKED
82:            {
83:                if(Index > _NRT_S - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
EB56  0E0F     MOVLW 0xF
EB58  0100     MOVLB 0x0
EB5A  65DE     CPFSGT __pcstackBANK0, BANKED
EB5C  D002     BRA 0xEB62
EB5E  00FF     RESET
EB60  D000     BRA 0xEB62
84:                return Sk[Index].S;
EB62  0100     MOVLB 0x0
EB64  51DE     MOVF __pcstackBANK0, W, BANKED
EB66  0D02     MULLW 0x2
EB68  2AF3     INCF PROD, F, ACCESS
EB6A  0E00     MOVLW 0x0
EB6C  22F4     ADDWFC PRODH, F, ACCESS
EB6E  0E00     MOVLW 0x0
EB70  24F3     ADDWF PROD, W, ACCESS
EB72  6ED9     MOVWF FSR2, ACCESS
EB74  0E02     MOVLW 0x2
EB76  20F4     ADDWFC PRODH, W, ACCESS
EB78  6EDA     MOVWF FSR2H, ACCESS
EB7A  50DF     MOVF INDF2, W, ACCESS
EB7C  0012     RETURN 0
85:            }
EB7E  0012     RETURN 0
86:            #endif
87:            /*--------------------------------------------------------------*/
88:            /*Funkcje obslugi timerow minut*/
89:            #if _NRT_M
90:            
91:            void StartRTM(const unsigned char Index)
E500  0100     MOVLB 0x0
E502  6FDE     MOVWF __pcstackBANK0, BANKED
92:            {
93:                if(Index > _NRT_M - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
E504  0E06     MOVLW 0x6
E506  0100     MOVLB 0x0
E508  65DE     CPFSGT __pcstackBANK0, BANKED
E50A  D002     BRA 0xE510
E50C  00FF     RESET
E50E  D000     BRA 0xE510
94:                Mn[Index].S = 0;
E510  0100     MOVLB 0x0
E512  51DE     MOVF __pcstackBANK0, W, BANKED
E514  0D02     MULLW 0x2
E516  0E2D     MOVLW 0x2D
E518  24F3     ADDWF PROD, W, ACCESS
E51A  6ED9     MOVWF FSR2, ACCESS
E51C  0E01     MOVLW 0x1
E51E  20F4     ADDWFC PRODH, W, ACCESS
E520  6EDA     MOVWF FSR2H, ACCESS
E522  6ADF     CLRF INDF2, ACCESS
95:                Mn[Index].M = 0;
E524  51DE     MOVF __pcstackBANK0, W, BANKED
E526  0D02     MULLW 0x2
E528  2AF3     INCF PROD, F, ACCESS
E52A  0E00     MOVLW 0x0
E52C  22F4     ADDWFC PRODH, F, ACCESS
E52E  0E2D     MOVLW 0x2D
E530  24F3     ADDWF PROD, W, ACCESS
E532  6ED9     MOVWF FSR2, ACCESS
E534  0E01     MOVLW 0x1
E536  20F4     ADDWFC PRODH, W, ACCESS
E538  6EDA     MOVWF FSR2H, ACCESS
E53A  0E00     MOVLW 0x0
E53C  6ADF     CLRF INDF2, ACCESS
96:            }
E53E  0012     RETURN 0
97:            
98:            unsigned char RTM(const unsigned char Index)
EB80  0100     MOVLB 0x0
EB82  6FDE     MOVWF __pcstackBANK0, BANKED
99:            {
100:               if(Index > _NRT_M - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
EB84  0E06     MOVLW 0x6
EB86  0100     MOVLB 0x0
EB88  65DE     CPFSGT __pcstackBANK0, BANKED
EB8A  D002     BRA 0xEB90
EB8C  00FF     RESET
EB8E  D000     BRA 0xEB90
101:               return Mn[Index].M;
EB90  0100     MOVLB 0x0
EB92  51DE     MOVF __pcstackBANK0, W, BANKED
EB94  0D02     MULLW 0x2
EB96  2AF3     INCF PROD, F, ACCESS
EB98  0E00     MOVLW 0x0
EB9A  22F4     ADDWFC PRODH, F, ACCESS
EB9C  0E2D     MOVLW 0x2D
EB9E  24F3     ADDWF PROD, W, ACCESS
EBA0  6ED9     MOVWF FSR2, ACCESS
EBA2  0E01     MOVLW 0x1
EBA4  20F4     ADDWFC PRODH, W, ACCESS
EBA6  6EDA     MOVWF FSR2H, ACCESS
EBA8  50DF     MOVF INDF2, W, ACCESS
EBAA  0012     RETURN 0
102:           }
EBAC  0012     RETURN 0
103:           
104:           unsigned char RTMs(const unsigned char Index)
105:           {
106:               if(Index > _NRT_M - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
107:               return Mn[Index].S;
108:           }
109:           #endif
110:           /*--------------------------------------------------------------*/
111:           /*Funkcje obslugi timerow godzin*/
112:           #if _NRT_G
113:           
114:           void StartRTG(const unsigned char Index)
E480  0100     MOVLB 0x0
E482  6FDE     MOVWF __pcstackBANK0, BANKED
115:           {
116:               if(Index > _NRT_G - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
E484  0E02     MOVLW 0x2
E486  0100     MOVLB 0x0
E488  65DE     CPFSGT __pcstackBANK0, BANKED
E48A  D002     BRA 0xE490
E48C  00FF     RESET
E48E  D000     BRA 0xE490
117:               Gd[Index].M = 0;
E490  0100     MOVLB 0x0
E492  51DE     MOVF __pcstackBANK0, W, BANKED
E494  0D02     MULLW 0x2
E496  0E3B     MOVLW 0x3B
E498  24F3     ADDWF PROD, W, ACCESS
E49A  6ED9     MOVWF FSR2, ACCESS
E49C  0E01     MOVLW 0x1
E49E  20F4     ADDWFC PRODH, W, ACCESS
E4A0  6EDA     MOVWF FSR2H, ACCESS
E4A2  6ADF     CLRF INDF2, ACCESS
118:               Gd[Index].G = 0;
E4A4  51DE     MOVF __pcstackBANK0, W, BANKED
E4A6  0D02     MULLW 0x2
E4A8  2AF3     INCF PROD, F, ACCESS
E4AA  0E00     MOVLW 0x0
E4AC  22F4     ADDWFC PRODH, F, ACCESS
E4AE  0E3B     MOVLW 0x3B
E4B0  24F3     ADDWF PROD, W, ACCESS
E4B2  6ED9     MOVWF FSR2, ACCESS
E4B4  0E01     MOVLW 0x1
E4B6  20F4     ADDWFC PRODH, W, ACCESS
E4B8  6EDA     MOVWF FSR2H, ACCESS
E4BA  0E00     MOVLW 0x0
E4BC  6ADF     CLRF INDF2, ACCESS
119:           }
E4BE  0012     RETURN 0
120:           
121:           unsigned char RTG(const unsigned char Index)
EB24  0100     MOVLB 0x0
EB26  6FDE     MOVWF __pcstackBANK0, BANKED
122:           {
123:               if(Index > _NRT_G - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
EB28  0E02     MOVLW 0x2
EB2A  0100     MOVLB 0x0
EB2C  65DE     CPFSGT __pcstackBANK0, BANKED
EB2E  D002     BRA 0xEB34
EB30  00FF     RESET
EB32  D000     BRA 0xEB34
124:               return Gd[Index].G;
EB34  0100     MOVLB 0x0
EB36  51DE     MOVF __pcstackBANK0, W, BANKED
EB38  0D02     MULLW 0x2
EB3A  2AF3     INCF PROD, F, ACCESS
EB3C  0E00     MOVLW 0x0
EB3E  22F4     ADDWFC PRODH, F, ACCESS
EB40  0E3B     MOVLW 0x3B
EB42  24F3     ADDWF PROD, W, ACCESS
EB44  6ED9     MOVWF FSR2, ACCESS
EB46  0E01     MOVLW 0x1
EB48  20F4     ADDWFC PRODH, W, ACCESS
EB4A  6EDA     MOVWF FSR2H, ACCESS
EB4C  50DF     MOVF INDF2, W, ACCESS
EB4E  0012     RETURN 0
125:           }
EB50  0012     RETURN 0
126:           #endif
127:           
128:           /*---------------------------------------------------------------*/
129:           
130:           /*Glowna funkcja obslugi timerow*/
131:           void IncRTimer(void)
132:           {
133:           #if (_NRT_M)||(_NRT_G)||(_NRT_S)||(_NRT_dS)||(_NRT_cS)
134:               unsigned char i;
135:           #endif
136:           
137:               /*zakres czasu od 0,01 do 2,55 sek. z krokiem 0,01 sek. blad=+/-0,01 sek*/
138:           
139:           #if _NRT_cS
140:               for(i = 0; i < _NRT_cS; i++)
141:                   if(cSk[i] < 255) cSk[i]++;
142:           #endif
143:           
144:               /*zakres czasu od 0,1 do 25,5 sek. z krokiem 0,1 sek. blad=+/-0,01 sek*/
145:           
146:           #if _NRT_dS
147:               for(i = 0; i < _NRT_dS; i++)
8C10  6A17     CLRF _DtCOf_su_CO, ACCESS
8C12  0E0B     MOVLW 0xB
8C14  6417     CPFSGT _DtCOf_su_CO, ACCESS
8C16  D001     BRA 0x8C1A
8C18  D039     BRA 0x8C8C
8C88  2A17     INCF _DtCOf_su_CO, F, ACCESS
8C8A  D7C3     BRA 0x8C12
148:               {
149:                   dSk[i].cS++;
8C1A  5017     MOVF _DtCOf_su_CO, W, ACCESS
8C1C  0D02     MULLW 0x2
8C1E  0E20     MOVLW 0x20
8C20  24F3     ADDWF PROD, W, ACCESS
8C22  6ED9     MOVWF FSR2, ACCESS
8C24  0E02     MOVLW 0x2
8C26  20F4     ADDWFC PRODH, W, ACCESS
8C28  6EDA     MOVWF FSR2H, ACCESS
8C2A  2ADF     INCF INDF2, F, ACCESS
150:                   if(dSk[i].cS > 9)
8C2C  5017     MOVF _DtCOf_su_CO, W, ACCESS
8C2E  0D02     MULLW 0x2
8C30  0E20     MOVLW 0x20
8C32  24F3     ADDWF PROD, W, ACCESS
8C34  6ED9     MOVWF FSR2, ACCESS
8C36  0E02     MOVLW 0x2
8C38  20F4     ADDWFC PRODH, W, ACCESS
8C3A  6EDA     MOVWF FSR2H, ACCESS
8C3C  0E09     MOVLW 0x9
8C3E  64DF     CPFSGT INDF2, ACCESS
8C40  D023     BRA 0x8C88
151:                   {
152:                       dSk[i].cS = 0;
8C42  5017     MOVF _DtCOf_su_CO, W, ACCESS
8C44  0D02     MULLW 0x2
8C46  0E20     MOVLW 0x20
8C48  24F3     ADDWF PROD, W, ACCESS
8C4A  6ED9     MOVWF FSR2, ACCESS
8C4C  0E02     MOVLW 0x2
8C4E  20F4     ADDWFC PRODH, W, ACCESS
8C50  6EDA     MOVWF FSR2H, ACCESS
8C52  6ADF     CLRF INDF2, ACCESS
153:                       if(dSk[i].dS < 255) dSk[i].dS++;
8C54  5017     MOVF _DtCOf_su_CO, W, ACCESS
8C56  0D02     MULLW 0x2
8C58  2AF3     INCF PROD, F, ACCESS
8C5A  0E00     MOVLW 0x0
8C5C  22F4     ADDWFC PRODH, F, ACCESS
8C5E  0E20     MOVLW 0x20
8C60  24F3     ADDWF PROD, W, ACCESS
8C62  6ED9     MOVWF FSR2, ACCESS
8C64  0E02     MOVLW 0x2
8C66  20F4     ADDWFC PRODH, W, ACCESS
8C68  6EDA     MOVWF FSR2H, ACCESS
8C6A  28DE     INCF POSTINC2, W, ACCESS
8C6C  E00D     BZ 0x8C88
8C6E  5017     MOVF _DtCOf_su_CO, W, ACCESS
8C70  0D02     MULLW 0x2
8C72  2AF3     INCF PROD, F, ACCESS
8C74  0E00     MOVLW 0x0
8C76  22F4     ADDWFC PRODH, F, ACCESS
8C78  0E20     MOVLW 0x20
8C7A  24F3     ADDWF PROD, W, ACCESS
8C7C  6ED9     MOVWF FSR2, ACCESS
8C7E  0E02     MOVLW 0x2
8C80  20F4     ADDWFC PRODH, W, ACCESS
8C82  6EDA     MOVWF FSR2H, ACCESS
8C84  2ADF     INCF INDF2, F, ACCESS
8C86  D000     BRA 0x8C88
154:                   }
155:               }
156:           #endif
157:           
158:           #if (_NRT_S)||(_NRT_M)||(_NRT_G)
159:           
160:               CommRT.cS++;
8C8C  0100     MOVLB 0x0
8C8E  2BBF     INCF CommRT, F, BANKED
161:               if(CommRT.cS > 9)
8C90  0E09     MOVLW 0x9
8C92  0100     MOVLB 0x0
8C94  65BF     CPFSGT CommRT, BANKED
8C96  0C09     RETLW 0x9
162:               {
163:                   CommRT.cS = 0;
8C98  6BBF     CLRF CommRT, BANKED
164:                   CommRT.dS++;
8C9A  0100     MOVLB 0x0
8C9C  2BC0     INCF 0xC0, F, BANKED
165:           
166:                   /*zakres czasu od 1 do 255 sek. z krokiem 1 sek. blad=+/-0,1 sek*/
167:           
168:           #if _NRT_S
169:                   for(i = 0; i < _NRT_S; i++)
8C9E  0E00     MOVLW 0x0
8CA0  6E17     MOVWF _DtCOf_su_CO, ACCESS
8CA2  0E0F     MOVLW 0xF
8CA4  6417     CPFSGT _DtCOf_su_CO, ACCESS
8CA6  D001     BRA 0x8CAA
8CA8  D039     BRA 0x8D1C
8D18  2A17     INCF _DtCOf_su_CO, F, ACCESS
8D1A  D7C3     BRA 0x8CA2
170:                   {
171:                       Sk[i].dS++;
8CAA  5017     MOVF _DtCOf_su_CO, W, ACCESS
8CAC  0D02     MULLW 0x2
8CAE  0E00     MOVLW 0x0
8CB0  24F3     ADDWF PROD, W, ACCESS
8CB2  6ED9     MOVWF FSR2, ACCESS
8CB4  0E02     MOVLW 0x2
8CB6  20F4     ADDWFC PRODH, W, ACCESS
8CB8  6EDA     MOVWF FSR2H, ACCESS
8CBA  2ADF     INCF INDF2, F, ACCESS
172:                       if(Sk[i].dS > 9)
8CBC  5017     MOVF _DtCOf_su_CO, W, ACCESS
8CBE  0D02     MULLW 0x2
8CC0  0E00     MOVLW 0x0
8CC2  24F3     ADDWF PROD, W, ACCESS
8CC4  6ED9     MOVWF FSR2, ACCESS
8CC6  0E02     MOVLW 0x2
8CC8  20F4     ADDWFC PRODH, W, ACCESS
8CCA  6EDA     MOVWF FSR2H, ACCESS
8CCC  0E09     MOVLW 0x9
8CCE  64DF     CPFSGT INDF2, ACCESS
8CD0  D023     BRA 0x8D18
173:                       {
174:                           Sk[i].dS = 0;
8CD2  5017     MOVF _DtCOf_su_CO, W, ACCESS
8CD4  0D02     MULLW 0x2
8CD6  0E00     MOVLW 0x0
8CD8  24F3     ADDWF PROD, W, ACCESS
8CDA  6ED9     MOVWF FSR2, ACCESS
8CDC  0E02     MOVLW 0x2
8CDE  20F4     ADDWFC PRODH, W, ACCESS
8CE0  6EDA     MOVWF FSR2H, ACCESS
8CE2  6ADF     CLRF INDF2, ACCESS
175:                           if(Sk[i].S < 255) Sk[i].S++;
8CE4  5017     MOVF _DtCOf_su_CO, W, ACCESS
8CE6  0D02     MULLW 0x2
8CE8  2AF3     INCF PROD, F, ACCESS
8CEA  0E00     MOVLW 0x0
8CEC  22F4     ADDWFC PRODH, F, ACCESS
8CEE  0E00     MOVLW 0x0
8CF0  24F3     ADDWF PROD, W, ACCESS
8CF2  6ED9     MOVWF FSR2, ACCESS
8CF4  0E02     MOVLW 0x2
8CF6  20F4     ADDWFC PRODH, W, ACCESS
8CF8  6EDA     MOVWF FSR2H, ACCESS
8CFA  28DE     INCF POSTINC2, W, ACCESS
8CFC  E00D     BZ 0x8D18
8CFE  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D00  0D02     MULLW 0x2
8D02  2AF3     INCF PROD, F, ACCESS
8D04  0E00     MOVLW 0x0
8D06  22F4     ADDWFC PRODH, F, ACCESS
8D08  0E00     MOVLW 0x0
8D0A  24F3     ADDWF PROD, W, ACCESS
8D0C  6ED9     MOVWF FSR2, ACCESS
8D0E  0E02     MOVLW 0x2
8D10  20F4     ADDWFC PRODH, W, ACCESS
8D12  6EDA     MOVWF FSR2H, ACCESS
8D14  2ADF     INCF INDF2, F, ACCESS
8D16  D000     BRA 0x8D18
176:                       }
177:                   }
178:           #endif
179:           
180:                   if(CommRT.dS > 9)
8D1C  0E09     MOVLW 0x9
8D1E  0100     MOVLB 0x0
8D20  65C0     CPFSGT 0xC0, BANKED
8D22  0C09     RETLW 0x9
181:                   {
182:                       CommRT.dS = 0;
8D24  6BC0     CLRF 0xC0, BANKED
183:                       CommRT.S++;
8D26  0100     MOVLB 0x0
8D28  2BC1     INCF 0xC1, F, BANKED
184:           
185:                       /*zakres czasu od 1 do 255 min. z krokiem 1 min. blad=+/- 1 sek*/
186:           
187:           #if _NRT_M
188:                       for(i = 0; i < _NRT_M; i++)
8D2A  0E00     MOVLW 0x0
8D2C  6E17     MOVWF _DtCOf_su_CO, ACCESS
8D2E  0E06     MOVLW 0x6
8D30  6417     CPFSGT _DtCOf_su_CO, ACCESS
8D32  D001     BRA 0x8D36
8D34  D039     BRA 0x8DA8
8DA4  2A17     INCF _DtCOf_su_CO, F, ACCESS
8DA6  D7C3     BRA 0x8D2E
189:                       {
190:                           Mn[i].S++;
8D36  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D38  0D02     MULLW 0x2
8D3A  0E2D     MOVLW 0x2D
8D3C  24F3     ADDWF PROD, W, ACCESS
8D3E  6ED9     MOVWF FSR2, ACCESS
8D40  0E01     MOVLW 0x1
8D42  20F4     ADDWFC PRODH, W, ACCESS
8D44  6EDA     MOVWF FSR2H, ACCESS
8D46  2ADF     INCF INDF2, F, ACCESS
191:                           if(Mn[i].S > 59)
8D48  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D4A  0D02     MULLW 0x2
8D4C  0E2D     MOVLW 0x2D
8D4E  24F3     ADDWF PROD, W, ACCESS
8D50  6ED9     MOVWF FSR2, ACCESS
8D52  0E01     MOVLW 0x1
8D54  20F4     ADDWFC PRODH, W, ACCESS
8D56  6EDA     MOVWF FSR2H, ACCESS
8D58  0E3B     MOVLW 0x3B
8D5A  64DF     CPFSGT INDF2, ACCESS
8D5C  D023     BRA 0x8DA4
192:                           {
193:                               Mn[i].S = 0;
8D5E  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D60  0D02     MULLW 0x2
8D62  0E2D     MOVLW 0x2D
8D64  24F3     ADDWF PROD, W, ACCESS
8D66  6ED9     MOVWF FSR2, ACCESS
8D68  0E01     MOVLW 0x1
8D6A  20F4     ADDWFC PRODH, W, ACCESS
8D6C  6EDA     MOVWF FSR2H, ACCESS
8D6E  6ADF     CLRF INDF2, ACCESS
194:                               if(Mn[i].M < 255) Mn[i].M++;
8D70  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D72  0D02     MULLW 0x2
8D74  2AF3     INCF PROD, F, ACCESS
8D76  0E00     MOVLW 0x0
8D78  22F4     ADDWFC PRODH, F, ACCESS
8D7A  0E2D     MOVLW 0x2D
8D7C  24F3     ADDWF PROD, W, ACCESS
8D7E  6ED9     MOVWF FSR2, ACCESS
8D80  0E01     MOVLW 0x1
8D82  20F4     ADDWFC PRODH, W, ACCESS
8D84  6EDA     MOVWF FSR2H, ACCESS
8D86  28DE     INCF POSTINC2, W, ACCESS
8D88  E00D     BZ 0x8DA4
8D8A  5017     MOVF _DtCOf_su_CO, W, ACCESS
8D8C  0D02     MULLW 0x2
8D8E  2AF3     INCF PROD, F, ACCESS
8D90  0E00     MOVLW 0x0
8D92  22F4     ADDWFC PRODH, F, ACCESS
8D94  0E2D     MOVLW 0x2D
8D96  24F3     ADDWF PROD, W, ACCESS
8D98  6ED9     MOVWF FSR2, ACCESS
8D9A  0E01     MOVLW 0x1
8D9C  20F4     ADDWFC PRODH, W, ACCESS
8D9E  6EDA     MOVWF FSR2H, ACCESS
8DA0  2ADF     INCF INDF2, F, ACCESS
8DA2  D000     BRA 0x8DA4
195:                           }
196:                       }
197:           #endif
198:           
199:                       if(CommRT.S > 59)
8DA8  0E3B     MOVLW 0x3B
8DAA  0100     MOVLB 0x0
8DAC  65C1     CPFSGT 0xC1, BANKED
8DAE  0C3B     RETLW 0x3B
200:                       {
201:                           CommRT.S = 0;
8DB0  0E00     MOVLW 0x0
8DB2  6FC1     MOVWF 0xC1, BANKED
202:           
203:                           /*zakres czasu od 1 do 255 godzin z krokiem 1 godz. blad=+/- 1 min*/
204:           
205:           #if _NRT_G
206:                           for(i = 0; i < _NRT_G; i++)
8DB4  6E17     MOVWF _DtCOf_su_CO, ACCESS
8DB6  0E02     MOVLW 0x2
8DB8  6417     CPFSGT _DtCOf_su_CO, ACCESS
8DBA  D002     BRA 0x8DC0
8DBC  0C02     RETLW 0x2
8DBE  0012     RETURN 0
8E2E  2A17     INCF _DtCOf_su_CO, F, ACCESS
8E30  0E02     MOVLW 0x2
8E32  6417     CPFSGT _DtCOf_su_CO, ACCESS
8E34  D7C5     BRA 0x8DC0
8E36  0C02     RETLW 0x2
207:                           {
208:                               Gd[i].M++;
8DC0  5017     MOVF _DtCOf_su_CO, W, ACCESS
8DC2  0D02     MULLW 0x2
8DC4  0E3B     MOVLW 0x3B
8DC6  24F3     ADDWF PROD, W, ACCESS
8DC8  6ED9     MOVWF FSR2, ACCESS
8DCA  0E01     MOVLW 0x1
8DCC  20F4     ADDWFC PRODH, W, ACCESS
8DCE  6EDA     MOVWF FSR2H, ACCESS
8DD0  2ADF     INCF INDF2, F, ACCESS
209:                               if(Gd[i].M > 59)
8DD2  5017     MOVF _DtCOf_su_CO, W, ACCESS
8DD4  0D02     MULLW 0x2
8DD6  0E3B     MOVLW 0x3B
8DD8  24F3     ADDWF PROD, W, ACCESS
8DDA  6ED9     MOVWF FSR2, ACCESS
8DDC  0E01     MOVLW 0x1
8DDE  20F4     ADDWFC PRODH, W, ACCESS
8DE0  6EDA     MOVWF FSR2H, ACCESS
8DE2  0E3B     MOVLW 0x3B
8DE4  64DF     CPFSGT INDF2, ACCESS
8DE6  D023     BRA 0x8E2E
210:                               {
211:                                   Gd[i].M = 0;
8DE8  5017     MOVF _DtCOf_su_CO, W, ACCESS
8DEA  0D02     MULLW 0x2
8DEC  0E3B     MOVLW 0x3B
8DEE  24F3     ADDWF PROD, W, ACCESS
8DF0  6ED9     MOVWF FSR2, ACCESS
8DF2  0E01     MOVLW 0x1
8DF4  20F4     ADDWFC PRODH, W, ACCESS
8DF6  6EDA     MOVWF FSR2H, ACCESS
8DF8  6ADF     CLRF INDF2, ACCESS
212:                                   if(Gd[i].G < 255) Gd[i].G++;
8DFA  5017     MOVF _DtCOf_su_CO, W, ACCESS
8DFC  0D02     MULLW 0x2
8DFE  2AF3     INCF PROD, F, ACCESS
8E00  0E00     MOVLW 0x0
8E02  22F4     ADDWFC PRODH, F, ACCESS
8E04  0E3B     MOVLW 0x3B
8E06  24F3     ADDWF PROD, W, ACCESS
8E08  6ED9     MOVWF FSR2, ACCESS
8E0A  0E01     MOVLW 0x1
8E0C  20F4     ADDWFC PRODH, W, ACCESS
8E0E  6EDA     MOVWF FSR2H, ACCESS
8E10  28DE     INCF POSTINC2, W, ACCESS
8E12  E00D     BZ 0x8E2E
8E14  5017     MOVF _DtCOf_su_CO, W, ACCESS
8E16  0D02     MULLW 0x2
8E18  2AF3     INCF PROD, F, ACCESS
8E1A  0E00     MOVLW 0x0
8E1C  22F4     ADDWFC PRODH, F, ACCESS
8E1E  0E3B     MOVLW 0x3B
8E20  24F3     ADDWF PROD, W, ACCESS
8E22  6ED9     MOVWF FSR2, ACCESS
8E24  0E01     MOVLW 0x1
8E26  20F4     ADDWFC PRODH, W, ACCESS
8E28  6EDA     MOVWF FSR2H, ACCESS
8E2A  2ADF     INCF INDF2, F, ACCESS
8E2C  D000     BRA 0x8E2E
213:                               }
214:                           }
215:           #endif
216:                       }
217:                   }
8E38  0012     RETURN 0
218:           
219:               }
220:           #endif
221:           
222:           }
8E3A  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/rgl.c  -----------------------------------
1:             /*rgl.c*/
2:             /*---------------------------------------------------------------------------------*/
3:             #include <pic18.h>
4:             #include "global.h"				//parametry globalne
5:             #include "rgl.h"				//parametry lokalne
6:             #include "main.tp.h"
7:             #include "pomiar.h"
8:             #include "pwm.h"
9:             #include "konfig2.h"
10:            #include "pompa.tp.h"
11:            
12:            
13:            volatile DtRgl rgl;
14:            
15:            extern DtPMP PMP;
16:            extern DataCO DtCO;
17:            extern DataCW DtCW;
18:            extern DtPWM PWM;
19:            extern DtKONF DtKNF;
20:            extern tpMAIN M;
21:            //extern unsigned char x;
22:            
23:            unsigned char tmr, tmr2;
24:            unsigned char pwm_center, pwm_kwr;
25:            
26:            //************************************************************
27:            //Procedura modulacji
28:            
29:            void Moduluj(void)
30:            {
31:                //	unsigned int wpw;
32:                //	unsigned char wpp;
33:            
34:                switch(DtKNF.tpkt) //rodzaj kotla
6188  D17D     BRA 0x6484
6484  0100     MOVLB 0x0
6486  519E     MOVF _PWMf_ENPWM2, W, BANKED
6488  E101     BNZ 0x648C
648A  D71B     BRA 0x62C2
648C  0A01     XORLW 0x1
648E  E101     BNZ 0x6492
6490  D67C     BRA 0x618A
6492  0A03     XORLW 0x3
6494  E101     BNZ 0x6498
6496  D764     BRA 0x6360
6498  0A01     XORLW 0x1
649A  E101     BNZ 0x649E
649C  D6C9     BRA 0x6230
649E  D7A9     BRA 0x63F2
35:                {
36:                    case _BITERM: //kociol bitermiczny (miniterm)
37:                    {
38:                        if(Mf_pob_CO) //obieg CO
618A  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
618C  D024     BRA 0x61D6
39:                        {
40:                            PWM.MAXPWM = PWM.MMAXCO; //maksymalna nastawa modulatora
618E  C07D     MOVFF _PFNf_obgCO, _PFNf_ofnserw
6190  F081     NOP
41:                            PWM.MINPWM = PWM.MDMOD;
6192  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
6194  F080     NOP
42:                            StartCO(); //parametry startowe dla CO
6196  ECA7     CALL 0xE14E, 0
6198  F070     NOP
43:                            ReadDataCO(); //wprowadzenie danych wejsciowych dla CO
619A  ECD7     CALL 0xF3AE, 0
619C  F079     NOP
44:                            ModToCO(); //zmien obieg na CO
619E  EC97     CALL 0xF32E, 0
61A0  F079     NOP
45:                            ModZgCO(); //pierwsze przyblizenie
61A2  EC31     CALL 0x9062, 0
61A4  F048     NOP
46:                            ModDkCO(); //drugie przyblizenie
61A6  ECCE     CALL 0xBB9C, 0
61A8  F05D     NOP
47:                            if(RTdS(_RTMOD) > _TOKM)
61AA  0E02     MOVLW 0x2
61AC  ECD7     CALL 0xEBAE, 0
61AE  F075     NOP
61B0  0100     MOVLB 0x0
61B2  6FFB     MOVWF d, BANKED
61B4  0E0A     MOVLW 0xA
61B6  65FB     CPFSGT d, BANKED
61B8  D00A     BRA 0x61CE
48:                            {
49:                                StartRTdS(_RTMOD);
61BA  0E02     MOVLW 0x2
61BC  ECA0     CALL 0xE540, 0
61BE  F072     NOP
50:                                IncConstCOCW(); //oblicza czas przez ktory temp CO = const
61C0  EC1F     CALL 0xF23E, 0
61C2  F079     NOP
51:                                IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
61C4  EC2D     CALL 0xB85A, 0
61C6  F05C     NOP
52:                                ModPruCO(); //trzecie przyblizenie
61C8  EC55     CALL 0x9AAA, 0
61CA  F04D     NOP
61CC  D000     BRA 0x61CE
53:                            }
54:                            ModPrzCO(); //reakcja superwizyjna
61CE  EC69     CALL 0xD4D2, 0
61D0  F06A     NOP
55:                            PropOPT();
61D2  EFBF     GOTO 0xF17E
61D4  F078     NOP
56:                        }
57:                        else
58:                            if(Mf_pob_CW) //obieg CW
61D6  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
61D8  0012     RETURN 0
59:                        {
60:                            StartMCW(); //parametry startowe dla CW
61DA  ECB0     CALL 0xC360, 0
61DC  F061     NOP
61:                            ReadDataCW(); //wprowadzenie danych wejsciowych dla CW
61DE  EC0D     CALL 0xF21A, 0
61E0  F079     NOP
62:                            ModToCW(); //zmien obieg na CW
61E2  EC82     CALL 0xF304, 0
61E4  F079     NOP
63:                            ModZgCW(); //pierwsze przyblizenie
61E6  EC57     CALL 0x94AE, 0
61E8  F04A     NOP
64:                            ModDkCW(); //drugie przyblizenie
61EA  EC01     CALL 0xBA02, 0
61EC  F05D     NOP
65:                            if(RTdS(_RTMOD) > _TOKM)
61EE  0E02     MOVLW 0x2
61F0  ECD7     CALL 0xEBAE, 0
61F2  F075     NOP
61F4  0100     MOVLB 0x0
61F6  6FFB     MOVWF d, BANKED
61F8  0E0A     MOVLW 0xA
61FA  65FB     CPFSGT d, BANKED
61FC  D014     BRA 0x6226
66:                            {
67:                                StartRTdS(_RTMOD);
61FE  0E02     MOVLW 0x2
6200  ECA0     CALL 0xE540, 0
6202  F072     NOP
68:                                if(tmr < 0xff) tmr++;
6204  0100     MOVLB 0x0
6206  29CD     INCF tmr, W, BANKED
6208  E002     BZ 0x620E
620A  2BCD     INCF tmr, F, BANKED
620C  D000     BRA 0x620E
69:                                if(tmr2 < 0xff) tmr2++;
620E  0101     MOVLB 0x1
6210  297B     INCF _PFNf_newPFN, W, BANKED
6212  E002     BZ 0x6218
6214  2B7B     INCF _PFNf_newPFN, F, BANKED
6216  D000     BRA 0x6218
70:                                IncConstCOCW(); //oblicza czas przez ktory temp CW = const
6218  EC1F     CALL 0xF23E, 0
621A  F079     NOP
71:                                IncMaxCW(); //inkrementacja maksymalnej wartosci mocy na palniku
621C  EC9F     CALL 0xA33E, 0
621E  F051     NOP
72:                                ModPruCW(); //trzecie przyblizenie
6220  EC46     CALL 0x4C8C, 0
6222  F026     NOP
6224  D000     BRA 0x6226
73:                            }
74:                            ModPrzCW(); //reakcja superwizyjna
6226  EC39     CALL 0x4072, 0
6228  F020     NOP
75:                            PropCO(); //zabezpieczenie od przegrzania w obwodzie CO				StartMCW2();		//parametry startowe dla CW
622A  EC70     CALL 0xD6E0, 0
622C  F06B     NOP
76:                        }
77:                        break;
622E  0012     RETURN 0
78:                    }
79:                    case _MONOHB: //kociol z hydroblokiem
80:                    {
81:                        if(Mf_pob_CO) //obieg CO
6230  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
6232  D024     BRA 0x627C
82:                        {
83:                            PWM.MAXPWM = PWM.MMAXCO; //maksymalna nastawa modulatora
6234  C07D     MOVFF _PFNf_obgCO, _PFNf_ofnserw
6236  F081     NOP
84:                            PWM.MINPWM = PWM.MDMOD;
6238  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
623A  F080     NOP
85:                            StartCO2(); //parametry startowe dla CO
623C  EC14     CALL 0xE028, 0
623E  F070     NOP
86:                            ReadDataCO2(); //wprowadzenie danych wejsciowych dla CO
6240  ECD2     CALL 0xF3A4, 0
6242  F079     NOP
87:                            ModToCO2(); //zmien obieg na CO
6244  EC90     CALL 0xF320, 0
6246  F079     NOP
88:                            ModZgCO(); //pierwsze przyblizenie
6248  EC31     CALL 0x9062, 0
624A  F048     NOP
89:                            ModDkCO(); //drugie przyblizenie
624C  ECCE     CALL 0xBB9C, 0
624E  F05D     NOP
90:                            if(RTdS(_RTMOD) > _TOKM)
6250  0E02     MOVLW 0x2
6252  ECD7     CALL 0xEBAE, 0
6254  F075     NOP
6256  0100     MOVLB 0x0
6258  6FFB     MOVWF d, BANKED
625A  0E0A     MOVLW 0xA
625C  65FB     CPFSGT d, BANKED
625E  D00A     BRA 0x6274
91:                            {
92:                                StartRTdS(_RTMOD);
6260  0E02     MOVLW 0x2
6262  ECA0     CALL 0xE540, 0
6264  F072     NOP
93:                                IncConstCO2(); //oblicza czas przez ktory temp CO = const
6266  EC28     CALL 0xF250, 0
6268  F079     NOP
94:                                IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
626A  EC2D     CALL 0xB85A, 0
626C  F05C     NOP
95:                                ModPruCO(); //trzecie przyblizenie
626E  EC55     CALL 0x9AAA, 0
6270  F04D     NOP
6272  D000     BRA 0x6274
96:                            }
97:            
98:                            ModPrzCO(); //reakcja superwizyjna
6274  EC69     CALL 0xD4D2, 0
6276  F06A     NOP
99:                            PropOPT();
6278  EFBF     GOTO 0xF17E
627A  F078     NOP
100:                       }
101:                       else
102:                           if(Mf_pob_CW) //obieg CW
627C  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
627E  0012     RETURN 0
103:                       {
104:                           StartMCW2(); //parametry startowe dla CW
6280  EC33     CALL 0xEA66, 0
6282  F075     NOP
105:                           ReadDataCW2(); //wprowadzenie danych wejsciowych dla CW
6284  EC04     CALL 0xF208, 0
6286  F079     NOP
106:                           ModToCW2(); //zmien obieg na CW
6288  EC7B     CALL 0xF2F6, 0
628A  F079     NOP
107:                           ModZgCW2(); //pierwsze przyblizenie
628C  EC33     CALL 0x7E66, 0
628E  F03F     NOP
108:                           ModDkCW2(); //drugie przyblizenie
6290  EC90     CALL 0xBD20, 0
6292  F05E     NOP
109:                           if(RTdS(_RTMOD) > _TOKM)
6294  0E02     MOVLW 0x2
6296  ECD7     CALL 0xEBAE, 0
6298  F075     NOP
629A  0100     MOVLB 0x0
629C  6FFB     MOVWF d, BANKED
629E  0E0A     MOVLW 0xA
62A0  65FB     CPFSGT d, BANKED
62A2  D00A     BRA 0x62B8
110:                           {
111:                               StartRTdS(_RTMOD);
62A4  0E02     MOVLW 0x2
62A6  ECA0     CALL 0xE540, 0
62A8  F072     NOP
112:                               IncConstCW2(); //oblicza czas przez ktory temp CW = const
62AA  ECBA     CALL 0xEF74, 0
62AC  F077     NOP
113:                               IncMaxCW2(); //inkrementacja maksymalnej wartosci mocy na palniku
62AE  EC41     CALL 0xCC82, 0
62B0  F066     NOP
114:                               ModPruCW2(); //trzecie przyblizenie
62B2  EC46     CALL 0x448C, 0
62B4  F022     NOP
62B6  D000     BRA 0x62B8
115:                           }
116:                           ModPrzCW2(); //reakcja superwizyjna
62B8  EC5E     CALL 0xDCBC, 0
62BA  F06E     NOP
117:                           PropCO2(); //zabezpieczenie od przegrzania w obwodzie CO
62BC  EC3E     CALL 0xD87C, 0
62BE  F06C     NOP
118:                       }
119:                       break;
62C0  0012     RETURN 0
120:                   }
121:                   case _UNICO:
122:                   {
123:                       if(Mf_pob_CO) //obieg CO
62C2  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
62C4  D024     BRA 0x630E
124:                       {
125:                           PWM.MAXPWM = PWM.MMAXCO; //maksymalna nastawa modulatora
62C6  C07D     MOVFF _PFNf_obgCO, _PFNf_ofnserw
62C8  F081     NOP
126:                           PWM.MINPWM = PWM.MDMOD;
62CA  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
62CC  F080     NOP
127:                           StartMCO3(); //parametry startowe dla CO
62CE  ECEF     CALL 0xE1DE, 0
62D0  F070     NOP
128:                           ReadDataCO2(); //wprowadzenie danych wejsciowych dla CO
62D2  ECD2     CALL 0xF3A4, 0
62D4  F079     NOP
129:                           ModToCO3(); //zmien obieg na CO
62D6  EC06     CALL 0xF40C, 0
62D8  F07A     NOP
130:                           ModZgCO(); //pierwsze przyblizenie
62DA  EC31     CALL 0x9062, 0
62DC  F048     NOP
131:                           ModDkCO(); //drugie przyblizenie
62DE  ECCE     CALL 0xBB9C, 0
62E0  F05D     NOP
132:                           if(RTdS(_RTMOD) > _TOKM)
62E2  0E02     MOVLW 0x2
62E4  ECD7     CALL 0xEBAE, 0
62E6  F075     NOP
62E8  0100     MOVLB 0x0
62EA  6FFB     MOVWF d, BANKED
62EC  0E0A     MOVLW 0xA
62EE  65FB     CPFSGT d, BANKED
62F0  D00A     BRA 0x6306
133:                           {
134:                               StartRTdS(_RTMOD);
62F2  0E02     MOVLW 0x2
62F4  ECA0     CALL 0xE540, 0
62F6  F072     NOP
135:                               IncConstCO2(); //oblicza czas przez ktory temp CO = const
62F8  EC28     CALL 0xF250, 0
62FA  F079     NOP
136:                               IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
62FC  EC2D     CALL 0xB85A, 0
62FE  F05C     NOP
137:                               ModPruCO(); //trzecie przyblizenie
6300  EC55     CALL 0x9AAA, 0
6302  F04D     NOP
6304  D000     BRA 0x6306
138:                           }
139:           
140:                           ModPrzCO(); //reakcja superwizyjna
6306  EC69     CALL 0xD4D2, 0
6308  F06A     NOP
141:                           PropOPT();
630A  EFBF     GOTO 0xF17E
630C  F078     NOP
142:                       }
143:                       else
144:                           if(Mf_pob_CW || Mf_pob_AL) //obieg CW
630E  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
6310  D002     BRA 0x6316
6312  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
6314  0012     RETURN 0
145:                       {
146:                           PWM.MAXPWM = PWM.MMAXCW; //maksymalna nastawa modulatora
6316  C07E     MOVFF _PFNf_obgCW, _PFNf_ofnserw
6318  F081     NOP
147:                           PWM.MINPWM = PWM.MDMOD;
631A  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
631C  F080     NOP
148:                           StartMCO3(); //parametry startowe dla CO
631E  ECEF     CALL 0xE1DE, 0
6320  F070     NOP
149:                           ReadDataCO2(); //wprowadzenie danych wejsciowych dla CO
6322  ECD2     CALL 0xF3A4, 0
6324  F079     NOP
150:                           ModToCW3(); //zmien obieg na CO
6326  EC2C     CALL 0xDE58, 0
6328  F06F     NOP
151:                           ModZgCO(); //pierwsze przyblizenie
632A  EC31     CALL 0x9062, 0
632C  F048     NOP
152:                           ModDkCO(); //drugie przyblizenie
632E  ECCE     CALL 0xBB9C, 0
6330  F05D     NOP
153:                           if(RTdS(_RTMOD) > _TOKM)
6332  0E02     MOVLW 0x2
6334  ECD7     CALL 0xEBAE, 0
6336  F075     NOP
6338  0100     MOVLB 0x0
633A  6FFB     MOVWF d, BANKED
633C  0E0A     MOVLW 0xA
633E  65FB     CPFSGT d, BANKED
6340  D00A     BRA 0x6356
154:                           {
155:                               StartRTdS(_RTMOD);
6342  0E02     MOVLW 0x2
6344  ECA0     CALL 0xE540, 0
6346  F072     NOP
156:                               IncConstCO2(); //oblicza czas przez ktory temp CO = const
6348  EC28     CALL 0xF250, 0
634A  F079     NOP
157:                               IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
634C  EC2D     CALL 0xB85A, 0
634E  F05C     NOP
158:                               ModPruCO(); //trzecie przyblizenie
6350  EC55     CALL 0x9AAA, 0
6352  F04D     NOP
6354  D000     BRA 0x6356
159:                           }
160:           
161:                           ModPrzCO(); //reakcja superwizyjna
6356  EC69     CALL 0xD4D2, 0
6358  F06A     NOP
162:                           PropOPT();
635A  ECBF     CALL 0xF17E, 0
635C  F078     NOP
163:                       }
164:                       break;
635E  0012     RETURN 0
165:                   }
166:                   case _BITERM2: //kociol bitermiczny (maxiterm)
167:                   {
168:                       if(Mf_pob_CO) //obieg CO
6360  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
6362  D024     BRA 0x63AC
169:                       {
170:                           PWM.MAXPWM = PWM.MMAXCO; //maksymalna nastawa modulatora
6364  C07D     MOVFF _PFNf_obgCO, _PFNf_ofnserw
6366  F081     NOP
171:                           PWM.MINPWM = PWM.MDMOD;
6368  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
636A  F080     NOP
172:                           StartCO4(); //parametry startowe dla CO
636C  EC83     CALL 0xE106, 0
636E  F070     NOP
173:                           ReadDataCO4(); //wprowadzenie danych wejsciowych dla CO
6370  ECCD     CALL 0xF39A, 0
6372  F079     NOP
174:                           ModToCO4(); //zmien obieg na CO
6374  EC89     CALL 0xF312, 0
6376  F079     NOP
175:                           ModZgCO(); //pierwsze przyblizenie
6378  EC31     CALL 0x9062, 0
637A  F048     NOP
176:                           ModDkCO(); //drugie przyblizenie
637C  ECCE     CALL 0xBB9C, 0
637E  F05D     NOP
177:                           if(RTdS(_RTMOD) > _TOKM)
6380  0E02     MOVLW 0x2
6382  ECD7     CALL 0xEBAE, 0
6384  F075     NOP
6386  0100     MOVLB 0x0
6388  6FFB     MOVWF d, BANKED
638A  0E0A     MOVLW 0xA
638C  65FB     CPFSGT d, BANKED
638E  D00A     BRA 0x63A4
178:                           {
179:                               StartRTdS(_RTMOD);
6390  0E02     MOVLW 0x2
6392  ECA0     CALL 0xE540, 0
6394  F072     NOP
180:                               IncConstCOCW4(); //oblicza czas przez ktory temp CO = const
6396  EC16     CALL 0xF22C, 0
6398  F079     NOP
181:                               IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
639A  EC2D     CALL 0xB85A, 0
639C  F05C     NOP
182:                               ModPruCO(); //trzecie przyblizenie
639E  EC55     CALL 0x9AAA, 0
63A0  F04D     NOP
63A2  D000     BRA 0x63A4
183:                           }
184:                           ModPrzCO(); //reakcja superwizyjna
63A4  EC69     CALL 0xD4D2, 0
63A6  F06A     NOP
185:                           PropOPT();
63A8  EFBF     GOTO 0xF17E
63AA  F078     NOP
186:                       }
187:                       else
188:                           if(Mf_pob_CW) //obieg CW
63AC  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
63AE  0012     RETURN 0
189:                       {
190:                           StartMCW4(); //parametry startowe dla CW
63B0  EC71     CALL 0xE6E2, 0
63B2  F073     NOP
191:                           ReadDataCW4(); //wprowadzenie danych wejsciowych dla CW
63B4  ECFB     CALL 0xF1F6, 0
63B6  F078     NOP
192:                           ModToCW4(); //zmien obieg na CW
63B8  EC74     CALL 0xF2E8, 0
63BA  F079     NOP
193:                           ModZgCW4(); //pierwsze przyblizenie
63BC  EC5F     CALL 0x80BE, 0
63BE  F040     NOP
194:                           ModDkCW4(); //drugie przyblizenie
63C0  EC30     CALL 0xBC60, 0
63C2  F05E     NOP
195:                           if(RTdS(_RTMOD) > _TOKM)
63C4  0E02     MOVLW 0x2
63C6  ECD7     CALL 0xEBAE, 0
63C8  F075     NOP
63CA  0100     MOVLB 0x0
63CC  6FFB     MOVWF d, BANKED
63CE  0E0A     MOVLW 0xA
63D0  65FB     CPFSGT d, BANKED
63D2  D00A     BRA 0x63E8
196:                           {
197:                               StartRTdS(_RTMOD);
63D4  0E02     MOVLW 0x2
63D6  ECA0     CALL 0xE540, 0
63D8  F072     NOP
198:                               IncConstCOCW4(); //oblicza czas przez ktory temp CW = const
63DA  EC16     CALL 0xF22C, 0
63DC  F079     NOP
199:                               IncMaxCW4(); //inkrementacja maksymalnej wartosci mocy na palniku
63DE  EC6F     CALL 0xD0DE, 0
63E0  F068     NOP
200:                               ModPruCW4(); //trzecie przyblizenie
63E2  EC64     CALL 0x6AC8, 0
63E4  F035     NOP
63E6  D000     BRA 0x63E8
201:                           }
202:                           ModPrzCW4(); //reakcja superwizyjna
63E8  EC48     CALL 0xAA90, 0
63EA  F055     NOP
203:                           PropCO4(); //zabezpieczenie od przegrzania w obwodzie CO				StartMCW2();		//parametry startowe dla CW
63EC  EC3C     CALL 0xD678, 0
63EE  F06B     NOP
204:                       }
205:                       break;
63F0  0012     RETURN 0
206:                   }
207:                   default: //domyslny monotermiczny
208:                   {
209:                       if(Mf_pob_CO) //obieg CO
63F2  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
63F4  D024     BRA 0x643E
210:                       {
211:                           PWM.MAXPWM = PWM.MMAXCO; //maksymalna nastawa modulatora
63F6  C07D     MOVFF _PFNf_obgCO, _PFNf_ofnserw
63F8  F081     NOP
212:                           PWM.MINPWM = PWM.MDMOD;
63FA  C067     MOVFF _PFNf_b_set_ncw, _PFNf_oflato
63FC  F080     NOP
213:                           StartCO2(); //parametry startowe dla CO
63FE  EC14     CALL 0xE028, 0
6400  F070     NOP
214:                           ReadDataCO2(); //wprowadzenie danych wejsciowych dla CO
6402  ECD2     CALL 0xF3A4, 0
6404  F079     NOP
215:                           ModToCO2(); //zmien obieg na CO
6406  EC90     CALL 0xF320, 0
6408  F079     NOP
216:                           ModZgCO(); //pierwsze przyblizenie
640A  EC31     CALL 0x9062, 0
640C  F048     NOP
217:                           ModDkCO(); //drugie przyblizenie
640E  ECCE     CALL 0xBB9C, 0
6410  F05D     NOP
218:                           if(RTdS(_RTMOD) > _TOKM)
6412  0E02     MOVLW 0x2
6414  ECD7     CALL 0xEBAE, 0
6416  F075     NOP
6418  0100     MOVLB 0x0
641A  6FFB     MOVWF d, BANKED
641C  0E0A     MOVLW 0xA
641E  65FB     CPFSGT d, BANKED
6420  D00A     BRA 0x6436
219:                           {
220:                               StartRTdS(_RTMOD);
6422  0E02     MOVLW 0x2
6424  ECA0     CALL 0xE540, 0
6426  F072     NOP
221:                               IncConstCO2(); //oblicza czas przez ktory temp CO = const
6428  EC28     CALL 0xF250, 0
642A  F079     NOP
222:                               IncMaxCO(); //inkrementacja maksymalnej wartosci mocy na palniku
642C  EC2D     CALL 0xB85A, 0
642E  F05C     NOP
223:                               ModPruCO(); //trzecie przyblizenie
6430  EC55     CALL 0x9AAA, 0
6432  F04D     NOP
6434  D000     BRA 0x6436
224:                           }
225:           
226:                           ModPrzCO(); //reakcja superwizyjna
6436  EC69     CALL 0xD4D2, 0
6438  F06A     NOP
227:                           PropOPT();
643A  EFBF     GOTO 0xF17E
643C  F078     NOP
228:                       }
229:                       else
230:                           if(Mf_pob_CW) //obieg CW
643E  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
6440  0012     RETURN 0
231:                       {
232:                           StartMCW2(); //parametry startowe dla CW
6442  EC33     CALL 0xEA66, 0
6444  F075     NOP
233:                           ReadDataCW2(); //wprowadzenie danych wejsciowych dla CW
6446  EC04     CALL 0xF208, 0
6448  F079     NOP
234:                           ModToCW2(); //zmien obieg na CW
644A  EC7B     CALL 0xF2F6, 0
644C  F079     NOP
235:                           ModZgCW2(); //pierwsze przyblizenie
644E  EC33     CALL 0x7E66, 0
6450  F03F     NOP
236:                           ModDkCW2(); //drugie przyblizenie
6452  EC90     CALL 0xBD20, 0
6454  F05E     NOP
237:                           if(RTdS(_RTMOD) > _TOKM)
6456  0E02     MOVLW 0x2
6458  ECD7     CALL 0xEBAE, 0
645A  F075     NOP
645C  0100     MOVLB 0x0
645E  6FFB     MOVWF d, BANKED
6460  0E0A     MOVLW 0xA
6462  65FB     CPFSGT d, BANKED
6464  D00A     BRA 0x647A
238:                           {
239:                               StartRTdS(_RTMOD);
6466  0E02     MOVLW 0x2
6468  ECA0     CALL 0xE540, 0
646A  F072     NOP
240:                               IncConstCW2(); //oblicza czas przez ktory temp CW = const
646C  ECBA     CALL 0xEF74, 0
646E  F077     NOP
241:                               IncMaxCW2(); //inkrementacja maksymalnej wartosci mocy na palniku
6470  EC41     CALL 0xCC82, 0
6472  F066     NOP
242:                               ModPruCW2(); //trzecie przyblizenie
6474  EC46     CALL 0x448C, 0
6476  F022     NOP
6478  D000     BRA 0x647A
243:                           }
244:                           ModPrzCW2(); //reakcja superwizyjna
647A  EC5E     CALL 0xDCBC, 0
647C  F06E     NOP
245:                           PropCO2(); //zabezpieczenie od przegrzania w obwodzie CO
647E  EC3E     CALL 0xD87C, 0
6480  F06C     NOP
246:                       }
247:                       break;
248:                   }
249:               }
6482  0012     RETURN 0
250:           }
64A0  0012     RETURN 0
251:           //************************************************************
252:           //------------------------------------------------------------
253:           //------------------------------------------------------------
254:           //------dowolny wymiennik - obieg CO
255:           //------------------------------------------------------------
256:           //------------------------------------------------------------								
257:           //-------------------------------------------------------------
258:           //parametry startowe dla CO - kociol 1 funkcyjny.
259:           
260:           void StartMCO1F(void)
261:           {
262:               unsigned char k;
263:           
264:               if(rglf_btco && !rglf_btcw) return; //praca w obiegu CO?
265:               if(rglf_btco && rglf_btcw) //zmiana obiegu CO na CW?
266:               {
267:                   rglf_btcw = 0;
268:                   if(!Tnizsza(0))
269:                   {
270:                       k = 10;
271:                       if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
272:                       else rgl.srp -= k;
273:                   }
274:               }
275:               else //rozpoczecie pracy w obiegu CO lub CW
276:               {
277:                   StartRTdS(_RTMOD);
278:                   DtCO.dDCO = 0;
279:                   DtCO.indCO = 0;
280:                   rglf_fz = 0;
281:                   rglf_med_up = 0;
282:                   rglf_fast_up = 0;
283:                   //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
284:                   if(PWM.MMAXCO > PWM.FIRSTPB)
285:                   {
286:                       rgl.xmod = PWM.FIRSTPB;
287:                   }
288:                   else
289:                   {
290:                       rgl.xmod = PWM.MMAXCO;
291:                   }
292:                   //		if(!PWMf_tpGZ) rgl.xmod=I80_MOD;
293:                   //		else rgl.xmod=I80_PMOD;
294:                   rgl.srp = 0;
295:                   rgl.ytmp = 0;
296:                   rglf_nmod = 0; //wyjdz z trybu nmod
297:                   rglf_btcw = 0;
298:                   rglf_btco = 1;
299:                   rglf_del1s = 0;
300:                   rglf_deln1 = 0;
301:                   rglf_inv_mod = 0;
302:               }
303:           }
304:           //-------------------------------------------------------------
305:           //pierwsze przyblizenie
306:           
307:           void ModZgCO(void)
308:           {
309:               signed long m;
310:               unsigned char p;
311:           
312:               //faza2
313:               if(rglf_fz) //aktualnie faza 2?
9062  A815     BTFSS rglf_btcw, 4, ACCESS
9064  D00C     BRA 0x907E
314:               {
315:                   if(Tnizsza(10)) //przygotowanie do przejscia do fazy 1
9066  0E0A     MOVLW 0xA
9068  ECDA     CALL 0xEFB4, 0
906A  F077     NOP
906C  A0D8     BTFSS STATUS, 0, ACCESS
906E  0012     RETURN 0
316:                   {
317:                       rgl.xmod = PWM.BufPWM;
9070  C060     MOVFF PWM, 0x3C
9072  F03C     NOP
318:                       rgl.srp = 0;
9074  6A3B     CLRF 0x3B, ACCESS
319:                       rgl.ytmp = 0;
9076  6A3A     CLRF 0x3A, ACCESS
320:                   }
9078  D002     BRA 0x907E
321:                   else return;
907A  0012     RETURN 0
907C  D000     BRA 0x907E
322:               }
323:               //faza1
324:               if((!Tnizsza(5) && Tmaleje(0)) || (!Tnizsza(2) && Tstoi())) //warunek przejscia do fazy 2
907E  0E05     MOVLW 0x5
9080  ECDA     CALL 0xEFB4, 0
9082  F077     NOP
9084  E204     BC 0x908E
9086  0E00     MOVLW 0x0
9088  ECA9     CALL 0xE752, 0
908A  F073     NOP
908C  E207     BC 0x909C
908E  0E02     MOVLW 0x2
9090  ECDA     CALL 0xEFB4, 0
9092  F077     NOP
9094  E212     BC 0x90BA
9096  ECAC     CALL 0xF358, 0
9098  F079     NOP
909A  E30F     BNC 0x90BA
325:               {
326:                   rglf_fz = 1;
909C  8815     BSF rglf_btcw, 4, ACCESS
327:                   rgl.srp = PWM.BufPWM;
909E  C060     MOVFF PWM, 0x3B
90A0  F03B     NOP
328:                   rgl.xmod = PWM.BufPWM;
90A2  C060     MOVFF PWM, 0x3C
90A4  F03C     NOP
329:                   if(rgl.xmod > PWM.MGMOD)
90A6  503C     MOVF 0x3C, W, ACCESS
90A8  0100     MOVLB 0x0
90AA  5D6A     SUBWF _PFNf_blkcs, W, BANKED
90AC  B0D8     BTFSC STATUS, 0, ACCESS
90AE  0012     RETURN 0
330:                   {
331:                       rgl.srp = PWM.MGMOD;
90B0  C06A     MOVFF _PFNf_blkcs, 0x3B
90B2  F03B     NOP
332:                       rgl.xmod = PWM.MGMOD;
90B4  C06A     MOVFF _PFNf_blkcs, 0x3C
90B6  F03C     NOP
333:                   }
334:                   return;
90B8  0012     RETURN 0
335:               }
336:               if(rgl.xmod >= PWM.MDMOD) m = (rgl.xmod - PWM.MDMOD)*10;
90BA  0100     MOVLB 0x0
90BC  5167     MOVF _PFNf_b_set_ncw, W, BANKED
90BE  5C3C     SUBWF 0x3C, W, ACCESS
90C0  E31C     BNC 0x90FA
90C2  5167     MOVF _PFNf_b_set_ncw, W, BANKED
90C4  6FEC     MOVWF dt, BANKED
90C6  6BED     CLRF min, BANKED
90C8  1FEC     COMF dt, F, BANKED
90CA  1FED     COMF min, F, BANKED
90CC  4BEC     INFSNZ dt, F, BANKED
90CE  2BED     INCF min, F, BANKED
90D0  503C     MOVF 0x3C, W, ACCESS
90D2  25EC     ADDWF dt, W, BANKED
90D4  6FDE     MOVWF __pcstackBANK0, BANKED
90D6  0E00     MOVLW 0x0
90D8  21ED     ADDWFC min, W, BANKED
90DA  6FDF     MOVWF pco, BANKED
90DC  6BE1     CLRF GIE_BIT_VAL, BANKED
90DE  0E0A     MOVLW 0xA
90E0  6FE0     MOVWF bdat, BANKED
90E2  EC5B     CALL 0xECB6, 0
90E4  F076     NOP
90E6  C0DE     MOVFF __pcstackBANK0, tid
90E8  F0F2     NOP
90EA  C0DF     MOVFF pco, min
90EC  F0F3     NOP
90EE  0100     MOVLB 0x0
90F0  0E00     MOVLW 0x0
90F2  BFF3     BTFSC min, 7, BANKED
90F4  0EFF     MOVLW 0xFF
90F6  6FF4     MOVWF pco, BANKED
90F8  D005     BRA 0x9104
337:               else m = 0;
90FA  0E00     MOVLW 0x0
90FC  0100     MOVLB 0x0
90FE  6BF2     CLRF tid, BANKED
9100  6BF3     CLRF min, BANKED
9102  6BF4     CLRF pco, BANKED
9104  6FF5     MOVWF max, BANKED
9106  D000     BRA 0x9108
338:               m = m / (DtCO.MAD_CO - DtCO.DAD_CO); //DAD_CO-MAD_CO
9108  C0F2     MOVFF tid, __pcstackBANK0
910A  F0DE     NOP
910C  C0F3     MOVFF min, pco
910E  F0DF     NOP
9110  C0F4     MOVFF pco, bdat
9112  F0E0     NOP
9114  C0F5     MOVFF max, GIE_BIT_VAL
9116  F0E1     NOP
9118  0100     MOVLB 0x0
911A  51DB     MOVF 0xDB, W, BANKED
911C  6FEC     MOVWF dt, BANKED
911E  6BED     CLRF min, BANKED
9120  1FEC     COMF dt, F, BANKED
9122  1FED     COMF min, F, BANKED
9124  4BEC     INFSNZ dt, F, BANKED
9126  2BED     INCF min, F, BANKED
9128  51DA     MOVF 0xDA, W, BANKED
912A  6FEE     MOVWF dt, BANKED
912C  6BEF     CLRF 0xEF, BANKED
912E  51EC     MOVF dt, W, BANKED
9130  27EE     ADDWF dt, F, BANKED
9132  51ED     MOVF min, W, BANKED
9134  23EF     ADDWFC 0xEF, F, BANKED
9136  C0EE     MOVFF dt, divisor
9138  F0E2     NOP
913A  C0EF     MOVFF 0xEF, a
913C  F0E3     NOP
913E  0E00     MOVLW 0x0
9140  BFE3     BTFSC a, 7, BANKED
9142  0EFF     MOVLW 0xFF
9144  6FE4     MOVWF k, BANKED
9146  6FE5     MOVWF k, BANKED
9148  ECF3     CALL 0xB3E6, 0
914A  F059     NOP
914C  C0DE     MOVFF __pcstackBANK0, tid
914E  F0F2     NOP
9150  C0DF     MOVFF pco, min
9152  F0F3     NOP
9154  C0E0     MOVFF bdat, pco
9156  F0F4     NOP
9158  C0E1     MOVFF GIE_BIT_VAL, max
915A  F0F5     NOP
339:               m = m * (DtCO.AC_CO - DtCO.DAD_CO); //DAD_CO-AC_CO
915C  0100     MOVLB 0x0
915E  51DB     MOVF 0xDB, W, BANKED
9160  6FEC     MOVWF dt, BANKED
9162  6BED     CLRF min, BANKED
9164  1FEC     COMF dt, F, BANKED
9166  1FED     COMF min, F, BANKED
9168  4BEC     INFSNZ dt, F, BANKED
916A  2BED     INCF min, F, BANKED
916C  51D9     MOVF 0xD9, W, BANKED
916E  6FEE     MOVWF dt, BANKED
9170  6BEF     CLRF 0xEF, BANKED
9172  51EC     MOVF dt, W, BANKED
9174  27EE     ADDWF dt, F, BANKED
9176  51ED     MOVF min, W, BANKED
9178  23EF     ADDWFC 0xEF, F, BANKED
917A  C0EE     MOVFF dt, __pcstackBANK0
917C  F0DE     NOP
917E  C0EF     MOVFF 0xEF, pco
9180  F0DF     NOP
9182  0E00     MOVLW 0x0
9184  BFDF     BTFSC pco, 7, BANKED
9186  0EFF     MOVLW 0xFF
9188  6FE0     MOVWF bdat, BANKED
918A  6FE1     MOVWF GIE_BIT_VAL, BANKED
918C  C0F2     MOVFF tid, divisor
918E  F0E2     NOP
9190  C0F3     MOVFF min, a
9192  F0E3     NOP
9194  C0F4     MOVFF pco, k
9196  F0E4     NOP
9198  C0F5     MOVFF max, k
919A  F0E5     NOP
919C  EC2F     CALL 0xDA5E, 0
919E  F06D     NOP
91A0  C0DE     MOVFF __pcstackBANK0, tid
91A2  F0F2     NOP
91A4  C0DF     MOVFF pco, min
91A6  F0F3     NOP
91A8  C0E0     MOVFF bdat, pco
91AA  F0F4     NOP
91AC  C0E1     MOVFF GIE_BIT_VAL, max
91AE  F0F5     NOP
340:               if(m < 0) m = 0;
91B0  0100     MOVLB 0x0
91B2  AFF5     BTFSS max, 7, BANKED
91B4  D005     BRA 0x91C0
91B6  6BF2     CLRF tid, BANKED
91B8  6BF3     CLRF min, BANKED
91BA  6BF4     CLRF pco, BANKED
91BC  6BF5     CLRF max, BANKED
91BE  D000     BRA 0x91C0
341:               m = m / 10 + PWM.MDMOD;
91C0  C0F2     MOVFF tid, __pcstackBANK0
91C2  F0DE     NOP
91C4  C0F3     MOVFF min, pco
91C6  F0DF     NOP
91C8  C0F4     MOVFF pco, bdat
91CA  F0E0     NOP
91CC  C0F5     MOVFF max, GIE_BIT_VAL
91CE  F0E1     NOP
91D0  0E0A     MOVLW 0xA
91D2  0100     MOVLB 0x0
91D4  6FE2     MOVWF divisor, BANKED
91D6  6BE3     CLRF a, BANKED
91D8  6BE4     CLRF k, BANKED
91DA  6BE5     CLRF k, BANKED
91DC  ECF3     CALL 0xB3E6, 0
91DE  F059     NOP
91E0  0100     MOVLB 0x0
91E2  5167     MOVF _PFNf_b_set_ncw, W, BANKED
91E4  25DE     ADDWF __pcstackBANK0, W, BANKED
91E6  6FF2     MOVWF tid, BANKED
91E8  0E00     MOVLW 0x0
91EA  21DF     ADDWFC pco, W, BANKED
91EC  6FF3     MOVWF min, BANKED
91EE  0E00     MOVLW 0x0
91F0  21E0     ADDWFC bdat, W, BANKED
91F2  6FF4     MOVWF pco, BANKED
91F4  0E00     MOVLW 0x0
91F6  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
91F8  6FF5     MOVWF max, BANKED
342:               if(m > 0xff) //przepelnienie
91FA  0100     MOVLB 0x0
91FC  BFF5     BTFSC max, 7, BANKED
91FE  D009     BRA 0x9212
9200  51F5     MOVF max, W, BANKED
9202  11F4     IORWF pco, W, BANKED
9204  E102     BNZ 0x920A
9206  05F3     DECF min, W, BANKED
9208  E304     BNC 0x9212
343:               {
344:                   rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
920A  9815     BCF rglf_btcw, 4, ACCESS
345:                   rgl.tmp_pwm = rgl.xmod;
920C  C03C     MOVFF 0x3C, 0x3D
920E  F03D     NOP
346:                   return;
9210  0012     RETURN 0
347:               }
348:               if(rglf_fz && (rgl.xmod > m))
9212  A815     BTFSS rglf_btcw, 4, ACCESS
9214  D017     BRA 0x9244
9216  C03C     MOVFF 0x3C, dt
9218  F0EC     NOP
921A  0100     MOVLB 0x0
921C  6BED     CLRF min, BANKED
921E  6BEE     CLRF dt, BANKED
9220  6BEF     CLRF 0xEF, BANKED
9222  51EC     MOVF dt, W, BANKED
9224  5DF2     SUBWF tid, W, BANKED
9226  51ED     MOVF min, W, BANKED
9228  59F3     SUBWFB min, W, BANKED
922A  51EE     MOVF dt, W, BANKED
922C  59F4     SUBWFB pco, W, BANKED
922E  51F5     MOVF max, W, BANKED
9230  0A80     XORLW 0x80
9232  6FF0     MOVWF p, BANKED
9234  51EF     MOVF 0xEF, W, BANKED
9236  0A80     XORLW 0x80
9238  59F0     SUBWFB p, W, BANKED
923A  E204     BC 0x9244
349:                   rgl.srp = (rgl.xmod - m); //przygotowanie lagodnego przejscia do fazy 1
923C  51F2     MOVF tid, W, BANKED
923E  0800     SUBLW 0x0
9240  243C     ADDWF 0x3C, W, ACCESS
9242  6E3B     MOVWF 0x3B, ACCESS
350:               m += rgl.srp;
9244  503B     MOVF 0x3B, W, ACCESS
9246  0100     MOVLB 0x0
9248  27F2     ADDWF tid, F, BANKED
924A  0E00     MOVLW 0x0
924C  23F3     ADDWFC min, F, BANKED
924E  23F4     ADDWFC pco, F, BANKED
9250  23F5     ADDWFC max, F, BANKED
351:               if(m > rgl.xmod) p = rgl.xmod;
9252  C03C     MOVFF 0x3C, dt
9254  F0EC     NOP
9256  6BED     CLRF min, BANKED
9258  6BEE     CLRF dt, BANKED
925A  6BEF     CLRF 0xEF, BANKED
925C  51F2     MOVF tid, W, BANKED
925E  5DEC     SUBWF dt, W, BANKED
9260  51F3     MOVF min, W, BANKED
9262  59ED     SUBWFB min, W, BANKED
9264  51F4     MOVF pco, W, BANKED
9266  59EE     SUBWFB dt, W, BANKED
9268  51EF     MOVF 0xEF, W, BANKED
926A  0A80     XORLW 0x80
926C  6FF0     MOVWF p, BANKED
926E  51F5     MOVF max, W, BANKED
9270  0A80     XORLW 0x80
9272  59F0     SUBWFB p, W, BANKED
9274  E203     BC 0x927C
9276  C03C     MOVFF 0x3C, m
9278  F0F1     NOP
927A  D002     BRA 0x9280
352:               else p = m;
927C  C0F2     MOVFF tid, m
927E  F0F1     NOP
353:               rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
9280  9815     BCF rglf_btcw, 4, ACCESS
354:               rgl.tmp_pwm = p;
9282  C0F1     MOVFF m, 0x3D
9284  F03D     NOP
355:           }
9286  0012     RETURN 0
356:           //-------------------------------------------------------------
357:           //drugie przyblizenie (tylko dla fazy 1)
358:           
359:           void ModDkCO(void)
360:           {
361:               signed long m;
362:               signed char ada;
363:               unsigned char k, p;
364:           
365:               if(!rglf_fz) return; //wyjscie jesli aktualnie faza 1
BB9C  A815     BTFSS rglf_btcw, 4, ACCESS
BB9E  0012     RETURN 0
BBA0  D001     BRA 0xBBA4
BBA2  0012     RETURN 0
366:               ada = DtCO.AC_CO - DtCO.DAD_CO;
BBA4  0100     MOVLB 0x0
BBA6  51DB     MOVF 0xDB, W, BANKED
BBA8  0800     SUBLW 0x0
BBAA  25D9     ADDWF 0xD9, W, BANKED
BBAC  6FE9     MOVWF p, BANKED
367:               k = 5;
BBAE  0E05     MOVLW 0x5
BBB0  0100     MOVLB 0x0
BBB2  6FEA     MOVWF tim, BANKED
368:               if(Twyzsza(0)) k = 6; //6		//(Tco>Tnst)?
BBB4  0E00     MOVLW 0x0
BBB6  ECC5     CALL 0xE78A, 0
BBB8  F073     NOP
BBBA  E304     BNC 0xBBC4
BBBC  0E06     MOVLW 0x6
BBBE  0100     MOVLB 0x0
BBC0  6FEA     MOVWF tim, BANKED
BBC2  D000     BRA 0xBBC4
369:               m = rgl.srp + k*ada;
BBC4  C0EA     MOVFF tim, __pcstackBANK0
BBC6  F0DE     NOP
BBC8  0100     MOVLB 0x0
BBCA  6BDF     CLRF pco, BANKED
BBCC  51E9     MOVF p, W, BANKED
BBCE  6FE0     MOVWF bdat, BANKED
BBD0  6BE1     CLRF GIE_BIT_VAL, BANKED
BBD2  BFE0     BTFSC bdat, 7, BANKED
BBD4  07E1     DECF GIE_BIT_VAL, F, BANKED
BBD6  EC5B     CALL 0xECB6, 0
BBD8  F076     NOP
BBDA  503B     MOVF 0x3B, W, ACCESS
BBDC  0100     MOVLB 0x0
BBDE  6FE4     MOVWF k, BANKED
BBE0  6BE5     CLRF k, BANKED
BBE2  51DE     MOVF __pcstackBANK0, W, BANKED
BBE4  27E4     ADDWF k, F, BANKED
BBE6  51DF     MOVF pco, W, BANKED
BBE8  23E5     ADDWFC k, F, BANKED
BBEA  C0E4     MOVFF k, dt
BBEC  F0EC     NOP
BBEE  C0E5     MOVFF k, min
BBF0  F0ED     NOP
BBF2  0E00     MOVLW 0x0
BBF4  BFED     BTFSC min, 7, BANKED
BBF6  0EFF     MOVLW 0xFF
BBF8  6FEE     MOVWF dt, BANKED
BBFA  6FEF     MOVWF 0xEF, BANKED
370:               if(m > rgl.xmod) p = rgl.xmod;
BBFC  C03C     MOVFF 0x3C, k
BBFE  F0E4     NOP
BC00  0100     MOVLB 0x0
BC02  6BE5     CLRF k, BANKED
BC04  6BE6     CLRF counter, BANKED
BC06  6BE7     CLRF sign, BANKED
BC08  51EC     MOVF dt, W, BANKED
BC0A  5DE4     SUBWF k, W, BANKED
BC0C  51ED     MOVF min, W, BANKED
BC0E  59E5     SUBWFB k, W, BANKED
BC10  51EE     MOVF dt, W, BANKED
BC12  59E6     SUBWFB counter, W, BANKED
BC14  51E7     MOVF sign, W, BANKED
BC16  0A80     XORLW 0x80
BC18  6FE8     MOVWF quotient, BANKED
BC1A  51EF     MOVF 0xEF, W, BANKED
BC1C  0A80     XORLW 0x80
BC1E  59E8     SUBWFB quotient, W, BANKED
BC20  E203     BC 0xBC28
BC22  C03C     MOVFF 0x3C, pop
BC24  F0EB     NOP
BC26  D019     BRA 0xBC5A
371:               else
372:                   if(m < PWM.MDMOD) p = PWM.MDMOD;
BC28  C067     MOVFF _PFNf_b_set_ncw, k
BC2A  F0E4     NOP
BC2C  0100     MOVLB 0x0
BC2E  6BE5     CLRF k, BANKED
BC30  6BE6     CLRF counter, BANKED
BC32  6BE7     CLRF sign, BANKED
BC34  51E4     MOVF k, W, BANKED
BC36  5DEC     SUBWF dt, W, BANKED
BC38  51E5     MOVF k, W, BANKED
BC3A  59ED     SUBWFB min, W, BANKED
BC3C  51E6     MOVF counter, W, BANKED
BC3E  59EE     SUBWFB dt, W, BANKED
BC40  51EF     MOVF 0xEF, W, BANKED
BC42  0A80     XORLW 0x80
BC44  6FE8     MOVWF quotient, BANKED
BC46  51E7     MOVF sign, W, BANKED
BC48  0A80     XORLW 0x80
BC4A  59E8     SUBWFB quotient, W, BANKED
BC4C  E203     BC 0xBC54
BC4E  C067     MOVFF _PFNf_b_set_ncw, pop
BC50  F0EB     NOP
BC52  D003     BRA 0xBC5A
373:               else p = m;
BC54  C0EC     MOVFF dt, pop
BC56  F0EB     NOP
BC58  D000     BRA 0xBC5A
374:               rgl.tmp_pwm = p;
BC5A  C0EB     MOVFF pop, 0x3D
BC5C  F03D     NOP
375:           }
BC5E  0012     RETURN 0
376:           //-------------------------------------------------------------						
377:           //trzecie przyblizenie
378:           //nowa wartosc punktu rownowagi srp.
379:           //wykonywane co krok czasowy
380:           
381:           void ModPruCO(void)
382:           {
383:               static unsigned char l;
384:               unsigned char tmp, k;
385:               //	signed char ada;
386:               if(!rglf_fz) //aktualnie faza 1?
9AAA  B815     BTFSC rglf_btcw, 4, ACCESS
9AAC  D03A     BRA 0x9B22
387:               {
388:                   if(Tmaleje(0) || rgl.ytmp > 2) //(Tco maleje)lub(Tco=CONST(>=3sek))?
9AAE  0E00     MOVLW 0x0
9AB0  ECA9     CALL 0xE752, 0
9AB2  F073     NOP
9AB4  E204     BC 0x9ABE
9AB6  0E02     MOVLW 0x2
9AB8  643A     CPFSGT 0x3A, ACCESS
9ABA  0C02     RETLW 0x2
9ABC  D000     BRA 0x9ABE
389:                   {
390:                       rgl.ytmp = 0;
9ABE  6A3A     CLRF 0x3A, ACCESS
391:                       if(PWM.BufPWM > rgl.xmod) return;
9AC0  0100     MOVLB 0x0
9AC2  5160     MOVF PWM, W, BANKED
9AC4  5C3C     SUBWF 0x3C, W, ACCESS
9AC6  A0D8     BTFSS STATUS, 0, ACCESS
9AC8  0012     RETURN 0
9ACA  D001     BRA 0x9ACE
9ACC  0012     RETURN 0
392:                       tmp = rgl.xmod - PWM.BufPWM;
9ACE  0100     MOVLB 0x0
9AD0  5160     MOVF PWM, W, BANKED
9AD2  0800     SUBLW 0x0
9AD4  243C     ADDWF 0x3C, W, ACCESS
9AD6  6FE9     MOVWF p, BANKED
393:                       k = 6;
9AD8  0E06     MOVLW 0x6
9ADA  0100     MOVLB 0x0
9ADC  6FEA     MOVWF tim, BANKED
394:                       if(k > tmp) k = tmp;
9ADE  0100     MOVLB 0x0
9AE0  51EA     MOVF tim, W, BANKED
9AE2  5DE9     SUBWF p, W, BANKED
9AE4  E203     BC 0x9AEC
9AE6  C0E9     MOVFF p, tim
9AE8  F0EA     NOP
9AEA  D000     BRA 0x9AEC
395:                       if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
9AEC  0100     MOVLB 0x0
9AEE  51EA     MOVF tim, W, BANKED
9AF0  C03B     MOVFF 0x3B, divisor
9AF2  F0E2     NOP
9AF4  6BE3     CLRF a, BANKED
9AF6  27E2     ADDWF divisor, F, BANKED
9AF8  0E00     MOVLW 0x0
9AFA  23E3     ADDWFC a, F, BANKED
9AFC  516A     MOVF _PFNf_blkcs, W, BANKED
9AFE  6FE4     MOVWF k, BANKED
9B00  6BE5     CLRF k, BANKED
9B02  51E2     MOVF divisor, W, BANKED
9B04  5DE4     SUBWF k, W, BANKED
9B06  51E5     MOVF k, W, BANKED
9B08  0A80     XORLW 0x80
9B0A  6FE6     MOVWF counter, BANKED
9B0C  51E3     MOVF a, W, BANKED
9B0E  0A80     XORLW 0x80
9B10  59E6     SUBWFB counter, W, BANKED
9B12  E203     BC 0x9B1A
9B14  C06A     MOVFF _PFNf_blkcs, 0x3B
9B16  F03B     NOP
9B18  0012     RETURN 0
396:                       else rgl.srp += k;
9B1A  0100     MOVLB 0x0
9B1C  51EA     MOVF tim, W, BANKED
9B1E  263B     ADDWF 0x3B, F, ACCESS
397:                   }
398:                   return;
399:               }
9B20  0012     RETURN 0
400:               else //aktualnie faza 2
401:               {
402:                   if(!Trowna()) //(Tco<>Tnst) ?
9B22  ECA5     CALL 0xF34A, 0
9B24  F079     NOP
9B26  E301     BNC 0x9B2A
9B28  D09D     BRA 0x9C64
403:                   {
404:                       if(DtCO.DAD_CO > DtCO.AC_CO) //Tco>Tnst ?
9B2A  0100     MOVLB 0x0
9B2C  51DB     MOVF 0xDB, W, BANKED
9B2E  5DD9     SUBWF 0xD9, W, BANKED
9B30  E244     BC 0x9BBA
405:                       {
406:                           if(Tmaleje(0)) return; //(Tco maleje)?
9B32  0E00     MOVLW 0x0
9B34  ECA9     CALL 0xE752, 0
9B36  F073     NOP
9B38  B0D8     BTFSC STATUS, 0, ACCESS
9B3A  0012     RETURN 0
9B3C  D001     BRA 0x9B40
9B3E  0012     RETURN 0
407:                           if(l >= 2)
9B40  0E01     MOVLW 0x1
9B42  0101     MOVLB 0x1
9B44  654D     CPFSGT 0x4D, BANKED
9B46  D005     BRA 0x9B52
408:                           {
409:                               k = 1;
9B48  0100     MOVLB 0x0
9B4A  6FEA     MOVWF tim, BANKED
410:                               l = 0;
9B4C  0101     MOVLB 0x1
9B4E  6B4D     CLRF 0x4D, BANKED
411:                           }
9B50  D005     BRA 0x9B5C
412:                           else
413:                           {
414:                               k = 0;
9B52  0100     MOVLB 0x0
9B54  6BEA     CLRF tim, BANKED
415:                               l++;
9B56  0101     MOVLB 0x1
9B58  2B4D     INCF 0x4D, F, BANKED
9B5A  D000     BRA 0x9B5C
416:                           }
417:                           if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
9B5C  0100     MOVLB 0x0
9B5E  5167     MOVF _PFNf_b_set_ncw, W, BANKED
9B60  6FE2     MOVWF divisor, BANKED
9B62  6BE3     CLRF a, BANKED
9B64  51EA     MOVF tim, W, BANKED
9B66  6FE4     MOVWF k, BANKED
9B68  6BE5     CLRF k, BANKED
9B6A  1FE4     COMF k, F, BANKED
9B6C  1FE5     COMF k, F, BANKED
9B6E  4BE4     INFSNZ k, F, BANKED
9B70  2BE5     INCF k, F, BANKED
9B72  503B     MOVF 0x3B, W, ACCESS
9B74  6FE6     MOVWF counter, BANKED
9B76  6BE7     CLRF sign, BANKED
9B78  51E4     MOVF k, W, BANKED
9B7A  27E6     ADDWF counter, F, BANKED
9B7C  51E5     MOVF k, W, BANKED
9B7E  23E7     ADDWFC sign, F, BANKED
9B80  51E2     MOVF divisor, W, BANKED
9B82  5DE6     SUBWF counter, W, BANKED
9B84  51E7     MOVF sign, W, BANKED
9B86  0A80     XORLW 0x80
9B88  6FE8     MOVWF quotient, BANKED
9B8A  51E3     MOVF a, W, BANKED
9B8C  0A80     XORLW 0x80
9B8E  59E8     SUBWFB quotient, W, BANKED
9B90  E203     BC 0x9B98
9B92  C067     MOVFF _PFNf_b_set_ncw, 0x3B
9B94  F03B     NOP
9B96  D003     BRA 0x9B9E
418:                           else rgl.srp -= k;
9B98  0100     MOVLB 0x0
9B9A  51EA     MOVF tim, W, BANKED
9B9C  5E3B     SUBWF 0x3B, F, ACCESS
419:                           if(rgl.srp > PWM.MAXPWM) rgl.srp = PWM.MAXPWM;
9B9E  503B     MOVF 0x3B, W, ACCESS
9BA0  0100     MOVLB 0x0
9BA2  5D81     SUBWF _PFNf_ofnserw, W, BANKED
9BA4  E203     BC 0x9BAC
9BA6  C081     MOVFF _PFNf_ofnserw, 0x3B
9BA8  F03B     NOP
9BAA  D000     BRA 0x9BAC
420:                           if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
9BAC  503B     MOVF 0x3B, W, ACCESS
9BAE  5C3C     SUBWF 0x3C, W, ACCESS
9BB0  B0D8     BTFSC STATUS, 0, ACCESS
9BB2  0012     RETURN 0
9BB4  C03B     MOVFF 0x3B, 0x3C
9BB6  F03C     NOP
421:                           return;
422:                       }
9BB8  0012     RETURN 0
423:                       else //Tco<Tnst
424:                       {
425:                           if(Trosnie(0)) return; //(Tco rosnie)?
9BBA  0E00     MOVLW 0x0
9BBC  ECE8     CALL 0xEFD0, 0
9BBE  F077     NOP
9BC0  B0D8     BTFSC STATUS, 0, ACCESS
9BC2  0012     RETURN 0
9BC4  D001     BRA 0x9BC8
9BC6  0012     RETURN 0
426:                           if(l >= 1)
9BC8  0101     MOVLB 0x1
9BCA  514D     MOVF 0x4D, W, BANKED
9BCC  E006     BZ 0x9BDA
427:                           {
428:                               k = 1;
9BCE  0E01     MOVLW 0x1
9BD0  0100     MOVLB 0x0
9BD2  6FEA     MOVWF tim, BANKED
429:                               l = 0;
9BD4  0101     MOVLB 0x1
9BD6  6B4D     CLRF 0x4D, BANKED
430:                           }
9BD8  D005     BRA 0x9BE4
431:                           else
432:                           {
433:                               k = 0;
9BDA  0100     MOVLB 0x0
9BDC  6BEA     CLRF tim, BANKED
434:                               l++;
9BDE  0101     MOVLB 0x1
9BE0  2B4D     INCF 0x4D, F, BANKED
9BE2  D000     BRA 0x9BE4
435:                           }
436:                           if(PWM.MAXPWM > PWM.MGMOD)
9BE4  0100     MOVLB 0x0
9BE6  5181     MOVF _PFNf_ofnserw, W, BANKED
9BE8  5D6A     SUBWF _PFNf_blkcs, W, BANKED
9BEA  E21A     BC 0x9C20
437:                           {
438:                               if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
9BEC  51EA     MOVF tim, W, BANKED
9BEE  C03B     MOVFF 0x3B, divisor
9BF0  F0E2     NOP
9BF2  6BE3     CLRF a, BANKED
9BF4  27E2     ADDWF divisor, F, BANKED
9BF6  0E00     MOVLW 0x0
9BF8  23E3     ADDWFC a, F, BANKED
9BFA  516A     MOVF _PFNf_blkcs, W, BANKED
9BFC  6FE4     MOVWF k, BANKED
9BFE  6BE5     CLRF k, BANKED
9C00  51E2     MOVF divisor, W, BANKED
9C02  5DE4     SUBWF k, W, BANKED
9C04  51E5     MOVF k, W, BANKED
9C06  0A80     XORLW 0x80
9C08  6FE6     MOVWF counter, BANKED
9C0A  51E3     MOVF a, W, BANKED
9C0C  0A80     XORLW 0x80
9C0E  59E6     SUBWFB counter, W, BANKED
9C10  E203     BC 0x9C18
9C12  C06A     MOVFF _PFNf_blkcs, 0x3B
9C14  F03B     NOP
9C16  D01F     BRA 0x9C56
439:                               else rgl.srp += k;
9C18  0100     MOVLB 0x0
9C1A  51EA     MOVF tim, W, BANKED
9C1C  263B     ADDWF 0x3B, F, ACCESS
440:                           }
9C1E  D01B     BRA 0x9C56
441:                           else
442:                           {
443:                               if(rgl.srp + k > PWM.MAXPWM) rgl.srp = PWM.MAXPWM;
9C20  0100     MOVLB 0x0
9C22  51EA     MOVF tim, W, BANKED
9C24  C03B     MOVFF 0x3B, divisor
9C26  F0E2     NOP
9C28  6BE3     CLRF a, BANKED
9C2A  27E2     ADDWF divisor, F, BANKED
9C2C  0E00     MOVLW 0x0
9C2E  23E3     ADDWFC a, F, BANKED
9C30  5181     MOVF _PFNf_ofnserw, W, BANKED
9C32  6FE4     MOVWF k, BANKED
9C34  6BE5     CLRF k, BANKED
9C36  51E2     MOVF divisor, W, BANKED
9C38  5DE4     SUBWF k, W, BANKED
9C3A  51E5     MOVF k, W, BANKED
9C3C  0A80     XORLW 0x80
9C3E  6FE6     MOVWF counter, BANKED
9C40  51E3     MOVF a, W, BANKED
9C42  0A80     XORLW 0x80
9C44  59E6     SUBWFB counter, W, BANKED
9C46  E203     BC 0x9C4E
9C48  C081     MOVFF _PFNf_ofnserw, 0x3B
9C4A  F03B     NOP
9C4C  D004     BRA 0x9C56
444:                               else rgl.srp += k;
9C4E  0100     MOVLB 0x0
9C50  51EA     MOVF tim, W, BANKED
9C52  263B     ADDWF 0x3B, F, ACCESS
9C54  D000     BRA 0x9C56
445:                           }
446:                           if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
9C56  503B     MOVF 0x3B, W, ACCESS
9C58  5C3C     SUBWF 0x3C, W, ACCESS
9C5A  B0D8     BTFSC STATUS, 0, ACCESS
9C5C  0012     RETURN 0
9C5E  C03B     MOVFF 0x3B, 0x3C
9C60  F03C     NOP
447:                       }
448:                   }
9C62  0012     RETURN 0
449:                   else l = 0;
9C64  0E00     MOVLW 0x0
9C66  0101     MOVLB 0x1
9C68  6F4D     MOVWF 0x4D, BANKED
9C6A  0012     RETURN 0
450:               }
451:           }
9C6C  0012     RETURN 0
452:           //-------------------------------------------------------------								
453:           //inkrementacja maksymalnej wartosci mocy na palniku
454:           //wykonywane co krok czasowy
455:           
456:           void IncMaxCO(void)
457:           {
458:               unsigned char k;
459:           
460:               if(Trosnie(1)) return; //(Tco rosnie szybciej niz 1K/sek)?
B85A  0E01     MOVLW 0x1
B85C  ECE8     CALL 0xEFD0, 0
B85E  F077     NOP
B860  B0D8     BTFSC STATUS, 0, ACCESS
B862  0012     RETURN 0
B864  D001     BRA 0xB868
B866  0012     RETURN 0
461:               //kontrolowany narost mocy
462:               k = 6;
B868  0E06     MOVLW 0x6
B86A  0100     MOVLB 0x0
B86C  6FE8     MOVWF quotient, BANKED
463:               if(!rglf_fz) //faza 1 ?
B86E  B815     BTFSC rglf_btcw, 4, ACCESS
B870  D024     BRA 0xB8BA
464:               {
465:                   /*if(rgl.xmod + k > _MG2_MOD) rgl.xmod = _MG2_MOD;
466:                   else rgl.xmod += k;
467:                   if(rgl.xmod > PWM.MAXPWM) rgl.xmod = PWM.MAXPWM;*/
468:                   if(rgl.xmod+k>PWM.MAXPWM)
B872  0100     MOVLB 0x0
B874  51E8     MOVF quotient, W, BANKED
B876  C03C     MOVFF 0x3C, a
B878  F0E3     NOP
B87A  6BE4     CLRF k, BANKED
B87C  27E3     ADDWF a, F, BANKED
B87E  0E00     MOVLW 0x0
B880  23E4     ADDWFC k, F, BANKED
B882  5181     MOVF _PFNf_ofnserw, W, BANKED
B884  6FE5     MOVWF k, BANKED
B886  6BE6     CLRF counter, BANKED
B888  51E3     MOVF a, W, BANKED
B88A  5DE5     SUBWF k, W, BANKED
B88C  51E6     MOVF counter, W, BANKED
B88E  0A80     XORLW 0x80
B890  6FE7     MOVWF sign, BANKED
B892  51E4     MOVF k, W, BANKED
B894  0A80     XORLW 0x80
B896  59E7     SUBWFB sign, W, BANKED
B898  E205     BC 0xB8A4
469:           		{
470:           	 		rgl.xmod=PWM.MAXPWM;
B89A  C081     MOVFF _PFNf_ofnserw, 0x3C
B89C  F03C     NOP
471:           			PmpToUP();			//reg. obrotami pompy
B89E  ECC8     CALL 0xDF90, 0
B8A0  F06F     NOP
472:           		}
B8A2  D006     BRA 0xB8B0
473:           		else
474:           		{
475:           	 		rgl.xmod+=k;
B8A4  0100     MOVLB 0x0
B8A6  51E8     MOVF quotient, W, BANKED
B8A8  263C     ADDWF 0x3C, F, ACCESS
476:           			PmpToDW();			//reg. obrotami pompy
B8AA  ECCB     CALL 0xE196, 0
B8AC  F070     NOP
B8AE  D000     BRA 0xB8B0
477:           		}
478:                   if(rgl.xmod>_MG2_MOD) rgl.xmod=_MG2_MOD;
B8B0  0EF0     MOVLW 0xF0
B8B2  643C     CPFSGT 0x3C, ACCESS
B8B4  0CF0     RETLW 0xF0
B8B6  6E3C     MOVWF 0x3C, ACCESS
479:               }
B8B8  0012     RETURN 0
480:               else //faza 2
481:               {
482:                   if(PWM.MAXPWM > PWM.MGMOD)
B8BA  0100     MOVLB 0x0
B8BC  5181     MOVF _PFNf_ofnserw, W, BANKED
B8BE  5D6A     SUBWF _PFNf_blkcs, W, BANKED
B8C0  E21A     BC 0xB8F6
483:                   {
484:                       if(rgl.xmod + k > PWM.MGMOD) rgl.xmod = PWM.MGMOD;
B8C2  51E8     MOVF quotient, W, BANKED
B8C4  C03C     MOVFF 0x3C, a
B8C6  F0E3     NOP
B8C8  6BE4     CLRF k, BANKED
B8CA  27E3     ADDWF a, F, BANKED
B8CC  0E00     MOVLW 0x0
B8CE  23E4     ADDWFC k, F, BANKED
B8D0  516A     MOVF _PFNf_blkcs, W, BANKED
B8D2  6FE5     MOVWF k, BANKED
B8D4  6BE6     CLRF counter, BANKED
B8D6  51E3     MOVF a, W, BANKED
B8D8  5DE5     SUBWF k, W, BANKED
B8DA  51E6     MOVF counter, W, BANKED
B8DC  0A80     XORLW 0x80
B8DE  6FE7     MOVWF sign, BANKED
B8E0  51E4     MOVF k, W, BANKED
B8E2  0A80     XORLW 0x80
B8E4  59E7     SUBWFB sign, W, BANKED
B8E6  E203     BC 0xB8EE
B8E8  C06A     MOVFF _PFNf_blkcs, 0x3C
B8EA  F03C     NOP
B8EC  0012     RETURN 0
485:                       else rgl.xmod += k;
B8EE  0100     MOVLB 0x0
B8F0  51E8     MOVF quotient, W, BANKED
B8F2  263C     ADDWF 0x3C, F, ACCESS
486:                   }
B8F4  0012     RETURN 0
487:                   else
488:                   {
489:                       if(rgl.xmod + k > PWM.MAXPWM) rgl.xmod = PWM.MAXPWM;
B8F6  0100     MOVLB 0x0
B8F8  51E8     MOVF quotient, W, BANKED
B8FA  C03C     MOVFF 0x3C, a
B8FC  F0E3     NOP
B8FE  6BE4     CLRF k, BANKED
B900  27E3     ADDWF a, F, BANKED
B902  0E00     MOVLW 0x0
B904  23E4     ADDWFC k, F, BANKED
B906  5181     MOVF _PFNf_ofnserw, W, BANKED
B908  6FE5     MOVWF k, BANKED
B90A  6BE6     CLRF counter, BANKED
B90C  51E3     MOVF a, W, BANKED
B90E  5DE5     SUBWF k, W, BANKED
B910  51E6     MOVF counter, W, BANKED
B912  0A80     XORLW 0x80
B914  6FE7     MOVWF sign, BANKED
B916  51E4     MOVF k, W, BANKED
B918  0A80     XORLW 0x80
B91A  59E7     SUBWFB sign, W, BANKED
B91C  E203     BC 0xB924
B91E  C081     MOVFF _PFNf_ofnserw, 0x3C
B920  F03C     NOP
B922  0012     RETURN 0
490:                       else rgl.xmod += k;
B924  0100     MOVLB 0x0
B926  51E8     MOVF quotient, W, BANKED
B928  263C     ADDWF 0x3C, F, ACCESS
491:                   }
B92A  0012     RETURN 0
492:               }
493:           }
B92C  0012     RETURN 0
494:           //-------------------------------------------------------------								
495:           //reakcja superwizyjna
496:           
497:           void ModPrzCO(void)
498:           {
499:               unsigned char k;
500:           
501:               if(!rglf_nmod) //nie jest w trybie nmod?
D4D2  BE15     BTFSC rglf_btcw, 7, ACCESS
D4D4  D02B     BRA 0xD52C
502:               {
503:                   if(Twyzsza(3)) //Tcw-Tnst>3 ?
D4D6  0E03     MOVLW 0x3
D4D8  ECC5     CALL 0xE78A, 0
D4DA  F073     NOP
D4DC  A0D8     BTFSS STATUS, 0, ACCESS
D4DE  0012     RETURN 0
504:                   {
505:                       rglf_nmod = 1; //wejdz w tryb nmod
D4E0  8E15     BSF rglf_btcw, 7, ACCESS
506:                       k = 20;
D4E2  0E14     MOVLW 0x14
D4E4  0100     MOVLB 0x0
D4E6  6FE9     MOVWF p, BANKED
507:                       if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
D4E8  0100     MOVLB 0x0
D4EA  5167     MOVF _PFNf_b_set_ncw, W, BANKED
D4EC  6FE2     MOVWF divisor, BANKED
D4EE  6BE3     CLRF a, BANKED
D4F0  51E9     MOVF p, W, BANKED
D4F2  6FE4     MOVWF k, BANKED
D4F4  6BE5     CLRF k, BANKED
D4F6  1FE4     COMF k, F, BANKED
D4F8  1FE5     COMF k, F, BANKED
D4FA  4BE4     INFSNZ k, F, BANKED
D4FC  2BE5     INCF k, F, BANKED
D4FE  503B     MOVF 0x3B, W, ACCESS
D500  6FE6     MOVWF counter, BANKED
D502  6BE7     CLRF sign, BANKED
D504  51E4     MOVF k, W, BANKED
D506  27E6     ADDWF counter, F, BANKED
D508  51E5     MOVF k, W, BANKED
D50A  23E7     ADDWFC sign, F, BANKED
D50C  51E2     MOVF divisor, W, BANKED
D50E  5DE6     SUBWF counter, W, BANKED
D510  51E7     MOVF sign, W, BANKED
D512  0A80     XORLW 0x80
D514  6FE8     MOVWF quotient, BANKED
D516  51E3     MOVF a, W, BANKED
D518  0A80     XORLW 0x80
D51A  59E8     SUBWFB quotient, W, BANKED
D51C  E203     BC 0xD524
D51E  C067     MOVFF _PFNf_b_set_ncw, 0x3B
D520  F03B     NOP
D522  0012     RETURN 0
508:                       else rgl.srp -= k;
D524  0100     MOVLB 0x0
D526  51E9     MOVF p, W, BANKED
D528  5E3B     SUBWF 0x3B, F, ACCESS
509:                   }
510:               }
D52A  0012     RETURN 0
511:               else //jest w trybie nmod?
512:               {
513:                   if(!Twyzsza(2))
D52C  0E02     MOVLW 0x2
D52E  ECC5     CALL 0xE78A, 0
D530  F073     NOP
D532  B0D8     BTFSC STATUS, 0, ACCESS
D534  0012     RETURN 0
514:                       rglf_nmod = 0; //wyjdz z trybu nmod
D536  9E15     BCF rglf_btcw, 7, ACCESS
D538  0012     RETURN 0
515:               }
516:           }
D53A  0012     RETURN 0
517:           //-------------------------------------------------------------							
518:           //Proporcjonalne OPEN-T
519:           
520:           void PropOPT(void)
521:           {
522:               if(rglf_nmod) //aktywny tryb nmod?
F17E  AE15     BTFSS rglf_btcw, 7, ACCESS
F180  D004     BRA 0xF18A
523:               {
524:                   WriteOPWM(PWM.MDMOD);
F182  0100     MOVLB 0x0
F184  5167     MOVF _PFNf_b_set_ncw, W, BANKED
F186  EF6C     GOTO 0xA4D8
F188  F052     NOP
525:                   //PWM.BufPWM=PWM.MDMOD;	//wymus minimum plomienia
526:               }
527:               else
528:               {
529:                   WriteOPWM(rgl.tmp_pwm);
F18A  503D     MOVF 0x3D, W, ACCESS
F18C  EF6C     GOTO 0xA4D8
F18E  F052     NOP
530:                   //PWM.BufPWM=rgl.tmp_pwm;
531:               }
532:           }
F190  0012     RETURN 0
533:           //************************************************************
534:           //------------------------------------------------------------
535:           //------------------------------------------------------------
536:           //------wymiennik bitermiczny (miniterm) - obieg CW
537:           //------------------------------------------------------------
538:           //------------------------------------------------------------
539:           //------------------------------------------------------------
540:           //parametry startowe dla CO
541:           
542:           void StartCO(void)
543:           {
544:               //	unsigned char k;
545:           
546:               if(rglf_btco || rglf_btcw) return; //praca w dowolnym obiegu CO?
E14E  AE14     BTFSS UADtf_RData, 7, ACCESS
E150  B015     BTFSC rglf_btcw, 0, ACCESS
E152  0012     RETURN 0
E154  D001     BRA 0xE158
E156  0012     RETURN 0
547:               StartRTdS(_RTMOD);
E158  0E02     MOVLW 0x2
E15A  ECA0     CALL 0xE540, 0
E15C  F072     NOP
548:               DtCO.dDCO = 0;
E15E  0100     MOVLB 0x0
E160  6BD6     CLRF 0xD6, BANKED
549:               DtCO.indCO = 0;
E162  0100     MOVLB 0x0
E164  6BD7     CLRF 0xD7, BANKED
550:               DtCW.dDCW = 0;
E166  0100     MOVLB 0x0
E168  6BB0     CLRF 0xB0, BANKED
551:               DtCW.indCW = 0;
E16A  0100     MOVLB 0x0
E16C  6BB2     CLRF 0xB2, BANKED
552:               rglf_fz = 0;
E16E  9815     BCF rglf_btcw, 4, ACCESS
553:               rglf_med_up = 0;
E170  9C15     BCF rglf_btcw, 6, ACCESS
554:               rglf_fast_up = 0;
E172  9615     BCF rglf_btcw, 3, ACCESS
555:               //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
556:               if(PWM.MMAXCO > PWM.FIRSTPB)
E174  0100     MOVLB 0x0
E176  517D     MOVF _PFNf_obgCO, W, BANKED
E178  5D78     SUBWF _PFNf_mod_ncw, W, BANKED
E17A  E203     BC 0xE182
557:               {
558:                   rgl.xmod = PWM.FIRSTPB;
E17C  C078     MOVFF _PFNf_mod_ncw, 0x3C
E17E  F03C     NOP
559:               }
E180  D003     BRA 0xE188
560:               else
561:               {
562:                   rgl.xmod = PWM.MMAXCO;
E182  C07D     MOVFF _PFNf_obgCO, 0x3C
E184  F03C     NOP
E186  D000     BRA 0xE188
563:               }
564:               rgl.srp = 0;
E188  0E00     MOVLW 0x0
E18A  6A3B     CLRF 0x3B, ACCESS
565:               rgl.ytmp = 0;
E18C  6A3A     CLRF 0x3A, ACCESS
566:               rglf_nmod = 0; //wyjdz z trybu nmod
E18E  9E15     BCF rglf_btcw, 7, ACCESS
567:               rglf_del1s = 0;
E190  9215     BCF rglf_btcw, 1, ACCESS
568:               rglf_inv_mod = 0;
E192  9A15     BCF rglf_btcw, 5, ACCESS
569:           }
E194  0012     RETURN 0
570:           //-------------------------------------------------------------
571:           //parametry startowe dla CW
572:           
573:           void StartMCW(void)
574:           {
575:               if(rglf_btco || rglf_btcw) return; //rozpoczecie pracy modulatora?
C360  AE14     BTFSS UADtf_RData, 7, ACCESS
C362  B015     BTFSC rglf_btcw, 0, ACCESS
C364  0012     RETURN 0
C366  D001     BRA 0xC36A
C368  0012     RETURN 0
576:               StartRTdS(_RTMOD);
C36A  0E02     MOVLW 0x2
C36C  ECA0     CALL 0xE540, 0
C36E  F072     NOP
577:               DtCO.dDCO = 0;
C370  0100     MOVLB 0x0
C372  6BD6     CLRF 0xD6, BANKED
578:               DtCW.dDCW = 0;
C374  0100     MOVLB 0x0
C376  6BB0     CLRF 0xB0, BANKED
579:               DtCO.indCO = 0;
C378  0100     MOVLB 0x0
C37A  6BD7     CLRF 0xD7, BANKED
580:               DtCW.indCW = 0;
C37C  0100     MOVLB 0x0
C37E  6BB2     CLRF 0xB2, BANKED
581:               rglf_fz = 0;
C380  9815     BCF rglf_btcw, 4, ACCESS
582:               rglf_med_up = 0;
C382  9C15     BCF rglf_btcw, 6, ACCESS
583:               rglf_fast_up = 0;
C384  9615     BCF rglf_btcw, 3, ACCESS
584:               //FirstPCW();
585:               rgl.srp = 0;
C386  6A3B     CLRF 0x3B, ACCESS
586:               rgl.ytmp = 0;
C388  6A3A     CLRF 0x3A, ACCESS
587:               rglf_nmod = 0;
C38A  9E15     BCF rglf_btcw, 7, ACCESS
588:               rglf_del1s = 0;
C38C  9215     BCF rglf_btcw, 1, ACCESS
589:               rglf_inv_mod = 0;
C38E  9A15     BCF rglf_btcw, 5, ACCESS
590:               rgl.xmod = FirstPCW();
C390  EC26     CALL 0x3C4C, 0
C392  F01E     NOP
C394  6E3C     MOVWF 0x3C, ACCESS
591:               tmr = 1;
C396  0E01     MOVLW 0x1
C398  0100     MOVLB 0x0
C39A  6FCD     MOVWF tmr, BANKED
592:               tmr2 = 1;
C39C  0E01     MOVLW 0x1
C39E  0101     MOVLB 0x1
C3A0  6F7B     MOVWF _PFNf_newPFN, BANKED
593:               pwm_center = PWM.MDMOD + (PWM.MGMOD - PWM.MDMOD) / 2;
C3A2  0100     MOVLB 0x0
C3A4  5167     MOVF _PFNf_b_set_ncw, W, BANKED
C3A6  6FF9     MOVWF fst, BANKED
C3A8  6BFA     CLRF pco, BANKED
C3AA  1FF9     COMF fst, F, BANKED
C3AC  1FFA     COMF pco, F, BANKED
C3AE  4BF9     INFSNZ fst, F, BANKED
C3B0  2BFA     INCF pco, F, BANKED
C3B2  516A     MOVF _PFNf_blkcs, W, BANKED
C3B4  25F9     ADDWF fst, W, BANKED
C3B6  6FE4     MOVWF k, BANKED
C3B8  0E00     MOVLW 0x0
C3BA  21FA     ADDWFC pco, W, BANKED
C3BC  6FE5     MOVWF k, BANKED
C3BE  6BE7     CLRF sign, BANKED
C3C0  0E02     MOVLW 0x2
C3C2  6FE6     MOVWF counter, BANKED
C3C4  EC09     CALL 0xC212, 0
C3C6  F061     NOP
C3C8  0100     MOVLB 0x0
C3CA  51E4     MOVF k, W, BANKED
C3CC  2567     ADDWF _PFNf_b_set_ncw, W, BANKED
C3CE  0101     MOVLB 0x1
C3D0  6F79     MOVWF _PFNf_newPCO, BANKED
594:               pwm_kwr = PWM.MDMOD + (PWM.MGMOD - PWM.MDMOD) / 4;
C3D2  0100     MOVLB 0x0
C3D4  5167     MOVF _PFNf_b_set_ncw, W, BANKED
C3D6  6FF9     MOVWF fst, BANKED
C3D8  6BFA     CLRF pco, BANKED
C3DA  1FF9     COMF fst, F, BANKED
C3DC  1FFA     COMF pco, F, BANKED
C3DE  4BF9     INFSNZ fst, F, BANKED
C3E0  2BFA     INCF pco, F, BANKED
C3E2  516A     MOVF _PFNf_blkcs, W, BANKED
C3E4  25F9     ADDWF fst, W, BANKED
C3E6  6FE4     MOVWF k, BANKED
C3E8  0E00     MOVLW 0x0
C3EA  21FA     ADDWFC pco, W, BANKED
C3EC  6FE5     MOVWF k, BANKED
C3EE  6BE7     CLRF sign, BANKED
C3F0  0E04     MOVLW 0x4
C3F2  6FE6     MOVWF counter, BANKED
C3F4  EC09     CALL 0xC212, 0
C3F6  F061     NOP
C3F8  0100     MOVLB 0x0
C3FA  51E4     MOVF k, W, BANKED
C3FC  2567     ADDWF _PFNf_b_set_ncw, W, BANKED
C3FE  0101     MOVLB 0x1
C400  6F7A     MOVWF _PFNf_newPCW, BANKED
595:           }
C402  0012     RETURN 0
596:           //-------------------------------------------------------------
597:           //pierwsze pobudzenie dla CW
598:           //-------------------------------------------------------------
599:           
600:           /*void FirstPCW(void)
601:           {
602:                   unsigned char tmp;
603:                   if(DtCW.PCW>=45)
604:                   {
605:                           if(PWM.MMAXCW>PWM.MGMOD)
606:                           {
607:                                   if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
608:                                   else rgl.xmod=PWM.FIRSTPB;
609:                           }
610:                           else
611:                           {
612:                                   if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
613:                                   else
614:                                   {
615:                                           if(PWM.MMAXCW>PWM.FIRSTPB) rgl.xmod=PWM.FIRSTPB;
616:                                           else rgl.xmod=PWM.MMAXCW;
617:                                   }
618:                           }
619:                   }
620:                   else
621:                   if(DtCW.PCW>=40)
622:                   {
623:                           tmp=(PWM.MGMOD-PWM.FIRSTPB)/2;
624:                           if(PWM.MMAXCW>(PWM.FIRSTPB+tmp))
625:                           {
626:                                   rgl.xmod=PWM.FIRSTPB+tmp;
627:                           }
628:                           else
629:                           {
630:                                   rgl.xmod=PWM.MMAXCW;
631:                           }
632:                   }
633:                   else
634:                   if(DtCW.PCW>=35)
635:                   {
636:                           if(PWM.MMAXCW>PWM.FIRSTPB)
637:                           {
638:                                   rgl.xmod=PWM.FIRSTPB;
639:                           }
640:                           else
641:                           {
642:                                   rgl.xmod=PWM.MMAXCW;
643:                           }
644:                   }
645:                   else
646:                   {
647:                           tmp=(PWM.FIRSTPB-PWM.MDMOD)/2;
648:                           if(PWM.MMAXCW>(PWM.FIRSTPB-tmp))
649:                           {
650:                                   rgl.xmod=PWM.FIRSTPB-tmp;
651:                           }
652:                           else
653:                           {
654:                                   rgl.xmod=PWM.MMAXCW;
655:                           }
656:                   }
657:           }*/
658:           unsigned char FirstPCW(void)
659:           {
660:               signed long m;
661:               unsigned char maxmod, p, p2, tmp;
662:           
663:               //-------
664:               //maksymalna dozwolona wartosc pierwszego pobudzenia
665:               //if(PWM.MMAXCW<PWM.FIRSTPB) maxmod=PWM.MMAXCW;					//wprowadzono ograniczenie mocy?
666:               //else maxmod=PWM.FIRSTPB;
667:               tmp = (PWM.FIRSTPB - PWM.MDMOD) / 4;
3C4C  0100     MOVLB 0x0
3C4E  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3C50  6FEC     MOVWF dt, BANKED
3C52  6BED     CLRF min, BANKED
3C54  1FEC     COMF dt, F, BANKED
3C56  1FED     COMF min, F, BANKED
3C58  4BEC     INFSNZ dt, F, BANKED
3C5A  2BED     INCF min, F, BANKED
3C5C  5178     MOVF _PFNf_mod_ncw, W, BANKED
3C5E  25EC     ADDWF dt, W, BANKED
3C60  6FE4     MOVWF k, BANKED
3C62  0E00     MOVLW 0x0
3C64  21ED     ADDWFC min, W, BANKED
3C66  6FE5     MOVWF k, BANKED
3C68  6BE7     CLRF sign, BANKED
3C6A  0E04     MOVLW 0x4
3C6C  6FE6     MOVWF counter, BANKED
3C6E  EC09     CALL 0xC212, 0
3C70  F061     NOP
3C72  0100     MOVLB 0x0
3C74  51E4     MOVF k, W, BANKED
3C76  6FF1     MOVWF m, BANKED
668:               if(PWM.MMAXCW > (PWM.FIRSTPB + tmp))
3C78  0100     MOVLB 0x0
3C7A  517E     MOVF _PFNf_obgCW, W, BANKED
3C7C  6FEC     MOVWF dt, BANKED
3C7E  6BED     CLRF min, BANKED
3C80  51F1     MOVF m, W, BANKED
3C82  C078     MOVFF _PFNf_mod_ncw, dt
3C84  F0EE     NOP
3C86  6BEF     CLRF 0xEF, BANKED
3C88  27EE     ADDWF dt, F, BANKED
3C8A  0E00     MOVLW 0x0
3C8C  23EF     ADDWFC 0xEF, F, BANKED
3C8E  51EC     MOVF dt, W, BANKED
3C90  5DEE     SUBWF dt, W, BANKED
3C92  51EF     MOVF 0xEF, W, BANKED
3C94  0A80     XORLW 0x80
3C96  6FF0     MOVWF p, BANKED
3C98  51ED     MOVF min, W, BANKED
3C9A  0A80     XORLW 0x80
3C9C  59F0     SUBWFB p, W, BANKED
3C9E  E204     BC 0x3CA8
669:               {
670:                   maxmod = PWM.FIRSTPB + tmp;
3CA0  5178     MOVF _PFNf_mod_ncw, W, BANKED
3CA2  25F1     ADDWF m, W, BANKED
3CA4  6FF4     MOVWF pco, BANKED
671:               }
3CA6  D003     BRA 0x3CAE
672:               else
673:               {
674:                   maxmod = PWM.MMAXCW;
3CA8  C07E     MOVFF _PFNf_obgCW, pco
3CAA  F0F4     NOP
3CAC  D000     BRA 0x3CAE
675:               }
676:           
677:           
678:               //-------
679:               //ze wzgledu na temperature
680:               if(DtCW.CW >= TMIN_MOD && DtCW.CW <= TMAX_MOD) //temperatura w przedziale roboczym?
3CAE  0E13     MOVLW 0x13
3CB0  0100     MOVLB 0x0
3CB2  65AA     CPFSGT DtCW, BANKED
3CB4  D094     BRA 0x3DDE
3CB6  0E3D     MOVLW 0x3D
3CB8  61AA     CPFSLT DtCW, BANKED
3CBA  D091     BRA 0x3DDE
681:               {
682:                   m = (TMAX_MOD - DtCW.CW)*10;
3CBC  51AA     MOVF DtCW, W, BANKED
3CBE  6FEC     MOVWF dt, BANKED
3CC0  6BED     CLRF min, BANKED
3CC2  1FEC     COMF dt, F, BANKED
3CC4  1FED     COMF min, F, BANKED
3CC6  4BEC     INFSNZ dt, F, BANKED
3CC8  2BED     INCF min, F, BANKED
3CCA  0E3C     MOVLW 0x3C
3CCC  25EC     ADDWF dt, W, BANKED
3CCE  6FDE     MOVWF __pcstackBANK0, BANKED
3CD0  0E00     MOVLW 0x0
3CD2  21ED     ADDWFC min, W, BANKED
3CD4  6FDF     MOVWF pco, BANKED
3CD6  6BE1     CLRF GIE_BIT_VAL, BANKED
3CD8  0E0A     MOVLW 0xA
3CDA  6FE0     MOVWF bdat, BANKED
3CDC  EC5B     CALL 0xECB6, 0
3CDE  F076     NOP
3CE0  C0DE     MOVFF __pcstackBANK0, max
3CE2  F0F5     NOP
3CE4  C0DF     MOVFF pco, ehi
3CE6  F0F6     NOP
3CE8  0100     MOVLB 0x0
3CEA  0E00     MOVLW 0x0
3CEC  BFF6     BTFSC ehi, 7, BANKED
3CEE  0EFF     MOVLW 0xFF
3CF0  6FF7     MOVWF step, BANKED
3CF2  6FF8     MOVWF step2, BANKED
683:                   m = m / (TMAX_MOD - TMIN_MOD);
3CF4  C0F5     MOVFF max, __pcstackBANK0
3CF6  F0DE     NOP
3CF8  C0F6     MOVFF ehi, pco
3CFA  F0DF     NOP
3CFC  C0F7     MOVFF step, bdat
3CFE  F0E0     NOP
3D00  C0F8     MOVFF step2, GIE_BIT_VAL
3D02  F0E1     NOP
3D04  0E28     MOVLW 0x28
3D06  0100     MOVLB 0x0
3D08  6FE2     MOVWF divisor, BANKED
3D0A  6BE3     CLRF a, BANKED
3D0C  6BE4     CLRF k, BANKED
3D0E  6BE5     CLRF k, BANKED
3D10  ECF3     CALL 0xB3E6, 0
3D12  F059     NOP
3D14  C0DE     MOVFF __pcstackBANK0, max
3D16  F0F5     NOP
3D18  C0DF     MOVFF pco, ehi
3D1A  F0F6     NOP
3D1C  C0E0     MOVFF bdat, step
3D1E  F0F7     NOP
3D20  C0E1     MOVFF GIE_BIT_VAL, step2
3D22  F0F8     NOP
684:                   m = m * (maxmod - PWM.MDMOD);
3D24  0100     MOVLB 0x0
3D26  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3D28  6FEC     MOVWF dt, BANKED
3D2A  6BED     CLRF min, BANKED
3D2C  1FEC     COMF dt, F, BANKED
3D2E  1FED     COMF min, F, BANKED
3D30  4BEC     INFSNZ dt, F, BANKED
3D32  2BED     INCF min, F, BANKED
3D34  51F4     MOVF pco, W, BANKED
3D36  6FEE     MOVWF dt, BANKED
3D38  6BEF     CLRF 0xEF, BANKED
3D3A  51EC     MOVF dt, W, BANKED
3D3C  27EE     ADDWF dt, F, BANKED
3D3E  51ED     MOVF min, W, BANKED
3D40  23EF     ADDWFC 0xEF, F, BANKED
3D42  C0EE     MOVFF dt, __pcstackBANK0
3D44  F0DE     NOP
3D46  C0EF     MOVFF 0xEF, pco
3D48  F0DF     NOP
3D4A  0E00     MOVLW 0x0
3D4C  BFDF     BTFSC pco, 7, BANKED
3D4E  0EFF     MOVLW 0xFF
3D50  6FE0     MOVWF bdat, BANKED
3D52  6FE1     MOVWF GIE_BIT_VAL, BANKED
3D54  C0F5     MOVFF max, divisor
3D56  F0E2     NOP
3D58  C0F6     MOVFF ehi, a
3D5A  F0E3     NOP
3D5C  C0F7     MOVFF step, k
3D5E  F0E4     NOP
3D60  C0F8     MOVFF step2, k
3D62  F0E5     NOP
3D64  EC2F     CALL 0xDA5E, 0
3D66  F06D     NOP
3D68  C0DE     MOVFF __pcstackBANK0, max
3D6A  F0F5     NOP
3D6C  C0DF     MOVFF pco, ehi
3D6E  F0F6     NOP
3D70  C0E0     MOVFF bdat, step
3D72  F0F7     NOP
3D74  C0E1     MOVFF GIE_BIT_VAL, step2
3D76  F0F8     NOP
685:                   if(m < 0) m = 0;
3D78  0100     MOVLB 0x0
3D7A  AFF8     BTFSS step2, 7, BANKED
3D7C  D005     BRA 0x3D88
3D7E  6BF5     CLRF max, BANKED
3D80  6BF6     CLRF ehi, BANKED
3D82  6BF7     CLRF step, BANKED
3D84  6BF8     CLRF step2, BANKED
3D86  D000     BRA 0x3D88
686:                   m = m / 10 + PWM.MDMOD;
3D88  C0F5     MOVFF max, __pcstackBANK0
3D8A  F0DE     NOP
3D8C  C0F6     MOVFF ehi, pco
3D8E  F0DF     NOP
3D90  C0F7     MOVFF step, bdat
3D92  F0E0     NOP
3D94  C0F8     MOVFF step2, GIE_BIT_VAL
3D96  F0E1     NOP
3D98  0E0A     MOVLW 0xA
3D9A  0100     MOVLB 0x0
3D9C  6FE2     MOVWF divisor, BANKED
3D9E  6BE3     CLRF a, BANKED
3DA0  6BE4     CLRF k, BANKED
3DA2  6BE5     CLRF k, BANKED
3DA4  ECF3     CALL 0xB3E6, 0
3DA6  F059     NOP
3DA8  0100     MOVLB 0x0
3DAA  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3DAC  25DE     ADDWF __pcstackBANK0, W, BANKED
3DAE  6FF5     MOVWF max, BANKED
3DB0  0E00     MOVLW 0x0
3DB2  21DF     ADDWFC pco, W, BANKED
3DB4  6FF6     MOVWF ehi, BANKED
3DB6  0E00     MOVLW 0x0
3DB8  21E0     ADDWFC bdat, W, BANKED
3DBA  6FF7     MOVWF step, BANKED
3DBC  0E00     MOVLW 0x0
3DBE  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
3DC0  6FF8     MOVWF step2, BANKED
687:                   if(m > 0xff) p = maxmod; //przepelnienie
3DC2  0100     MOVLB 0x0
3DC4  BFF8     BTFSC step2, 7, BANKED
3DC6  D008     BRA 0x3DD8
3DC8  51F8     MOVF step2, W, BANKED
3DCA  11F7     IORWF step, W, BANKED
3DCC  E102     BNZ 0x3DD2
3DCE  05F6     DECF ehi, W, BANKED
3DD0  E303     BNC 0x3DD8
3DD2  C0F4     MOVFF pco, tid
3DD4  F0F2     NOP
3DD6  D011     BRA 0x3DFA
688:                   else p = m;
3DD8  C0F5     MOVFF max, tid
3DDA  F0F2     NOP
689:               }
3DDC  D00E     BRA 0x3DFA
690:               else //temperatura poza przedzialem?
691:               {
692:                   if(DtCW.CW < TMIN_MOD) p = maxmod;
3DDE  0E14     MOVLW 0x14
3DE0  0100     MOVLB 0x0
3DE2  61AA     CPFSLT DtCW, BANKED
3DE4  D003     BRA 0x3DEC
3DE6  C0F4     MOVFF pco, tid
3DE8  F0F2     NOP
3DEA  D000     BRA 0x3DEC
693:                   if(DtCW.CW > TMAX_MOD) p = PWM.MDMOD;
3DEC  0E3C     MOVLW 0x3C
3DEE  0100     MOVLB 0x0
3DF0  65AA     CPFSGT DtCW, BANKED
3DF2  D003     BRA 0x3DFA
3DF4  C067     MOVFF _PFNf_b_set_ncw, tid
3DF6  F0F2     NOP
3DF8  D000     BRA 0x3DFA
694:               }
695:               //-------
696:               //ze wzgledu na nastawe
697:               m = (DtCW.PCW - F1_MIN_PCW)*10;
3DFA  0EE2     MOVLW 0xE2
3DFC  0100     MOVLB 0x0
3DFE  25AB     ADDWF _rglf_fast_up, W, BANKED
3E00  6FDE     MOVWF __pcstackBANK0, BANKED
3E02  6BDF     CLRF pco, BANKED
3E04  0EFF     MOVLW 0xFF
3E06  23DF     ADDWFC pco, F, BANKED
3E08  6BE1     CLRF GIE_BIT_VAL, BANKED
3E0A  0E0A     MOVLW 0xA
3E0C  6FE0     MOVWF bdat, BANKED
3E0E  EC5B     CALL 0xECB6, 0
3E10  F076     NOP
3E12  C0DE     MOVFF __pcstackBANK0, max
3E14  F0F5     NOP
3E16  C0DF     MOVFF pco, ehi
3E18  F0F6     NOP
3E1A  0100     MOVLB 0x0
3E1C  0E00     MOVLW 0x0
3E1E  BFF6     BTFSC ehi, 7, BANKED
3E20  0EFF     MOVLW 0xFF
3E22  6FF7     MOVWF step, BANKED
3E24  6FF8     MOVWF step2, BANKED
698:               m = m / (F1_MAX_PCW - F1_MIN_PCW);
3E26  C0F5     MOVFF max, __pcstackBANK0
3E28  F0DE     NOP
3E2A  C0F6     MOVFF ehi, pco
3E2C  F0DF     NOP
3E2E  C0F7     MOVFF step, bdat
3E30  F0E0     NOP
3E32  C0F8     MOVFF step2, GIE_BIT_VAL
3E34  F0E1     NOP
3E36  0E1E     MOVLW 0x1E
3E38  0100     MOVLB 0x0
3E3A  6FE2     MOVWF divisor, BANKED
3E3C  6BE3     CLRF a, BANKED
3E3E  6BE4     CLRF k, BANKED
3E40  6BE5     CLRF k, BANKED
3E42  ECF3     CALL 0xB3E6, 0
3E44  F059     NOP
3E46  C0DE     MOVFF __pcstackBANK0, max
3E48  F0F5     NOP
3E4A  C0DF     MOVFF pco, ehi
3E4C  F0F6     NOP
3E4E  C0E0     MOVFF bdat, step
3E50  F0F7     NOP
3E52  C0E1     MOVFF GIE_BIT_VAL, step2
3E54  F0F8     NOP
699:               m = m * (maxmod - PWM.MDMOD);
3E56  0100     MOVLB 0x0
3E58  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3E5A  6FEC     MOVWF dt, BANKED
3E5C  6BED     CLRF min, BANKED
3E5E  1FEC     COMF dt, F, BANKED
3E60  1FED     COMF min, F, BANKED
3E62  4BEC     INFSNZ dt, F, BANKED
3E64  2BED     INCF min, F, BANKED
3E66  51F4     MOVF pco, W, BANKED
3E68  6FEE     MOVWF dt, BANKED
3E6A  6BEF     CLRF 0xEF, BANKED
3E6C  51EC     MOVF dt, W, BANKED
3E6E  27EE     ADDWF dt, F, BANKED
3E70  51ED     MOVF min, W, BANKED
3E72  23EF     ADDWFC 0xEF, F, BANKED
3E74  C0EE     MOVFF dt, __pcstackBANK0
3E76  F0DE     NOP
3E78  C0EF     MOVFF 0xEF, pco
3E7A  F0DF     NOP
3E7C  0E00     MOVLW 0x0
3E7E  BFDF     BTFSC pco, 7, BANKED
3E80  0EFF     MOVLW 0xFF
3E82  6FE0     MOVWF bdat, BANKED
3E84  6FE1     MOVWF GIE_BIT_VAL, BANKED
3E86  C0F5     MOVFF max, divisor
3E88  F0E2     NOP
3E8A  C0F6     MOVFF ehi, a
3E8C  F0E3     NOP
3E8E  C0F7     MOVFF step, k
3E90  F0E4     NOP
3E92  C0F8     MOVFF step2, k
3E94  F0E5     NOP
3E96  EC2F     CALL 0xDA5E, 0
3E98  F06D     NOP
3E9A  C0DE     MOVFF __pcstackBANK0, max
3E9C  F0F5     NOP
3E9E  C0DF     MOVFF pco, ehi
3EA0  F0F6     NOP
3EA2  C0E0     MOVFF bdat, step
3EA4  F0F7     NOP
3EA6  C0E1     MOVFF GIE_BIT_VAL, step2
3EA8  F0F8     NOP
700:               if(m < 0) m = 0;
3EAA  0100     MOVLB 0x0
3EAC  AFF8     BTFSS step2, 7, BANKED
3EAE  D005     BRA 0x3EBA
3EB0  6BF5     CLRF max, BANKED
3EB2  6BF6     CLRF ehi, BANKED
3EB4  6BF7     CLRF step, BANKED
3EB6  6BF8     CLRF step2, BANKED
3EB8  D000     BRA 0x3EBA
701:               m = m / 10 + PWM.MDMOD;
3EBA  C0F5     MOVFF max, __pcstackBANK0
3EBC  F0DE     NOP
3EBE  C0F6     MOVFF ehi, pco
3EC0  F0DF     NOP
3EC2  C0F7     MOVFF step, bdat
3EC4  F0E0     NOP
3EC6  C0F8     MOVFF step2, GIE_BIT_VAL
3EC8  F0E1     NOP
3ECA  0E0A     MOVLW 0xA
3ECC  0100     MOVLB 0x0
3ECE  6FE2     MOVWF divisor, BANKED
3ED0  6BE3     CLRF a, BANKED
3ED2  6BE4     CLRF k, BANKED
3ED4  6BE5     CLRF k, BANKED
3ED6  ECF3     CALL 0xB3E6, 0
3ED8  F059     NOP
3EDA  0100     MOVLB 0x0
3EDC  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3EDE  25DE     ADDWF __pcstackBANK0, W, BANKED
3EE0  6FF5     MOVWF max, BANKED
3EE2  0E00     MOVLW 0x0
3EE4  21DF     ADDWFC pco, W, BANKED
3EE6  6FF6     MOVWF ehi, BANKED
3EE8  0E00     MOVLW 0x0
3EEA  21E0     ADDWFC bdat, W, BANKED
3EEC  6FF7     MOVWF step, BANKED
3EEE  0E00     MOVLW 0x0
3EF0  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
3EF2  6FF8     MOVWF step2, BANKED
702:               if(m > 0xff) p2 = maxmod; //przepelnienie
3EF4  0100     MOVLB 0x0
3EF6  BFF8     BTFSC step2, 7, BANKED
3EF8  D008     BRA 0x3F0A
3EFA  51F8     MOVF step2, W, BANKED
3EFC  11F7     IORWF step, W, BANKED
3EFE  E102     BNZ 0x3F04
3F00  05F6     DECF ehi, W, BANKED
3F02  E303     BNC 0x3F0A
3F04  C0F4     MOVFF pco, min
3F06  F0F3     NOP
3F08  D003     BRA 0x3F10
703:               else p2 = m;
3F0A  C0F5     MOVFF max, min
3F0C  F0F3     NOP
3F0E  D000     BRA 0x3F10
704:               //-------
705:               //wybrana zostaje nizsza wartosc z p i p2
706:               if(p > p2) p = p2;
3F10  0100     MOVLB 0x0
3F12  51F2     MOVF tid, W, BANKED
3F14  5DF3     SUBWF min, W, BANKED
3F16  E203     BC 0x3F1E
3F18  C0F3     MOVFF min, tid
3F1A  F0F2     NOP
3F1C  D000     BRA 0x3F1E
707:               //-------
708:               //ze wzgledu na relacje miêdzy temperatura i nastawa
709:               if(DtCW.DCW >= DMIN_MOD && DtCW.DCW <= DMAX_MOD) //roznica w przedziale roboczym?
3F1E  0100     MOVLB 0x0
3F20  BFAF     BTFSC _rglf_nmod, 7, BANKED
3F22  D08E     BRA 0x4040
3F24  51AF     MOVF _rglf_nmod, W, BANKED
3F26  0A80     XORLW 0x80
3F28  0F57     ADDLW 0x57
3F2A  E301     BNC 0x3F2E
3F2C  D089     BRA 0x4040
710:               {
711:                   m = DtCW.DCW * 10;
3F2E  51AF     MOVF _rglf_nmod, W, BANKED
3F30  6FDE     MOVWF __pcstackBANK0, BANKED
3F32  6BDF     CLRF pco, BANKED
3F34  BFDE     BTFSC __pcstackBANK0, 7, BANKED
3F36  07DF     DECF pco, F, BANKED
3F38  6BE1     CLRF GIE_BIT_VAL, BANKED
3F3A  0E0A     MOVLW 0xA
3F3C  6FE0     MOVWF bdat, BANKED
3F3E  EC5B     CALL 0xECB6, 0
3F40  F076     NOP
3F42  C0DE     MOVFF __pcstackBANK0, max
3F44  F0F5     NOP
3F46  C0DF     MOVFF pco, ehi
3F48  F0F6     NOP
3F4A  0100     MOVLB 0x0
3F4C  0E00     MOVLW 0x0
3F4E  BFF6     BTFSC ehi, 7, BANKED
3F50  0EFF     MOVLW 0xFF
3F52  6FF7     MOVWF step, BANKED
3F54  6FF8     MOVWF step2, BANKED
712:                   m = m / (DMAX_MOD - DMIN_MOD);
3F56  C0F5     MOVFF max, __pcstackBANK0
3F58  F0DE     NOP
3F5A  C0F6     MOVFF ehi, pco
3F5C  F0DF     NOP
3F5E  C0F7     MOVFF step, bdat
3F60  F0E0     NOP
3F62  C0F8     MOVFF step2, GIE_BIT_VAL
3F64  F0E1     NOP
3F66  0E28     MOVLW 0x28
3F68  0100     MOVLB 0x0
3F6A  6FE2     MOVWF divisor, BANKED
3F6C  6BE3     CLRF a, BANKED
3F6E  6BE4     CLRF k, BANKED
3F70  6BE5     CLRF k, BANKED
3F72  ECF3     CALL 0xB3E6, 0
3F74  F059     NOP
3F76  C0DE     MOVFF __pcstackBANK0, max
3F78  F0F5     NOP
3F7A  C0DF     MOVFF pco, ehi
3F7C  F0F6     NOP
3F7E  C0E0     MOVFF bdat, step
3F80  F0F7     NOP
3F82  C0E1     MOVFF GIE_BIT_VAL, step2
3F84  F0F8     NOP
713:                   m = m * (maxmod - PWM.MDMOD);
3F86  0100     MOVLB 0x0
3F88  5167     MOVF _PFNf_b_set_ncw, W, BANKED
3F8A  6FEC     MOVWF dt, BANKED
3F8C  6BED     CLRF min, BANKED
3F8E  1FEC     COMF dt, F, BANKED
3F90  1FED     COMF min, F, BANKED
3F92  4BEC     INFSNZ dt, F, BANKED
3F94  2BED     INCF min, F, BANKED
3F96  51F4     MOVF pco, W, BANKED
3F98  6FEE     MOVWF dt, BANKED
3F9A  6BEF     CLRF 0xEF, BANKED
3F9C  51EC     MOVF dt, W, BANKED
3F9E  27EE     ADDWF dt, F, BANKED
3FA0  51ED     MOVF min, W, BANKED
3FA2  23EF     ADDWFC 0xEF, F, BANKED
3FA4  C0EE     MOVFF dt, __pcstackBANK0
3FA6  F0DE     NOP
3FA8  C0EF     MOVFF 0xEF, pco
3FAA  F0DF     NOP
3FAC  0E00     MOVLW 0x0
3FAE  BFDF     BTFSC pco, 7, BANKED
3FB0  0EFF     MOVLW 0xFF
3FB2  6FE0     MOVWF bdat, BANKED
3FB4  6FE1     MOVWF GIE_BIT_VAL, BANKED
3FB6  C0F5     MOVFF max, divisor
3FB8  F0E2     NOP
3FBA  C0F6     MOVFF ehi, a
3FBC  F0E3     NOP
3FBE  C0F7     MOVFF step, k
3FC0  F0E4     NOP
3FC2  C0F8     MOVFF step2, k
3FC4  F0E5     NOP
3FC6  EC2F     CALL 0xDA5E, 0
3FC8  F06D     NOP
3FCA  C0DE     MOVFF __pcstackBANK0, max
3FCC  F0F5     NOP
3FCE  C0DF     MOVFF pco, ehi
3FD0  F0F6     NOP
3FD2  C0E0     MOVFF bdat, step
3FD4  F0F7     NOP
3FD6  C0E1     MOVFF GIE_BIT_VAL, step2
3FD8  F0F8     NOP
714:                   if(m < 0) m = 0;
3FDA  0100     MOVLB 0x0
3FDC  AFF8     BTFSS step2, 7, BANKED
3FDE  D005     BRA 0x3FEA
3FE0  6BF5     CLRF max, BANKED
3FE2  6BF6     CLRF ehi, BANKED
3FE4  6BF7     CLRF step, BANKED
3FE6  6BF8     CLRF step2, BANKED
3FE8  D000     BRA 0x3FEA
715:                   m = m / 10 + PWM.MDMOD;
3FEA  C0F5     MOVFF max, __pcstackBANK0
3FEC  F0DE     NOP
3FEE  C0F6     MOVFF ehi, pco
3FF0  F0DF     NOP
3FF2  C0F7     MOVFF step, bdat
3FF4  F0E0     NOP
3FF6  C0F8     MOVFF step2, GIE_BIT_VAL
3FF8  F0E1     NOP
3FFA  0E0A     MOVLW 0xA
3FFC  0100     MOVLB 0x0
3FFE  6FE2     MOVWF divisor, BANKED
4000  6BE3     CLRF a, BANKED
4002  6BE4     CLRF k, BANKED
4004  6BE5     CLRF k, BANKED
4006  ECF3     CALL 0xB3E6, 0
4008  F059     NOP
400A  0100     MOVLB 0x0
400C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
400E  25DE     ADDWF __pcstackBANK0, W, BANKED
4010  6FF5     MOVWF max, BANKED
4012  0E00     MOVLW 0x0
4014  21DF     ADDWFC pco, W, BANKED
4016  6FF6     MOVWF ehi, BANKED
4018  0E00     MOVLW 0x0
401A  21E0     ADDWFC bdat, W, BANKED
401C  6FF7     MOVWF step, BANKED
401E  0E00     MOVLW 0x0
4020  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
4022  6FF8     MOVWF step2, BANKED
716:                   if(m > 0xff) p2 = maxmod; //przepelnienie
4024  0100     MOVLB 0x0
4026  BFF8     BTFSC step2, 7, BANKED
4028  D008     BRA 0x403A
402A  51F8     MOVF step2, W, BANKED
402C  11F7     IORWF step, W, BANKED
402E  E102     BNZ 0x4034
4030  05F6     DECF ehi, W, BANKED
4032  E303     BNC 0x403A
4034  C0F4     MOVFF pco, min
4036  F0F3     NOP
4038  D011     BRA 0x405C
717:                   else p2 = m;
403A  C0F5     MOVFF max, min
403C  F0F3     NOP
718:               }
403E  D00E     BRA 0x405C
719:               else //roznica poza przedzialem?
720:               {
721:                   if(DtCW.DCW > DMAX_MOD) p2 = maxmod;
4040  0100     MOVLB 0x0
4042  51AF     MOVF _rglf_nmod, W, BANKED
4044  0A80     XORLW 0x80
4046  0F57     ADDLW 0x57
4048  E303     BNC 0x4050
404A  C0F4     MOVFF pco, min
404C  F0F3     NOP
404E  D000     BRA 0x4050
722:                   if(DtCW.DCW < DMIN_MOD) p2 = PWM.MDMOD;
4050  0100     MOVLB 0x0
4052  AFAF     BTFSS _rglf_nmod, 7, BANKED
4054  D003     BRA 0x405C
4056  C067     MOVFF _PFNf_b_set_ncw, min
4058  F0F3     NOP
405A  D000     BRA 0x405C
723:               }
724:               //-------
725:               //wybrana zostaje nizsza wartosc z p i p2
726:               if(p > p2) p = p2;
405C  0100     MOVLB 0x0
405E  51F2     MOVF tid, W, BANKED
4060  5DF3     SUBWF min, W, BANKED
4062  E203     BC 0x406A
4064  C0F3     MOVFF min, tid
4066  F0F2     NOP
4068  D000     BRA 0x406A
727:               //-------
728:               return p; //wartosc pierwszego pobudzenia
406A  0100     MOVLB 0x0
406C  51F2     MOVF tid, W, BANKED
406E  0012     RETURN 0
729:           }
4070  0012     RETURN 0
730:           //-------------------------------------------------------------
731:           //zeruj parametry modulatora po zmianie obiegu
732:           
733:           void ClrMod(void)
734:           {
735:               rglf_fz = 0;
F0DE  9815     BCF rglf_btcw, 4, ACCESS
736:               rglf_med_up = 0;
F0E0  9C15     BCF rglf_btcw, 6, ACCESS
737:               rglf_fast_up = 0;
F0E2  9615     BCF rglf_btcw, 3, ACCESS
738:               rgl.xmod = PWM.BufPWM;
F0E4  C060     MOVFF PWM, 0x3C
F0E6  F03C     NOP
739:               rgl.srp = 0;
F0E8  0E00     MOVLW 0x0
F0EA  6A3B     CLRF 0x3B, ACCESS
740:               rgl.ytmp = 0;
F0EC  6A3A     CLRF 0x3A, ACCESS
741:               rglf_nmod = 0;
F0EE  9E15     BCF rglf_btcw, 7, ACCESS
742:               rglf_del1s = 0;
F0F0  9215     BCF rglf_btcw, 1, ACCESS
743:               rglf_inv_mod = 0;
F0F2  9A15     BCF rglf_btcw, 5, ACCESS
744:           }
F0F4  0012     RETURN 0
745:           //-------------------------------------------------------------
746:           //zmien obieg na CW
747:           
748:           void ModToCW(void)
749:           {
750:               rglf_btcw = 1;
F304  8015     BSF rglf_btcw, 0, ACCESS
751:               if(rglf_btco)
F306  AE14     BTFSS UADtf_RData, 7, ACCESS
F308  0012     RETURN 0
752:               {
753:                   rglf_btco = 0;
F30A  9E14     BCF UADtf_RData, 7, ACCESS
754:                   ClrMod();
F30C  EF6F     GOTO 0xF0DE
F30E  F078     NOP
755:               }
756:           }
F310  0012     RETURN 0
757:           //-------------------------------------------------------------
758:           //zmien obieg na CO
759:           
760:           void ModToCO(void)
761:           {
762:               rglf_btco = 1;
F32E  8E14     BSF UADtf_RData, 7, ACCESS
763:               if(rglf_btcw)
F330  A015     BTFSS rglf_btcw, 0, ACCESS
F332  0012     RETURN 0
764:               {
765:                   rglf_btcw = 0;
F334  9015     BCF rglf_btcw, 0, ACCESS
766:                   ClrMod();
F336  EF6F     GOTO 0xF0DE
F338  F078     NOP
767:               }
768:           }
F33A  0012     RETURN 0
769:           //-------------------------------------------------------------
770:           //oblicza czas przez ktory temp=const
771:           
772:           void IncConstCOCW(void)
773:           {
774:               if(Tstoi()) rgl.ytmp++;
F23E  ECAC     CALL 0xF358, 0
F240  F079     NOP
F242  E302     BNC 0xF248
F244  2A3A     INCF 0x3A, F, ACCESS
F246  0012     RETURN 0
775:               else rgl.ytmp = 0;
F248  0E00     MOVLW 0x0
F24A  6E3A     MOVWF 0x3A, ACCESS
F24C  0C00     RETLW 0x0
776:           }
F24E  0012     RETURN 0
777:           //-------------------------------------------------------------
778:           //wprowadzenie danych wejsciowych-CO
779:           
780:           void ReadDataCO(void)
781:           {
782:               rgl.x_t = DtCO.DCO;
F3AE  C0D5     MOVFF 0xD5, rgl
F3B0  F036     NOP
783:               rgl.x_dt = DtCO.dDCO;
F3B2  C0D6     MOVFF 0xD6, 0x38
F3B4  F038     NOP
784:           }
F3B6  0012     RETURN 0
785:           //-------------------------------------------------------------
786:           //wprowadzenie danych wejsciowych-CW
787:           
788:           void ReadDataCW(void)
789:           {
790:               rgl.x_t = DtCW.DCW;
F21A  C0AF     MOVFF _rglf_nmod, rgl
F21C  F036     NOP
791:               rgl.x_f = DtCO.DCO;
F21E  C0D5     MOVFF 0xD5, 0x37
F220  F037     NOP
792:               rgl.x_dt = DtCW.dDCW;
F222  C0B0     MOVFF 0xB0, 0x38
F224  F038     NOP
793:               rgl.x_df = DtCO.dDCO;
F226  C0D6     MOVFF 0xD6, 0x39
F228  F039     NOP
794:           }
F22A  0012     RETURN 0
795:           //-------------------------------------------------------------
796:           //pierwsze przyblizenie
797:           
798:           void ModZgCW(void)
799:           {
800:               signed long m;
801:               unsigned char p;
802:               if(rglf_fz) //aktualnie faza 2?
94AE  A815     BTFSS rglf_btcw, 4, ACCESS
94B0  D00E     BRA 0x94CE
803:               {
804:                   if(Tnizsza(3)) //2 przygotowanie do przejscia do fazy 1
94B2  0E03     MOVLW 0x3
94B4  ECDA     CALL 0xEFB4, 0
94B6  F077     NOP
94B8  A0D8     BTFSS STATUS, 0, ACCESS
94BA  0012     RETURN 0
805:                   {
806:                       rgl.xmod = PWM.BufPWM;
94BC  C060     MOVFF PWM, 0x3C
94BE  F03C     NOP
807:                       rgl.srp = 0;
94C0  6A3B     CLRF 0x3B, ACCESS
808:                       rgl.ytmp = 0;
94C2  6A3A     CLRF 0x3A, ACCESS
809:                       rglf_nmod = 0;
94C4  9E15     BCF rglf_btcw, 7, ACCESS
810:                       rglf_del1s = 0;
94C6  9215     BCF rglf_btcw, 1, ACCESS
811:                   }
94C8  D002     BRA 0x94CE
812:                   else return;
94CA  0012     RETURN 0
94CC  D000     BRA 0x94CE
813:               }
814:               if(Twyzsza(0) && Tstoi()) //warunek przejscia do fazy 2
94CE  0E00     MOVLW 0x0
94D0  ECC5     CALL 0xE78A, 0
94D2  F073     NOP
94D4  E314     BNC 0x94FE
94D6  ECAC     CALL 0xF358, 0
94D8  F079     NOP
94DA  E311     BNC 0x94FE
815:               {
816:                   rglf_fz = 1;
94DC  8815     BSF rglf_btcw, 4, ACCESS
817:                   rglf_fast_up = 0;
94DE  9615     BCF rglf_btcw, 3, ACCESS
818:                   rglf_med_up = 0;
94E0  9C15     BCF rglf_btcw, 6, ACCESS
819:                   rgl.srp = PWM.BufPWM;
94E2  C060     MOVFF PWM, 0x3B
94E4  F03B     NOP
820:                   rgl.xmod = PWM.BufPWM;
94E6  C060     MOVFF PWM, 0x3C
94E8  F03C     NOP
821:                   if(rgl.xmod > PWM.MGMOD)
94EA  503C     MOVF 0x3C, W, ACCESS
94EC  0100     MOVLB 0x0
94EE  5D6A     SUBWF _PFNf_blkcs, W, BANKED
94F0  B0D8     BTFSC STATUS, 0, ACCESS
94F2  0012     RETURN 0
822:                   {
823:                       rgl.srp = PWM.MGMOD;
94F4  C06A     MOVFF _PFNf_blkcs, 0x3B
94F6  F03B     NOP
824:                       rgl.xmod = PWM.MGMOD;
94F8  C06A     MOVFF _PFNf_blkcs, 0x3C
94FA  F03C     NOP
825:                   }
826:                   return;
94FC  0012     RETURN 0
827:               }
828:               if(rgl.xmod >= PWM.MDMOD) m = (rgl.xmod - PWM.MDMOD)*10;
94FE  0100     MOVLB 0x0
9500  5167     MOVF _PFNf_b_set_ncw, W, BANKED
9502  5C3C     SUBWF 0x3C, W, ACCESS
9504  E31C     BNC 0x953E
9506  5167     MOVF _PFNf_b_set_ncw, W, BANKED
9508  6FEC     MOVWF dt, BANKED
950A  6BED     CLRF min, BANKED
950C  1FEC     COMF dt, F, BANKED
950E  1FED     COMF min, F, BANKED
9510  4BEC     INFSNZ dt, F, BANKED
9512  2BED     INCF min, F, BANKED
9514  503C     MOVF 0x3C, W, ACCESS
9516  25EC     ADDWF dt, W, BANKED
9518  6FDE     MOVWF __pcstackBANK0, BANKED
951A  0E00     MOVLW 0x0
951C  21ED     ADDWFC min, W, BANKED
951E  6FDF     MOVWF pco, BANKED
9520  6BE1     CLRF GIE_BIT_VAL, BANKED
9522  0E0A     MOVLW 0xA
9524  6FE0     MOVWF bdat, BANKED
9526  EC5B     CALL 0xECB6, 0
9528  F076     NOP
952A  C0DE     MOVFF __pcstackBANK0, tid
952C  F0F2     NOP
952E  C0DF     MOVFF pco, min
9530  F0F3     NOP
9532  0100     MOVLB 0x0
9534  0E00     MOVLW 0x0
9536  BFF3     BTFSC min, 7, BANKED
9538  0EFF     MOVLW 0xFF
953A  6FF4     MOVWF pco, BANKED
953C  D005     BRA 0x9548
829:               else m = 0;
953E  0E00     MOVLW 0x0
9540  0100     MOVLB 0x0
9542  6BF2     CLRF tid, BANKED
9544  6BF3     CLRF min, BANKED
9546  6BF4     CLRF pco, BANKED
9548  6FF5     MOVWF max, BANKED
954A  D000     BRA 0x954C
830:               m = m / (DtCW.MAD_CW - DtCW.DAD_CW); //DAD_CW-MAD_CW
954C  C0F2     MOVFF tid, __pcstackBANK0
954E  F0DE     NOP
9550  C0F3     MOVFF min, pco
9552  F0DF     NOP
9554  C0F4     MOVFF pco, bdat
9556  F0E0     NOP
9558  C0F5     MOVFF max, GIE_BIT_VAL
955A  F0E1     NOP
955C  0100     MOVLB 0x0
955E  51B6     MOVF 0xB6, W, BANKED
9560  6FEC     MOVWF dt, BANKED
9562  6BED     CLRF min, BANKED
9564  1FEC     COMF dt, F, BANKED
9566  1FED     COMF min, F, BANKED
9568  4BEC     INFSNZ dt, F, BANKED
956A  2BED     INCF min, F, BANKED
956C  51B5     MOVF 0xB5, W, BANKED
956E  6FEE     MOVWF dt, BANKED
9570  6BEF     CLRF 0xEF, BANKED
9572  51EC     MOVF dt, W, BANKED
9574  27EE     ADDWF dt, F, BANKED
9576  51ED     MOVF min, W, BANKED
9578  23EF     ADDWFC 0xEF, F, BANKED
957A  C0EE     MOVFF dt, divisor
957C  F0E2     NOP
957E  C0EF     MOVFF 0xEF, a
9580  F0E3     NOP
9582  0E00     MOVLW 0x0
9584  BFE3     BTFSC a, 7, BANKED
9586  0EFF     MOVLW 0xFF
9588  6FE4     MOVWF k, BANKED
958A  6FE5     MOVWF k, BANKED
958C  ECF3     CALL 0xB3E6, 0
958E  F059     NOP
9590  C0DE     MOVFF __pcstackBANK0, tid
9592  F0F2     NOP
9594  C0DF     MOVFF pco, min
9596  F0F3     NOP
9598  C0E0     MOVFF bdat, pco
959A  F0F4     NOP
959C  C0E1     MOVFF GIE_BIT_VAL, max
959E  F0F5     NOP
831:               m = m * (DtCW.AC_CW - DtCW.DAD_CW); //DAD_CW-AC_CW
95A0  0100     MOVLB 0x0
95A2  51B6     MOVF 0xB6, W, BANKED
95A4  6FEC     MOVWF dt, BANKED
95A6  6BED     CLRF min, BANKED
95A8  1FEC     COMF dt, F, BANKED
95AA  1FED     COMF min, F, BANKED
95AC  4BEC     INFSNZ dt, F, BANKED
95AE  2BED     INCF min, F, BANKED
95B0  51B4     MOVF 0xB4, W, BANKED
95B2  6FEE     MOVWF dt, BANKED
95B4  6BEF     CLRF 0xEF, BANKED
95B6  51EC     MOVF dt, W, BANKED
95B8  27EE     ADDWF dt, F, BANKED
95BA  51ED     MOVF min, W, BANKED
95BC  23EF     ADDWFC 0xEF, F, BANKED
95BE  C0EE     MOVFF dt, __pcstackBANK0
95C0  F0DE     NOP
95C2  C0EF     MOVFF 0xEF, pco
95C4  F0DF     NOP
95C6  0E00     MOVLW 0x0
95C8  BFDF     BTFSC pco, 7, BANKED
95CA  0EFF     MOVLW 0xFF
95CC  6FE0     MOVWF bdat, BANKED
95CE  6FE1     MOVWF GIE_BIT_VAL, BANKED
95D0  C0F2     MOVFF tid, divisor
95D2  F0E2     NOP
95D4  C0F3     MOVFF min, a
95D6  F0E3     NOP
95D8  C0F4     MOVFF pco, k
95DA  F0E4     NOP
95DC  C0F5     MOVFF max, k
95DE  F0E5     NOP
95E0  EC2F     CALL 0xDA5E, 0
95E2  F06D     NOP
95E4  C0DE     MOVFF __pcstackBANK0, tid
95E6  F0F2     NOP
95E8  C0DF     MOVFF pco, min
95EA  F0F3     NOP
95EC  C0E0     MOVFF bdat, pco
95EE  F0F4     NOP
95F0  C0E1     MOVFF GIE_BIT_VAL, max
95F2  F0F5     NOP
832:               if(m < 0) m = 0;
95F4  0100     MOVLB 0x0
95F6  AFF5     BTFSS max, 7, BANKED
95F8  D005     BRA 0x9604
95FA  6BF2     CLRF tid, BANKED
95FC  6BF3     CLRF min, BANKED
95FE  6BF4     CLRF pco, BANKED
9600  6BF5     CLRF max, BANKED
9602  D000     BRA 0x9604
833:               m = m / 10 + PWM.MDMOD;
9604  C0F2     MOVFF tid, __pcstackBANK0
9606  F0DE     NOP
9608  C0F3     MOVFF min, pco
960A  F0DF     NOP
960C  C0F4     MOVFF pco, bdat
960E  F0E0     NOP
9610  C0F5     MOVFF max, GIE_BIT_VAL
9612  F0E1     NOP
9614  0E0A     MOVLW 0xA
9616  0100     MOVLB 0x0
9618  6FE2     MOVWF divisor, BANKED
961A  6BE3     CLRF a, BANKED
961C  6BE4     CLRF k, BANKED
961E  6BE5     CLRF k, BANKED
9620  ECF3     CALL 0xB3E6, 0
9622  F059     NOP
9624  0100     MOVLB 0x0
9626  5167     MOVF _PFNf_b_set_ncw, W, BANKED
9628  25DE     ADDWF __pcstackBANK0, W, BANKED
962A  6FF2     MOVWF tid, BANKED
962C  0E00     MOVLW 0x0
962E  21DF     ADDWFC pco, W, BANKED
9630  6FF3     MOVWF min, BANKED
9632  0E00     MOVLW 0x0
9634  21E0     ADDWFC bdat, W, BANKED
9636  6FF4     MOVWF pco, BANKED
9638  0E00     MOVLW 0x0
963A  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
963C  6FF5     MOVWF max, BANKED
834:               if(m > 0xff) //przepelnienie
963E  0100     MOVLB 0x0
9640  BFF5     BTFSC max, 7, BANKED
9642  D009     BRA 0x9656
9644  51F5     MOVF max, W, BANKED
9646  11F4     IORWF pco, W, BANKED
9648  E102     BNZ 0x964E
964A  05F3     DECF min, W, BANKED
964C  E304     BNC 0x9656
835:               {
836:                   rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
964E  9815     BCF rglf_btcw, 4, ACCESS
837:                   rgl.tmp_pwm = rgl.xmod;
9650  C03C     MOVFF 0x3C, 0x3D
9652  F03D     NOP
838:                   return;
9654  0012     RETURN 0
839:               }
840:               if(rglf_fz && (rgl.xmod > m))
9656  A815     BTFSS rglf_btcw, 4, ACCESS
9658  D017     BRA 0x9688
965A  C03C     MOVFF 0x3C, dt
965C  F0EC     NOP
965E  0100     MOVLB 0x0
9660  6BED     CLRF min, BANKED
9662  6BEE     CLRF dt, BANKED
9664  6BEF     CLRF 0xEF, BANKED
9666  51EC     MOVF dt, W, BANKED
9668  5DF2     SUBWF tid, W, BANKED
966A  51ED     MOVF min, W, BANKED
966C  59F3     SUBWFB min, W, BANKED
966E  51EE     MOVF dt, W, BANKED
9670  59F4     SUBWFB pco, W, BANKED
9672  51F5     MOVF max, W, BANKED
9674  0A80     XORLW 0x80
9676  6FF0     MOVWF p, BANKED
9678  51EF     MOVF 0xEF, W, BANKED
967A  0A80     XORLW 0x80
967C  59F0     SUBWFB p, W, BANKED
967E  E204     BC 0x9688
841:                   rgl.srp = (rgl.xmod - m); //przygotowanie lagodnego przejscia do fazy 1
9680  51F2     MOVF tid, W, BANKED
9682  0800     SUBLW 0x0
9684  243C     ADDWF 0x3C, W, ACCESS
9686  6E3B     MOVWF 0x3B, ACCESS
842:               m += rgl.srp;
9688  503B     MOVF 0x3B, W, ACCESS
968A  0100     MOVLB 0x0
968C  27F2     ADDWF tid, F, BANKED
968E  0E00     MOVLW 0x0
9690  23F3     ADDWFC min, F, BANKED
9692  23F4     ADDWFC pco, F, BANKED
9694  23F5     ADDWFC max, F, BANKED
843:               if(m > rgl.xmod) p = rgl.xmod;
9696  C03C     MOVFF 0x3C, dt
9698  F0EC     NOP
969A  6BED     CLRF min, BANKED
969C  6BEE     CLRF dt, BANKED
969E  6BEF     CLRF 0xEF, BANKED
96A0  51F2     MOVF tid, W, BANKED
96A2  5DEC     SUBWF dt, W, BANKED
96A4  51F3     MOVF min, W, BANKED
96A6  59ED     SUBWFB min, W, BANKED
96A8  51F4     MOVF pco, W, BANKED
96AA  59EE     SUBWFB dt, W, BANKED
96AC  51EF     MOVF 0xEF, W, BANKED
96AE  0A80     XORLW 0x80
96B0  6FF0     MOVWF p, BANKED
96B2  51F5     MOVF max, W, BANKED
96B4  0A80     XORLW 0x80
96B6  59F0     SUBWFB p, W, BANKED
96B8  E203     BC 0x96C0
96BA  C03C     MOVFF 0x3C, m
96BC  F0F1     NOP
96BE  D002     BRA 0x96C4
844:               else p = m;
96C0  C0F2     MOVFF tid, m
96C2  F0F1     NOP
845:               rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
96C4  9815     BCF rglf_btcw, 4, ACCESS
846:               rgl.tmp_pwm = p;
96C6  C0F1     MOVFF m, 0x3D
96C8  F03D     NOP
847:           }
96CA  0012     RETURN 0
848:           //-------------------------------------------------------------
849:           //drugie przyblizenie (tylko dla fazy 1)
850:           
851:           void ModDkCW(void)
852:           {
853:               signed long m;
854:               signed char ada;
855:               unsigned char k, p;
856:           
857:               if(!rglf_fz) return; //wyjscie jesli aktualnie faza 1
BA02  A815     BTFSS rglf_btcw, 4, ACCESS
BA04  0012     RETURN 0
BA06  D001     BRA 0xBA0A
BA08  0012     RETURN 0
858:               ada = DtCW.AC_CW - DtCW.DAD_CW;
BA0A  0100     MOVLB 0x0
BA0C  51B6     MOVF 0xB6, W, BANKED
BA0E  0800     SUBLW 0x0
BA10  25B4     ADDWF 0xB4, W, BANKED
BA12  6FE9     MOVWF p, BANKED
859:               k = 1;
BA14  0E01     MOVLW 0x1
BA16  0100     MOVLB 0x0
BA18  6FEA     MOVWF tim, BANKED
860:               if(Trowna()) return; //Tcw!=Tnst?
BA1A  ECA5     CALL 0xF34A, 0
BA1C  F079     NOP
BA1E  B0D8     BTFSC STATUS, 0, ACCESS
BA20  0012     RETURN 0
BA22  D001     BRA 0xBA26
BA24  0012     RETURN 0
861:               if(Tnizsza(0)) //Tcw<Tnst?
BA26  0E00     MOVLW 0x0
BA28  ECDA     CALL 0xEFB4, 0
BA2A  F077     NOP
BA2C  E304     BNC 0xBA36
862:               {
863:                   k = 2;
BA2E  0E02     MOVLW 0x2
BA30  0100     MOVLB 0x0
BA32  6FEA     MOVWF tim, BANKED
BA34  D000     BRA 0xBA36
864:                   /*if(!Trosnie(0))					//(Tcw=CONST) lub (Tcw maleje) ?
865:                   {
866:                           k=1;
867:                           if(Tnizsza(1)) k=3;			//3Tnst-Tcw>=2?
868:                   }*/
869:               }
870:               /*else								//Tcw>Tnst?
871:               {
872:                       if(!Tmaleje(0)) 				//(Tcw=CONST) lub (Tcw rosnie) ?
873:                       {
874:                               k=1;
875:                               if(Twyzsza(1)) k=2;			//2Tcw-Tnst>=2?
876:                       }
877:               }*/
878:               m = rgl.srp + k*ada;
BA36  C0EA     MOVFF tim, __pcstackBANK0
BA38  F0DE     NOP
BA3A  0100     MOVLB 0x0
BA3C  6BDF     CLRF pco, BANKED
BA3E  51E9     MOVF p, W, BANKED
BA40  6FE0     MOVWF bdat, BANKED
BA42  6BE1     CLRF GIE_BIT_VAL, BANKED
BA44  BFE0     BTFSC bdat, 7, BANKED
BA46  07E1     DECF GIE_BIT_VAL, F, BANKED
BA48  EC5B     CALL 0xECB6, 0
BA4A  F076     NOP
BA4C  503B     MOVF 0x3B, W, ACCESS
BA4E  0100     MOVLB 0x0
BA50  6FE4     MOVWF k, BANKED
BA52  6BE5     CLRF k, BANKED
BA54  51DE     MOVF __pcstackBANK0, W, BANKED
BA56  27E4     ADDWF k, F, BANKED
BA58  51DF     MOVF pco, W, BANKED
BA5A  23E5     ADDWFC k, F, BANKED
BA5C  C0E4     MOVFF k, dt
BA5E  F0EC     NOP
BA60  C0E5     MOVFF k, min
BA62  F0ED     NOP
BA64  0E00     MOVLW 0x0
BA66  BFED     BTFSC min, 7, BANKED
BA68  0EFF     MOVLW 0xFF
BA6A  6FEE     MOVWF dt, BANKED
BA6C  6FEF     MOVWF 0xEF, BANKED
879:               if(m > rgl.xmod) p = rgl.xmod;
BA6E  C03C     MOVFF 0x3C, k
BA70  F0E4     NOP
BA72  0100     MOVLB 0x0
BA74  6BE5     CLRF k, BANKED
BA76  6BE6     CLRF counter, BANKED
BA78  6BE7     CLRF sign, BANKED
BA7A  51EC     MOVF dt, W, BANKED
BA7C  5DE4     SUBWF k, W, BANKED
BA7E  51ED     MOVF min, W, BANKED
BA80  59E5     SUBWFB k, W, BANKED
BA82  51EE     MOVF dt, W, BANKED
BA84  59E6     SUBWFB counter, W, BANKED
BA86  51E7     MOVF sign, W, BANKED
BA88  0A80     XORLW 0x80
BA8A  6FE8     MOVWF quotient, BANKED
BA8C  51EF     MOVF 0xEF, W, BANKED
BA8E  0A80     XORLW 0x80
BA90  59E8     SUBWFB quotient, W, BANKED
BA92  E203     BC 0xBA9A
BA94  C03C     MOVFF 0x3C, pop
BA96  F0EB     NOP
BA98  D019     BRA 0xBACC
880:               else
881:                   if(m < PWM.MDMOD) p = PWM.MDMOD;
BA9A  C067     MOVFF _PFNf_b_set_ncw, k
BA9C  F0E4     NOP
BA9E  0100     MOVLB 0x0
BAA0  6BE5     CLRF k, BANKED
BAA2  6BE6     CLRF counter, BANKED
BAA4  6BE7     CLRF sign, BANKED
BAA6  51E4     MOVF k, W, BANKED
BAA8  5DEC     SUBWF dt, W, BANKED
BAAA  51E5     MOVF k, W, BANKED
BAAC  59ED     SUBWFB min, W, BANKED
BAAE  51E6     MOVF counter, W, BANKED
BAB0  59EE     SUBWFB dt, W, BANKED
BAB2  51EF     MOVF 0xEF, W, BANKED
BAB4  0A80     XORLW 0x80
BAB6  6FE8     MOVWF quotient, BANKED
BAB8  51E7     MOVF sign, W, BANKED
BABA  0A80     XORLW 0x80
BABC  59E8     SUBWFB quotient, W, BANKED
BABE  E203     BC 0xBAC6
BAC0  C067     MOVFF _PFNf_b_set_ncw, pop
BAC2  F0EB     NOP
BAC4  D003     BRA 0xBACC
882:               else p = m;
BAC6  C0EC     MOVFF dt, pop
BAC8  F0EB     NOP
BACA  D000     BRA 0xBACC
883:               rgl.tmp_pwm = p;
BACC  C0EB     MOVFF pop, 0x3D
BACE  F03D     NOP
884:           }
BAD0  0012     RETURN 0
885:           //-------------------------------------------------------------
886:           //trzecie przyblizenie
887:           //nowa wartosc punktu rownowagi srp.
888:           //wykonywane co krok czasowy
889:           
890:           void ModPruCW(void)
891:           {
892:               static unsigned char l, m, o, p, q, r, s;
893:               unsigned char tmp;
894:               signed char k;
895:           
896:               if(!rglf_fz) //aktualnie faza 1?
4C8C  B815     BTFSC rglf_btcw, 4, ACCESS
4C8E  D107     BRA 0x4E9E
897:               {
898:                   l = 0;
4C90  0101     MOVLB 0x1
4C92  6B5C     CLRF 0x5C, BANKED
899:                   m = 0;
4C94  6B5D     CLRF 0x5D, BANKED
900:                   o = 0;
4C96  6B5E     CLRF 0x5E, BANKED
901:                   p = 0;
4C98  6B5F     CLRF 0x5F, BANKED
902:                   if(q < 255) q++; //licznik sekund
4C9A  0101     MOVLB 0x1
4C9C  2960     INCF PWM, W, BANKED
4C9E  E002     BZ 0x4CA4
4CA0  2B60     INCF PWM, F, BANKED
4CA2  D000     BRA 0x4CA4
903:                   if(s < 255) s++; //licznik sekund
4CA4  0100     MOVLB 0x0
4CA6  29C7     INCF s, W, BANKED
4CA8  E002     BZ 0x4CAE
4CAA  2BC7     INCF s, F, BANKED
4CAC  D000     BRA 0x4CAE
904:                   if(DtCWf_newPCW) s = 0; //zmieniono nastawe?
4CAE  AC04     BTFSS DtCWf_err_CW, 6, ACCESS
4CB0  D003     BRA 0x4CB8
4CB2  0100     MOVLB 0x0
4CB4  6BC7     CLRF s, BANKED
4CB6  D000     BRA 0x4CB8
905:                   if(Tnizsza(0)) //Tcw<Tnst?
4CB8  0E00     MOVLW 0x0
4CBA  ECDA     CALL 0xEFB4, 0
4CBC  F077     NOP
4CBE  A0D8     BTFSS STATUS, 0, ACCESS
4CC0  0012     RETURN 0
906:                   {
907:                       if(!Tnizsza(10)) //Tnst-Tcw<=10 ?
4CC2  0E0A     MOVLW 0xA
4CC4  ECDA     CALL 0xEFB4, 0
4CC6  F077     NOP
4CC8  B0D8     BTFSC STATUS, 0, ACCESS
4CCA  0012     RETURN 0
908:                       {
909:                           k = 0;
4CCC  0100     MOVLB 0x0
4CCE  6BEA     CLRF tim, BANKED
910:                           if(rgl.tmp_pwm >= pwm_center)
4CD0  0101     MOVLB 0x1
4CD2  5179     MOVF _PFNf_newPCO, W, BANKED
4CD4  5C3D     SUBWF 0x3D, W, ACCESS
4CD6  E32F     BNC 0x4D36
911:                           {
912:                               if(Tnizsza(5) && Tstoi() && s >= 1)
4CD8  0E05     MOVLW 0x5
4CDA  ECDA     CALL 0xEFB4, 0
4CDC  F077     NOP
4CDE  E309     BNC 0x4CF2
4CE0  ECAC     CALL 0xF358, 0
4CE2  F079     NOP
4CE4  E306     BNC 0x4CF2
4CE6  0100     MOVLB 0x0
4CE8  51C7     MOVF s, W, BANKED
4CEA  E003     BZ 0x4CF2
913:                               {
914:                                   s = 0;
4CEC  6BC7     CLRF s, BANKED
915:                                   k = 20; //k=2
4CEE  0E14     MOVLW 0x14
4CF0  D061     BRA 0x4DB4
916:                               }
917:                               else
918:                                   if(Tnizsza(4) && Tstoi() && s >= 1)
4CF2  0E04     MOVLW 0x4
4CF4  ECDA     CALL 0xEFB4, 0
4CF6  F077     NOP
4CF8  E309     BNC 0x4D0C
4CFA  ECAC     CALL 0xF358, 0
4CFC  F079     NOP
4CFE  E306     BNC 0x4D0C
4D00  0100     MOVLB 0x0
4D02  51C7     MOVF s, W, BANKED
4D04  E003     BZ 0x4D0C
919:                               {
920:                                   s = 0;
4D06  6BC7     CLRF s, BANKED
921:                                   k = 15; //k=2
4D08  0E0F     MOVLW 0xF
4D0A  D054     BRA 0x4DB4
922:                               }
923:                               else
924:                                   if(Tnizsza(2) && Tstoi() && s >= 1)
4D0C  0E02     MOVLW 0x2
4D0E  ECDA     CALL 0xEFB4, 0
4D10  F077     NOP
4D12  E306     BNC 0x4D20
4D14  ECAC     CALL 0xF358, 0
4D16  F079     NOP
4D18  E303     BNC 0x4D20
4D1A  0100     MOVLB 0x0
4D1C  51C7     MOVF s, W, BANKED
4D1E  E119     BNZ 0x4D52
925:                               {
926:                                   s = 0;
927:                                   k = 10; //k=2
928:                               }
929:                               else
930:                                   if(Tstoi() && s >= 1)
4D20  ECAC     CALL 0xF358, 0
4D22  F079     NOP
4D24  E34A     BNC 0x4DBA
4D26  0100     MOVLB 0x0
4D28  51C7     MOVF s, W, BANKED
4D2A  E047     BZ 0x4DBA
931:                               {
932:                                   s = 0;
4D2C  0100     MOVLB 0x0
4D2E  6BC7     CLRF s, BANKED
933:                                   k = 5; //k=2
4D30  0E05     MOVLW 0x5
4D32  D040     BRA 0x4DB4
934:                               }
935:                           }
4D34  D042     BRA 0x4DBA
936:                           else
937:                           {
938:                               if(rgl.tmp_pwm >= pwm_kwr)
4D36  0101     MOVLB 0x1
4D38  517A     MOVF _PFNf_newPCW, W, BANKED
4D3A  5C3D     SUBWF 0x3D, W, ACCESS
4D3C  E329     BNC 0x4D90
939:                               {
940:                                   if(Tnizsza(5) && Tstoi() && s >= 1)
4D3E  0E05     MOVLW 0x5
4D40  ECDA     CALL 0xEFB4, 0
4D42  F077     NOP
4D44  E30A     BNC 0x4D5A
4D46  ECAC     CALL 0xF358, 0
4D48  F079     NOP
4D4A  E307     BNC 0x4D5A
4D4C  0100     MOVLB 0x0
4D4E  51C7     MOVF s, W, BANKED
4D50  E004     BZ 0x4D5A
941:                                   {
942:                                       s = 0;
4D52  0100     MOVLB 0x0
4D54  6BC7     CLRF s, BANKED
943:                                       k = 10; //k=2
4D56  0E0A     MOVLW 0xA
4D58  D02D     BRA 0x4DB4
944:                                   }
945:                                   else
946:                                       if(Tnizsza(4) && Tstoi() && s >= 1)
4D5A  0E04     MOVLW 0x4
4D5C  ECDA     CALL 0xEFB4, 0
4D5E  F077     NOP
4D60  E309     BNC 0x4D74
4D62  ECAC     CALL 0xF358, 0
4D64  F079     NOP
4D66  E306     BNC 0x4D74
4D68  0100     MOVLB 0x0
4D6A  51C7     MOVF s, W, BANKED
4D6C  E003     BZ 0x4D74
947:                                   {
948:                                       s = 0;
4D6E  6BC7     CLRF s, BANKED
949:                                       k = 8; //k=2
4D70  0E08     MOVLW 0x8
4D72  D020     BRA 0x4DB4
950:                                   }
951:                                   else
952:                                       if(Tnizsza(2) && Tstoi() && s >= 1)
4D74  0E02     MOVLW 0x2
4D76  ECDA     CALL 0xEFB4, 0
4D78  F077     NOP
4D7A  E306     BNC 0x4D88
4D7C  ECAC     CALL 0xF358, 0
4D7E  F079     NOP
4D80  E303     BNC 0x4D88
4D82  0100     MOVLB 0x0
4D84  51C7     MOVF s, W, BANKED
4D86  E1D2     BNZ 0x4D2C
953:                                   {
954:                                       s = 0;
955:                                       k = 5; //k=2
956:                                   }
957:                                   else
958:                                       if(Tstoi() && s >= 1)
4D88  ECAC     CALL 0xF358, 0
4D8A  F079     NOP
4D8C  D00D     BRA 0x4DA8
959:                                   {
960:                                       s = 0;
961:                                       k = 2; //k=2
962:                                   }
963:                               }
4D8E  D015     BRA 0x4DBA
964:                               else
965:                               {
966:                                   if(Tnizsza(2) && Tstoi() && s >= 1)
4D90  0E02     MOVLW 0x2
4D92  ECDA     CALL 0xEFB4, 0
4D94  F077     NOP
4D96  E306     BNC 0x4DA4
4D98  ECAC     CALL 0xF358, 0
4D9A  F079     NOP
4D9C  E303     BNC 0x4DA4
4D9E  0100     MOVLB 0x0
4DA0  51C7     MOVF s, W, BANKED
4DA2  E1C4     BNZ 0x4D2C
967:                                   {
968:                                       s = 0;
969:                                       k = 5; //k=2
970:                                   }
971:                                   else
972:                                       if(Tstoi() && s >= 1)
4DA4  ECAC     CALL 0xF358, 0
4DA6  F079     NOP
4DA8  E308     BNC 0x4DBA
4DAA  0100     MOVLB 0x0
4DAC  51C7     MOVF s, W, BANKED
4DAE  E005     BZ 0x4DBA
973:                                   {
974:                                       s = 0;
4DB0  6BC7     CLRF s, BANKED
975:                                       k = 2; //k=2
4DB2  0E02     MOVLW 0x2
4DB4  0100     MOVLB 0x0
4DB6  6FEA     MOVWF tim, BANKED
976:                                   }
977:                               }
4DB8  D000     BRA 0x4DBA
978:                           }
979:                           if(rgl.tmp_pwm >= pwm_kwr)
4DBA  0101     MOVLB 0x1
4DBC  517A     MOVF _PFNf_newPCW, W, BANKED
4DBE  5C3D     SUBWF 0x3D, W, ACCESS
4DC0  E314     BNC 0x4DEA
980:                           {
981:                               if(Trosnie(1) && s >= 1) //szybki narost temperatury
4DC2  0E01     MOVLW 0x1
4DC4  ECE8     CALL 0xEFD0, 0
4DC6  F077     NOP
4DC8  E30E     BNC 0x4DE6
4DCA  0100     MOVLB 0x0
4DCC  51C7     MOVF s, W, BANKED
4DCE  E00B     BZ 0x4DE6
982:                               {
983:                                   s = 0;
4DD0  6BC7     CLRF s, BANKED
984:                                   k = 10; //10
4DD2  0E0A     MOVLW 0xA
4DD4  6FEA     MOVWF tim, BANKED
985:                                   if(Trosnie(2)) k = 8; //8b.szybki narost temperatury?
4DD6  0E02     MOVLW 0x2
4DD8  ECE8     CALL 0xEFD0, 0
4DDA  F077     NOP
4DDC  E306     BNC 0x4DEA
4DDE  0E08     MOVLW 0x8
4DE0  0100     MOVLB 0x0
4DE2  6FEA     MOVWF tim, BANKED
986:                               }
4DE4  D002     BRA 0x4DEA
987:                               else
988:                                   rgl.ytmp = 0;
4DE6  6A3A     CLRF 0x3A, ACCESS
4DE8  D000     BRA 0x4DEA
989:                           }
990:                           if(PWM.BufPWM > rgl.xmod) return;
4DEA  0100     MOVLB 0x0
4DEC  5160     MOVF PWM, W, BANKED
4DEE  5C3C     SUBWF 0x3C, W, ACCESS
4DF0  A0D8     BTFSS STATUS, 0, ACCESS
4DF2  0012     RETURN 0
4DF4  D001     BRA 0x4DF8
4DF6  0012     RETURN 0
991:                           tmp = rgl.xmod - PWM.BufPWM;
4DF8  0100     MOVLB 0x0
4DFA  5160     MOVF PWM, W, BANKED
4DFC  0800     SUBLW 0x0
4DFE  243C     ADDWF 0x3C, W, ACCESS
4E00  6FE9     MOVWF p, BANKED
992:                           if(k > tmp) k = tmp;
4E02  51E9     MOVF p, W, BANKED
4E04  80D8     BSF STATUS, 0, ACCESS
4E06  84D8     BSF STATUS, 2, ACCESS
4E08  AFEA     BTFSS tim, 7, BANKED
4E0A  5DEA     SUBWF tim, W, BANKED
4E0C  A0D8     BTFSS STATUS, 0, ACCESS
4E0E  84D8     BSF STATUS, 2, ACCESS
4E10  E003     BZ 0x4E18
4E12  C0E9     MOVFF p, tim
4E14  F0EA     NOP
4E16  D000     BRA 0x4E18
993:                           if(PWM.MMAXCW > PWM.MGMOD)
4E18  0100     MOVLB 0x0
4E1A  517E     MOVF _PFNf_obgCW, W, BANKED
4E1C  5D6A     SUBWF _PFNf_blkcs, W, BANKED
4E1E  E21F     BC 0x4E5E
994:                           {
995:                               if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
4E20  C0EA     MOVFF tim, divisor
4E22  F0E2     NOP
4E24  6BE3     CLRF a, BANKED
4E26  BFE2     BTFSC divisor, 7, BANKED
4E28  07E3     DECF a, F, BANKED
4E2A  503B     MOVF 0x3B, W, ACCESS
4E2C  6FE4     MOVWF k, BANKED
4E2E  6BE5     CLRF k, BANKED
4E30  51E2     MOVF divisor, W, BANKED
4E32  27E4     ADDWF k, F, BANKED
4E34  51E3     MOVF a, W, BANKED
4E36  23E5     ADDWFC k, F, BANKED
4E38  516A     MOVF _PFNf_blkcs, W, BANKED
4E3A  6FE6     MOVWF counter, BANKED
4E3C  6BE7     CLRF sign, BANKED
4E3E  51E4     MOVF k, W, BANKED
4E40  5DE6     SUBWF counter, W, BANKED
4E42  51E7     MOVF sign, W, BANKED
4E44  0A80     XORLW 0x80
4E46  6FE8     MOVWF quotient, BANKED
4E48  51E5     MOVF k, W, BANKED
4E4A  0A80     XORLW 0x80
4E4C  59E8     SUBWFB quotient, W, BANKED
4E4E  E203     BC 0x4E56
4E50  C06A     MOVFF _PFNf_blkcs, 0x3B
4E52  F03B     NOP
4E54  0012     RETURN 0
996:                               else rgl.srp += k;
4E56  0100     MOVLB 0x0
4E58  51EA     MOVF tim, W, BANKED
4E5A  263B     ADDWF 0x3B, F, ACCESS
997:                           }
4E5C  0012     RETURN 0
998:                           else
999:                           {
1000:                              if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
4E5E  C0EA     MOVFF tim, divisor
4E60  F0E2     NOP
4E62  0100     MOVLB 0x0
4E64  6BE3     CLRF a, BANKED
4E66  BFE2     BTFSC divisor, 7, BANKED
4E68  07E3     DECF a, F, BANKED
4E6A  503B     MOVF 0x3B, W, ACCESS
4E6C  6FE4     MOVWF k, BANKED
4E6E  6BE5     CLRF k, BANKED
4E70  51E2     MOVF divisor, W, BANKED
4E72  27E4     ADDWF k, F, BANKED
4E74  51E3     MOVF a, W, BANKED
4E76  23E5     ADDWFC k, F, BANKED
4E78  517E     MOVF _PFNf_obgCW, W, BANKED
4E7A  6FE6     MOVWF counter, BANKED
4E7C  6BE7     CLRF sign, BANKED
4E7E  51E4     MOVF k, W, BANKED
4E80  5DE6     SUBWF counter, W, BANKED
4E82  51E7     MOVF sign, W, BANKED
4E84  0A80     XORLW 0x80
4E86  6FE8     MOVWF quotient, BANKED
4E88  51E5     MOVF k, W, BANKED
4E8A  0A80     XORLW 0x80
4E8C  59E8     SUBWFB quotient, W, BANKED
4E8E  E203     BC 0x4E96
4E90  C07E     MOVFF _PFNf_obgCW, 0x3B
4E92  F03B     NOP
4E94  0012     RETURN 0
1001:                              else rgl.srp += k;
4E96  0100     MOVLB 0x0
4E98  51EA     MOVF tim, W, BANKED
4E9A  263B     ADDWF 0x3B, F, ACCESS
1002:                          }
1003:                          return;
1004:                      }
1005:                      else return;
1006:                  }
1007:                  else return;
1008:              }
4E9C  0012     RETURN 0
1009:              else //aktualnie faza 2
1010:              {
1011:                  q = 0;
4E9E  0101     MOVLB 0x1
4EA0  6B60     CLRF PWM, BANKED
1012:                  r = 0;
4EA2  6B61     CLRF 0x61, BANKED
1013:                  s = 0;
4EA4  0100     MOVLB 0x0
4EA6  6BC7     CLRF s, BANKED
1014:                  if(m < 255) m++; //licznik sekund dla spadku temp CO
4EA8  0101     MOVLB 0x1
4EAA  295D     INCF 0x5D, W, BANKED
4EAC  E002     BZ 0x4EB2
4EAE  2B5D     INCF 0x5D, F, BANKED
4EB0  D000     BRA 0x4EB2
1015:                  if(p < 255) p++; //licznik sekund dla spadku temp CO
4EB2  0101     MOVLB 0x1
4EB4  295F     INCF 0x5F, W, BANKED
4EB6  E002     BZ 0x4EBC
4EB8  2B5F     INCF 0x5F, F, BANKED
4EBA  D000     BRA 0x4EBC
1016:                  if(o < 255) o++; //licznik sekund dla narostu temp CO
4EBC  0101     MOVLB 0x1
4EBE  295E     INCF 0x5E, W, BANKED
4EC0  E002     BZ 0x4EC6
4EC2  2B5E     INCF 0x5E, F, BANKED
4EC4  D000     BRA 0x4EC6
1017:                  if(DtCW.DAD_CW > DtCW.AC_CW) //Tcw>Tnst ?
4EC6  0100     MOVLB 0x0
4EC8  51B6     MOVF 0xB6, W, BANKED
4ECA  5DB4     SUBWF 0xB4, W, BANKED
4ECC  E269     BC 0x4FA0
1018:                  {
1019:                      k = 0;
4ECE  6BEA     CLRF tim, BANKED
1020:                      if(Trosnie(0) && m >= 2)
4ED0  0E00     MOVLW 0x0
4ED2  ECE8     CALL 0xEFD0, 0
4ED4  F077     NOP
4ED6  E30C     BNC 0x4EF0
4ED8  0E01     MOVLW 0x1
4EDA  0101     MOVLB 0x1
4EDC  655D     CPFSGT 0x5D, BANKED
4EDE  D008     BRA 0x4EF0
1021:                      {
1022:                          p = 0;
4EE0  6B5F     CLRF 0x5F, BANKED
1023:                          o = 0;
4EE2  6B5E     CLRF 0x5E, BANKED
1024:                          l = 0;
4EE4  6B5C     CLRF 0x5C, BANKED
1025:                          m = 0;
4EE6  6B5D     CLRF 0x5D, BANKED
1026:                          k = 2; //3
4EE8  0E02     MOVLW 0x2
4EEA  0100     MOVLB 0x0
4EEC  6FEA     MOVWF tim, BANKED
1027:                      }
4EEE  D01D     BRA 0x4F2A
1028:                      else
1029:                          if(Twyzsza(1)) //gdy jest powyzej zakresu nastawa+1
4EF0  0E01     MOVLW 0x1
4EF2  ECC5     CALL 0xE78A, 0
4EF4  F073     NOP
4EF6  E316     BNC 0x4F24
1030:                      {
1031:                          if(Tstoi())
4EF8  ECAC     CALL 0xF358, 0
4EFA  F079     NOP
4EFC  E316     BNC 0x4F2A
1032:                          {
1033:                              if(l >= 2)
4EFE  0E01     MOVLW 0x1
4F00  0101     MOVLB 0x1
4F02  655C     CPFSGT 0x5C, BANKED
4F04  D00A     BRA 0x4F1A
1034:                              {
1035:                                  k = 1;
4F06  0100     MOVLB 0x0
4F08  6FEA     MOVWF tim, BANKED
1036:                                  if(Twyzsza(3)) k = 2;
4F0A  0E03     MOVLW 0x3
4F0C  ECC5     CALL 0xE78A, 0
4F0E  F073     NOP
4F10  E309     BNC 0x4F24
4F12  0E02     MOVLW 0x2
4F14  0100     MOVLB 0x0
4F16  6FEA     MOVWF tim, BANKED
4F18  D005     BRA 0x4F24
1037:                                  l = 0;
1038:                              }
1039:                              else
1040:                              {
1041:                                  k = 0;
4F1A  0100     MOVLB 0x0
4F1C  6BEA     CLRF tim, BANKED
1042:                                  l++;
4F1E  0101     MOVLB 0x1
4F20  2B5C     INCF 0x5C, F, BANKED
1043:                              }
1044:                          }
1045:                      }
4F22  D003     BRA 0x4F2A
1046:                      else l = 0;
4F24  0101     MOVLB 0x1
4F26  6B5C     CLRF 0x5C, BANKED
4F28  D000     BRA 0x4F2A
1047:                      if(PWM.MMAXCW > PWM.MGMOD)
4F2A  0100     MOVLB 0x0
4F2C  517E     MOVF _PFNf_obgCW, W, BANKED
4F2E  5D6A     SUBWF _PFNf_blkcs, W, BANKED
4F30  E206     BC 0x4F3E
1048:                      {
1049:                          if(rgl.srp > PWM.MGMOD) rgl.srp = PWM.MGMOD;
4F32  503B     MOVF 0x3B, W, ACCESS
4F34  5D6A     SUBWF _PFNf_blkcs, W, BANKED
4F36  E20A     BC 0x4F4C
4F38  C06A     MOVFF _PFNf_blkcs, 0x3B
4F3A  F03B     NOP
1050:                      }
4F3C  D007     BRA 0x4F4C
1051:                      else
1052:                      {
1053:                          if(rgl.srp > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
4F3E  503B     MOVF 0x3B, W, ACCESS
4F40  0100     MOVLB 0x0
4F42  5D7E     SUBWF _PFNf_obgCW, W, BANKED
4F44  E203     BC 0x4F4C
4F46  C07E     MOVFF _PFNf_obgCW, 0x3B
4F48  F03B     NOP
4F4A  D000     BRA 0x4F4C
1054:                      }
1055:                      if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
4F4C  0100     MOVLB 0x0
4F4E  5167     MOVF _PFNf_b_set_ncw, W, BANKED
4F50  6FE2     MOVWF divisor, BANKED
4F52  6BE3     CLRF a, BANKED
4F54  C0EA     MOVFF tim, k
4F56  F0E4     NOP
4F58  6BE5     CLRF k, BANKED
4F5A  BFE4     BTFSC k, 7, BANKED
4F5C  07E5     DECF k, F, BANKED
4F5E  1FE4     COMF k, F, BANKED
4F60  1FE5     COMF k, F, BANKED
4F62  4BE4     INFSNZ k, F, BANKED
4F64  2BE5     INCF k, F, BANKED
4F66  503B     MOVF 0x3B, W, ACCESS
4F68  6FE6     MOVWF counter, BANKED
4F6A  6BE7     CLRF sign, BANKED
4F6C  51E4     MOVF k, W, BANKED
4F6E  27E6     ADDWF counter, F, BANKED
4F70  51E5     MOVF k, W, BANKED
4F72  23E7     ADDWFC sign, F, BANKED
4F74  51E2     MOVF divisor, W, BANKED
4F76  5DE6     SUBWF counter, W, BANKED
4F78  51E7     MOVF sign, W, BANKED
4F7A  0A80     XORLW 0x80
4F7C  6FE8     MOVWF quotient, BANKED
4F7E  51E3     MOVF a, W, BANKED
4F80  0A80     XORLW 0x80
4F82  59E8     SUBWFB quotient, W, BANKED
4F84  E203     BC 0x4F8C
4F86  C067     MOVFF _PFNf_b_set_ncw, 0x3B
4F88  F03B     NOP
4F8A  D003     BRA 0x4F92
1056:                      else rgl.srp -= k;
4F8C  0100     MOVLB 0x0
4F8E  51EA     MOVF tim, W, BANKED
4F90  5E3B     SUBWF 0x3B, F, ACCESS
1057:          
1058:                      //if(rgl.srp>PWM.MMAXCW) rgl.srp=PWM.MMAXCW;
1059:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
4F92  503B     MOVF 0x3B, W, ACCESS
4F94  5C3C     SUBWF 0x3C, W, ACCESS
4F96  B0D8     BTFSC STATUS, 0, ACCESS
4F98  0012     RETURN 0
4F9A  C03B     MOVFF 0x3B, 0x3C
4F9C  F03C     NOP
1060:                      return;
1061:                  }
4F9E  0012     RETURN 0
1062:                  else //Tcw<Tnst
1063:                  {
1064:                      k = 0;
4FA0  0100     MOVLB 0x0
4FA2  6BEA     CLRF tim, BANKED
1065:                      if(Tmaleje(0) && m >= 2)
4FA4  0E00     MOVLW 0x0
4FA6  ECA9     CALL 0xE752, 0
4FA8  F073     NOP
4FAA  E30C     BNC 0x4FC4
4FAC  0E01     MOVLW 0x1
4FAE  0101     MOVLB 0x1
4FB0  655D     CPFSGT 0x5D, BANKED
4FB2  D008     BRA 0x4FC4
1066:                      {
1067:                          p = 0;
4FB4  6B5F     CLRF 0x5F, BANKED
1068:                          o = 0;
4FB6  6B5E     CLRF 0x5E, BANKED
1069:                          l = 0;
4FB8  6B5C     CLRF 0x5C, BANKED
1070:                          m = 0;
4FBA  6B5D     CLRF 0x5D, BANKED
1071:                          k = 5; //1
4FBC  0E05     MOVLW 0x5
4FBE  0100     MOVLB 0x0
4FC0  6FEA     MOVWF tim, BANKED
1072:                          //if(Tnizsza(0)) k=3;				//3
1073:                      }
4FC2  D016     BRA 0x4FF0
1074:                      else
1075:                          if(Tnizsza(1))
4FC4  0E01     MOVLW 0x1
4FC6  ECDA     CALL 0xEFB4, 0
4FC8  F077     NOP
4FCA  E30F     BNC 0x4FEA
1076:                      {
1077:                          if(Tstoi())
4FCC  ECAC     CALL 0xF358, 0
4FCE  F079     NOP
4FD0  E30F     BNC 0x4FF0
1078:                          {
1079:                              if(l >= 3)
4FD2  0E02     MOVLW 0x2
4FD4  0101     MOVLB 0x1
4FD6  655C     CPFSGT 0x5C, BANKED
4FD8  D003     BRA 0x4FE0
1080:                              {
1081:                                  k = 2;
4FDA  0100     MOVLB 0x0
4FDC  6FEA     MOVWF tim, BANKED
4FDE  D005     BRA 0x4FEA
1082:                                  l = 0;
1083:                              }
1084:                              else
1085:                              {
1086:                                  k = 0;
4FE0  0100     MOVLB 0x0
4FE2  6BEA     CLRF tim, BANKED
1087:                                  l++;
4FE4  0101     MOVLB 0x1
4FE6  2B5C     INCF 0x5C, F, BANKED
1088:                              }
1089:                          }
1090:                      }
4FE8  D003     BRA 0x4FF0
1091:                      else l = 0;
4FEA  0101     MOVLB 0x1
4FEC  6B5C     CLRF 0x5C, BANKED
4FEE  D000     BRA 0x4FF0
1092:                      if(PWM.MMAXCW > PWM.MGMOD)
4FF0  0100     MOVLB 0x0
4FF2  517E     MOVF _PFNf_obgCW, W, BANKED
4FF4  5D6A     SUBWF _PFNf_blkcs, W, BANKED
4FF6  E21F     BC 0x5036
1093:                      {
1094:                          if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
4FF8  C0EA     MOVFF tim, divisor
4FFA  F0E2     NOP
4FFC  6BE3     CLRF a, BANKED
4FFE  BFE2     BTFSC divisor, 7, BANKED
5000  07E3     DECF a, F, BANKED
5002  503B     MOVF 0x3B, W, ACCESS
5004  6FE4     MOVWF k, BANKED
5006  6BE5     CLRF k, BANKED
5008  51E2     MOVF divisor, W, BANKED
500A  27E4     ADDWF k, F, BANKED
500C  51E3     MOVF a, W, BANKED
500E  23E5     ADDWFC k, F, BANKED
5010  516A     MOVF _PFNf_blkcs, W, BANKED
5012  6FE6     MOVWF counter, BANKED
5014  6BE7     CLRF sign, BANKED
5016  51E4     MOVF k, W, BANKED
5018  5DE6     SUBWF counter, W, BANKED
501A  51E7     MOVF sign, W, BANKED
501C  0A80     XORLW 0x80
501E  6FE8     MOVWF quotient, BANKED
5020  51E5     MOVF k, W, BANKED
5022  0A80     XORLW 0x80
5024  59E8     SUBWFB quotient, W, BANKED
5026  E203     BC 0x502E
5028  C06A     MOVFF _PFNf_blkcs, 0x3B
502A  F03B     NOP
502C  D024     BRA 0x5076
1095:                          else rgl.srp += k;
502E  0100     MOVLB 0x0
5030  51EA     MOVF tim, W, BANKED
5032  263B     ADDWF 0x3B, F, ACCESS
1096:                      }
5034  D020     BRA 0x5076
1097:                      else
1098:                      {
1099:                          if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
5036  C0EA     MOVFF tim, divisor
5038  F0E2     NOP
503A  0100     MOVLB 0x0
503C  6BE3     CLRF a, BANKED
503E  BFE2     BTFSC divisor, 7, BANKED
5040  07E3     DECF a, F, BANKED
5042  503B     MOVF 0x3B, W, ACCESS
5044  6FE4     MOVWF k, BANKED
5046  6BE5     CLRF k, BANKED
5048  51E2     MOVF divisor, W, BANKED
504A  27E4     ADDWF k, F, BANKED
504C  51E3     MOVF a, W, BANKED
504E  23E5     ADDWFC k, F, BANKED
5050  517E     MOVF _PFNf_obgCW, W, BANKED
5052  6FE6     MOVWF counter, BANKED
5054  6BE7     CLRF sign, BANKED
5056  51E4     MOVF k, W, BANKED
5058  5DE6     SUBWF counter, W, BANKED
505A  51E7     MOVF sign, W, BANKED
505C  0A80     XORLW 0x80
505E  6FE8     MOVWF quotient, BANKED
5060  51E5     MOVF k, W, BANKED
5062  0A80     XORLW 0x80
5064  59E8     SUBWFB quotient, W, BANKED
5066  E203     BC 0x506E
5068  C07E     MOVFF _PFNf_obgCW, 0x3B
506A  F03B     NOP
506C  D004     BRA 0x5076
1100:                          else rgl.srp += k;
506E  0100     MOVLB 0x0
5070  51EA     MOVF tim, W, BANKED
5072  263B     ADDWF 0x3B, F, ACCESS
5074  D000     BRA 0x5076
1101:                      }
1102:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
5076  503B     MOVF 0x3B, W, ACCESS
5078  5C3C     SUBWF 0x3C, W, ACCESS
507A  B0D8     BTFSC STATUS, 0, ACCESS
507C  0012     RETURN 0
507E  C03B     MOVFF 0x3B, 0x3C
5080  F03C     NOP
1103:                      return;
1104:                  }
5082  0012     RETURN 0
1105:              }
1106:          }
5084  0012     RETURN 0
1107:          
1108:          //------------------------------------------------------------
1109:          //inkrementacja maksymalnej wartosci mocy na palniku
1110:          //wykonywane co krok czasowy
1111:          
1112:          void IncMaxCW(void)
1113:          {
1114:              unsigned char k;
1115:          
1116:              //decyzja o wejsciu w tryb INVMOD
1117:              //kontrola maksimum mocy dla fazy 2
1118:              if(rglf_fz) //faza 2 ?
A33E  A815     BTFSS rglf_btcw, 4, ACCESS
A340  D013     BRA 0xA368
1119:              {
1120:                  if(PWM.MMAXCW > PWM.MGMOD)
A342  0100     MOVLB 0x0
A344  517E     MOVF _PFNf_obgCW, W, BANKED
A346  5D6A     SUBWF _PFNf_blkcs, W, BANKED
A348  E207     BC 0xA358
1121:                  {
1122:                      if(rgl.xmod > PWM.MGMOD) rgl.xmod = PWM.MGMOD;
A34A  503C     MOVF 0x3C, W, ACCESS
A34C  5D6A     SUBWF _PFNf_blkcs, W, BANKED
A34E  B0D8     BTFSC STATUS, 0, ACCESS
A350  0012     RETURN 0
A352  C06A     MOVFF _PFNf_blkcs, 0x3C
A354  F03C     NOP
1123:                  }
A356  0012     RETURN 0
1124:                  else
1125:                  {
1126:                      if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
A358  503C     MOVF 0x3C, W, ACCESS
A35A  0100     MOVLB 0x0
A35C  5D7E     SUBWF _PFNf_obgCW, W, BANKED
A35E  B0D8     BTFSC STATUS, 0, ACCESS
A360  0012     RETURN 0
A362  C07E     MOVFF _PFNf_obgCW, 0x3C
A364  F03C     NOP
1127:                  }
1128:                  return;
A366  0012     RETURN 0
1129:              }
1130:              //jednorazowa modyfikacja wartosci srp ze wzgledu na szybkosc
1131:              //narostu temperatury
1132:              if(Trosnie(2) && !rglf_med_up) //(Tcw rosnie szybciej niz 3K/sek)?
A368  0E02     MOVLW 0x2
A36A  ECE8     CALL 0xEFD0, 0
A36C  F077     NOP
A36E  B0D8     BTFSC STATUS, 0, ACCESS
A370  BC15     BTFSC rglf_btcw, 6, ACCESS
A372  D03D     BRA 0xA3EE
1133:              {
1134:                  rglf_med_up = 1;
A374  8C15     BSF rglf_btcw, 6, ACCESS
1135:                  k = 5; //10
A376  0E05     MOVLW 0x5
A378  0100     MOVLB 0x0
A37A  6FE4     MOVWF k, BANKED
1136:                  if(PWM.MMAXCW > PWM.MGMOD)
A37C  0100     MOVLB 0x0
A37E  517E     MOVF _PFNf_obgCW, W, BANKED
A380  5D6A     SUBWF _PFNf_blkcs, W, BANKED
A382  E21A     BC 0xA3B8
1137:                  {
1138:                      if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
A384  51E4     MOVF k, W, BANKED
A386  C03B     MOVFF 0x3B, pco
A388  F0DF     NOP
A38A  6BE0     CLRF bdat, BANKED
A38C  27DF     ADDWF pco, F, BANKED
A38E  0E00     MOVLW 0x0
A390  23E0     ADDWFC bdat, F, BANKED
A392  516A     MOVF _PFNf_blkcs, W, BANKED
A394  6FE1     MOVWF GIE_BIT_VAL, BANKED
A396  6BE2     CLRF divisor, BANKED
A398  51DF     MOVF pco, W, BANKED
A39A  5DE1     SUBWF GIE_BIT_VAL, W, BANKED
A39C  51E2     MOVF divisor, W, BANKED
A39E  0A80     XORLW 0x80
A3A0  6FE3     MOVWF a, BANKED
A3A2  51E0     MOVF bdat, W, BANKED
A3A4  0A80     XORLW 0x80
A3A6  59E3     SUBWFB a, W, BANKED
A3A8  E203     BC 0xA3B0
A3AA  C06A     MOVFF _PFNf_blkcs, 0x3B
A3AC  F03B     NOP
A3AE  D01F     BRA 0xA3EE
1139:                      else rgl.srp += k;
A3B0  0100     MOVLB 0x0
A3B2  51E4     MOVF k, W, BANKED
A3B4  263B     ADDWF 0x3B, F, ACCESS
1140:                  }
A3B6  D01B     BRA 0xA3EE
1141:                  else
1142:                  {
1143:                      if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
A3B8  0100     MOVLB 0x0
A3BA  51E4     MOVF k, W, BANKED
A3BC  C03B     MOVFF 0x3B, pco
A3BE  F0DF     NOP
A3C0  6BE0     CLRF bdat, BANKED
A3C2  27DF     ADDWF pco, F, BANKED
A3C4  0E00     MOVLW 0x0
A3C6  23E0     ADDWFC bdat, F, BANKED
A3C8  517E     MOVF _PFNf_obgCW, W, BANKED
A3CA  6FE1     MOVWF GIE_BIT_VAL, BANKED
A3CC  6BE2     CLRF divisor, BANKED
A3CE  51DF     MOVF pco, W, BANKED
A3D0  5DE1     SUBWF GIE_BIT_VAL, W, BANKED
A3D2  51E2     MOVF divisor, W, BANKED
A3D4  0A80     XORLW 0x80
A3D6  6FE3     MOVWF a, BANKED
A3D8  51E0     MOVF bdat, W, BANKED
A3DA  0A80     XORLW 0x80
A3DC  59E3     SUBWFB a, W, BANKED
A3DE  E203     BC 0xA3E6
A3E0  C07E     MOVFF _PFNf_obgCW, 0x3B
A3E2  F03B     NOP
A3E4  D004     BRA 0xA3EE
1144:                      else rgl.srp += k;
A3E6  0100     MOVLB 0x0
A3E8  51E4     MOVF k, W, BANKED
A3EA  263B     ADDWF 0x3B, F, ACCESS
1145:                  }
A3EC  D000     BRA 0xA3EE
1146:              }
1147:              if(Trosnie(3) && !rglf_fast_up) //(Tcw rosnie szybciej niz 4K/sek)?
A3EE  0E03     MOVLW 0x3
A3F0  ECE8     CALL 0xEFD0, 0
A3F2  F077     NOP
A3F4  B0D8     BTFSC STATUS, 0, ACCESS
A3F6  B615     BTFSC rglf_btcw, 3, ACCESS
A3F8  D03D     BRA 0xA474
1148:              {
1149:                  rglf_fast_up = 1;
A3FA  8615     BSF rglf_btcw, 3, ACCESS
1150:                  k = 8; //12
A3FC  0E08     MOVLW 0x8
A3FE  0100     MOVLB 0x0
A400  6FE4     MOVWF k, BANKED
1151:                  if(PWM.MMAXCW > PWM.MGMOD)
A402  0100     MOVLB 0x0
A404  517E     MOVF _PFNf_obgCW, W, BANKED
A406  5D6A     SUBWF _PFNf_blkcs, W, BANKED
A408  E21A     BC 0xA43E
1152:                  {
1153:                      if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
A40A  51E4     MOVF k, W, BANKED
A40C  C03B     MOVFF 0x3B, pco
A40E  F0DF     NOP
A410  6BE0     CLRF bdat, BANKED
A412  27DF     ADDWF pco, F, BANKED
A414  0E00     MOVLW 0x0
A416  23E0     ADDWFC bdat, F, BANKED
A418  516A     MOVF _PFNf_blkcs, W, BANKED
A41A  6FE1     MOVWF GIE_BIT_VAL, BANKED
A41C  6BE2     CLRF divisor, BANKED
A41E  51DF     MOVF pco, W, BANKED
A420  5DE1     SUBWF GIE_BIT_VAL, W, BANKED
A422  51E2     MOVF divisor, W, BANKED
A424  0A80     XORLW 0x80
A426  6FE3     MOVWF a, BANKED
A428  51E0     MOVF bdat, W, BANKED
A42A  0A80     XORLW 0x80
A42C  59E3     SUBWFB a, W, BANKED
A42E  E203     BC 0xA436
A430  C06A     MOVFF _PFNf_blkcs, 0x3B
A432  F03B     NOP
A434  D01F     BRA 0xA474
1154:                      else rgl.srp += k;
A436  0100     MOVLB 0x0
A438  51E4     MOVF k, W, BANKED
A43A  263B     ADDWF 0x3B, F, ACCESS
1155:                  }
A43C  D01B     BRA 0xA474
1156:                  else
1157:                  {
1158:                      if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
A43E  0100     MOVLB 0x0
A440  51E4     MOVF k, W, BANKED
A442  C03B     MOVFF 0x3B, pco
A444  F0DF     NOP
A446  6BE0     CLRF bdat, BANKED
A448  27DF     ADDWF pco, F, BANKED
A44A  0E00     MOVLW 0x0
A44C  23E0     ADDWFC bdat, F, BANKED
A44E  517E     MOVF _PFNf_obgCW, W, BANKED
A450  6FE1     MOVWF GIE_BIT_VAL, BANKED
A452  6BE2     CLRF divisor, BANKED
A454  51DF     MOVF pco, W, BANKED
A456  5DE1     SUBWF GIE_BIT_VAL, W, BANKED
A458  51E2     MOVF divisor, W, BANKED
A45A  0A80     XORLW 0x80
A45C  6FE3     MOVWF a, BANKED
A45E  51E0     MOVF bdat, W, BANKED
A460  0A80     XORLW 0x80
A462  59E3     SUBWFB a, W, BANKED
A464  E203     BC 0xA46C
A466  C07E     MOVFF _PFNf_obgCW, 0x3B
A468  F03B     NOP
A46A  D004     BRA 0xA474
1159:                      else rgl.srp += k;
A46C  0100     MOVLB 0x0
A46E  51E4     MOVF k, W, BANKED
A470  263B     ADDWF 0x3B, F, ACCESS
A472  D000     BRA 0xA474
1160:                  }
1161:              }
1162:          
1163:              //kontrolowany narost mocy
1164:              if(rgl.tmp_pwm >= pwm_kwr)
A474  0101     MOVLB 0x1
A476  517A     MOVF _PFNf_newPCW, W, BANKED
A478  5C3D     SUBWF 0x3D, W, ACCESS
A47A  E308     BNC 0xA48C
1165:              {
1166:                  if(Trosnie(2)) return;
A47C  0E02     MOVLW 0x2
A47E  ECE8     CALL 0xEFD0, 0
A480  F077     NOP
A482  B0D8     BTFSC STATUS, 0, ACCESS
A484  0012     RETURN 0
A486  D008     BRA 0xA498
A488  0012     RETURN 0
1167:              }
A48A  D006     BRA 0xA498
1168:              else
1169:              {
1170:                  if(Trosnie(1)) return;
A48C  0E01     MOVLW 0x1
A48E  ECE8     CALL 0xEFD0, 0
A490  F077     NOP
A492  D7F7     BRA 0xA482
A494  0012     RETURN 0
A496  D000     BRA 0xA498
1171:              }
1172:              k = 5;
A498  0E05     MOVLW 0x5
A49A  0100     MOVLB 0x0
A49C  6FE4     MOVWF k, BANKED
1173:              if(rgl.xmod + k > _MG2_MOD) rgl.xmod = _MG2_MOD;
A49E  0100     MOVLB 0x0
A4A0  51E4     MOVF k, W, BANKED
A4A2  C03C     MOVFF 0x3C, pco
A4A4  F0DF     NOP
A4A6  6BE0     CLRF bdat, BANKED
A4A8  27DF     ADDWF pco, F, BANKED
A4AA  0E00     MOVLW 0x0
A4AC  23E0     ADDWFC bdat, F, BANKED
A4AE  BFE0     BTFSC bdat, 7, BANKED
A4B0  D008     BRA 0xA4C2
A4B2  51E0     MOVF bdat, W, BANKED
A4B4  E103     BNZ 0xA4BC
A4B6  0EF1     MOVLW 0xF1
A4B8  5DDF     SUBWF pco, W, BANKED
A4BA  E303     BNC 0xA4C2
A4BC  0EF0     MOVLW 0xF0
A4BE  6E3C     MOVWF 0x3C, ACCESS
A4C0  D003     BRA 0xA4C8
1174:              else rgl.xmod += k;
A4C2  0100     MOVLB 0x0
A4C4  51E4     MOVF k, W, BANKED
A4C6  263C     ADDWF 0x3C, F, ACCESS
1175:              if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
A4C8  503C     MOVF 0x3C, W, ACCESS
A4CA  0100     MOVLB 0x0
A4CC  5D7E     SUBWF _PFNf_obgCW, W, BANKED
A4CE  A0D8     BTFSS STATUS, 0, ACCESS
A4D0  C07E     MOVFF _PFNf_obgCW, 0x3C
A4D2  F03C     NOP
A4D4  0012     RETURN 0
1176:          }
A4D6  0012     RETURN 0
1177:          //------------------------------------------------------------
1178:          //reakcja superwizyjna
1179:          
1180:          /*void ModPrzCW(void)
1181:          {
1182:                  if(!rglf_nmod)					//nie jest w trybie nmod?
1183:                  {
1184:                          if(rglf_fz)					//faza 2 ?
1185:                          {
1186:                                  if(!Tmaleje(0))			//(Tcw nie maleje ?)
1187:                                  {
1188:                                          if(Twyzsza(4))		//Tcw-Tnst>4 ?
1189:                                          {
1190:                                                  if(rgl.srp-15<PWM.MDMOD) rgl.srp=PWM.MDMOD;
1191:                                                  else rgl.srp-=15;
1192:                                                  rglf_nmod=1;		//wejdz w tryb nmod
1193:                                                  return;
1194:                                          }
1195:                                          else return;
1196:                                  }
1197:                                  else return;
1198:                          }
1199:                          else return;
1200:                  }
1201:                  else							//jest w trybie nmod?
1202:                  {
1203:                          if(Tmaleje(0))				//(Tcw maleje ?)
1204:                                                  rglf_nmod=0;		//wyjdz z trybu nmod
1205:                  }
1206:          }*/
1207:          void ModPrzCW(void)
1208:          {
1209:              unsigned char p, maxmod;
1210:              signed int r;
1211:              static unsigned char timer1;
1212:          
1213:              //stabilizacja predkosci dochodzenia do temp. zadanej.
1214:              if(Tnizsza(0))//(!Tnizsza(20)&&Tnizsza(0)) //!Tnizsza(15)&&Tnizsza(0)
4072  0E00     MOVLW 0x0
4074  ECDA     CALL 0xEFB4, 0
4076  F077     NOP
4078  E201     BC 0x407C
407A  D1C7     BRA 0x440A
1215:              {
1216:                  if(PWM.MMAXCW < PWM.MGMOD) maxmod = PWM.MMAXCW; //wprowadzono ograniczenie mocy?
407C  0100     MOVLB 0x0
407E  516A     MOVF _PFNf_blkcs, W, BANKED
4080  5D7E     SUBWF _PFNf_obgCW, W, BANKED
4082  E203     BC 0x408A
4084  C07E     MOVFF _PFNf_obgCW, min
4086  F0F3     NOP
4088  D003     BRA 0x4090
1217:                  else maxmod = PWM.MGMOD;
408A  C06A     MOVFF _PFNf_blkcs, min
408C  F0F3     NOP
408E  D000     BRA 0x4090
1218:          
1219:          
1220:                  if(rgl.tmp_pwm >= pwm_center)
4090  0101     MOVLB 0x1
4092  5179     MOVF _PFNf_newPCO, W, BANKED
4094  5C3D     SUBWF 0x3D, W, ACCESS
4096  E201     BC 0x409A
4098  D0DF     BRA 0x4258
1221:                  {
1222:                      if(rgl.xmod <= maxmod) p = rgl.xmod;
409A  503C     MOVF 0x3C, W, ACCESS
409C  0100     MOVLB 0x0
409E  5DF3     SUBWF min, W, BANKED
40A0  E303     BNC 0x40A8
40A2  C03C     MOVFF 0x3C, ehi
40A4  F0F6     NOP
40A6  D005     BRA 0x40B2
1223:                      else
1224:                      {
1225:                          p = maxmod;
40A8  C0F3     MOVFF min, ehi
40AA  F0F6     NOP
1226:                          rgl.xmod = maxmod;
40AC  C0F3     MOVFF min, 0x3C
40AE  F03C     NOP
40B0  D000     BRA 0x40B2
1227:                      }
1228:                      if((DtCW.ddDCW > 6) && (tmr > 1)) //temperatura rosnie szybciej ni¿ 3 stop. na sek.?
40B2  0100     MOVLB 0x0
40B4  51B1     MOVF 0xB1, W, BANKED
40B6  0A80     XORLW 0x80
40B8  0F79     ADDLW 0x79
40BA  E344     BNC 0x4144
40BC  0E01     MOVLW 0x1
40BE  65CD     CPFSGT tmr, BANKED
40C0  D041     BRA 0x4144
1229:                      {
1230:                          tmr = 0;
40C2  6BCD     CLRF tmr, BANKED
1231:                          r = p - PWM.MDMOD;
40C4  0100     MOVLB 0x0
40C6  5167     MOVF _PFNf_b_set_ncw, W, BANKED
40C8  6FEC     MOVWF dt, BANKED
40CA  6BED     CLRF min, BANKED
40CC  1FEC     COMF dt, F, BANKED
40CE  1FED     COMF min, F, BANKED
40D0  4BEC     INFSNZ dt, F, BANKED
40D2  2BED     INCF min, F, BANKED
40D4  51F6     MOVF ehi, W, BANKED
40D6  25EC     ADDWF dt, W, BANKED
40D8  6FF4     MOVWF pco, BANKED
40DA  0E00     MOVLW 0x0
40DC  21ED     ADDWFC min, W, BANKED
40DE  6FF5     MOVWF max, BANKED
1232:                          if((p - (r / 3)) > PWM.MDMOD) p -= r / 3; //4
40E0  C0F4     MOVFF pco, k
40E2  F0E4     NOP
40E4  C0F5     MOVFF max, k
40E6  F0E5     NOP
40E8  0100     MOVLB 0x0
40EA  6BE7     CLRF sign, BANKED
40EC  0E03     MOVLW 0x3
40EE  6FE6     MOVWF counter, BANKED
40F0  EC09     CALL 0xC212, 0
40F2  F061     NOP
40F4  0100     MOVLB 0x0
40F6  1FE4     COMF k, F, BANKED
40F8  1FE5     COMF k, F, BANKED
40FA  4BE4     INFSNZ k, F, BANKED
40FC  2BE5     INCF k, F, BANKED
40FE  51F6     MOVF ehi, W, BANKED
4100  6FEC     MOVWF dt, BANKED
4102  6BED     CLRF min, BANKED
4104  51E4     MOVF k, W, BANKED
4106  27EC     ADDWF dt, F, BANKED
4108  51E5     MOVF k, W, BANKED
410A  23ED     ADDWFC min, F, BANKED
410C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
410E  6FEE     MOVWF dt, BANKED
4110  6BEF     CLRF 0xEF, BANKED
4112  51EC     MOVF dt, W, BANKED
4114  5DEE     SUBWF dt, W, BANKED
4116  51EF     MOVF 0xEF, W, BANKED
4118  0A80     XORLW 0x80
411A  6FF0     MOVWF p, BANKED
411C  51ED     MOVF min, W, BANKED
411E  0A80     XORLW 0x80
4120  59F0     SUBWFB p, W, BANKED
4122  E301     BNC 0x4126
4124  D16E     BRA 0x4402
4126  C0F4     MOVFF pco, k
4128  F0E4     NOP
412A  C0F5     MOVFF max, k
412C  F0E5     NOP
412E  6BE7     CLRF sign, BANKED
4130  0E03     MOVLW 0x3
4132  6FE6     MOVWF counter, BANKED
4134  EC09     CALL 0xC212, 0
4136  F061     NOP
4138  0100     MOVLB 0x0
413A  51E4     MOVF k, W, BANKED
413C  5FF6     SUBWF ehi, F, BANKED
1233:                          else p = PWM.MDMOD;
1234:                          rgl.xmod = p;
413E  C0F6     MOVFF ehi, 0x3C
4140  F03C     NOP
1235:                      }
4142  D163     BRA 0x440A
1236:                      else
1237:                          if((DtCW.ddDCW > 4) && (tmr > 1)) //temperatura rosnie szybciej ni¿ 3 stop. na sek.?
4144  0100     MOVLB 0x0
4146  51B1     MOVF 0xB1, W, BANKED
4148  0A80     XORLW 0x80
414A  0F7B     ADDLW 0x7B
414C  E33F     BNC 0x41CC
414E  0E01     MOVLW 0x1
4150  65CD     CPFSGT tmr, BANKED
4152  D03C     BRA 0x41CC
1238:                      {
1239:                          tmr = 0;
4154  6BCD     CLRF tmr, BANKED
1240:                          r = p - PWM.MDMOD;
4156  0100     MOVLB 0x0
4158  5167     MOVF _PFNf_b_set_ncw, W, BANKED
415A  6FEC     MOVWF dt, BANKED
415C  6BED     CLRF min, BANKED
415E  1FEC     COMF dt, F, BANKED
4160  1FED     COMF min, F, BANKED
4162  4BEC     INFSNZ dt, F, BANKED
4164  2BED     INCF min, F, BANKED
4166  51F6     MOVF ehi, W, BANKED
4168  25EC     ADDWF dt, W, BANKED
416A  6FF4     MOVWF pco, BANKED
416C  0E00     MOVLW 0x0
416E  21ED     ADDWFC min, W, BANKED
4170  6FF5     MOVWF max, BANKED
1241:                          if((p - (r / 4)) > PWM.MDMOD) p -= r / 4; //4
4172  C0F4     MOVFF pco, k
4174  F0E4     NOP
4176  C0F5     MOVFF max, k
4178  F0E5     NOP
417A  0100     MOVLB 0x0
417C  6BE7     CLRF sign, BANKED
417E  0E04     MOVLW 0x4
4180  6FE6     MOVWF counter, BANKED
4182  EC09     CALL 0xC212, 0
4184  F061     NOP
4186  0100     MOVLB 0x0
4188  1FE4     COMF k, F, BANKED
418A  1FE5     COMF k, F, BANKED
418C  4BE4     INFSNZ k, F, BANKED
418E  2BE5     INCF k, F, BANKED
4190  51F6     MOVF ehi, W, BANKED
4192  6FEC     MOVWF dt, BANKED
4194  6BED     CLRF min, BANKED
4196  51E4     MOVF k, W, BANKED
4198  27EC     ADDWF dt, F, BANKED
419A  51E5     MOVF k, W, BANKED
419C  23ED     ADDWFC min, F, BANKED
419E  5167     MOVF _PFNf_b_set_ncw, W, BANKED
41A0  6FEE     MOVWF dt, BANKED
41A2  6BEF     CLRF 0xEF, BANKED
41A4  51EC     MOVF dt, W, BANKED
41A6  5DEE     SUBWF dt, W, BANKED
41A8  51EF     MOVF 0xEF, W, BANKED
41AA  0A80     XORLW 0x80
41AC  6FF0     MOVWF p, BANKED
41AE  51ED     MOVF min, W, BANKED
41B0  0A80     XORLW 0x80
41B2  59F0     SUBWFB p, W, BANKED
41B4  E301     BNC 0x41B8
41B6  D125     BRA 0x4402
41B8  C0F4     MOVFF pco, k
41BA  F0E4     NOP
41BC  C0F5     MOVFF max, k
41BE  F0E5     NOP
41C0  6BE7     CLRF sign, BANKED
41C2  0E04     MOVLW 0x4
41C4  6FE6     MOVWF counter, BANKED
41C6  EC09     CALL 0xC212, 0
41C8  F061     NOP
41CA  D7B6     BRA 0x4138
1242:                          else p = PWM.MDMOD;
1243:                          rgl.xmod = p;
1244:                      }
1245:                      else
1246:                          if((DtCW.ddDCW > 3) && (tmr > 0)) //tmr2									//temperatura rosnie szybciej ni¿ 3 stop. na sek.?
41CC  0100     MOVLB 0x0
41CE  51B1     MOVF 0xB1, W, BANKED
41D0  0A80     XORLW 0x80
41D2  0F7C     ADDLW 0x7C
41D4  E201     BC 0x41D8
41D6  D119     BRA 0x440A
41D8  51CD     MOVF tmr, W, BANKED
41DA  E101     BNZ 0x41DE
41DC  D116     BRA 0x440A
1247:                      {
1248:                          tmr = 0;
41DE  6BCD     CLRF tmr, BANKED
1249:                          r = p - PWM.MDMOD;
41E0  0100     MOVLB 0x0
41E2  5167     MOVF _PFNf_b_set_ncw, W, BANKED
41E4  6FEC     MOVWF dt, BANKED
41E6  6BED     CLRF min, BANKED
41E8  1FEC     COMF dt, F, BANKED
41EA  1FED     COMF min, F, BANKED
41EC  4BEC     INFSNZ dt, F, BANKED
41EE  2BED     INCF min, F, BANKED
41F0  51F6     MOVF ehi, W, BANKED
41F2  25EC     ADDWF dt, W, BANKED
41F4  6FF4     MOVWF pco, BANKED
41F6  0E00     MOVLW 0x0
41F8  21ED     ADDWFC min, W, BANKED
41FA  6FF5     MOVWF max, BANKED
1250:                          if((p - (r / 14)) > PWM.MDMOD) p -= r / 14; //16
41FC  C0F4     MOVFF pco, k
41FE  F0E4     NOP
4200  C0F5     MOVFF max, k
4202  F0E5     NOP
4204  0100     MOVLB 0x0
4206  6BE7     CLRF sign, BANKED
4208  0E0E     MOVLW 0xE
420A  6FE6     MOVWF counter, BANKED
420C  EC09     CALL 0xC212, 0
420E  F061     NOP
4210  0100     MOVLB 0x0
4212  1FE4     COMF k, F, BANKED
4214  1FE5     COMF k, F, BANKED
4216  4BE4     INFSNZ k, F, BANKED
4218  2BE5     INCF k, F, BANKED
421A  51F6     MOVF ehi, W, BANKED
421C  6FEC     MOVWF dt, BANKED
421E  6BED     CLRF min, BANKED
4220  51E4     MOVF k, W, BANKED
4222  27EC     ADDWF dt, F, BANKED
4224  51E5     MOVF k, W, BANKED
4226  23ED     ADDWFC min, F, BANKED
4228  5167     MOVF _PFNf_b_set_ncw, W, BANKED
422A  6FEE     MOVWF dt, BANKED
422C  6BEF     CLRF 0xEF, BANKED
422E  51EC     MOVF dt, W, BANKED
4230  5DEE     SUBWF dt, W, BANKED
4232  51EF     MOVF 0xEF, W, BANKED
4234  0A80     XORLW 0x80
4236  6FF0     MOVWF p, BANKED
4238  51ED     MOVF min, W, BANKED
423A  0A80     XORLW 0x80
423C  59F0     SUBWFB p, W, BANKED
423E  E301     BNC 0x4242
4240  D0E0     BRA 0x4402
4242  C0F4     MOVFF pco, k
4244  F0E4     NOP
4246  C0F5     MOVFF max, k
4248  F0E5     NOP
424A  6BE7     CLRF sign, BANKED
424C  0E0E     MOVLW 0xE
424E  6FE6     MOVWF counter, BANKED
4250  EC09     CALL 0xC212, 0
4252  F061     NOP
4254  D771     BRA 0x4138
1251:                          else p = PWM.MDMOD;
1252:                          rgl.xmod = p;
1253:                      }
1254:                  }
4256  D0D9     BRA 0x440A
1255:                  else
1256:                  {
1257:                      if(rgl.xmod <= maxmod) p = rgl.xmod;
4258  503C     MOVF 0x3C, W, ACCESS
425A  0100     MOVLB 0x0
425C  5DF3     SUBWF min, W, BANKED
425E  E303     BNC 0x4266
4260  C03C     MOVFF 0x3C, ehi
4262  F0F6     NOP
4264  D005     BRA 0x4270
1258:                      else
1259:                      {
1260:                          p = maxmod;
4266  C0F3     MOVFF min, ehi
4268  F0F6     NOP
1261:                          rgl.xmod = maxmod;
426A  C0F3     MOVFF min, 0x3C
426C  F03C     NOP
426E  D000     BRA 0x4270
1262:                      }
1263:                      if((DtCW.ddDCW > 6) && (tmr > 1)) //temperatura rosnie szybciej ni¿ 3 stop. na sek.?
4270  0100     MOVLB 0x0
4272  51B1     MOVF 0xB1, W, BANKED
4274  0A80     XORLW 0x80
4276  0F79     ADDLW 0x79
4278  E33F     BNC 0x42F8
427A  0E01     MOVLW 0x1
427C  65CD     CPFSGT tmr, BANKED
427E  D03C     BRA 0x42F8
1264:                      {
1265:                          tmr = 0;
4280  6BCD     CLRF tmr, BANKED
1266:                          r = p - PWM.MDMOD;
4282  0100     MOVLB 0x0
4284  5167     MOVF _PFNf_b_set_ncw, W, BANKED
4286  6FEC     MOVWF dt, BANKED
4288  6BED     CLRF min, BANKED
428A  1FEC     COMF dt, F, BANKED
428C  1FED     COMF min, F, BANKED
428E  4BEC     INFSNZ dt, F, BANKED
4290  2BED     INCF min, F, BANKED
4292  51F6     MOVF ehi, W, BANKED
4294  25EC     ADDWF dt, W, BANKED
4296  6FF4     MOVWF pco, BANKED
4298  0E00     MOVLW 0x0
429A  21ED     ADDWFC min, W, BANKED
429C  6FF5     MOVWF max, BANKED
1267:                          if((p - (r / 2)) > PWM.MDMOD) p -= r / 2; //2
429E  C0F4     MOVFF pco, k
42A0  F0E4     NOP
42A2  C0F5     MOVFF max, k
42A4  F0E5     NOP
42A6  0100     MOVLB 0x0
42A8  6BE7     CLRF sign, BANKED
42AA  0E02     MOVLW 0x2
42AC  6FE6     MOVWF counter, BANKED
42AE  EC09     CALL 0xC212, 0
42B0  F061     NOP
42B2  0100     MOVLB 0x0
42B4  1FE4     COMF k, F, BANKED
42B6  1FE5     COMF k, F, BANKED
42B8  4BE4     INFSNZ k, F, BANKED
42BA  2BE5     INCF k, F, BANKED
42BC  51F6     MOVF ehi, W, BANKED
42BE  6FEC     MOVWF dt, BANKED
42C0  6BED     CLRF min, BANKED
42C2  51E4     MOVF k, W, BANKED
42C4  27EC     ADDWF dt, F, BANKED
42C6  51E5     MOVF k, W, BANKED
42C8  23ED     ADDWFC min, F, BANKED
42CA  5167     MOVF _PFNf_b_set_ncw, W, BANKED
42CC  6FEE     MOVWF dt, BANKED
42CE  6BEF     CLRF 0xEF, BANKED
42D0  51EC     MOVF dt, W, BANKED
42D2  5DEE     SUBWF dt, W, BANKED
42D4  51EF     MOVF 0xEF, W, BANKED
42D6  0A80     XORLW 0x80
42D8  6FF0     MOVWF p, BANKED
42DA  51ED     MOVF min, W, BANKED
42DC  0A80     XORLW 0x80
42DE  59F0     SUBWFB p, W, BANKED
42E0  E301     BNC 0x42E4
42E2  D08F     BRA 0x4402
42E4  C0F4     MOVFF pco, k
42E6  F0E4     NOP
42E8  C0F5     MOVFF max, k
42EA  F0E5     NOP
42EC  6BE7     CLRF sign, BANKED
42EE  0E02     MOVLW 0x2
42F0  6FE6     MOVWF counter, BANKED
42F2  EC09     CALL 0xC212, 0
42F4  F061     NOP
42F6  D720     BRA 0x4138
1268:                          else p = PWM.MDMOD;
1269:                          rgl.xmod = p;
1270:                      }
1271:                      else
1272:                          if((DtCW.ddDCW > 4) && (tmr > 1)) //temperatura rosnie szybciej ni¿ 3 stop. na sek.?
42F8  0100     MOVLB 0x0
42FA  51B1     MOVF 0xB1, W, BANKED
42FC  0A80     XORLW 0x80
42FE  0F7B     ADDLW 0x7B
4300  E33E     BNC 0x437E
4302  0E01     MOVLW 0x1
4304  65CD     CPFSGT tmr, BANKED
4306  D03B     BRA 0x437E
1273:                      {
1274:                          tmr = 0;
4308  6BCD     CLRF tmr, BANKED
1275:                          r = p - PWM.MDMOD;
430A  0100     MOVLB 0x0
430C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
430E  6FEC     MOVWF dt, BANKED
4310  6BED     CLRF min, BANKED
4312  1FEC     COMF dt, F, BANKED
4314  1FED     COMF min, F, BANKED
4316  4BEC     INFSNZ dt, F, BANKED
4318  2BED     INCF min, F, BANKED
431A  51F6     MOVF ehi, W, BANKED
431C  25EC     ADDWF dt, W, BANKED
431E  6FF4     MOVWF pco, BANKED
4320  0E00     MOVLW 0x0
4322  21ED     ADDWFC min, W, BANKED
4324  6FF5     MOVWF max, BANKED
1276:                          if((p - (r / 3)) > PWM.MDMOD) p -= r / 3; //3
4326  C0F4     MOVFF pco, k
4328  F0E4     NOP
432A  C0F5     MOVFF max, k
432C  F0E5     NOP
432E  0100     MOVLB 0x0
4330  6BE7     CLRF sign, BANKED
4332  0E03     MOVLW 0x3
4334  6FE6     MOVWF counter, BANKED
4336  EC09     CALL 0xC212, 0
4338  F061     NOP
433A  0100     MOVLB 0x0
433C  1FE4     COMF k, F, BANKED
433E  1FE5     COMF k, F, BANKED
4340  4BE4     INFSNZ k, F, BANKED
4342  2BE5     INCF k, F, BANKED
4344  51F6     MOVF ehi, W, BANKED
4346  6FEC     MOVWF dt, BANKED
4348  6BED     CLRF min, BANKED
434A  51E4     MOVF k, W, BANKED
434C  27EC     ADDWF dt, F, BANKED
434E  51E5     MOVF k, W, BANKED
4350  23ED     ADDWFC min, F, BANKED
4352  5167     MOVF _PFNf_b_set_ncw, W, BANKED
4354  6FEE     MOVWF dt, BANKED
4356  6BEF     CLRF 0xEF, BANKED
4358  51EC     MOVF dt, W, BANKED
435A  5DEE     SUBWF dt, W, BANKED
435C  51EF     MOVF 0xEF, W, BANKED
435E  0A80     XORLW 0x80
4360  6FF0     MOVWF p, BANKED
4362  51ED     MOVF min, W, BANKED
4364  0A80     XORLW 0x80
4366  59F0     SUBWFB p, W, BANKED
4368  E24C     BC 0x4402
436A  C0F4     MOVFF pco, k
436C  F0E4     NOP
436E  C0F5     MOVFF max, k
4370  F0E5     NOP
4372  6BE7     CLRF sign, BANKED
4374  0E03     MOVLW 0x3
4376  6FE6     MOVWF counter, BANKED
4378  EC09     CALL 0xC212, 0
437A  F061     NOP
437C  D6DD     BRA 0x4138
1277:                          else p = PWM.MDMOD;
1278:                          rgl.xmod = p;
1279:                      }
1280:                      else
1281:                          if((DtCW.ddDCW > 3) && (tmr > 0)) //tmr2									//temperatura rosnie szybciej ni¿ 3 stop. na sek.?
437E  0100     MOVLB 0x0
4380  51B1     MOVF 0xB1, W, BANKED
4382  0A80     XORLW 0x80
4384  0F7C     ADDLW 0x7C
4386  E341     BNC 0x440A
4388  51CD     MOVF tmr, W, BANKED
438A  E03F     BZ 0x440A
1282:                      {
1283:                          tmr = 0;
438C  6BCD     CLRF tmr, BANKED
1284:                          r = p - PWM.MDMOD;
438E  0100     MOVLB 0x0
4390  5167     MOVF _PFNf_b_set_ncw, W, BANKED
4392  6FEC     MOVWF dt, BANKED
4394  6BED     CLRF min, BANKED
4396  1FEC     COMF dt, F, BANKED
4398  1FED     COMF min, F, BANKED
439A  4BEC     INFSNZ dt, F, BANKED
439C  2BED     INCF min, F, BANKED
439E  51F6     MOVF ehi, W, BANKED
43A0  25EC     ADDWF dt, W, BANKED
43A2  6FF4     MOVWF pco, BANKED
43A4  0E00     MOVLW 0x0
43A6  21ED     ADDWFC min, W, BANKED
43A8  6FF5     MOVWF max, BANKED
1285:                          if((p - (r / 4)) > PWM.MDMOD) p -= r / 4; //8
43AA  C0F4     MOVFF pco, k
43AC  F0E4     NOP
43AE  C0F5     MOVFF max, k
43B0  F0E5     NOP
43B2  0100     MOVLB 0x0
43B4  6BE7     CLRF sign, BANKED
43B6  0E04     MOVLW 0x4
43B8  6FE6     MOVWF counter, BANKED
43BA  EC09     CALL 0xC212, 0
43BC  F061     NOP
43BE  0100     MOVLB 0x0
43C0  1FE4     COMF k, F, BANKED
43C2  1FE5     COMF k, F, BANKED
43C4  4BE4     INFSNZ k, F, BANKED
43C6  2BE5     INCF k, F, BANKED
43C8  51F6     MOVF ehi, W, BANKED
43CA  6FEC     MOVWF dt, BANKED
43CC  6BED     CLRF min, BANKED
43CE  51E4     MOVF k, W, BANKED
43D0  27EC     ADDWF dt, F, BANKED
43D2  51E5     MOVF k, W, BANKED
43D4  23ED     ADDWFC min, F, BANKED
43D6  5167     MOVF _PFNf_b_set_ncw, W, BANKED
43D8  6FEE     MOVWF dt, BANKED
43DA  6BEF     CLRF 0xEF, BANKED
43DC  51EC     MOVF dt, W, BANKED
43DE  5DEE     SUBWF dt, W, BANKED
43E0  51EF     MOVF 0xEF, W, BANKED
43E2  0A80     XORLW 0x80
43E4  6FF0     MOVWF p, BANKED
43E6  51ED     MOVF min, W, BANKED
43E8  0A80     XORLW 0x80
43EA  59F0     SUBWFB p, W, BANKED
43EC  E20A     BC 0x4402
43EE  C0F4     MOVFF pco, k
43F0  F0E4     NOP
43F2  C0F5     MOVFF max, k
43F4  F0E5     NOP
43F6  6BE7     CLRF sign, BANKED
43F8  0E04     MOVLW 0x4
43FA  6FE6     MOVWF counter, BANKED
43FC  EC09     CALL 0xC212, 0
43FE  F061     NOP
4400  D69B     BRA 0x4138
1286:                          else p = PWM.MDMOD;
4402  C067     MOVFF _PFNf_b_set_ncw, ehi
4404  F0F6     NOP
4406  D69B     BRA 0x413E
1287:                          rgl.xmod = p;
1288:                      }
1289:                  }
4408  D000     BRA 0x440A
1290:                  /*else
1291:                  if((DtCW.ddDCW<=0)&&(tmr2>1))
1292:                  {
1293:                          tmr2=0;
1294:                          r=p-PWM.MDMOD;
1295:                          if((p+(r/16))<maxmod) p+=r/16;
1296:                          else p=maxmod;
1297:                          rgl.xmod=p;
1298:                  }*/
1299:              }
1300:              if(!rglf_nmod) //nie jest w trybie nmod?
440A  BE15     BTFSC rglf_btcw, 7, ACCESS
440C  D036     BRA 0x447A
1301:              {
1302:                  if(rglf_fz) //faza 2 ?
440E  A815     BTFSS rglf_btcw, 4, ACCESS
4410  0012     RETURN 0
1303:                  {
1304:                      if(!Tmaleje(0)) //(Tcw nie maleje ?)
4412  0E00     MOVLW 0x0
4414  ECA9     CALL 0xE752, 0
4416  F073     NOP
4418  B0D8     BTFSC STATUS, 0, ACCESS
441A  0012     RETURN 0
1305:                      {
1306:                          if(Twyzsza(4)) //Tcw-Tnst>4 ?
441C  0E04     MOVLW 0x4
441E  ECC5     CALL 0xE78A, 0
4420  F073     NOP
4422  A0D8     BTFSS STATUS, 0, ACCESS
4424  0012     RETURN 0
1307:                          {
1308:                              if(rgl.tmp_pwm >= pwm_kwr)
4426  0101     MOVLB 0x1
4428  517A     MOVF _PFNf_newPCW, W, BANKED
442A  5C3D     SUBWF 0x3D, W, ACCESS
442C  E31D     BNC 0x4468
1309:                              {
1310:                                  if(rgl.srp - 5 < PWM.MDMOD) rgl.srp = PWM.MDMOD; //10
442E  0100     MOVLB 0x0
4430  5167     MOVF _PFNf_b_set_ncw, W, BANKED
4432  6FEC     MOVWF dt, BANKED
4434  6BED     CLRF min, BANKED
4436  0EFB     MOVLW 0xFB
4438  6FEE     MOVWF dt, BANKED
443A  69EF     SETF 0xEF, BANKED
443C  503B     MOVF 0x3B, W, ACCESS
443E  6FF0     MOVWF p, BANKED
4440  6BF1     CLRF m, BANKED
4442  51EE     MOVF dt, W, BANKED
4444  27F0     ADDWF p, F, BANKED
4446  51EF     MOVF 0xEF, W, BANKED
4448  23F1     ADDWFC m, F, BANKED
444A  51EC     MOVF dt, W, BANKED
444C  5DF0     SUBWF p, W, BANKED
444E  51F1     MOVF m, W, BANKED
4450  0A80     XORLW 0x80
4452  6FF2     MOVWF tid, BANKED
4454  51ED     MOVF min, W, BANKED
4456  0A80     XORLW 0x80
4458  59F2     SUBWFB tid, W, BANKED
445A  E203     BC 0x4462
445C  C067     MOVFF _PFNf_b_set_ncw, 0x3B
445E  F03B     NOP
4460  D003     BRA 0x4468
1311:                                  else rgl.srp -= 5;
4462  0E05     MOVLW 0x5
4464  5E3B     SUBWF 0x3B, F, ACCESS
4466  D000     BRA 0x4468
1312:                              }
1313:                              rglf_nmod = 1; //wejdz w tryb nmod
4468  8E15     BSF rglf_btcw, 7, ACCESS
1314:                              return;
446A  0012     RETURN 0
1315:                          }
446C  D00C     BRA 0x4486
1316:                          else return;
446E  0012     RETURN 0
1317:                      }
4470  D00A     BRA 0x4486
1318:                      else return;
4472  0012     RETURN 0
1319:                  }
4474  D008     BRA 0x4486
1320:                  else return;
4476  0012     RETURN 0
1321:              }
4478  D006     BRA 0x4486
1322:              else //jest w trybie nmod?
1323:              {
1324:                  if(Tmaleje(0)) //(Tcw maleje ?)
447A  0E00     MOVLW 0x0
447C  ECA9     CALL 0xE752, 0
447E  F073     NOP
4480  E302     BNC 0x4486
1325:                      rglf_nmod = 0; //wyjdz z trybu nmod
4482  9E15     BCF rglf_btcw, 7, ACCESS
4484  D000     BRA 0x4486
1326:              }
1327:              timer1++;
4486  0101     MOVLB 0x1
4488  2B63     INCF 0x63, F, BANKED
1328:          }
448A  0012     RETURN 0
1329:          
1330:          
1331:          
1332:          //------------------------------------------------------------
1333:          //Zabezpieczenie od przegrzania w obwodzie CO
1334:          
1335:          void PropCO(void)
1336:          {
1337:              if(!rglf_nmod) //nie jest w trybie nmod?
D6E0  BE15     BTFSC rglf_btcw, 7, ACCESS
D6E2  D02D     BRA 0xD73E
1338:              {
1339:                  if(!DtCOf_err_CO) //awaria czujnika temperatury CO?
D6E4  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
D6E6  D028     BRA 0xD738
1340:                  {
1341:                      if(rgl.x_f == 3) //=86C ?
D6E8  0E03     MOVLW 0x3
D6EA  1837     XORWF 0x37, W, ACCESS
D6EC  E107     BNZ 0xD6FC
1342:                      {
1343:                          if(rgl.tmp_pwm > PWM.MGMOD)
D6EE  503D     MOVF 0x3D, W, ACCESS
D6F0  0100     MOVLB 0x0
D6F2  5D6A     SUBWF _PFNf_blkcs, W, BANKED
D6F4  E221     BC 0xD738
1344:                              rgl.tmp_pwm = PWM.MGMOD; //=MGMOD
D6F6  C06A     MOVFF _PFNf_blkcs, 0x3D
D6F8  F03D     NOP
1345:                      }
D6FA  D01E     BRA 0xD738
1346:                      else
1347:                          if(rgl.x_f == 2) //=87C ?
D6FC  0E02     MOVLW 0x2
D6FE  1837     XORWF 0x37, W, ACCESS
D700  E107     BNZ 0xD710
1348:                      {
1349:                          if(rgl.tmp_pwm > PWM.PROP1)
D702  503D     MOVF 0x3D, W, ACCESS
D704  0100     MOVLB 0x0
D706  5D79     SUBWF _PFNf_newPCO, W, BANKED
D708  E217     BC 0xD738
1350:                              rgl.tmp_pwm = PWM.PROP1; //-1/7
D70A  C079     MOVFF _PFNf_newPCO, 0x3D
D70C  F03D     NOP
1351:                      }
D70E  D014     BRA 0xD738
1352:                      else
1353:                          if(rgl.x_f == 1) //=88C ?
D710  0437     DECF 0x37, W, ACCESS
D712  E107     BNZ 0xD722
1354:                      {
1355:                          if(rgl.tmp_pwm > PWM.PROP2)
D714  503D     MOVF 0x3D, W, ACCESS
D716  0100     MOVLB 0x0
D718  5D7A     SUBWF _PFNf_newPCW, W, BANKED
D71A  E20E     BC 0xD738
1356:                              rgl.tmp_pwm = PWM.PROP2; //-2/7
D71C  C07A     MOVFF _PFNf_newPCW, 0x3D
D71E  F03D     NOP
1357:                      }
D720  D00B     BRA 0xD738
1358:                      else
1359:                          if(rgl.x_f <= 0) //>=89C ?
D722  5037     MOVF 0x37, W, ACCESS
D724  0A80     XORLW 0x80
D726  0F7F     ADDLW 0x7F
D728  E207     BC 0xD738
1360:                      {
1361:                          if(rgl.tmp_pwm > PWM.PROP3)
D72A  503D     MOVF 0x3D, W, ACCESS
D72C  0100     MOVLB 0x0
D72E  5D7B     SUBWF _PFNf_newPFN, W, BANKED
D730  E203     BC 0xD738
1362:                              rgl.tmp_pwm = PWM.PROP3; //-3/7
D732  C07B     MOVFF _PFNf_newPFN, 0x3D
D734  F03D     NOP
1363:                      }
1364:                  }
D736  D000     BRA 0xD738
1365:                  WriteOPWM(rgl.tmp_pwm);
D738  503D     MOVF 0x3D, W, ACCESS
D73A  EF6C     GOTO 0xA4D8
D73C  F052     NOP
1366:              }
1367:              else WriteOPWM(PWM.MDMOD); //PWM.BufPWM=PWM.MDMOD;			//wymus minimum plomienia
D73E  0100     MOVLB 0x0
D740  5167     MOVF _PFNf_b_set_ncw, W, BANKED
D742  EF6C     GOTO 0xA4D8
D744  F052     NOP
1368:          }
D746  0012     RETURN 0
1369:          //************************************************************
1370:          //------------------------------------------------------------
1371:          //------------------------------------------------------------
1372:          //------wymiennik bitermiczny (maksiterm) - obieg CW
1373:          //------------------------------------------------------------
1374:          //------------------------------------------------------------
1375:          //------------------------------------------------------------
1376:          //parametry startowe dla CO
1377:          
1378:          void StartCO4(void)
1379:          {
1380:              //unsigned char k;
1381:          
1382:              if(rglf_btco || rglf_btcw) return; //praca w dowolnym obiegu CO?
E106  AE14     BTFSS UADtf_RData, 7, ACCESS
E108  B015     BTFSC rglf_btcw, 0, ACCESS
E10A  0012     RETURN 0
E10C  D001     BRA 0xE110
E10E  0012     RETURN 0
1383:              StartRTdS(_RTMOD);
E110  0E02     MOVLW 0x2
E112  ECA0     CALL 0xE540, 0
E114  F072     NOP
1384:              DtCO.dDCO = 0;
E116  0100     MOVLB 0x0
E118  6BD6     CLRF 0xD6, BANKED
1385:              DtCO.indCO = 0;
E11A  0100     MOVLB 0x0
E11C  6BD7     CLRF 0xD7, BANKED
1386:              DtCW.dDCW = 0;
E11E  0100     MOVLB 0x0
E120  6BB0     CLRF 0xB0, BANKED
1387:              DtCW.indCW = 0;
E122  0100     MOVLB 0x0
E124  6BB2     CLRF 0xB2, BANKED
1388:              rglf_fz = 0;
E126  9815     BCF rglf_btcw, 4, ACCESS
1389:              rglf_med_up = 0;
E128  9C15     BCF rglf_btcw, 6, ACCESS
1390:              rglf_fast_up = 0;
E12A  9615     BCF rglf_btcw, 3, ACCESS
1391:              //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
1392:              if(PWM.MMAXCO > PWM.FIRSTPB)
E12C  0100     MOVLB 0x0
E12E  517D     MOVF _PFNf_obgCO, W, BANKED
E130  5D78     SUBWF _PFNf_mod_ncw, W, BANKED
E132  E203     BC 0xE13A
1393:              {
1394:                  rgl.xmod = PWM.FIRSTPB;
E134  C078     MOVFF _PFNf_mod_ncw, 0x3C
E136  F03C     NOP
1395:              }
E138  D003     BRA 0xE140
1396:              else
1397:              {
1398:                  rgl.xmod = PWM.MMAXCO;
E13A  C07D     MOVFF _PFNf_obgCO, 0x3C
E13C  F03C     NOP
E13E  D000     BRA 0xE140
1399:              }
1400:              rgl.srp = 0;
E140  0E00     MOVLW 0x0
E142  6A3B     CLRF 0x3B, ACCESS
1401:              rgl.ytmp = 0;
E144  6A3A     CLRF 0x3A, ACCESS
1402:              rglf_nmod = 0; //wyjdz z trybu nmod
E146  9E15     BCF rglf_btcw, 7, ACCESS
1403:              rglf_del1s = 0;
E148  9215     BCF rglf_btcw, 1, ACCESS
1404:              rglf_inv_mod = 0;
E14A  9A15     BCF rglf_btcw, 5, ACCESS
1405:          }
E14C  0012     RETURN 0
1406:          //-------------------------------------------------------------
1407:          //parametry startowe dla CW
1408:          
1409:          void StartMCW4(void)
1410:          {
1411:              if(rglf_btco || rglf_btcw) return; //rozpoczecie pracy modulatora?
E6E2  AE14     BTFSS UADtf_RData, 7, ACCESS
E6E4  B015     BTFSC rglf_btcw, 0, ACCESS
E6E6  0012     RETURN 0
E6E8  D001     BRA 0xE6EC
E6EA  0012     RETURN 0
1412:              StartRTdS(_RTMOD);
E6EC  0E02     MOVLW 0x2
E6EE  ECA0     CALL 0xE540, 0
E6F0  F072     NOP
1413:              DtCO.dDCO = 0;
E6F2  0100     MOVLB 0x0
E6F4  6BD6     CLRF 0xD6, BANKED
1414:              DtCW.dDCW = 0;
E6F6  0100     MOVLB 0x0
E6F8  6BB0     CLRF 0xB0, BANKED
1415:              DtCO.indCO = 0;
E6FA  0100     MOVLB 0x0
E6FC  6BD7     CLRF 0xD7, BANKED
1416:              DtCW.indCW = 0;
E6FE  0100     MOVLB 0x0
E700  6BB2     CLRF 0xB2, BANKED
1417:              rglf_fz = 0;
E702  9815     BCF rglf_btcw, 4, ACCESS
1418:              rglf_med_up = 0;
E704  9C15     BCF rglf_btcw, 6, ACCESS
1419:              rglf_fast_up = 0;
E706  9615     BCF rglf_btcw, 3, ACCESS
1420:              //FirstPCW4();
1421:              rgl.srp = 0;
E708  6A3B     CLRF 0x3B, ACCESS
1422:              rgl.ytmp = 0;
E70A  0E00     MOVLW 0x0
E70C  6A3A     CLRF 0x3A, ACCESS
1423:              rglf_nmod = 0;
E70E  9E15     BCF rglf_btcw, 7, ACCESS
1424:              rglf_del1s = 0;
E710  9215     BCF rglf_btcw, 1, ACCESS
1425:              rglf_inv_mod = 0;
E712  9A15     BCF rglf_btcw, 5, ACCESS
1426:              rgl.xmod = PWM.MDMOD;
E714  C067     MOVFF _PFNf_b_set_ncw, 0x3C
E716  F03C     NOP
1427:          }
E718  0012     RETURN 0
1428:          //-------------------------------------------------------------
1429:          //pierwsze pobudzenie dla CW
1430:          
1431:          void FirstPCW4(void)
1432:          {
1433:              if(PWM.MMAXCW > PWM.MGMOD)
1434:              {
1435:                  if(DtCW.DCW > 0) rgl.xmod = PWM.MGMOD;
1436:                  else rgl.xmod = PWM.FIRSTPB;
1437:              }
1438:              else
1439:              {
1440:                  if(DtCW.DCW > 0) rgl.xmod = PWM.MMAXCW;
1441:                  else
1442:                  {
1443:                      if(PWM.MMAXCW > PWM.FIRSTPB) rgl.xmod = PWM.FIRSTPB;
1444:                      else rgl.xmod = PWM.MMAXCW;
1445:                  }
1446:              }
1447:          }
1448:          //-------------------------------------------------------------
1449:          //zeruj parametry modulatora po zmianie obiegu
1450:          
1451:          void ClrMod4(void)
1452:          {
1453:              rglf_fz = 0;
F0C6  9815     BCF rglf_btcw, 4, ACCESS
1454:              rglf_med_up = 0;
F0C8  9C15     BCF rglf_btcw, 6, ACCESS
1455:              rglf_fast_up = 0;
F0CA  9615     BCF rglf_btcw, 3, ACCESS
1456:              rgl.xmod = PWM.BufPWM;
F0CC  C060     MOVFF PWM, 0x3C
F0CE  F03C     NOP
1457:              rgl.srp = 0;
F0D0  0E00     MOVLW 0x0
F0D2  6A3B     CLRF 0x3B, ACCESS
1458:              rgl.ytmp = 0;
F0D4  6A3A     CLRF 0x3A, ACCESS
1459:              rglf_nmod = 0;
F0D6  9E15     BCF rglf_btcw, 7, ACCESS
1460:              rglf_del1s = 0;
F0D8  9215     BCF rglf_btcw, 1, ACCESS
1461:              rglf_inv_mod = 0;
F0DA  9A15     BCF rglf_btcw, 5, ACCESS
1462:          }
F0DC  0012     RETURN 0
1463:          //-------------------------------------------------------------
1464:          //zmien obieg na CW
1465:          
1466:          void ModToCW4(void)
1467:          {
1468:              rglf_btcw = 1;
F2E8  8015     BSF rglf_btcw, 0, ACCESS
1469:              if(rglf_btco)
F2EA  AE14     BTFSS UADtf_RData, 7, ACCESS
F2EC  0012     RETURN 0
1470:              {
1471:                  rglf_btco = 0;
F2EE  9E14     BCF UADtf_RData, 7, ACCESS
1472:                  ClrMod4();
F2F0  EF63     GOTO 0xF0C6
F2F2  F078     NOP
1473:              }
1474:          }
F2F4  0012     RETURN 0
1475:          //-------------------------------------------------------------
1476:          //zmien obieg na CO
1477:          
1478:          void ModToCO4(void)
1479:          {
1480:              rglf_btco = 1;
F312  8E14     BSF UADtf_RData, 7, ACCESS
1481:              if(rglf_btcw)
F314  A015     BTFSS rglf_btcw, 0, ACCESS
F316  0012     RETURN 0
1482:              {
1483:                  rglf_btcw = 0;
F318  9015     BCF rglf_btcw, 0, ACCESS
1484:                  ClrMod4();
F31A  EF63     GOTO 0xF0C6
F31C  F078     NOP
1485:              }
1486:          }
F31E  0012     RETURN 0
1487:          //-------------------------------------------------------------
1488:          //oblicza czas przez ktory temp=const
1489:          
1490:          void IncConstCOCW4(void)
1491:          {
1492:              if(Tstoi()) rgl.ytmp++;
F22C  ECAC     CALL 0xF358, 0
F22E  F079     NOP
F230  E302     BNC 0xF236
F232  2A3A     INCF 0x3A, F, ACCESS
F234  0012     RETURN 0
1493:              else rgl.ytmp = 0;
F236  0E00     MOVLW 0x0
F238  6E3A     MOVWF 0x3A, ACCESS
F23A  0C00     RETLW 0x0
1494:          }
F23C  0012     RETURN 0
1495:          //-------------------------------------------------------------
1496:          //wprowadzenie danych wejsciowych-CO
1497:          
1498:          void ReadDataCO4(void)
1499:          {
1500:              rgl.x_t = DtCO.DCO;
F39A  C0D5     MOVFF 0xD5, rgl
F39C  F036     NOP
1501:              rgl.x_dt = DtCO.dDCO;
F39E  C0D6     MOVFF 0xD6, 0x38
F3A0  F038     NOP
1502:          }
F3A2  0012     RETURN 0
1503:          //-------------------------------------------------------------
1504:          //wprowadzenie danych wejsciowych-CW
1505:          
1506:          void ReadDataCW4(void)
1507:          {
1508:              rgl.x_t = DtCW.DCW;
F1F6  C0AF     MOVFF _rglf_nmod, rgl
F1F8  F036     NOP
1509:              rgl.x_f = DtCO.DCO;
F1FA  C0D5     MOVFF 0xD5, 0x37
F1FC  F037     NOP
1510:              rgl.x_dt = DtCW.dDCW;
F1FE  C0B0     MOVFF 0xB0, 0x38
F200  F038     NOP
1511:              rgl.x_df = DtCO.dDCO;
F202  C0D6     MOVFF 0xD6, 0x39
F204  F039     NOP
1512:          }
F206  0012     RETURN 0
1513:          //-------------------------------------------------------------
1514:          //pierwsze przyblizenie
1515:          
1516:          void ModZgCW4(void)
1517:          {
1518:              signed long m;
1519:              unsigned char p;
1520:              static unsigned char pop;
1521:          
1522:              if(Tnizsza(10))
80BE  0E0A     MOVLW 0xA
80C0  ECDA     CALL 0xEFB4, 0
80C2  F077     NOP
80C4  E303     BNC 0x80CC
1523:              {
1524:                  pop = 0; //20wartosc poprawki na przesterowanie
80C6  0101     MOVLB 0x1
80C8  6B65     CLRF 0x65, BANKED
80CA  D000     BRA 0x80CC
1525:                  //FirstPCW4();
1526:              }
1527:              if(rglf_fz) //aktualnie faza 2?
80CC  A815     BTFSS rglf_btcw, 4, ACCESS
80CE  D00F     BRA 0x80EE
1528:              {
1529:                  if(Tnizsza(2)) //Tnizsza(2)przygotowanie do przejscia do fazy 1
80D0  0E02     MOVLW 0x2
80D2  ECDA     CALL 0xEFB4, 0
80D4  F077     NOP
80D6  A0D8     BTFSS STATUS, 0, ACCESS
80D8  0012     RETURN 0
1530:                  {
1531:                      rgl.xmod = PWM.BufPWM;
80DA  C060     MOVFF PWM, 0x3C
80DC  F03C     NOP
1532:                      rgl.srp = 0;
80DE  6A3B     CLRF 0x3B, ACCESS
1533:                      rgl.ytmp = 0;
80E0  6A3A     CLRF 0x3A, ACCESS
1534:                      rglf_del1s = 0;
80E2  9215     BCF rglf_btcw, 1, ACCESS
1535:                      pop = 0;
80E4  0101     MOVLB 0x1
80E6  6B65     CLRF 0x65, BANKED
1536:                  }
80E8  D002     BRA 0x80EE
1537:                  else return;
80EA  0012     RETURN 0
80EC  D000     BRA 0x80EE
1538:              }
1539:              if(!Tnizsza(1)) //warunek przejscia do fazy 2
80EE  0E01     MOVLW 0x1
80F0  ECDA     CALL 0xEFB4, 0
80F2  F077     NOP
80F4  E226     BC 0x8142
1540:              {
1541:                  rglf_fz = 1;
80F6  8815     BSF rglf_btcw, 4, ACCESS
1542:                  rglf_fast_up = 0;
80F8  9615     BCF rglf_btcw, 3, ACCESS
1543:                  rglf_med_up = 0;
80FA  9C15     BCF rglf_btcw, 6, ACCESS
1544:                  rgl.srp = PWM.BufPWM + pop;
80FC  0100     MOVLB 0x0
80FE  5160     MOVF PWM, W, BANKED
8100  0101     MOVLB 0x1
8102  2565     ADDWF 0x65, W, BANKED
8104  6E3B     MOVWF 0x3B, ACCESS
1545:                  rgl.xmod = PWM.BufPWM + pop;
8106  0100     MOVLB 0x0
8108  5160     MOVF PWM, W, BANKED
810A  0101     MOVLB 0x1
810C  2565     ADDWF 0x65, W, BANKED
810E  6E3C     MOVWF 0x3C, ACCESS
1546:                  pop = 0;
8110  0101     MOVLB 0x1
8112  6B65     CLRF 0x65, BANKED
1547:                  if(PWM.MMAXCW > PWM.MGMOD)
8114  0100     MOVLB 0x0
8116  517E     MOVF _PFNf_obgCW, W, BANKED
8118  5D6A     SUBWF _PFNf_blkcs, W, BANKED
811A  E209     BC 0x812E
1548:                  {
1549:                      if(rgl.xmod > PWM.MGMOD)
811C  503C     MOVF 0x3C, W, ACCESS
811E  5D6A     SUBWF _PFNf_blkcs, W, BANKED
8120  B0D8     BTFSC STATUS, 0, ACCESS
8122  0012     RETURN 0
1550:                      {
1551:                          rgl.srp = PWM.MGMOD;
8124  C06A     MOVFF _PFNf_blkcs, 0x3B
8126  F03B     NOP
1552:                          rgl.xmod = PWM.MGMOD;
8128  C06A     MOVFF _PFNf_blkcs, 0x3C
812A  F03C     NOP
1553:                      }
1554:                  }
812C  0012     RETURN 0
1555:                  else
1556:                  {
1557:                      if(rgl.xmod > PWM.MMAXCW)
812E  503C     MOVF 0x3C, W, ACCESS
8130  0100     MOVLB 0x0
8132  5D7E     SUBWF _PFNf_obgCW, W, BANKED
8134  B0D8     BTFSC STATUS, 0, ACCESS
8136  0012     RETURN 0
1558:                      {
1559:                          rgl.srp = PWM.MMAXCW;
8138  C07E     MOVFF _PFNf_obgCW, 0x3B
813A  F03B     NOP
1560:                          rgl.xmod = PWM.MMAXCW;
813C  C07E     MOVFF _PFNf_obgCW, 0x3C
813E  F03C     NOP
1561:                      }
1562:                  }
1563:                  return;
8140  0012     RETURN 0
1564:              }
1565:              if(rgl.xmod >= PWM.MDMOD) m = (rgl.xmod - PWM.MDMOD)*10;
8142  0100     MOVLB 0x0
8144  5167     MOVF _PFNf_b_set_ncw, W, BANKED
8146  5C3C     SUBWF 0x3C, W, ACCESS
8148  E31C     BNC 0x8182
814A  5167     MOVF _PFNf_b_set_ncw, W, BANKED
814C  6FEC     MOVWF dt, BANKED
814E  6BED     CLRF min, BANKED
8150  1FEC     COMF dt, F, BANKED
8152  1FED     COMF min, F, BANKED
8154  4BEC     INFSNZ dt, F, BANKED
8156  2BED     INCF min, F, BANKED
8158  503C     MOVF 0x3C, W, ACCESS
815A  25EC     ADDWF dt, W, BANKED
815C  6FDE     MOVWF __pcstackBANK0, BANKED
815E  0E00     MOVLW 0x0
8160  21ED     ADDWFC min, W, BANKED
8162  6FDF     MOVWF pco, BANKED
8164  6BE1     CLRF GIE_BIT_VAL, BANKED
8166  0E0A     MOVLW 0xA
8168  6FE0     MOVWF bdat, BANKED
816A  EC5B     CALL 0xECB6, 0
816C  F076     NOP
816E  C0DE     MOVFF __pcstackBANK0, tid
8170  F0F2     NOP
8172  C0DF     MOVFF pco, min
8174  F0F3     NOP
8176  0100     MOVLB 0x0
8178  0E00     MOVLW 0x0
817A  BFF3     BTFSC min, 7, BANKED
817C  0EFF     MOVLW 0xFF
817E  6FF4     MOVWF pco, BANKED
8180  D005     BRA 0x818C
1566:              else m = 0;
8182  0E00     MOVLW 0x0
8184  0100     MOVLB 0x0
8186  6BF2     CLRF tid, BANKED
8188  6BF3     CLRF min, BANKED
818A  6BF4     CLRF pco, BANKED
818C  6FF5     MOVWF max, BANKED
818E  D000     BRA 0x8190
1567:              m = m / (DtCW.MAD_CW - DtCW.DAD_CW); //DAD_CW-MAD_CW
8190  C0F2     MOVFF tid, __pcstackBANK0
8192  F0DE     NOP
8194  C0F3     MOVFF min, pco
8196  F0DF     NOP
8198  C0F4     MOVFF pco, bdat
819A  F0E0     NOP
819C  C0F5     MOVFF max, GIE_BIT_VAL
819E  F0E1     NOP
81A0  0100     MOVLB 0x0
81A2  51B6     MOVF 0xB6, W, BANKED
81A4  6FEC     MOVWF dt, BANKED
81A6  6BED     CLRF min, BANKED
81A8  1FEC     COMF dt, F, BANKED
81AA  1FED     COMF min, F, BANKED
81AC  4BEC     INFSNZ dt, F, BANKED
81AE  2BED     INCF min, F, BANKED
81B0  51B5     MOVF 0xB5, W, BANKED
81B2  6FEE     MOVWF dt, BANKED
81B4  6BEF     CLRF 0xEF, BANKED
81B6  51EC     MOVF dt, W, BANKED
81B8  27EE     ADDWF dt, F, BANKED
81BA  51ED     MOVF min, W, BANKED
81BC  23EF     ADDWFC 0xEF, F, BANKED
81BE  C0EE     MOVFF dt, divisor
81C0  F0E2     NOP
81C2  C0EF     MOVFF 0xEF, a
81C4  F0E3     NOP
81C6  0E00     MOVLW 0x0
81C8  BFE3     BTFSC a, 7, BANKED
81CA  0EFF     MOVLW 0xFF
81CC  6FE4     MOVWF k, BANKED
81CE  6FE5     MOVWF k, BANKED
81D0  ECF3     CALL 0xB3E6, 0
81D2  F059     NOP
81D4  C0DE     MOVFF __pcstackBANK0, tid
81D6  F0F2     NOP
81D8  C0DF     MOVFF pco, min
81DA  F0F3     NOP
81DC  C0E0     MOVFF bdat, pco
81DE  F0F4     NOP
81E0  C0E1     MOVFF GIE_BIT_VAL, max
81E2  F0F5     NOP
1568:              m = m * (DtCW.AC_CW - DtCW.DAD_CW); //DAD_CW-AC_CW
81E4  0100     MOVLB 0x0
81E6  51B6     MOVF 0xB6, W, BANKED
81E8  6FEC     MOVWF dt, BANKED
81EA  6BED     CLRF min, BANKED
81EC  1FEC     COMF dt, F, BANKED
81EE  1FED     COMF min, F, BANKED
81F0  4BEC     INFSNZ dt, F, BANKED
81F2  2BED     INCF min, F, BANKED
81F4  51B4     MOVF 0xB4, W, BANKED
81F6  6FEE     MOVWF dt, BANKED
81F8  6BEF     CLRF 0xEF, BANKED
81FA  51EC     MOVF dt, W, BANKED
81FC  27EE     ADDWF dt, F, BANKED
81FE  51ED     MOVF min, W, BANKED
8200  23EF     ADDWFC 0xEF, F, BANKED
8202  C0EE     MOVFF dt, __pcstackBANK0
8204  F0DE     NOP
8206  C0EF     MOVFF 0xEF, pco
8208  F0DF     NOP
820A  0E00     MOVLW 0x0
820C  BFDF     BTFSC pco, 7, BANKED
820E  0EFF     MOVLW 0xFF
8210  6FE0     MOVWF bdat, BANKED
8212  6FE1     MOVWF GIE_BIT_VAL, BANKED
8214  C0F2     MOVFF tid, divisor
8216  F0E2     NOP
8218  C0F3     MOVFF min, a
821A  F0E3     NOP
821C  C0F4     MOVFF pco, k
821E  F0E4     NOP
8220  C0F5     MOVFF max, k
8222  F0E5     NOP
8224  EC2F     CALL 0xDA5E, 0
8226  F06D     NOP
8228  C0DE     MOVFF __pcstackBANK0, tid
822A  F0F2     NOP
822C  C0DF     MOVFF pco, min
822E  F0F3     NOP
8230  C0E0     MOVFF bdat, pco
8232  F0F4     NOP
8234  C0E1     MOVFF GIE_BIT_VAL, max
8236  F0F5     NOP
1569:              if(m < 0) m = 0;
8238  0100     MOVLB 0x0
823A  AFF5     BTFSS max, 7, BANKED
823C  D005     BRA 0x8248
823E  6BF2     CLRF tid, BANKED
8240  6BF3     CLRF min, BANKED
8242  6BF4     CLRF pco, BANKED
8244  6BF5     CLRF max, BANKED
8246  D000     BRA 0x8248
1570:              m = m / 10 + PWM.MDMOD;
8248  C0F2     MOVFF tid, __pcstackBANK0
824A  F0DE     NOP
824C  C0F3     MOVFF min, pco
824E  F0DF     NOP
8250  C0F4     MOVFF pco, bdat
8252  F0E0     NOP
8254  C0F5     MOVFF max, GIE_BIT_VAL
8256  F0E1     NOP
8258  0E0A     MOVLW 0xA
825A  0100     MOVLB 0x0
825C  6FE2     MOVWF divisor, BANKED
825E  6BE3     CLRF a, BANKED
8260  6BE4     CLRF k, BANKED
8262  6BE5     CLRF k, BANKED
8264  ECF3     CALL 0xB3E6, 0
8266  F059     NOP
8268  0100     MOVLB 0x0
826A  5167     MOVF _PFNf_b_set_ncw, W, BANKED
826C  25DE     ADDWF __pcstackBANK0, W, BANKED
826E  6FF2     MOVWF tid, BANKED
8270  0E00     MOVLW 0x0
8272  21DF     ADDWFC pco, W, BANKED
8274  6FF3     MOVWF min, BANKED
8276  0E00     MOVLW 0x0
8278  21E0     ADDWFC bdat, W, BANKED
827A  6FF4     MOVWF pco, BANKED
827C  0E00     MOVLW 0x0
827E  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
8280  6FF5     MOVWF max, BANKED
1571:              if(m > 0xff) //przepelnienie
8282  0100     MOVLB 0x0
8284  BFF5     BTFSC max, 7, BANKED
8286  D009     BRA 0x829A
8288  51F5     MOVF max, W, BANKED
828A  11F4     IORWF pco, W, BANKED
828C  E102     BNZ 0x8292
828E  05F3     DECF min, W, BANKED
8290  E304     BNC 0x829A
1572:              {
1573:                  rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
8292  9815     BCF rglf_btcw, 4, ACCESS
1574:                  rgl.tmp_pwm = rgl.xmod;
8294  C03C     MOVFF 0x3C, 0x3D
8296  F03D     NOP
1575:                  return;
8298  0012     RETURN 0
1576:              }
1577:              if(rglf_fz && (rgl.xmod > m))
829A  A815     BTFSS rglf_btcw, 4, ACCESS
829C  D017     BRA 0x82CC
829E  C03C     MOVFF 0x3C, dt
82A0  F0EC     NOP
82A2  0100     MOVLB 0x0
82A4  6BED     CLRF min, BANKED
82A6  6BEE     CLRF dt, BANKED
82A8  6BEF     CLRF 0xEF, BANKED
82AA  51EC     MOVF dt, W, BANKED
82AC  5DF2     SUBWF tid, W, BANKED
82AE  51ED     MOVF min, W, BANKED
82B0  59F3     SUBWFB min, W, BANKED
82B2  51EE     MOVF dt, W, BANKED
82B4  59F4     SUBWFB pco, W, BANKED
82B6  51F5     MOVF max, W, BANKED
82B8  0A80     XORLW 0x80
82BA  6FF0     MOVWF p, BANKED
82BC  51EF     MOVF 0xEF, W, BANKED
82BE  0A80     XORLW 0x80
82C0  59F0     SUBWFB p, W, BANKED
82C2  E204     BC 0x82CC
1578:                  rgl.srp = (rgl.xmod - m); //przygotowanie lagodnego przejscia do fazy 1
82C4  51F2     MOVF tid, W, BANKED
82C6  0800     SUBLW 0x0
82C8  243C     ADDWF 0x3C, W, ACCESS
82CA  6E3B     MOVWF 0x3B, ACCESS
1579:              m += rgl.srp;
82CC  503B     MOVF 0x3B, W, ACCESS
82CE  0100     MOVLB 0x0
82D0  27F2     ADDWF tid, F, BANKED
82D2  0E00     MOVLW 0x0
82D4  23F3     ADDWFC min, F, BANKED
82D6  23F4     ADDWFC pco, F, BANKED
82D8  23F5     ADDWFC max, F, BANKED
1580:              if(m > rgl.xmod) p = rgl.xmod;
82DA  C03C     MOVFF 0x3C, dt
82DC  F0EC     NOP
82DE  6BED     CLRF min, BANKED
82E0  6BEE     CLRF dt, BANKED
82E2  6BEF     CLRF 0xEF, BANKED
82E4  51F2     MOVF tid, W, BANKED
82E6  5DEC     SUBWF dt, W, BANKED
82E8  51F3     MOVF min, W, BANKED
82EA  59ED     SUBWFB min, W, BANKED
82EC  51F4     MOVF pco, W, BANKED
82EE  59EE     SUBWFB dt, W, BANKED
82F0  51EF     MOVF 0xEF, W, BANKED
82F2  0A80     XORLW 0x80
82F4  6FF0     MOVWF p, BANKED
82F6  51F5     MOVF max, W, BANKED
82F8  0A80     XORLW 0x80
82FA  59F0     SUBWFB p, W, BANKED
82FC  E203     BC 0x8304
82FE  C03C     MOVFF 0x3C, m
8300  F0F1     NOP
8302  D002     BRA 0x8308
1581:              else p = m;
8304  C0F2     MOVFF tid, m
8306  F0F1     NOP
1582:              rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
8308  9815     BCF rglf_btcw, 4, ACCESS
1583:              rgl.tmp_pwm = p;
830A  C0F1     MOVFF m, 0x3D
830C  F03D     NOP
1584:          }
830E  0012     RETURN 0
1585:          //-------------------------------------------------------------
1586:          //drugie przyblizenie (tylko dla fazy 2)
1587:          
1588:          void ModDkCW4(void)
1589:          {
1590:              signed long m;
1591:              signed char ada;
1592:              unsigned char k, p;
1593:          
1594:              if(!rglf_fz) return; //wyjscie jesli aktualnie faza 1
BC60  A815     BTFSS rglf_btcw, 4, ACCESS
BC62  0012     RETURN 0
BC64  D001     BRA 0xBC68
BC66  0012     RETURN 0
1595:              ada = DtCW.AC_CW - DtCW.DAD_CW;
BC68  0100     MOVLB 0x0
BC6A  51B6     MOVF 0xB6, W, BANKED
BC6C  0800     SUBLW 0x0
BC6E  25B4     ADDWF 0xB4, W, BANKED
BC70  6FEB     MOVWF pop, BANKED
1596:              k = 2; //9
BC72  0E02     MOVLW 0x2
BC74  0100     MOVLB 0x0
BC76  6FE9     MOVWF p, BANKED
1597:              if(ada < 0) k = 1; //8
BC78  0100     MOVLB 0x0
BC7A  AFEB     BTFSS pop, 7, BANKED
BC7C  D003     BRA 0xBC84
BC7E  0E01     MOVLW 0x1
BC80  6FE9     MOVWF p, BANKED
BC82  D000     BRA 0xBC84
1598:              m = rgl.srp + k*ada;
BC84  C0E9     MOVFF p, __pcstackBANK0
BC86  F0DE     NOP
BC88  0100     MOVLB 0x0
BC8A  6BDF     CLRF pco, BANKED
BC8C  51EB     MOVF pop, W, BANKED
BC8E  6FE0     MOVWF bdat, BANKED
BC90  6BE1     CLRF GIE_BIT_VAL, BANKED
BC92  BFE0     BTFSC bdat, 7, BANKED
BC94  07E1     DECF GIE_BIT_VAL, F, BANKED
BC96  EC5B     CALL 0xECB6, 0
BC98  F076     NOP
BC9A  503B     MOVF 0x3B, W, ACCESS
BC9C  0100     MOVLB 0x0
BC9E  6FE4     MOVWF k, BANKED
BCA0  6BE5     CLRF k, BANKED
BCA2  51DE     MOVF __pcstackBANK0, W, BANKED
BCA4  27E4     ADDWF k, F, BANKED
BCA6  51DF     MOVF pco, W, BANKED
BCA8  23E5     ADDWFC k, F, BANKED
BCAA  C0E4     MOVFF k, dt
BCAC  F0EC     NOP
BCAE  C0E5     MOVFF k, min
BCB0  F0ED     NOP
BCB2  0E00     MOVLW 0x0
BCB4  BFED     BTFSC min, 7, BANKED
BCB6  0EFF     MOVLW 0xFF
BCB8  6FEE     MOVWF dt, BANKED
BCBA  6FEF     MOVWF 0xEF, BANKED
1599:              if(m > rgl.xmod) p = rgl.xmod;
BCBC  C03C     MOVFF 0x3C, k
BCBE  F0E4     NOP
BCC0  0100     MOVLB 0x0
BCC2  6BE5     CLRF k, BANKED
BCC4  6BE6     CLRF counter, BANKED
BCC6  6BE7     CLRF sign, BANKED
BCC8  51EC     MOVF dt, W, BANKED
BCCA  5DE4     SUBWF k, W, BANKED
BCCC  51ED     MOVF min, W, BANKED
BCCE  59E5     SUBWFB k, W, BANKED
BCD0  51EE     MOVF dt, W, BANKED
BCD2  59E6     SUBWFB counter, W, BANKED
BCD4  51E7     MOVF sign, W, BANKED
BCD6  0A80     XORLW 0x80
BCD8  6FE8     MOVWF quotient, BANKED
BCDA  51EF     MOVF 0xEF, W, BANKED
BCDC  0A80     XORLW 0x80
BCDE  59E8     SUBWFB quotient, W, BANKED
BCE0  E203     BC 0xBCE8
BCE2  C03C     MOVFF 0x3C, tim
BCE4  F0EA     NOP
BCE6  D019     BRA 0xBD1A
1600:              else
1601:                  if(m < PWM.MDMOD) p = PWM.MDMOD;
BCE8  C067     MOVFF _PFNf_b_set_ncw, k
BCEA  F0E4     NOP
BCEC  0100     MOVLB 0x0
BCEE  6BE5     CLRF k, BANKED
BCF0  6BE6     CLRF counter, BANKED
BCF2  6BE7     CLRF sign, BANKED
BCF4  51E4     MOVF k, W, BANKED
BCF6  5DEC     SUBWF dt, W, BANKED
BCF8  51E5     MOVF k, W, BANKED
BCFA  59ED     SUBWFB min, W, BANKED
BCFC  51E6     MOVF counter, W, BANKED
BCFE  59EE     SUBWFB dt, W, BANKED
BD00  51EF     MOVF 0xEF, W, BANKED
BD02  0A80     XORLW 0x80
BD04  6FE8     MOVWF quotient, BANKED
BD06  51E7     MOVF sign, W, BANKED
BD08  0A80     XORLW 0x80
BD0A  59E8     SUBWFB quotient, W, BANKED
BD0C  E203     BC 0xBD14
BD0E  C067     MOVFF _PFNf_b_set_ncw, tim
BD10  F0EA     NOP
BD12  D003     BRA 0xBD1A
1602:              else p = m;
BD14  C0EC     MOVFF dt, tim
BD16  F0EA     NOP
BD18  D000     BRA 0xBD1A
1603:              rgl.tmp_pwm = p;
BD1A  C0EA     MOVFF tim, 0x3D
BD1C  F03D     NOP
1604:          }
BD1E  0012     RETURN 0
1605:          //-------------------------------------------------------------
1606:          //trzecie przyblizenie
1607:          //nowa wartosc punktu rownowagi srp.
1608:          //wykonywane co krok czasowy
1609:          
1610:          void ModPruCW4(void)
1611:          {
1612:              static unsigned char l, m, o, p, q, r, s;
1613:              unsigned char tmp;
1614:              signed char k;
1615:              if(!rglf_fz) //aktualnie faza 1?
6AC8  B815     BTFSC rglf_btcw, 4, ACCESS
6ACA  D09B     BRA 0x6C02
1616:              {
1617:                  l = 0;
6ACC  0101     MOVLB 0x1
6ACE  6B55     CLRF 0x55, BANKED
1618:                  m = 0;
6AD0  6B56     CLRF 0x56, BANKED
1619:                  o = 0;
6AD2  6B57     CLRF 0x57, BANKED
1620:                  p = 0;
6AD4  6B58     CLRF 0x58, BANKED
1621:                  if(q < 255) q++; //licznik sekund
6AD6  0101     MOVLB 0x1
6AD8  2959     INCF 0x59, W, BANKED
6ADA  E002     BZ 0x6AE0
6ADC  2B59     INCF 0x59, F, BANKED
6ADE  D000     BRA 0x6AE0
1622:                  if(s < 255) s++; //licznik sekund
6AE0  0101     MOVLB 0x1
6AE2  295B     INCF 0x5B, W, BANKED
6AE4  E002     BZ 0x6AEA
6AE6  2B5B     INCF 0x5B, F, BANKED
6AE8  D000     BRA 0x6AEA
1623:                  if(DtCWf_newPCW) s = 0; //zmieniono nastawe?
6AEA  AC04     BTFSS DtCWf_err_CW, 6, ACCESS
6AEC  D003     BRA 0x6AF4
6AEE  0101     MOVLB 0x1
6AF0  6B5B     CLRF 0x5B, BANKED
6AF2  D000     BRA 0x6AF4
1624:                  if(Tnizsza(0)) //Tcw<Tnst?
6AF4  0E00     MOVLW 0x0
6AF6  ECDA     CALL 0xEFB4, 0
6AF8  F077     NOP
6AFA  A0D8     BTFSS STATUS, 0, ACCESS
6AFC  0012     RETURN 0
1625:                  {
1626:                      if(!Tnizsza(10)) //Tnst-Tcw<=10 ?
6AFE  0E0A     MOVLW 0xA
6B00  ECDA     CALL 0xEFB4, 0
6B02  F077     NOP
6B04  B0D8     BTFSC STATUS, 0, ACCESS
6B06  0012     RETURN 0
1627:                      {
1628:                          k = 0;
6B08  0E00     MOVLW 0x0
6B0A  0100     MOVLB 0x0
6B0C  6FEA     MOVWF tim, BANKED
1629:                          if(Tstoi() && s >= 1)
6B0E  ECAC     CALL 0xF358, 0
6B10  F079     NOP
6B12  E308     BNC 0x6B24
6B14  0101     MOVLB 0x1
6B16  515B     MOVF 0x5B, W, BANKED
6B18  E005     BZ 0x6B24
1630:                          {
1631:                              s = 0;
6B1A  6B5B     CLRF 0x5B, BANKED
1632:                              k = 2;
6B1C  0E02     MOVLW 0x2
6B1E  0100     MOVLB 0x0
6B20  6FEA     MOVWF tim, BANKED
6B22  D000     BRA 0x6B24
1633:                          }
1634:                          if(Trosnie(1) && s >= 1) //szybki narost temperatury
6B24  0E01     MOVLW 0x1
6B26  ECE8     CALL 0xEFD0, 0
6B28  F077     NOP
6B2A  E30F     BNC 0x6B4A
6B2C  0101     MOVLB 0x1
6B2E  515B     MOVF 0x5B, W, BANKED
6B30  E00C     BZ 0x6B4A
1635:                          {
1636:                              s = 0;
6B32  6B5B     CLRF 0x5B, BANKED
1637:                              k = 10;
6B34  0E0A     MOVLW 0xA
6B36  0100     MOVLB 0x0
6B38  6FEA     MOVWF tim, BANKED
1638:                              if(Trosnie(2)) k = 8; //b.szybki narost temperatury?
6B3A  0E02     MOVLW 0x2
6B3C  ECE8     CALL 0xEFD0, 0
6B3E  F077     NOP
6B40  E306     BNC 0x6B4E
6B42  0E08     MOVLW 0x8
6B44  0100     MOVLB 0x0
6B46  6FEA     MOVWF tim, BANKED
1639:                          }
6B48  D002     BRA 0x6B4E
1640:                          else
1641:                              rgl.ytmp = 0;
6B4A  6A3A     CLRF 0x3A, ACCESS
6B4C  D000     BRA 0x6B4E
1642:                          if(PWM.BufPWM > rgl.xmod) return;
6B4E  0100     MOVLB 0x0
6B50  5160     MOVF PWM, W, BANKED
6B52  5C3C     SUBWF 0x3C, W, ACCESS
6B54  A0D8     BTFSS STATUS, 0, ACCESS
6B56  0012     RETURN 0
6B58  D001     BRA 0x6B5C
6B5A  0012     RETURN 0
1643:                          tmp = rgl.xmod - PWM.BufPWM;
6B5C  0100     MOVLB 0x0
6B5E  5160     MOVF PWM, W, BANKED
6B60  0800     SUBLW 0x0
6B62  243C     ADDWF 0x3C, W, ACCESS
6B64  6FE9     MOVWF p, BANKED
1644:                          if(k > tmp) k = tmp;
6B66  51E9     MOVF p, W, BANKED
6B68  80D8     BSF STATUS, 0, ACCESS
6B6A  84D8     BSF STATUS, 2, ACCESS
6B6C  AFEA     BTFSS tim, 7, BANKED
6B6E  5DEA     SUBWF tim, W, BANKED
6B70  A0D8     BTFSS STATUS, 0, ACCESS
6B72  84D8     BSF STATUS, 2, ACCESS
6B74  E003     BZ 0x6B7C
6B76  C0E9     MOVFF p, tim
6B78  F0EA     NOP
6B7A  D000     BRA 0x6B7C
1645:                          if(PWM.MMAXCW > PWM.MGMOD)
6B7C  0100     MOVLB 0x0
6B7E  517E     MOVF _PFNf_obgCW, W, BANKED
6B80  5D6A     SUBWF _PFNf_blkcs, W, BANKED
6B82  E21F     BC 0x6BC2
1646:                          {
1647:                              if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
6B84  C0EA     MOVFF tim, divisor
6B86  F0E2     NOP
6B88  6BE3     CLRF a, BANKED
6B8A  BFE2     BTFSC divisor, 7, BANKED
6B8C  07E3     DECF a, F, BANKED
6B8E  503B     MOVF 0x3B, W, ACCESS
6B90  6FE4     MOVWF k, BANKED
6B92  6BE5     CLRF k, BANKED
6B94  51E2     MOVF divisor, W, BANKED
6B96  27E4     ADDWF k, F, BANKED
6B98  51E3     MOVF a, W, BANKED
6B9A  23E5     ADDWFC k, F, BANKED
6B9C  516A     MOVF _PFNf_blkcs, W, BANKED
6B9E  6FE6     MOVWF counter, BANKED
6BA0  6BE7     CLRF sign, BANKED
6BA2  51E4     MOVF k, W, BANKED
6BA4  5DE6     SUBWF counter, W, BANKED
6BA6  51E7     MOVF sign, W, BANKED
6BA8  0A80     XORLW 0x80
6BAA  6FE8     MOVWF quotient, BANKED
6BAC  51E5     MOVF k, W, BANKED
6BAE  0A80     XORLW 0x80
6BB0  59E8     SUBWFB quotient, W, BANKED
6BB2  E203     BC 0x6BBA
6BB4  C06A     MOVFF _PFNf_blkcs, 0x3B
6BB6  F03B     NOP
6BB8  0012     RETURN 0
1648:                              else rgl.srp += k;
6BBA  0100     MOVLB 0x0
6BBC  51EA     MOVF tim, W, BANKED
6BBE  263B     ADDWF 0x3B, F, ACCESS
1649:                          }
6BC0  0012     RETURN 0
1650:                          else
1651:                          {
1652:                              if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
6BC2  C0EA     MOVFF tim, divisor
6BC4  F0E2     NOP
6BC6  0100     MOVLB 0x0
6BC8  6BE3     CLRF a, BANKED
6BCA  BFE2     BTFSC divisor, 7, BANKED
6BCC  07E3     DECF a, F, BANKED
6BCE  503B     MOVF 0x3B, W, ACCESS
6BD0  6FE4     MOVWF k, BANKED
6BD2  6BE5     CLRF k, BANKED
6BD4  51E2     MOVF divisor, W, BANKED
6BD6  27E4     ADDWF k, F, BANKED
6BD8  51E3     MOVF a, W, BANKED
6BDA  23E5     ADDWFC k, F, BANKED
6BDC  517E     MOVF _PFNf_obgCW, W, BANKED
6BDE  6FE6     MOVWF counter, BANKED
6BE0  6BE7     CLRF sign, BANKED
6BE2  51E4     MOVF k, W, BANKED
6BE4  5DE6     SUBWF counter, W, BANKED
6BE6  51E7     MOVF sign, W, BANKED
6BE8  0A80     XORLW 0x80
6BEA  6FE8     MOVWF quotient, BANKED
6BEC  51E5     MOVF k, W, BANKED
6BEE  0A80     XORLW 0x80
6BF0  59E8     SUBWFB quotient, W, BANKED
6BF2  E203     BC 0x6BFA
6BF4  C07E     MOVFF _PFNf_obgCW, 0x3B
6BF6  F03B     NOP
6BF8  0012     RETURN 0
1653:                              else rgl.srp += k;
6BFA  0100     MOVLB 0x0
6BFC  51EA     MOVF tim, W, BANKED
6BFE  263B     ADDWF 0x3B, F, ACCESS
1654:                          }
1655:                          return;
1656:                      }
1657:                      else return;
1658:                  }
1659:                  else return;
1660:              }
6C00  0012     RETURN 0
1661:              else //aktualnie faza 2
1662:              {
1663:                  q = 0;
6C02  0101     MOVLB 0x1
6C04  6B59     CLRF 0x59, BANKED
1664:                  r = 0;
6C06  6B5A     CLRF 0x5A, BANKED
1665:                  s = 0;
6C08  6B5B     CLRF 0x5B, BANKED
1666:                  if(m < 255) m++; //licznik sekund dla spadku temp CO
6C0A  0101     MOVLB 0x1
6C0C  2956     INCF 0x56, W, BANKED
6C0E  E002     BZ 0x6C14
6C10  2B56     INCF 0x56, F, BANKED
6C12  D000     BRA 0x6C14
1667:                  if(p < 255) p++; //licznik sekund dla spadku temp CO
6C14  0101     MOVLB 0x1
6C16  2958     INCF 0x58, W, BANKED
6C18  E002     BZ 0x6C1E
6C1A  2B58     INCF 0x58, F, BANKED
6C1C  D000     BRA 0x6C1E
1668:                  if(o < 255) o++; //licznik sekund dla narostu temp CO
6C1E  0101     MOVLB 0x1
6C20  2957     INCF 0x57, W, BANKED
6C22  E002     BZ 0x6C28
6C24  2B57     INCF 0x57, F, BANKED
6C26  D000     BRA 0x6C28
1669:                  if(DtCW.DAD_CW > DtCW.AC_CW) //Tcw>Tnst ?
6C28  0100     MOVLB 0x0
6C2A  51B6     MOVF 0xB6, W, BANKED
6C2C  5DB4     SUBWF 0xB4, W, BANKED
6C2E  E25F     BC 0x6CEE
1670:                  {
1671:                      k = 0;
6C30  6BEA     CLRF tim, BANKED
1672:                      if(Trosnie(0) && m >= 2)
6C32  0E00     MOVLW 0x0
6C34  ECE8     CALL 0xEFD0, 0
6C36  F077     NOP
6C38  E30C     BNC 0x6C52
6C3A  0E01     MOVLW 0x1
6C3C  0101     MOVLB 0x1
6C3E  6556     CPFSGT 0x56, BANKED
6C40  D008     BRA 0x6C52
1673:                      {
1674:                          p = 0;
6C42  6B58     CLRF 0x58, BANKED
1675:                          o = 0;
6C44  6B57     CLRF 0x57, BANKED
1676:                          l = 0;
6C46  6B55     CLRF 0x55, BANKED
1677:                          m = 0;
6C48  6B56     CLRF 0x56, BANKED
1678:                          k = 2; //3
6C4A  0E02     MOVLW 0x2
6C4C  0100     MOVLB 0x0
6C4E  6FEA     MOVWF tim, BANKED
1679:                      }
6C50  D01D     BRA 0x6C8C
1680:                      else
1681:                          if(Twyzsza(1)) //gdy jest powyzej zakresu nastawa+1
6C52  0E01     MOVLW 0x1
6C54  ECC5     CALL 0xE78A, 0
6C56  F073     NOP
6C58  E316     BNC 0x6C86
1682:                      {
1683:                          if(Tstoi())
6C5A  ECAC     CALL 0xF358, 0
6C5C  F079     NOP
6C5E  E316     BNC 0x6C8C
1684:                          {
1685:                              if(l >= 2)
6C60  0E01     MOVLW 0x1
6C62  0101     MOVLB 0x1
6C64  6555     CPFSGT 0x55, BANKED
6C66  D00A     BRA 0x6C7C
1686:                              {
1687:                                  k = 1;
6C68  0100     MOVLB 0x0
6C6A  6FEA     MOVWF tim, BANKED
1688:                                  if(Twyzsza(3)) k = 2;
6C6C  0E03     MOVLW 0x3
6C6E  ECC5     CALL 0xE78A, 0
6C70  F073     NOP
6C72  E309     BNC 0x6C86
6C74  0E02     MOVLW 0x2
6C76  0100     MOVLB 0x0
6C78  6FEA     MOVWF tim, BANKED
6C7A  D005     BRA 0x6C86
1689:                                  l = 0;
1690:                              }
1691:                              else
1692:                              {
1693:                                  k = 0;
6C7C  0100     MOVLB 0x0
6C7E  6BEA     CLRF tim, BANKED
1694:                                  l++;
6C80  0101     MOVLB 0x1
6C82  2B55     INCF 0x55, F, BANKED
1695:                              }
1696:                          }
1697:                      }
6C84  D003     BRA 0x6C8C
1698:                      else l = 0;
6C86  0101     MOVLB 0x1
6C88  6B55     CLRF 0x55, BANKED
6C8A  D000     BRA 0x6C8C
1699:                      if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
6C8C  0100     MOVLB 0x0
6C8E  5167     MOVF _PFNf_b_set_ncw, W, BANKED
6C90  6FE2     MOVWF divisor, BANKED
6C92  6BE3     CLRF a, BANKED
6C94  C0EA     MOVFF tim, k
6C96  F0E4     NOP
6C98  6BE5     CLRF k, BANKED
6C9A  BFE4     BTFSC k, 7, BANKED
6C9C  07E5     DECF k, F, BANKED
6C9E  1FE4     COMF k, F, BANKED
6CA0  1FE5     COMF k, F, BANKED
6CA2  4BE4     INFSNZ k, F, BANKED
6CA4  2BE5     INCF k, F, BANKED
6CA6  503B     MOVF 0x3B, W, ACCESS
6CA8  6FE6     MOVWF counter, BANKED
6CAA  6BE7     CLRF sign, BANKED
6CAC  51E4     MOVF k, W, BANKED
6CAE  27E6     ADDWF counter, F, BANKED
6CB0  51E5     MOVF k, W, BANKED
6CB2  23E7     ADDWFC sign, F, BANKED
6CB4  51E2     MOVF divisor, W, BANKED
6CB6  5DE6     SUBWF counter, W, BANKED
6CB8  51E7     MOVF sign, W, BANKED
6CBA  0A80     XORLW 0x80
6CBC  6FE8     MOVWF quotient, BANKED
6CBE  51E3     MOVF a, W, BANKED
6CC0  0A80     XORLW 0x80
6CC2  59E8     SUBWFB quotient, W, BANKED
6CC4  E203     BC 0x6CCC
6CC6  C067     MOVFF _PFNf_b_set_ncw, 0x3B
6CC8  F03B     NOP
6CCA  D003     BRA 0x6CD2
1700:                      else rgl.srp -= k;
6CCC  0100     MOVLB 0x0
6CCE  51EA     MOVF tim, W, BANKED
6CD0  5E3B     SUBWF 0x3B, F, ACCESS
1701:                      if(rgl.srp > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
6CD2  503B     MOVF 0x3B, W, ACCESS
6CD4  0100     MOVLB 0x0
6CD6  5D7E     SUBWF _PFNf_obgCW, W, BANKED
6CD8  E203     BC 0x6CE0
6CDA  C07E     MOVFF _PFNf_obgCW, 0x3B
6CDC  F03B     NOP
6CDE  D000     BRA 0x6CE0
1702:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
6CE0  503B     MOVF 0x3B, W, ACCESS
6CE2  5C3C     SUBWF 0x3C, W, ACCESS
6CE4  B0D8     BTFSC STATUS, 0, ACCESS
6CE6  0012     RETURN 0
6CE8  C03B     MOVFF 0x3B, 0x3C
6CEA  F03C     NOP
1703:                      return;
1704:                  }
6CEC  0012     RETURN 0
1705:                  else //Tcw<Tnst
1706:                  {
1707:                      k = 0;
6CEE  0100     MOVLB 0x0
6CF0  6BEA     CLRF tim, BANKED
1708:                      if(Tmaleje(0) && m >= 2)
6CF2  0E00     MOVLW 0x0
6CF4  ECA9     CALL 0xE752, 0
6CF6  F073     NOP
6CF8  E30B     BNC 0x6D10
6CFA  0E01     MOVLW 0x1
6CFC  0101     MOVLB 0x1
6CFE  6556     CPFSGT 0x56, BANKED
6D00  D007     BRA 0x6D10
1709:                      {
1710:                          p = 0;
6D02  6B58     CLRF 0x58, BANKED
1711:                          o = 0;
6D04  6B57     CLRF 0x57, BANKED
1712:                          l = 0;
6D06  6B55     CLRF 0x55, BANKED
1713:                          m = 0;
6D08  6B56     CLRF 0x56, BANKED
1714:                          k = 1; //2
6D0A  0100     MOVLB 0x0
6D0C  6FEA     MOVWF tim, BANKED
1715:                          //if(Tnizsza(0)) k=3;				//3
1716:                      }
6D0E  D016     BRA 0x6D3C
1717:                      else
1718:                          if(Tnizsza(1))
6D10  0E01     MOVLW 0x1
6D12  ECDA     CALL 0xEFB4, 0
6D14  F077     NOP
6D16  E30F     BNC 0x6D36
1719:                      {
1720:                          if(Tstoi())
6D18  ECAC     CALL 0xF358, 0
6D1A  F079     NOP
6D1C  E30F     BNC 0x6D3C
1721:                          {
1722:                              if(l >= 3)
6D1E  0E02     MOVLW 0x2
6D20  0101     MOVLB 0x1
6D22  6555     CPFSGT 0x55, BANKED
6D24  D003     BRA 0x6D2C
1723:                              {
1724:                                  k = 2;
6D26  0100     MOVLB 0x0
6D28  6FEA     MOVWF tim, BANKED
6D2A  D005     BRA 0x6D36
1725:                                  l = 0;
1726:                              }
1727:                              else
1728:                              {
1729:                                  k = 0;
6D2C  0100     MOVLB 0x0
6D2E  6BEA     CLRF tim, BANKED
1730:                                  l++;
6D30  0101     MOVLB 0x1
6D32  2B55     INCF 0x55, F, BANKED
1731:                              }
1732:                          }
1733:                      }
6D34  D003     BRA 0x6D3C
1734:                      else l = 0;
6D36  0101     MOVLB 0x1
6D38  6B55     CLRF 0x55, BANKED
6D3A  D000     BRA 0x6D3C
1735:                      if(PWM.MMAXCW > PWM.MGMOD)
6D3C  0100     MOVLB 0x0
6D3E  517E     MOVF _PFNf_obgCW, W, BANKED
6D40  5D6A     SUBWF _PFNf_blkcs, W, BANKED
6D42  E21F     BC 0x6D82
1736:                      {
1737:                          if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
6D44  C0EA     MOVFF tim, divisor
6D46  F0E2     NOP
6D48  6BE3     CLRF a, BANKED
6D4A  BFE2     BTFSC divisor, 7, BANKED
6D4C  07E3     DECF a, F, BANKED
6D4E  503B     MOVF 0x3B, W, ACCESS
6D50  6FE4     MOVWF k, BANKED
6D52  6BE5     CLRF k, BANKED
6D54  51E2     MOVF divisor, W, BANKED
6D56  27E4     ADDWF k, F, BANKED
6D58  51E3     MOVF a, W, BANKED
6D5A  23E5     ADDWFC k, F, BANKED
6D5C  516A     MOVF _PFNf_blkcs, W, BANKED
6D5E  6FE6     MOVWF counter, BANKED
6D60  6BE7     CLRF sign, BANKED
6D62  51E4     MOVF k, W, BANKED
6D64  5DE6     SUBWF counter, W, BANKED
6D66  51E7     MOVF sign, W, BANKED
6D68  0A80     XORLW 0x80
6D6A  6FE8     MOVWF quotient, BANKED
6D6C  51E5     MOVF k, W, BANKED
6D6E  0A80     XORLW 0x80
6D70  59E8     SUBWFB quotient, W, BANKED
6D72  E203     BC 0x6D7A
6D74  C06A     MOVFF _PFNf_blkcs, 0x3B
6D76  F03B     NOP
6D78  D024     BRA 0x6DC2
1738:                          else rgl.srp += k;
6D7A  0100     MOVLB 0x0
6D7C  51EA     MOVF tim, W, BANKED
6D7E  263B     ADDWF 0x3B, F, ACCESS
1739:                      }
6D80  D020     BRA 0x6DC2
1740:                      else
1741:                      {
1742:                          if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
6D82  C0EA     MOVFF tim, divisor
6D84  F0E2     NOP
6D86  0100     MOVLB 0x0
6D88  6BE3     CLRF a, BANKED
6D8A  BFE2     BTFSC divisor, 7, BANKED
6D8C  07E3     DECF a, F, BANKED
6D8E  503B     MOVF 0x3B, W, ACCESS
6D90  6FE4     MOVWF k, BANKED
6D92  6BE5     CLRF k, BANKED
6D94  51E2     MOVF divisor, W, BANKED
6D96  27E4     ADDWF k, F, BANKED
6D98  51E3     MOVF a, W, BANKED
6D9A  23E5     ADDWFC k, F, BANKED
6D9C  517E     MOVF _PFNf_obgCW, W, BANKED
6D9E  6FE6     MOVWF counter, BANKED
6DA0  6BE7     CLRF sign, BANKED
6DA2  51E4     MOVF k, W, BANKED
6DA4  5DE6     SUBWF counter, W, BANKED
6DA6  51E7     MOVF sign, W, BANKED
6DA8  0A80     XORLW 0x80
6DAA  6FE8     MOVWF quotient, BANKED
6DAC  51E5     MOVF k, W, BANKED
6DAE  0A80     XORLW 0x80
6DB0  59E8     SUBWFB quotient, W, BANKED
6DB2  E203     BC 0x6DBA
6DB4  C07E     MOVFF _PFNf_obgCW, 0x3B
6DB6  F03B     NOP
6DB8  D004     BRA 0x6DC2
1743:                          else rgl.srp += k;
6DBA  0100     MOVLB 0x0
6DBC  51EA     MOVF tim, W, BANKED
6DBE  263B     ADDWF 0x3B, F, ACCESS
6DC0  D000     BRA 0x6DC2
1744:                      }
1745:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
6DC2  503B     MOVF 0x3B, W, ACCESS
6DC4  5C3C     SUBWF 0x3C, W, ACCESS
6DC6  B0D8     BTFSC STATUS, 0, ACCESS
6DC8  0012     RETURN 0
6DCA  C03B     MOVFF 0x3B, 0x3C
6DCC  F03C     NOP
1746:                      return;
1747:                  }
6DCE  0012     RETURN 0
1748:              }
1749:          }
6DD0  0012     RETURN 0
1750:          //------------------------------------------------------------
1751:          //inkrementacja maksymalnej wartosci mocy na palniku
1752:          //wykonywane co krok czasowy
1753:          
1754:          void IncMaxCW4(void)
1755:          {
1756:              unsigned char k;
1757:          
1758:              //kontrola maksimum mocy dla fazy 2
1759:              if(rglf_fz) //faza 2 ?
D0DE  A815     BTFSS rglf_btcw, 4, ACCESS
D0E0  D013     BRA 0xD108
1760:              {
1761:                  if(PWM.MMAXCW > PWM.MGMOD)
D0E2  0100     MOVLB 0x0
D0E4  517E     MOVF _PFNf_obgCW, W, BANKED
D0E6  5D6A     SUBWF _PFNf_blkcs, W, BANKED
D0E8  E207     BC 0xD0F8
1762:                  {
1763:                      if(rgl.xmod > PWM.MGMOD) rgl.xmod = PWM.MGMOD;
D0EA  503C     MOVF 0x3C, W, ACCESS
D0EC  5D6A     SUBWF _PFNf_blkcs, W, BANKED
D0EE  B0D8     BTFSC STATUS, 0, ACCESS
D0F0  0012     RETURN 0
D0F2  C06A     MOVFF _PFNf_blkcs, 0x3C
D0F4  F03C     NOP
1764:                  }
D0F6  0012     RETURN 0
1765:                  else
1766:                  {
1767:                      if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
D0F8  503C     MOVF 0x3C, W, ACCESS
D0FA  0100     MOVLB 0x0
D0FC  5D7E     SUBWF _PFNf_obgCW, W, BANKED
D0FE  B0D8     BTFSC STATUS, 0, ACCESS
D100  0012     RETURN 0
D102  C07E     MOVFF _PFNf_obgCW, 0x3C
D104  F03C     NOP
1768:                  }
1769:                  return;
D106  0012     RETURN 0
1770:              }
1771:          
1772:              //kontrolowany narost mocy dla fazy 1
1773:              if(Trosnie(1)) return; //(Tcw lub Tco rosnie szybciej niz 1K/sek)?
D108  0E01     MOVLW 0x1
D10A  ECE8     CALL 0xEFD0, 0
D10C  F077     NOP
D10E  B0D8     BTFSC STATUS, 0, ACCESS
D110  0012     RETURN 0
D112  D001     BRA 0xD116
D114  0012     RETURN 0
1774:              k = 5;
D116  0E05     MOVLW 0x5
D118  0100     MOVLB 0x0
D11A  6FE1     MOVWF GIE_BIT_VAL, BANKED
1775:              if(rgl.xmod + k > _MG2_MOD) rgl.xmod = _MG2_MOD;
D11C  0100     MOVLB 0x0
D11E  51E1     MOVF GIE_BIT_VAL, W, BANKED
D120  C03C     MOVFF 0x3C, pco
D122  F0DF     NOP
D124  6BE0     CLRF bdat, BANKED
D126  27DF     ADDWF pco, F, BANKED
D128  0E00     MOVLW 0x0
D12A  23E0     ADDWFC bdat, F, BANKED
D12C  BFE0     BTFSC bdat, 7, BANKED
D12E  D008     BRA 0xD140
D130  51E0     MOVF bdat, W, BANKED
D132  E103     BNZ 0xD13A
D134  0EF1     MOVLW 0xF1
D136  5DDF     SUBWF pco, W, BANKED
D138  E303     BNC 0xD140
D13A  0EF0     MOVLW 0xF0
D13C  6E3C     MOVWF 0x3C, ACCESS
D13E  D003     BRA 0xD146
1776:              else rgl.xmod += k;
D140  0100     MOVLB 0x0
D142  51E1     MOVF GIE_BIT_VAL, W, BANKED
D144  263C     ADDWF 0x3C, F, ACCESS
1777:              if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
D146  503C     MOVF 0x3C, W, ACCESS
D148  0100     MOVLB 0x0
D14A  5D7E     SUBWF _PFNf_obgCW, W, BANKED
D14C  A0D8     BTFSS STATUS, 0, ACCESS
D14E  C07E     MOVFF _PFNf_obgCW, 0x3C
D150  F03C     NOP
D152  0012     RETURN 0
1778:          }
D154  0012     RETURN 0
1779:          //------------------------------------------------------------
1780:          //reakcja superwizyjna
1781:          
1782:          void ModPrzCW4(void)
1783:          {
1784:              static unsigned char trb = 0;
1785:              unsigned int p;
1786:          
1787:              p = (rgl.tmp_pwm - PWM.MDMOD)*100;
AA90  0100     MOVLB 0x0
AA92  5167     MOVF _PFNf_b_set_ncw, W, BANKED
AA94  6FEB     MOVWF pop, BANKED
AA96  6BEC     CLRF dt, BANKED
AA98  1FEB     COMF pop, F, BANKED
AA9A  1FEC     COMF dt, F, BANKED
AA9C  4BEB     INFSNZ pop, F, BANKED
AA9E  2BEC     INCF dt, F, BANKED
AAA0  503D     MOVF 0x3D, W, ACCESS
AAA2  25EB     ADDWF pop, W, BANKED
AAA4  6FDE     MOVWF __pcstackBANK0, BANKED
AAA6  0E00     MOVLW 0x0
AAA8  21EC     ADDWFC dt, W, BANKED
AAAA  6FDF     MOVWF pco, BANKED
AAAC  6BE1     CLRF GIE_BIT_VAL, BANKED
AAAE  0E64     MOVLW 0x64
AAB0  6FE0     MOVWF bdat, BANKED
AAB2  EC5B     CALL 0xECB6, 0
AAB4  F076     NOP
AAB6  C0DE     MOVFF __pcstackBANK0, tid
AAB8  F0F2     NOP
AABA  C0DF     MOVFF pco, min
AABC  F0F3     NOP
1788:              p = p / (PWM.MGMOD - PWM.MDMOD);
AABE  C0F2     MOVFF tid, k
AAC0  F0E4     NOP
AAC2  C0F3     MOVFF min, k
AAC4  F0E5     NOP
AAC6  0100     MOVLB 0x0
AAC8  5167     MOVF _PFNf_b_set_ncw, W, BANKED
AACA  6FEB     MOVWF pop, BANKED
AACC  6BEC     CLRF dt, BANKED
AACE  1FEB     COMF pop, F, BANKED
AAD0  1FEC     COMF dt, F, BANKED
AAD2  4BEB     INFSNZ pop, F, BANKED
AAD4  2BEC     INCF dt, F, BANKED
AAD6  516A     MOVF _PFNf_blkcs, W, BANKED
AAD8  25EB     ADDWF pop, W, BANKED
AADA  6FE6     MOVWF counter, BANKED
AADC  0E00     MOVLW 0x0
AADE  21EC     ADDWFC dt, W, BANKED
AAE0  6FE7     MOVWF sign, BANKED
AAE2  EC0B     CALL 0xD816, 0
AAE4  F06C     NOP
AAE6  C0E4     MOVFF k, tid
AAE8  F0F2     NOP
AAEA  C0E5     MOVFF k, min
AAEC  F0F3     NOP
1789:          
1790:              if(!rglf_nmod) //nie jest w trybie nmod?
AAEE  BE15     BTFSC rglf_btcw, 7, ACCESS
AAF0  D06A     BRA 0xABC6
1791:              {
1792:                  trb = 0;
AAF2  0E00     MOVLW 0x0
AAF4  0101     MOVLB 0x1
AAF6  6F62     MOVWF 0x62, BANKED
1793:                  if(p <= 35)
AAF8  0100     MOVLB 0x0
AAFA  51F3     MOVF min, W, BANKED
AAFC  E113     BNZ 0xAB24
AAFE  0E24     MOVLW 0x24
AB00  5DF2     SUBWF tid, W, BANKED
AB02  B0D8     BTFSC STATUS, 0, ACCESS
AB04  D00F     BRA 0xAB24
1794:                  {
1795:                      if(!Tmaleje(0) && Twyzsza(3)) //(Tcw nie maleje ?)
AB06  0E00     MOVLW 0x0
AB08  ECA9     CALL 0xE752, 0
AB0A  F073     NOP
AB0C  B0D8     BTFSC STATUS, 0, ACCESS
AB0E  0012     RETURN 0
AB10  0E03     MOVLW 0x3
AB12  ECC5     CALL 0xE78A, 0
AB14  F073     NOP
AB16  A0D8     BTFSS STATUS, 0, ACCESS
AB18  0012     RETURN 0
1796:                      {
1797:                          trb = 1;
AB1A  0E01     MOVLW 0x1
AB1C  0101     MOVLB 0x1
AB1E  6F62     MOVWF 0x62, BANKED
1798:                          rglf_nmod = 1; //wejdz w tryb nmod
AB20  8E15     BSF rglf_btcw, 7, ACCESS
1799:                      }
1800:                  }
AB22  0012     RETURN 0
1801:                  else
1802:                  {
1803:                      if(!Tmaleje(0)) //(Tcw nie maleje ?)
AB24  0E00     MOVLW 0x0
AB26  ECA9     CALL 0xE752, 0
AB28  F073     NOP
AB2A  B0D8     BTFSC STATUS, 0, ACCESS
AB2C  0012     RETURN 0
1804:                      {
1805:                          if(Twyzsza(5)) //Tcw-Tnst>4 ?
AB2E  0E05     MOVLW 0x5
AB30  ECC5     CALL 0xE78A, 0
AB32  F073     NOP
AB34  A0D8     BTFSS STATUS, 0, ACCESS
AB36  0012     RETURN 0
1806:                          {
1807:                              if(rgl.srp - 3 < PWM.MDMOD) rgl.srp = PWM.MDMOD;
AB38  0100     MOVLB 0x0
AB3A  5167     MOVF _PFNf_b_set_ncw, W, BANKED
AB3C  6FEB     MOVWF pop, BANKED
AB3E  6BEC     CLRF dt, BANKED
AB40  0EFD     MOVLW 0xFD
AB42  6FED     MOVWF min, BANKED
AB44  69EE     SETF dt, BANKED
AB46  503B     MOVF 0x3B, W, ACCESS
AB48  6FEF     MOVWF 0xEF, BANKED
AB4A  6BF0     CLRF p, BANKED
AB4C  51ED     MOVF min, W, BANKED
AB4E  27EF     ADDWF 0xEF, F, BANKED
AB50  51EE     MOVF dt, W, BANKED
AB52  23F0     ADDWFC p, F, BANKED
AB54  51EB     MOVF pop, W, BANKED
AB56  5DEF     SUBWF 0xEF, W, BANKED
AB58  51F0     MOVF p, W, BANKED
AB5A  0A80     XORLW 0x80
AB5C  6FF1     MOVWF m, BANKED
AB5E  51EC     MOVF dt, W, BANKED
AB60  0A80     XORLW 0x80
AB62  59F1     SUBWFB m, W, BANKED
AB64  E203     BC 0xAB6C
AB66  C067     MOVFF _PFNf_b_set_ncw, 0x3B
AB68  F03B     NOP
AB6A  D003     BRA 0xAB72
1808:                              else rgl.srp -= 3;
AB6C  0E03     MOVLW 0x3
AB6E  5E3B     SUBWF 0x3B, F, ACCESS
AB70  D000     BRA 0xAB72
1809:                              trb = 2;
AB72  0E02     MOVLW 0x2
AB74  0101     MOVLB 0x1
AB76  6F62     MOVWF 0x62, BANKED
1810:                              rglf_nmod = 1; //wejdz w tryb nmod
AB78  8E15     BSF rglf_btcw, 7, ACCESS
1811:                              return;
1812:                          }
1813:                      }
1814:                      else return;
1815:                  }
1816:              }
AB7A  0012     RETURN 0
1817:              else //jest w trybie nmod?
1818:              {
1819:                  switch(trb)
AB7C  D024     BRA 0xABC6
ABC6  0101     MOVLB 0x1
ABC8  5162     MOVF 0x62, W, BANKED
ABCA  0A01     XORLW 0x1
ABCC  E0D8     BZ 0xAB7E
ABCE  0A03     XORLW 0x3
ABD0  E0EC     BZ 0xABAA
1820:                  {
1821:                      case 1:
1822:                      {
1823:                          if(!Twyzsza(3))
AB7E  0E03     MOVLW 0x3
AB80  ECC5     CALL 0xE78A, 0
AB82  F073     NOP
AB84  B0D8     BTFSC STATUS, 0, ACCESS
AB86  0012     RETURN 0
1824:                          {
1825:                              if(Tnizsza(3) || Tstoi() || Tmaleje(0))
AB88  0E03     MOVLW 0x3
AB8A  ECDA     CALL 0xEFB4, 0
AB8C  F077     NOP
AB8E  E208     BC 0xABA0
AB90  ECAC     CALL 0xF358, 0
AB92  F079     NOP
AB94  E205     BC 0xABA0
AB96  0E00     MOVLW 0x0
AB98  ECA9     CALL 0xE752, 0
AB9A  F073     NOP
AB9C  A0D8     BTFSS STATUS, 0, ACCESS
AB9E  0012     RETURN 0
1826:                              {
1827:                                  trb = 0;
ABA0  0E00     MOVLW 0x0
ABA2  0101     MOVLB 0x1
ABA4  6F62     MOVWF 0x62, BANKED
1828:                                  rglf_nmod = 0; //jezeli Tcw maleje wyjdz z trybu nmod
ABA6  9E15     BCF rglf_btcw, 7, ACCESS
1829:                              }
1830:                          }
1831:                          break;
ABA8  0012     RETURN 0
1832:                      }
1833:                      case 2:
1834:                      {
1835:                          if(Tmaleje(0) || !Twyzsza(4)) //(Tcw maleje ?)
ABAA  0E00     MOVLW 0x0
ABAC  ECA9     CALL 0xE752, 0
ABAE  F073     NOP
ABB0  E205     BC 0xABBC
ABB2  0E04     MOVLW 0x4
ABB4  ECC5     CALL 0xE78A, 0
ABB6  F073     NOP
ABB8  B0D8     BTFSC STATUS, 0, ACCESS
ABBA  0012     RETURN 0
1836:                          {
1837:                              trb = 0;
ABBC  0E00     MOVLW 0x0
ABBE  0101     MOVLB 0x1
ABC0  6F62     MOVWF 0x62, BANKED
1838:                              rglf_nmod = 0; //wyjdz z trybu nmod
ABC2  9E15     BCF rglf_btcw, 7, ACCESS
1839:                              return;
1840:                          }
1841:                          break;
1842:                      }
1843:                  }
ABC4  0012     RETURN 0
ABD2  0012     RETURN 0
1844:              }
1845:          }
ABD4  0012     RETURN 0
1846:          //------------------------------------------------------------
1847:          //Zabezpieczenie od przegrzania w obwodzie CO
1848:          
1849:          void PropCO4(void)
1850:          {
1851:              if(!rglf_nmod) //nie jest w trybie nmod?
D678  BE15     BTFSC rglf_btcw, 7, ACCESS
D67A  D02D     BRA 0xD6D6
1852:              {
1853:                  if(!DtCOf_err_CO) //awaria czujnika temperatury CO?
D67C  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
D67E  D028     BRA 0xD6D0
1854:                  {
1855:                      if(rgl.x_f == 3) //=86C ?
D680  0E03     MOVLW 0x3
D682  1837     XORWF 0x37, W, ACCESS
D684  E107     BNZ 0xD694
1856:                      {
1857:                          if(rgl.tmp_pwm > PWM.MGMOD)
D686  503D     MOVF 0x3D, W, ACCESS
D688  0100     MOVLB 0x0
D68A  5D6A     SUBWF _PFNf_blkcs, W, BANKED
D68C  E221     BC 0xD6D0
1858:                              rgl.tmp_pwm = PWM.MGMOD; //=MGMOD
D68E  C06A     MOVFF _PFNf_blkcs, 0x3D
D690  F03D     NOP
1859:                      }
D692  D01E     BRA 0xD6D0
1860:                      else
1861:                          if(rgl.x_f == 2) //=87C ?
D694  0E02     MOVLW 0x2
D696  1837     XORWF 0x37, W, ACCESS
D698  E107     BNZ 0xD6A8
1862:                      {
1863:                          if(rgl.tmp_pwm > PWM.PROP1)
D69A  503D     MOVF 0x3D, W, ACCESS
D69C  0100     MOVLB 0x0
D69E  5D79     SUBWF _PFNf_newPCO, W, BANKED
D6A0  E217     BC 0xD6D0
1864:                              rgl.tmp_pwm = PWM.PROP1; //-1/7
D6A2  C079     MOVFF _PFNf_newPCO, 0x3D
D6A4  F03D     NOP
1865:                      }
D6A6  D014     BRA 0xD6D0
1866:                      else
1867:                          if(rgl.x_f == 1) //=88C ?
D6A8  0437     DECF 0x37, W, ACCESS
D6AA  E107     BNZ 0xD6BA
1868:                      {
1869:                          if(rgl.tmp_pwm > PWM.PROP2)
D6AC  503D     MOVF 0x3D, W, ACCESS
D6AE  0100     MOVLB 0x0
D6B0  5D7A     SUBWF _PFNf_newPCW, W, BANKED
D6B2  E20E     BC 0xD6D0
1870:                              rgl.tmp_pwm = PWM.PROP2; //-2/7
D6B4  C07A     MOVFF _PFNf_newPCW, 0x3D
D6B6  F03D     NOP
1871:                      }
D6B8  D00B     BRA 0xD6D0
1872:                      else
1873:                          if(rgl.x_f <= 0) //>=89C ?
D6BA  5037     MOVF 0x37, W, ACCESS
D6BC  0A80     XORLW 0x80
D6BE  0F7F     ADDLW 0x7F
D6C0  E207     BC 0xD6D0
1874:                      {
1875:                          if(rgl.tmp_pwm > PWM.PROP3)
D6C2  503D     MOVF 0x3D, W, ACCESS
D6C4  0100     MOVLB 0x0
D6C6  5D7B     SUBWF _PFNf_newPFN, W, BANKED
D6C8  E203     BC 0xD6D0
1876:                              rgl.tmp_pwm = PWM.PROP3; //-3/7
D6CA  C07B     MOVFF _PFNf_newPFN, 0x3D
D6CC  F03D     NOP
1877:                      }
1878:                  }
D6CE  D000     BRA 0xD6D0
1879:                  WriteOPWM(rgl.tmp_pwm);
D6D0  503D     MOVF 0x3D, W, ACCESS
D6D2  EF6C     GOTO 0xA4D8
D6D4  F052     NOP
1880:              }
1881:              else WriteOPWM(PWM.MDMOD); //wymus minimum plomienia
D6D6  0100     MOVLB 0x0
D6D8  5167     MOVF _PFNf_b_set_ncw, W, BANKED
D6DA  EF6C     GOTO 0xA4D8
D6DC  F052     NOP
1882:          }
D6DE  0012     RETURN 0
1883:          //************************************************************
1884:          //------------------------------------------------------------
1885:          //------------------------------------------------------------
1886:          //------wymiennik plytowy - obieg CW
1887:          //------------------------------------------------------------
1888:          //------------------------------------------------------------
1889:          //------------------------------------------------------------
1890:          //parametry startowe dla CO
1891:          
1892:          void StartCO2(void)
1893:          {
1894:              //	unsigned char k;
1895:          
1896:              if(rglf_btco || rglf_btcw) return; //praca w dowolnym obiegu CO?
E028  AE14     BTFSS UADtf_RData, 7, ACCESS
E02A  B015     BTFSC rglf_btcw, 0, ACCESS
E02C  0012     RETURN 0
E02E  D001     BRA 0xE032
E030  0012     RETURN 0
1897:              StartRTdS(_RTMOD);
E032  0E02     MOVLW 0x2
E034  ECA0     CALL 0xE540, 0
E036  F072     NOP
1898:              DtCO.dDCO = 0;
E038  0100     MOVLB 0x0
E03A  6BD6     CLRF 0xD6, BANKED
1899:              DtCO.indCO = 0;
E03C  0100     MOVLB 0x0
E03E  6BD7     CLRF 0xD7, BANKED
1900:              DtCW.dDCW = 0;
E040  0100     MOVLB 0x0
E042  6BB0     CLRF 0xB0, BANKED
1901:              DtCW.indCW = 0;
E044  0100     MOVLB 0x0
E046  6BB2     CLRF 0xB2, BANKED
1902:              rglf_fz = 0;
E048  9815     BCF rglf_btcw, 4, ACCESS
1903:              rglf_med_up = 0;
E04A  9C15     BCF rglf_btcw, 6, ACCESS
1904:              rglf_fast_up = 0;
E04C  9615     BCF rglf_btcw, 3, ACCESS
1905:              //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
1906:              //if(!PWMf_tpGZ) rgl.xmod=I80_MOD;
1907:              //else rgl.xmod=I80_PMOD;
1908:              if(PWM.MMAXCO > PWM.FIRSTPB)
E04E  0100     MOVLB 0x0
E050  517D     MOVF _PFNf_obgCO, W, BANKED
E052  5D78     SUBWF _PFNf_mod_ncw, W, BANKED
E054  E203     BC 0xE05C
1909:              {
1910:                  rgl.xmod = PWM.FIRSTPB;
E056  C078     MOVFF _PFNf_mod_ncw, 0x3C
E058  F03C     NOP
1911:              }
E05A  D003     BRA 0xE062
1912:              else
1913:              {
1914:                  rgl.xmod = PWM.MMAXCO;
E05C  C07D     MOVFF _PFNf_obgCO, 0x3C
E05E  F03C     NOP
E060  D000     BRA 0xE062
1915:              }
1916:              /*
1917:                      if(!PWMf_tpGZ)
1918:                      {
1919:                              if(PWM.MMAXCO>I80_MOD)
1920:                              {
1921:                                      rgl.xmod=I80_MOD;
1922:                              }
1923:                              else
1924:                              {
1925:                                      rgl.xmod=PWM.MMAXCO;
1926:                              }
1927:                      }
1928:                      else
1929:                      {
1930:                              if(PWM.MMAXCO>I80_PMOD)
1931:                              {
1932:                                      rgl.xmod=I80_PMOD;
1933:                              }
1934:                              else
1935:                              {
1936:                                      rgl.xmod=PWM.MMAXCO;
1937:                              }
1938:                      }
1939:               */
1940:              rgl.srp = 0;
E062  0E00     MOVLW 0x0
E064  6A3B     CLRF 0x3B, ACCESS
1941:              rgl.ytmp = 0;
E066  6A3A     CLRF 0x3A, ACCESS
1942:              rglf_nmod = 0; //wyjdz z trybu nmod
E068  9E15     BCF rglf_btcw, 7, ACCESS
1943:              rglf_del1s = 0;
E06A  9215     BCF rglf_btcw, 1, ACCESS
1944:              rglf_deln1 = 0;
E06C  9415     BCF rglf_btcw, 2, ACCESS
1945:              rglf_inv_mod = 0;
E06E  9A15     BCF rglf_btcw, 5, ACCESS
1946:          }
E070  0012     RETURN 0
1947:          //-------------------------------------------------------------
1948:          //parametry startowe dla CW
1949:          
1950:          void StartMCW2(void)
1951:          {
1952:              if(rglf_btco || rglf_btcw) return; //rozpoczecie pracy modulatora?
EA66  AE14     BTFSS UADtf_RData, 7, ACCESS
EA68  B015     BTFSC rglf_btcw, 0, ACCESS
EA6A  0012     RETURN 0
EA6C  D001     BRA 0xEA70
EA6E  0012     RETURN 0
1953:              StartRTdS(_RTMOD);
EA70  0E02     MOVLW 0x2
EA72  ECA0     CALL 0xE540, 0
EA74  F072     NOP
1954:              DtCO.dDCO = 0;
EA76  0100     MOVLB 0x0
EA78  6BD6     CLRF 0xD6, BANKED
1955:              DtCW.dDCW = 0;
EA7A  0100     MOVLB 0x0
EA7C  6BB0     CLRF 0xB0, BANKED
1956:              DtCO.indCO = 0;
EA7E  0100     MOVLB 0x0
EA80  6BD7     CLRF 0xD7, BANKED
1957:              DtCW.indCW = 0;
EA82  0100     MOVLB 0x0
EA84  6BB2     CLRF 0xB2, BANKED
1958:              rglf_fz = 0;
EA86  9815     BCF rglf_btcw, 4, ACCESS
1959:              FirstPCW2();
EA88  ECBF     CALL 0xE37E, 0
EA8A  F071     NOP
1960:              rgl.srp = 0;
EA8C  6A3B     CLRF 0x3B, ACCESS
1961:              rgl.ytmp = 0;
EA8E  0E00     MOVLW 0x0
EA90  6A3A     CLRF 0x3A, ACCESS
1962:              rglf_del1s = 0;
EA92  9215     BCF rglf_btcw, 1, ACCESS
1963:          }
EA94  0012     RETURN 0
1964:          //-------------------------------------------------------------	
1965:          //pierwsze pobudzenie dla CW
1966:          
1967:          void FirstPCW2(void)
1968:          {
1969:              if(PWM.MMAXCW > PWM.MGMOD)
E37E  0100     MOVLB 0x0
E380  517E     MOVF _PFNf_obgCW, W, BANKED
E382  5D6A     SUBWF _PFNf_blkcs, W, BANKED
E384  E20A     BC 0xE39A
1970:              {
1971:                  if(DtCW.DCW > 0) rgl.xmod = PWM.MGMOD;
E386  51AF     MOVF _rglf_nmod, W, BANKED
E388  0A80     XORLW 0x80
E38A  0F7F     ADDLW 0x7F
E38C  E303     BNC 0xE394
E38E  C06A     MOVFF _PFNf_blkcs, 0x3C
E390  F03C     NOP
E392  0012     RETURN 0
1972:                  else rgl.xmod = PWM.FIRSTPB;
E394  C078     MOVFF _PFNf_mod_ncw, 0x3C
E396  F03C     NOP
1973:              }
E398  0012     RETURN 0
1974:              else
1975:              {
1976:                  if(DtCW.DCW > 0) rgl.xmod = PWM.MMAXCW;
E39A  0100     MOVLB 0x0
E39C  51AF     MOVF _rglf_nmod, W, BANKED
E39E  0A80     XORLW 0x80
E3A0  0F7F     ADDLW 0x7F
E3A2  E303     BNC 0xE3AA
E3A4  C07E     MOVFF _PFNf_obgCW, 0x3C
E3A6  F03C     NOP
E3A8  0012     RETURN 0
1977:                  else
1978:                  {
1979:                      if(PWM.MMAXCW > PWM.FIRSTPB) rgl.xmod = PWM.FIRSTPB;
E3AA  0100     MOVLB 0x0
E3AC  517E     MOVF _PFNf_obgCW, W, BANKED
E3AE  5D78     SUBWF _PFNf_mod_ncw, W, BANKED
E3B0  E203     BC 0xE3B8
E3B2  C078     MOVFF _PFNf_mod_ncw, 0x3C
E3B4  F03C     NOP
E3B6  0012     RETURN 0
1980:                      else rgl.xmod = PWM.MMAXCW;
E3B8  C07E     MOVFF _PFNf_obgCW, 0x3C
E3BA  F03C     NOP
1981:                  }
E3BC  0012     RETURN 0
1982:              }
1983:              /*	if(!PWMf_tpGZ)
1984:                      {
1985:                              if(PWM.MMAXCW>PWM.MGMOD)
1986:                              {
1987:                                      if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
1988:                                      else rgl.xmod=PWM.FIRSTPB;
1989:                              }
1990:                              else
1991:                              {
1992:                                      if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
1993:                                      else
1994:                                      {
1995:                                              if(PWM.MMAXCW>PWM.FIRSTPB) rgl.xmod=PWM.FIRSTPB;
1996:                                              else rgl.xmod=PWM.MMAXCW;
1997:                                      }
1998:                              }
1999:                      }
2000:                      else
2001:                      {
2002:                              if(PWM.MMAXCW>PWM.MGMOD)
2003:                              {
2004:                                      if(DtCW.DCW>0) rgl.xmod=PWM.MGMOD;
2005:                                      else rgl.xmod=I80_PMOD;
2006:                              }
2007:                              else
2008:                              {
2009:                                      if(DtCW.DCW>0) rgl.xmod=PWM.MMAXCW;
2010:                                      else
2011:                                      {
2012:                                              if(PWM.MMAXCW>I80_PMOD) rgl.xmod=I80_PMOD;
2013:                                              else rgl.xmod=PWM.MMAXCW;
2014:                                      }
2015:                              }
2016:                      }
2017:               */
2018:          }
E3BE  0012     RETURN 0
2019:          //-------------------------------------------------------------
2020:          //zeruj parametry modulatora po zmianie obiegu
2021:          
2022:          void ClrMod2(void)
2023:          {
2024:              rglf_fz = 0;
F2CA  9815     BCF rglf_btcw, 4, ACCESS
2025:              rgl.xmod = PWM.BufPWM;
F2CC  C060     MOVFF PWM, 0x3C
F2CE  F03C     NOP
2026:              rgl.srp = 0;
F2D0  0E00     MOVLW 0x0
F2D2  6A3B     CLRF 0x3B, ACCESS
2027:              rgl.ytmp = 0;
F2D4  6A3A     CLRF 0x3A, ACCESS
2028:              rglf_del1s = 0;
F2D6  9215     BCF rglf_btcw, 1, ACCESS
2029:          }
F2D8  0012     RETURN 0
2030:          //-------------------------------------------------------------
2031:          //zmien obieg na CW
2032:          
2033:          void ModToCW2(void)
2034:          {
2035:              rglf_btcw = 1;
F2F6  8015     BSF rglf_btcw, 0, ACCESS
2036:              if(rglf_btco)
F2F8  AE14     BTFSS UADtf_RData, 7, ACCESS
F2FA  0012     RETURN 0
2037:              {
2038:                  rglf_btco = 0;
F2FC  9E14     BCF UADtf_RData, 7, ACCESS
2039:                  ClrMod2();
F2FE  EF65     GOTO 0xF2CA
F300  F079     NOP
2040:              }
2041:          }
F302  0012     RETURN 0
2042:          //-------------------------------------------------------------
2043:          //zmien obieg na CO
2044:          
2045:          void ModToCO2(void)
2046:          {
2047:              rglf_btco = 1;
F320  8E14     BSF UADtf_RData, 7, ACCESS
2048:              if(rglf_btcw)
F322  A015     BTFSS rglf_btcw, 0, ACCESS
F324  0012     RETURN 0
2049:              {
2050:                  rglf_btcw = 0;
F326  9015     BCF rglf_btcw, 0, ACCESS
2051:                  ClrMod2();
F328  EF65     GOTO 0xF2CA
F32A  F079     NOP
2052:              }
2053:          }
F32C  0012     RETURN 0
2054:          //-------------------------------------------------------------
2055:          //oblicza czas przez ktory temp=const
2056:          
2057:          void IncConstCW2(void)
2058:          {
2059:              if(!TFrosnie(0))
EF74  0E00     MOVLW 0x0
EF76  ECF6     CALL 0xEFEC, 0
EF78  F077     NOP
EF7A  E208     BC 0xEF8C
2060:              {
2061:                  if(Tstoi()) rgl.ytmp++;
EF7C  ECAC     CALL 0xF358, 0
EF7E  F079     NOP
EF80  E302     BNC 0xEF86
EF82  2A3A     INCF 0x3A, F, ACCESS
EF84  0012     RETURN 0
2062:                  else rgl.ytmp = 0;
EF86  0E00     MOVLW 0x0
EF88  6E3A     MOVWF 0x3A, ACCESS
2063:              }
EF8A  0012     RETURN 0
2064:              else rgl.ytmp = 0;
EF8C  0E00     MOVLW 0x0
EF8E  6E3A     MOVWF 0x3A, ACCESS
EF90  0C00     RETLW 0x0
2065:          }
EF92  0012     RETURN 0
2066:          //-------------------------------------------------------------
2067:          
2068:          void IncConstCO2(void)
2069:          {
2070:              if(Tstoi()) rgl.ytmp++;
F250  ECAC     CALL 0xF358, 0
F252  F079     NOP
F254  E302     BNC 0xF25A
F256  2A3A     INCF 0x3A, F, ACCESS
F258  0012     RETURN 0
2071:              else rgl.ytmp = 0;
F25A  0E00     MOVLW 0x0
F25C  6E3A     MOVWF 0x3A, ACCESS
F25E  0C00     RETLW 0x0
2072:          }
F260  0012     RETURN 0
2073:          //-------------------------------------------------------------	
2074:          //wprowadzenie danych wejsciowych-CO
2075:          
2076:          void ReadDataCO2(void)
2077:          {
2078:              rgl.x_t = DtCO.DCO;
F3A4  C0D5     MOVFF 0xD5, rgl
F3A6  F036     NOP
2079:              rgl.x_dt = DtCO.dDCO;
F3A8  C0D6     MOVFF 0xD6, 0x38
F3AA  F038     NOP
2080:          }
F3AC  0012     RETURN 0
2081:          //-------------------------------------------------------------
2082:          //wprowadzenie danych wejsciowych-CW
2083:          
2084:          void ReadDataCW2(void)
2085:          {
2086:              rgl.x_t = DtCW.DCW;
F208  C0AF     MOVFF _rglf_nmod, rgl
F20A  F036     NOP
2087:              rgl.x_f = DtCO.DCO;
F20C  C0D5     MOVFF 0xD5, 0x37
F20E  F037     NOP
2088:              rgl.x_dt = DtCW.dDCW;
F210  C0B0     MOVFF 0xB0, 0x38
F212  F038     NOP
2089:              rgl.x_df = DtCO.dDCO;
F214  C0D6     MOVFF 0xD6, 0x39
F216  F039     NOP
2090:          }
F218  0012     RETURN 0
2091:          //-------------------------------------------------------------
2092:          //pierwsze przyblizenie
2093:          
2094:          void ModZgCW2(void)
2095:          {
2096:              signed long m;
2097:              unsigned char p;
2098:              static unsigned char pop;
2099:          
2100:              if(Tnizsza(10))
7E66  0E0A     MOVLW 0xA
7E68  ECDA     CALL 0xEFB4, 0
7E6A  F077     NOP
7E6C  E306     BNC 0x7E7A
2101:              {
2102:                  pop = 20; //wartosc poprawki na przesterowanie
7E6E  0E14     MOVLW 0x14
7E70  0101     MOVLB 0x1
7E72  6F64     MOVWF 0x64, BANKED
2103:                  FirstPCW2();
7E74  ECBF     CALL 0xE37E, 0
7E76  F071     NOP
7E78  D000     BRA 0x7E7A
2104:              }
2105:              if(rglf_fz) //aktualnie faza 2?
7E7A  A815     BTFSS rglf_btcw, 4, ACCESS
7E7C  D00F     BRA _IRCF0
2106:              {
2107:                  if(Tnizsza(2)) //Tnizsza(2)przygotowanie do przejscia do fazy 1
7E7E  0E02     MOVLW 0x2
7E80  ECDA     CALL 0xEFB4, 0
7E82  F077     NOP
7E84  A0D8     BTFSS STATUS, 0, ACCESS
7E86  0012     RETURN 0
2108:                  {
2109:                      rgl.xmod = PWM.BufPWM;
7E88  C060     MOVFF PWM, 0x3C
7E8A  F03C     NOP
2110:                      rgl.srp = 0;
7E8C  6A3B     CLRF 0x3B, ACCESS
2111:                      rgl.ytmp = 0;
7E8E  6A3A     CLRF 0x3A, ACCESS
2112:                      rglf_del1s = 0;
7E90  9215     BCF rglf_btcw, 1, ACCESS
2113:                      pop = 0;
7E92  0101     MOVLB 0x1
7E94  6B64     CLRF 0x64, BANKED
2114:                  }
7E96  D002     BRA _IRCF0
2115:                  else return;
7E98  0012     RETURN 0
7E9A  D000     BRA _IRCF0
2116:              }
2117:              if(!Tnizsza(1)) //warunek przejscia do fazy 2
7E9C  0E01     MOVLW 0x1
7E9E  ECDA     CALL 0xEFB4, 0
7EA0  F077     NOP
7EA2  E226     BC 0x7EF0
2118:              {
2119:                  rglf_fz = 1;
7EA4  8815     BSF rglf_btcw, 4, ACCESS
2120:                  rglf_fast_up = 0;
7EA6  9615     BCF rglf_btcw, 3, ACCESS
2121:                  rglf_med_up = 0;
7EA8  9C15     BCF rglf_btcw, 6, ACCESS
2122:                  rgl.srp = PWM.BufPWM + pop;
7EAA  0100     MOVLB 0x0
7EAC  5160     MOVF PWM, W, BANKED
7EAE  0101     MOVLB 0x1
7EB0  2564     ADDWF 0x64, W, BANKED
7EB2  6E3B     MOVWF 0x3B, ACCESS
2123:                  rgl.xmod = PWM.BufPWM + pop;
7EB4  0100     MOVLB 0x0
7EB6  5160     MOVF PWM, W, BANKED
7EB8  0101     MOVLB 0x1
7EBA  2564     ADDWF 0x64, W, BANKED
7EBC  6E3C     MOVWF 0x3C, ACCESS
2124:                  pop = 0;
7EBE  0101     MOVLB 0x1
7EC0  6B64     CLRF 0x64, BANKED
2125:                  if(PWM.MMAXCW > PWM.MGMOD)
7EC2  0100     MOVLB 0x0
7EC4  517E     MOVF _PFNf_obgCW, W, BANKED
7EC6  5D6A     SUBWF _PFNf_blkcs, W, BANKED
7EC8  E209     BC 0x7EDC
2126:                  {
2127:                      if(rgl.xmod > PWM.MGMOD)
7ECA  503C     MOVF 0x3C, W, ACCESS
7ECC  5D6A     SUBWF _PFNf_blkcs, W, BANKED
7ECE  B0D8     BTFSC STATUS, 0, ACCESS
7ED0  0012     RETURN 0
2128:                      {
2129:                          rgl.srp = PWM.MGMOD;
7ED2  C06A     MOVFF _PFNf_blkcs, 0x3B
7ED4  F03B     NOP
2130:                          rgl.xmod = PWM.MGMOD;
7ED6  C06A     MOVFF _PFNf_blkcs, 0x3C
7ED8  F03C     NOP
2131:                      }
2132:                  }
7EDA  0012     RETURN 0
2133:                  else
2134:                  {
2135:                      if(rgl.xmod > PWM.MMAXCW)
7EDC  503C     MOVF 0x3C, W, ACCESS
7EDE  0100     MOVLB 0x0
7EE0  5D7E     SUBWF _PFNf_obgCW, W, BANKED
7EE2  B0D8     BTFSC STATUS, 0, ACCESS
7EE4  0012     RETURN 0
2136:                      {
2137:                          rgl.srp = PWM.MMAXCW;
7EE6  C07E     MOVFF _PFNf_obgCW, 0x3B
7EE8  F03B     NOP
2138:                          rgl.xmod = PWM.MMAXCW;
7EEA  C07E     MOVFF _PFNf_obgCW, 0x3C
7EEC  F03C     NOP
2139:                      }
2140:                  }
2141:                  return;
7EEE  0012     RETURN 0
2142:              }
2143:              if(rgl.xmod >= PWM.MDMOD) m = (rgl.xmod - PWM.MDMOD)*10;
7EF0  0100     MOVLB 0x0
7EF2  5167     MOVF _PFNf_b_set_ncw, W, BANKED
7EF4  5C3C     SUBWF 0x3C, W, ACCESS
7EF6  E31C     BNC 0x7F30
7EF8  5167     MOVF _PFNf_b_set_ncw, W, BANKED
7EFA  6FEC     MOVWF dt, BANKED
7EFC  6BED     CLRF min, BANKED
7EFE  1FEC     COMF dt, F, BANKED
7F00  1FED     COMF min, F, BANKED
7F02  4BEC     INFSNZ dt, F, BANKED
7F04  2BED     INCF min, F, BANKED
7F06  503C     MOVF 0x3C, W, ACCESS
7F08  25EC     ADDWF dt, W, BANKED
7F0A  6FDE     MOVWF __pcstackBANK0, BANKED
7F0C  0E00     MOVLW 0x0
7F0E  21ED     ADDWFC min, W, BANKED
7F10  6FDF     MOVWF pco, BANKED
7F12  6BE1     CLRF GIE_BIT_VAL, BANKED
7F14  0E0A     MOVLW 0xA
7F16  6FE0     MOVWF bdat, BANKED
7F18  EC5B     CALL 0xECB6, 0
7F1A  F076     NOP
7F1C  C0DE     MOVFF __pcstackBANK0, tid
7F1E  F0F2     NOP
7F20  C0DF     MOVFF pco, min
7F22  F0F3     NOP
7F24  0100     MOVLB 0x0
7F26  0E00     MOVLW 0x0
7F28  BFF3     BTFSC min, 7, BANKED
7F2A  0EFF     MOVLW 0xFF
7F2C  6FF4     MOVWF pco, BANKED
7F2E  D005     BRA 0x7F3A
2144:              else m = 0;
7F30  0E00     MOVLW 0x0
7F32  0100     MOVLB 0x0
7F34  6BF2     CLRF tid, BANKED
7F36  6BF3     CLRF min, BANKED
7F38  6BF4     CLRF pco, BANKED
7F3A  6FF5     MOVWF max, BANKED
7F3C  D000     BRA 0x7F3E
2145:              m = m / (DtCW.MAD_CW - DtCW.DAD_CW); //DAD_CW-MAD_CW
7F3E  C0F2     MOVFF tid, __pcstackBANK0
7F40  F0DE     NOP
7F42  C0F3     MOVFF min, pco
7F44  F0DF     NOP
7F46  C0F4     MOVFF pco, bdat
7F48  F0E0     NOP
7F4A  C0F5     MOVFF max, GIE_BIT_VAL
7F4C  F0E1     NOP
7F4E  0100     MOVLB 0x0
7F50  51B6     MOVF 0xB6, W, BANKED
7F52  6FEC     MOVWF dt, BANKED
7F54  6BED     CLRF min, BANKED
7F56  1FEC     COMF dt, F, BANKED
7F58  1FED     COMF min, F, BANKED
7F5A  4BEC     INFSNZ dt, F, BANKED
7F5C  2BED     INCF min, F, BANKED
7F5E  51B5     MOVF 0xB5, W, BANKED
7F60  6FEE     MOVWF dt, BANKED
7F62  6BEF     CLRF 0xEF, BANKED
7F64  51EC     MOVF dt, W, BANKED
7F66  27EE     ADDWF dt, F, BANKED
7F68  51ED     MOVF min, W, BANKED
7F6A  23EF     ADDWFC 0xEF, F, BANKED
7F6C  C0EE     MOVFF dt, divisor
7F6E  F0E2     NOP
7F70  C0EF     MOVFF 0xEF, a
7F72  F0E3     NOP
7F74  0E00     MOVLW 0x0
7F76  BFE3     BTFSC a, 7, BANKED
7F78  0EFF     MOVLW 0xFF
7F7A  6FE4     MOVWF k, BANKED
7F7C  6FE5     MOVWF k, BANKED
7F7E  ECF3     CALL 0xB3E6, 0
7F80  F059     NOP
7F82  C0DE     MOVFF __pcstackBANK0, tid
7F84  F0F2     NOP
7F86  C0DF     MOVFF pco, min
7F88  F0F3     NOP
7F8A  C0E0     MOVFF bdat, pco
7F8C  F0F4     NOP
7F8E  C0E1     MOVFF GIE_BIT_VAL, max
7F90  F0F5     NOP
2146:              m = m * (DtCW.AC_CW - DtCW.DAD_CW); //DAD_CW-AC_CW
7F92  0100     MOVLB 0x0
7F94  51B6     MOVF 0xB6, W, BANKED
7F96  6FEC     MOVWF dt, BANKED
7F98  6BED     CLRF min, BANKED
7F9A  1FEC     COMF dt, F, BANKED
7F9C  1FED     COMF min, F, BANKED
7F9E  4BEC     INFSNZ dt, F, BANKED
7FA0  2BED     INCF min, F, BANKED
7FA2  51B4     MOVF 0xB4, W, BANKED
7FA4  6FEE     MOVWF dt, BANKED
7FA6  6BEF     CLRF 0xEF, BANKED
7FA8  51EC     MOVF dt, W, BANKED
7FAA  27EE     ADDWF dt, F, BANKED
7FAC  51ED     MOVF min, W, BANKED
7FAE  23EF     ADDWFC 0xEF, F, BANKED
7FB0  C0EE     MOVFF dt, __pcstackBANK0
7FB2  F0DE     NOP
7FB4  C0EF     MOVFF 0xEF, pco
7FB6  F0DF     NOP
7FB8  0E00     MOVLW 0x0
7FBA  BFDF     BTFSC pco, 7, BANKED
7FBC  0EFF     MOVLW 0xFF
7FBE  6FE0     MOVWF bdat, BANKED
7FC0  6FE1     MOVWF GIE_BIT_VAL, BANKED
7FC2  C0F2     MOVFF tid, divisor
7FC4  F0E2     NOP
7FC6  C0F3     MOVFF min, a
7FC8  F0E3     NOP
7FCA  C0F4     MOVFF pco, k
7FCC  F0E4     NOP
7FCE  C0F5     MOVFF max, k
7FD0  F0E5     NOP
7FD2  EC2F     CALL 0xDA5E, 0
7FD4  F06D     NOP
7FD6  C0DE     MOVFF __pcstackBANK0, tid
7FD8  F0F2     NOP
7FDA  C0DF     MOVFF pco, min
7FDC  F0F3     NOP
7FDE  C0E0     MOVFF bdat, pco
7FE0  F0F4     NOP
7FE2  C0E1     MOVFF GIE_BIT_VAL, max
7FE4  F0F5     NOP
2147:              if(m < 0) m = 0;
7FE6  0100     MOVLB 0x0
7FE8  AFF5     BTFSS max, 7, BANKED
7FEA  D005     BRA 0x7FF6
7FEC  6BF2     CLRF tid, BANKED
7FEE  6BF3     CLRF min, BANKED
7FF0  6BF4     CLRF pco, BANKED
7FF2  6BF5     CLRF max, BANKED
7FF4  D000     BRA 0x7FF6
2148:              m = m / 10 + PWM.MDMOD;
7FF6  C0F2     MOVFF tid, __pcstackBANK0
7FF8  F0DE     NOP
7FFA  C0F3     MOVFF min, pco
7FFC  F0DF     NOP
7FFE  C0F4     MOVFF pco, bdat
8000  F0E0     NOP
8002  C0F5     MOVFF max, GIE_BIT_VAL
8004  F0E1     NOP
8006  0E0A     MOVLW 0xA
8008  0100     MOVLB 0x0
800A  6FE2     MOVWF divisor, BANKED
800C  6BE3     CLRF a, BANKED
800E  6BE4     CLRF k, BANKED
8010  6BE5     CLRF k, BANKED
8012  ECF3     CALL 0xB3E6, 0
8014  F059     NOP
8016  0100     MOVLB 0x0
8018  5167     MOVF _PFNf_b_set_ncw, W, BANKED
801A  25DE     ADDWF __pcstackBANK0, W, BANKED
801C  6FF2     MOVWF tid, BANKED
801E  0E00     MOVLW 0x0
8020  21DF     ADDWFC pco, W, BANKED
8022  6FF3     MOVWF min, BANKED
8024  0E00     MOVLW 0x0
8026  21E0     ADDWFC bdat, W, BANKED
8028  6FF4     MOVWF pco, BANKED
802A  0E00     MOVLW 0x0
802C  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
802E  6FF5     MOVWF max, BANKED
2149:              if(m > 0xff) //przepelnienie
8030  0100     MOVLB 0x0
8032  BFF5     BTFSC max, 7, BANKED
8034  D009     BRA 0x8048
8036  51F5     MOVF max, W, BANKED
8038  11F4     IORWF pco, W, BANKED
803A  E102     BNZ 0x8040
803C  05F3     DECF min, W, BANKED
803E  E304     BNC 0x8048
2150:              {
2151:                  rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
8040  9815     BCF rglf_btcw, 4, ACCESS
2152:                  rgl.tmp_pwm = rgl.xmod;
8042  C03C     MOVFF 0x3C, 0x3D
8044  F03D     NOP
2153:                  return;
8046  0012     RETURN 0
2154:              }
2155:              if(rglf_fz && (rgl.xmod > m))
8048  A815     BTFSS rglf_btcw, 4, ACCESS
804A  D017     BRA 0x807A
804C  C03C     MOVFF 0x3C, dt
804E  F0EC     NOP
8050  0100     MOVLB 0x0
8052  6BED     CLRF min, BANKED
8054  6BEE     CLRF dt, BANKED
8056  6BEF     CLRF 0xEF, BANKED
8058  51EC     MOVF dt, W, BANKED
805A  5DF2     SUBWF tid, W, BANKED
805C  51ED     MOVF min, W, BANKED
805E  59F3     SUBWFB min, W, BANKED
8060  51EE     MOVF dt, W, BANKED
8062  59F4     SUBWFB pco, W, BANKED
8064  51F5     MOVF max, W, BANKED
8066  0A80     XORLW 0x80
8068  6FF0     MOVWF p, BANKED
806A  51EF     MOVF 0xEF, W, BANKED
806C  0A80     XORLW 0x80
806E  59F0     SUBWFB p, W, BANKED
8070  E204     BC 0x807A
2156:                  rgl.srp = (rgl.xmod - m); //przygotowanie lagodnego przejscia do fazy 1
8072  51F2     MOVF tid, W, BANKED
8074  0800     SUBLW 0x0
8076  243C     ADDWF 0x3C, W, ACCESS
8078  6E3B     MOVWF 0x3B, ACCESS
2157:              m += rgl.srp;
807A  503B     MOVF 0x3B, W, ACCESS
807C  0100     MOVLB 0x0
807E  27F2     ADDWF tid, F, BANKED
8080  0E00     MOVLW 0x0
8082  23F3     ADDWFC min, F, BANKED
8084  23F4     ADDWFC pco, F, BANKED
8086  23F5     ADDWFC max, F, BANKED
2158:              if(m > rgl.xmod) p = rgl.xmod;
8088  C03C     MOVFF 0x3C, dt
808A  F0EC     NOP
808C  6BED     CLRF min, BANKED
808E  6BEE     CLRF dt, BANKED
8090  6BEF     CLRF 0xEF, BANKED
8092  51F2     MOVF tid, W, BANKED
8094  5DEC     SUBWF dt, W, BANKED
8096  51F3     MOVF min, W, BANKED
8098  59ED     SUBWFB min, W, BANKED
809A  51F4     MOVF pco, W, BANKED
809C  59EE     SUBWFB dt, W, BANKED
809E  51EF     MOVF 0xEF, W, BANKED
80A0  0A80     XORLW 0x80
80A2  6FF0     MOVWF p, BANKED
80A4  51F5     MOVF max, W, BANKED
80A6  0A80     XORLW 0x80
80A8  59F0     SUBWFB p, W, BANKED
80AA  E203     BC 0x80B2
80AC  C03C     MOVFF 0x3C, m
80AE  F0F1     NOP
80B0  D002     BRA 0x80B6
2159:              else p = m;
80B2  C0F2     MOVFF tid, m
80B4  F0F1     NOP
2160:              rglf_fz = 0; //przejscie do fazy1 przy aktywnej fazie2
80B6  9815     BCF rglf_btcw, 4, ACCESS
2161:              rgl.tmp_pwm = p;
80B8  C0F1     MOVFF m, 0x3D
80BA  F03D     NOP
2162:          }
80BC  0012     RETURN 0
2163:          //-------------------------------------------------------------
2164:          //drugie przyblizenie (tylko dla fazy 2)
2165:          
2166:          void ModDkCW2(void)
2167:          {
2168:              signed long m;
2169:              signed char ada;
2170:              unsigned char k, p;
2171:          
2172:              if(!rglf_fz) return; //wyjscie jesli aktualnie faza 1
BD20  A815     BTFSS rglf_btcw, 4, ACCESS
BD22  0012     RETURN 0
BD24  D001     BRA 0xBD28
BD26  0012     RETURN 0
2173:              ada = DtCW.AC_CW - DtCW.DAD_CW;
BD28  0100     MOVLB 0x0
BD2A  51B6     MOVF 0xB6, W, BANKED
BD2C  0800     SUBLW 0x0
BD2E  25B4     ADDWF 0xB4, W, BANKED
BD30  6FEB     MOVWF pop, BANKED
2174:              k = 9; //9
BD32  0E09     MOVLW 0x9
BD34  0100     MOVLB 0x0
BD36  6FE9     MOVWF p, BANKED
2175:              if(ada < 0) k = 8; //8
BD38  0100     MOVLB 0x0
BD3A  AFEB     BTFSS pop, 7, BANKED
BD3C  D003     BRA 0xBD44
BD3E  0E08     MOVLW 0x8
BD40  6FE9     MOVWF p, BANKED
BD42  D000     BRA 0xBD44
2176:              m = rgl.srp + k*ada;
BD44  C0E9     MOVFF p, __pcstackBANK0
BD46  F0DE     NOP
BD48  0100     MOVLB 0x0
BD4A  6BDF     CLRF pco, BANKED
BD4C  51EB     MOVF pop, W, BANKED
BD4E  6FE0     MOVWF bdat, BANKED
BD50  6BE1     CLRF GIE_BIT_VAL, BANKED
BD52  BFE0     BTFSC bdat, 7, BANKED
BD54  07E1     DECF GIE_BIT_VAL, F, BANKED
BD56  EC5B     CALL 0xECB6, 0
BD58  F076     NOP
BD5A  503B     MOVF 0x3B, W, ACCESS
BD5C  0100     MOVLB 0x0
BD5E  6FE4     MOVWF k, BANKED
BD60  6BE5     CLRF k, BANKED
BD62  51DE     MOVF __pcstackBANK0, W, BANKED
BD64  27E4     ADDWF k, F, BANKED
BD66  51DF     MOVF pco, W, BANKED
BD68  23E5     ADDWFC k, F, BANKED
BD6A  C0E4     MOVFF k, dt
BD6C  F0EC     NOP
BD6E  C0E5     MOVFF k, min
BD70  F0ED     NOP
BD72  0E00     MOVLW 0x0
BD74  BFED     BTFSC min, 7, BANKED
BD76  0EFF     MOVLW 0xFF
BD78  6FEE     MOVWF dt, BANKED
BD7A  6FEF     MOVWF 0xEF, BANKED
2177:              if(m > rgl.xmod) p = rgl.xmod;
BD7C  C03C     MOVFF 0x3C, k
BD7E  F0E4     NOP
BD80  0100     MOVLB 0x0
BD82  6BE5     CLRF k, BANKED
BD84  6BE6     CLRF counter, BANKED
BD86  6BE7     CLRF sign, BANKED
BD88  51EC     MOVF dt, W, BANKED
BD8A  5DE4     SUBWF k, W, BANKED
BD8C  51ED     MOVF min, W, BANKED
BD8E  59E5     SUBWFB k, W, BANKED
BD90  51EE     MOVF dt, W, BANKED
BD92  59E6     SUBWFB counter, W, BANKED
BD94  51E7     MOVF sign, W, BANKED
BD96  0A80     XORLW 0x80
BD98  6FE8     MOVWF quotient, BANKED
BD9A  51EF     MOVF 0xEF, W, BANKED
BD9C  0A80     XORLW 0x80
BD9E  59E8     SUBWFB quotient, W, BANKED
BDA0  E203     BC 0xBDA8
BDA2  C03C     MOVFF 0x3C, tim
BDA4  F0EA     NOP
BDA6  D019     BRA 0xBDDA
2178:              else
2179:                  if(m < PWM.MDMOD) p = PWM.MDMOD;
BDA8  C067     MOVFF _PFNf_b_set_ncw, k
BDAA  F0E4     NOP
BDAC  0100     MOVLB 0x0
BDAE  6BE5     CLRF k, BANKED
BDB0  6BE6     CLRF counter, BANKED
BDB2  6BE7     CLRF sign, BANKED
BDB4  51E4     MOVF k, W, BANKED
BDB6  5DEC     SUBWF dt, W, BANKED
BDB8  51E5     MOVF k, W, BANKED
BDBA  59ED     SUBWFB min, W, BANKED
BDBC  51E6     MOVF counter, W, BANKED
BDBE  59EE     SUBWFB dt, W, BANKED
BDC0  51EF     MOVF 0xEF, W, BANKED
BDC2  0A80     XORLW 0x80
BDC4  6FE8     MOVWF quotient, BANKED
BDC6  51E7     MOVF sign, W, BANKED
BDC8  0A80     XORLW 0x80
BDCA  59E8     SUBWFB quotient, W, BANKED
BDCC  E203     BC 0xBDD4
BDCE  C067     MOVFF _PFNf_b_set_ncw, tim
BDD0  F0EA     NOP
BDD2  D003     BRA 0xBDDA
2180:              else p = m;
BDD4  C0EC     MOVFF dt, tim
BDD6  F0EA     NOP
BDD8  D000     BRA 0xBDDA
2181:              rgl.tmp_pwm = p;
BDDA  C0EA     MOVFF tim, 0x3D
BDDC  F03D     NOP
2182:          }
BDDE  0012     RETURN 0
2183:          //-------------------------------------------------------------
2184:          //trzecie przyblizenie
2185:          //nowa wartosc punktu rownowagi srp.
2186:          //wykonywane co krok czasowy
2187:          
2188:          void ModPruCW2(void)
2189:          {
2190:              static unsigned char l, m, o, p, q, r, s;
2191:              unsigned char tmp;
2192:              signed char k;
2193:              if(!rglf_fz) //aktualnie faza 1?
448C  B815     BTFSC rglf_btcw, 4, ACCESS
448E  D0B2     BRA 0x45F4
2194:              {
2195:                  l = 0;
4490  0101     MOVLB 0x1
4492  6B4E     CLRF 0x4E, BANKED
2196:                  m = 0;
4494  6B4F     CLRF 0x4F, BANKED
2197:                  o = 0;
4496  6B50     CLRF 0x50, BANKED
2198:                  p = 0;
4498  6B51     CLRF 0x51, BANKED
2199:                  if(q < 255) q++; //licznik sekund
449A  0101     MOVLB 0x1
449C  2952     INCF 0x52, W, BANKED
449E  E002     BZ 0x44A4
44A0  2B52     INCF 0x52, F, BANKED
44A2  D000     BRA 0x44A4
2200:                  if(s < 255) s++; //licznik sekund
44A4  0101     MOVLB 0x1
44A6  2954     INCF 0x54, W, BANKED
44A8  E002     BZ 0x44AE
44AA  2B54     INCF 0x54, F, BANKED
44AC  D000     BRA 0x44AE
2201:                  if(DtCWf_newPCW) s = 0; //zmieniono nastawe?
44AE  AC04     BTFSS DtCWf_err_CW, 6, ACCESS
44B0  D003     BRA 0x44B8
44B2  0101     MOVLB 0x1
44B4  6B54     CLRF 0x54, BANKED
44B6  D000     BRA 0x44B8
2202:                  if(Tnizsza(0)) //Tcw<Tnst?
44B8  0E00     MOVLW 0x0
44BA  ECDA     CALL 0xEFB4, 0
44BC  F077     NOP
44BE  A0D8     BTFSS STATUS, 0, ACCESS
44C0  0012     RETURN 0
2203:                  {
2204:                      if(!Tnizsza(10)) //Tnst-Tcw<=10 ?
44C2  0E0A     MOVLW 0xA
44C4  ECDA     CALL 0xEFB4, 0
44C6  F077     NOP
44C8  B0D8     BTFSC STATUS, 0, ACCESS
44CA  0012     RETURN 0
2205:                      {
2206:                          k = 0;
44CC  0100     MOVLB 0x0
44CE  6BEA     CLRF tim, BANKED
2207:                          if((Trosnie(1) || TFrosnie(1)) && s >= 1) //szybki narost temperatury
44D0  0E01     MOVLW 0x1
44D2  ECE8     CALL 0xEFD0, 0
44D4  F077     NOP
44D6  E204     BC 0x44E0
44D8  0E01     MOVLW 0x1
44DA  ECF6     CALL 0xEFEC, 0
44DC  F077     NOP
44DE  E312     BNC 0x4504
44E0  0101     MOVLB 0x1
44E2  5154     MOVF 0x54, W, BANKED
44E4  E00F     BZ 0x4504
2208:                          {
2209:                              s = 0;
44E6  6B54     CLRF 0x54, BANKED
2210:                              k = 10;
44E8  0E0A     MOVLW 0xA
44EA  0100     MOVLB 0x0
44EC  6FEA     MOVWF tim, BANKED
2211:                              if(Trosnie(2) || TFrosnie(2)) k = 8; //b.szybki narost temperatury?
44EE  0E02     MOVLW 0x2
44F0  ECE8     CALL 0xEFD0, 0
44F2  F077     NOP
44F4  E204     BC 0x44FE
44F6  0E02     MOVLW 0x2
44F8  ECF6     CALL 0xEFEC, 0
44FA  F077     NOP
44FC  E320     BNC 0x453E
44FE  0E08     MOVLW 0x8
4500  D00A     BRA 0x4516
2212:                          }
4502  D01D     BRA 0x453E
2213:                          else
2214:                              if(TFmaleje(0) && q >= 1)
4504  0E00     MOVLW 0x0
4506  EC8D     CALL 0xE71A, 0
4508  F073     NOP
450A  E308     BNC 0x451C
450C  0101     MOVLB 0x1
450E  5152     MOVF 0x52, W, BANKED
4510  E005     BZ 0x451C
2215:                          {
2216:                              q = 0;
4512  6B52     CLRF 0x52, BANKED
2217:                              k = 6;
4514  0E06     MOVLW 0x6
4516  0100     MOVLB 0x0
4518  6FEA     MOVWF tim, BANKED
2218:                          }
451A  D011     BRA 0x453E
2219:                          else
2220:                              if(TFstoi())
451C  EC9E     CALL 0xF33C, 0
451E  F079     NOP
4520  E30E     BNC 0x453E
2221:                          {
2222:                              if(r >= 1)
4522  0101     MOVLB 0x1
4524  5153     MOVF 0x53, W, BANKED
4526  E006     BZ 0x4534
2223:                              {
2224:                                  k = 6;
4528  0E06     MOVLW 0x6
452A  0100     MOVLB 0x0
452C  6FEA     MOVWF tim, BANKED
2225:                                  r = 0;
452E  0101     MOVLB 0x1
4530  6B53     CLRF 0x53, BANKED
2226:                              }
4532  D005     BRA 0x453E
2227:                              else
2228:                              {
2229:                                  k = 0;
4534  0100     MOVLB 0x0
4536  6BEA     CLRF tim, BANKED
2230:                                  r++;
4538  0101     MOVLB 0x1
453A  2B53     INCF 0x53, F, BANKED
2231:                              }
2232:                          }
2233:                          rgl.ytmp = 0;
453C  D000     BRA 0x453E
453E  6A3A     CLRF 0x3A, ACCESS
2234:                          if(PWM.BufPWM > rgl.xmod) return;
4540  0100     MOVLB 0x0
4542  5160     MOVF PWM, W, BANKED
4544  5C3C     SUBWF 0x3C, W, ACCESS
4546  A0D8     BTFSS STATUS, 0, ACCESS
4548  0012     RETURN 0
454A  D001     BRA 0x454E
454C  0012     RETURN 0
2235:                          tmp = rgl.xmod - PWM.BufPWM;
454E  0100     MOVLB 0x0
4550  5160     MOVF PWM, W, BANKED
4552  0800     SUBLW 0x0
4554  243C     ADDWF 0x3C, W, ACCESS
4556  6FE9     MOVWF p, BANKED
2236:                          if(k > tmp) k = tmp;
4558  51E9     MOVF p, W, BANKED
455A  80D8     BSF STATUS, 0, ACCESS
455C  84D8     BSF STATUS, 2, ACCESS
455E  AFEA     BTFSS tim, 7, BANKED
4560  5DEA     SUBWF tim, W, BANKED
4562  A0D8     BTFSS STATUS, 0, ACCESS
4564  84D8     BSF STATUS, 2, ACCESS
4566  E003     BZ 0x456E
4568  C0E9     MOVFF p, tim
456A  F0EA     NOP
456C  D000     BRA 0x456E
2237:                          //if(rgl.srp+k>PWM.MGMOD) rgl.srp=PWM.MGMOD;
2238:                          //else rgl.srp+=k;
2239:                          if(PWM.MMAXCW > PWM.MGMOD)
456E  0100     MOVLB 0x0
4570  517E     MOVF _PFNf_obgCW, W, BANKED
4572  5D6A     SUBWF _PFNf_blkcs, W, BANKED
4574  E21F     BC 0x45B4
2240:                          {
2241:                              if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
4576  C0EA     MOVFF tim, divisor
4578  F0E2     NOP
457A  6BE3     CLRF a, BANKED
457C  BFE2     BTFSC divisor, 7, BANKED
457E  07E3     DECF a, F, BANKED
4580  503B     MOVF 0x3B, W, ACCESS
4582  6FE4     MOVWF k, BANKED
4584  6BE5     CLRF k, BANKED
4586  51E2     MOVF divisor, W, BANKED
4588  27E4     ADDWF k, F, BANKED
458A  51E3     MOVF a, W, BANKED
458C  23E5     ADDWFC k, F, BANKED
458E  516A     MOVF _PFNf_blkcs, W, BANKED
4590  6FE6     MOVWF counter, BANKED
4592  6BE7     CLRF sign, BANKED
4594  51E4     MOVF k, W, BANKED
4596  5DE6     SUBWF counter, W, BANKED
4598  51E7     MOVF sign, W, BANKED
459A  0A80     XORLW 0x80
459C  6FE8     MOVWF quotient, BANKED
459E  51E5     MOVF k, W, BANKED
45A0  0A80     XORLW 0x80
45A2  59E8     SUBWFB quotient, W, BANKED
45A4  E203     BC 0x45AC
45A6  C06A     MOVFF _PFNf_blkcs, 0x3B
45A8  F03B     NOP
45AA  0012     RETURN 0
2242:                              else rgl.srp += k;
45AC  0100     MOVLB 0x0
45AE  51EA     MOVF tim, W, BANKED
45B0  263B     ADDWF 0x3B, F, ACCESS
2243:                          }
45B2  0012     RETURN 0
2244:                          else
2245:                          {
2246:                              if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
45B4  C0EA     MOVFF tim, divisor
45B6  F0E2     NOP
45B8  0100     MOVLB 0x0
45BA  6BE3     CLRF a, BANKED
45BC  BFE2     BTFSC divisor, 7, BANKED
45BE  07E3     DECF a, F, BANKED
45C0  503B     MOVF 0x3B, W, ACCESS
45C2  6FE4     MOVWF k, BANKED
45C4  6BE5     CLRF k, BANKED
45C6  51E2     MOVF divisor, W, BANKED
45C8  27E4     ADDWF k, F, BANKED
45CA  51E3     MOVF a, W, BANKED
45CC  23E5     ADDWFC k, F, BANKED
45CE  517E     MOVF _PFNf_obgCW, W, BANKED
45D0  6FE6     MOVWF counter, BANKED
45D2  6BE7     CLRF sign, BANKED
45D4  51E4     MOVF k, W, BANKED
45D6  5DE6     SUBWF counter, W, BANKED
45D8  51E7     MOVF sign, W, BANKED
45DA  0A80     XORLW 0x80
45DC  6FE8     MOVWF quotient, BANKED
45DE  51E5     MOVF k, W, BANKED
45E0  0A80     XORLW 0x80
45E2  59E8     SUBWFB quotient, W, BANKED
45E4  E203     BC 0x45EC
45E6  C07E     MOVFF _PFNf_obgCW, 0x3B
45E8  F03B     NOP
45EA  0012     RETURN 0
2247:                              else rgl.srp += k;
45EC  0100     MOVLB 0x0
45EE  51EA     MOVF tim, W, BANKED
45F0  263B     ADDWF 0x3B, F, ACCESS
2248:                          }
2249:                          return;
2250:                      }
2251:                      else return;
2252:                  }
2253:                  else return;
2254:              }
45F2  0012     RETURN 0
2255:              else //aktualnie faza 2
2256:              {
2257:                  q = 0;
45F4  0101     MOVLB 0x1
45F6  6B52     CLRF 0x52, BANKED
2258:                  r = 0;
45F8  6B53     CLRF 0x53, BANKED
2259:                  s = 0;
45FA  6B54     CLRF 0x54, BANKED
2260:                  if(m < 255) m++; //licznik sekund dla spadku temp CO
45FC  0101     MOVLB 0x1
45FE  294F     INCF 0x4F, W, BANKED
4600  E002     BZ 0x4606
4602  2B4F     INCF 0x4F, F, BANKED
4604  D000     BRA 0x4606
2261:                  if(p < 255) p++; //licznik sekund dla spadku temp CO
4606  0101     MOVLB 0x1
4608  2951     INCF 0x51, W, BANKED
460A  E002     BZ 0x4610
460C  2B51     INCF 0x51, F, BANKED
460E  D000     BRA 0x4610
2262:                  if(o < 255) o++; //licznik sekund dla narostu temp CO
4610  0101     MOVLB 0x1
4612  2950     INCF 0x50, W, BANKED
4614  E002     BZ 0x461A
4616  2B50     INCF 0x50, F, BANKED
4618  D000     BRA 0x461A
2263:                  if(DtCW.DAD_CW > DtCW.AC_CW) //Tcw>Tnst ?
461A  0100     MOVLB 0x0
461C  51B6     MOVF 0xB6, W, BANKED
461E  5DB4     SUBWF 0xB4, W, BANKED
4620  E301     BNC 0x4624
4622  D08B     BRA 0x473A
2264:                  {
2265:                      k = 0;
4624  6BEA     CLRF tim, BANKED
2266:                      if(TFmaleje(0) && !Twyzsza(0) && p >= 2) //(Tmaleje(0)||TFmaleje(0)
4626  0E00     MOVLW 0x0
4628  EC8D     CALL 0xE71A, 0
462A  F073     NOP
462C  E30F     BNC 0x464C
462E  0E00     MOVLW 0x0
4630  ECC5     CALL 0xE78A, 0
4632  F073     NOP
4634  E20B     BC 0x464C
4636  0E01     MOVLW 0x1
4638  0101     MOVLB 0x1
463A  6551     CPFSGT 0x51, BANKED
463C  D007     BRA 0x464C
2267:                      {
2268:                          p = 0;
463E  6B51     CLRF 0x51, BANKED
2269:                          o = 0;
4640  6B50     CLRF 0x50, BANKED
2270:                          l = 0;
4642  6B4E     CLRF 0x4E, BANKED
2271:                          m = 0;
4644  6B4F     CLRF 0x4F, BANKED
2272:                          k = -1; //1
4646  0100     MOVLB 0x0
4648  69EA     SETF tim, BANKED
2273:                      }
464A  D046     BRA 0x46D8
2274:                      else
2275:                          if(TFrosnie(0) && o >= 2)
464C  0E00     MOVLW 0x0
464E  ECF6     CALL 0xEFEC, 0
4650  F077     NOP
4652  E312     BNC 0x4678
4654  0E01     MOVLW 0x1
4656  0101     MOVLB 0x1
4658  6550     CPFSGT 0x50, BANKED
465A  D00E     BRA 0x4678
2276:                      {
2277:                          o = 0;
465C  0E00     MOVLW 0x0
465E  6F50     MOVWF 0x50, BANKED
2278:                          p = 0;
4660  6F51     MOVWF 0x51, BANKED
2279:                          l = 0;
4662  6F4E     MOVWF 0x4E, BANKED
2280:                          m = 0;
4664  6F4F     MOVWF 0x4F, BANKED
2281:                          k = 2; //3
4666  0E02     MOVLW 0x2
4668  0100     MOVLB 0x0
466A  6FEA     MOVWF tim, BANKED
2282:                          if(Trowna()) k = 1;
466C  ECA5     CALL 0xF34A, 0
466E  F079     NOP
4670  E333     BNC 0x46D8
4672  0E01     MOVLW 0x1
4674  D00E     BRA 0x4692
2283:                      }
4676  D030     BRA 0x46D8
2284:                      else
2285:                          if(Trosnie(0) && m >= 2)
4678  0E00     MOVLW 0x0
467A  ECE8     CALL 0xEFD0, 0
467C  F077     NOP
467E  E30C     BNC 0x4698
4680  0E01     MOVLW 0x1
4682  0101     MOVLB 0x1
4684  654F     CPFSGT 0x4F, BANKED
4686  D008     BRA 0x4698
2286:                      {
2287:                          p = 0;
4688  6B51     CLRF 0x51, BANKED
2288:                          o = 0;
468A  6B50     CLRF 0x50, BANKED
2289:                          l = 0;
468C  6B4E     CLRF 0x4E, BANKED
2290:                          m = 0;
468E  6B4F     CLRF 0x4F, BANKED
2291:                          k = 3; //2
4690  0E03     MOVLW 0x3
4692  0100     MOVLB 0x0
4694  6FEA     MOVWF tim, BANKED
2292:                      }
4696  D020     BRA 0x46D8
2293:                      else
2294:                          if(Twyzsza(1)) //gdy jest powyzej zakresu nastawa+1
4698  0E01     MOVLW 0x1
469A  ECC5     CALL 0xE78A, 0
469C  F073     NOP
469E  E319     BNC 0x46D2
2295:                      {
2296:                          if(Tstoi() && TFstoi())
46A0  ECAC     CALL 0xF358, 0
46A2  F079     NOP
46A4  E319     BNC 0x46D8
46A6  EC9E     CALL 0xF33C, 0
46A8  F079     NOP
46AA  E316     BNC 0x46D8
2297:                          {
2298:                              if(l >= 2)
46AC  0E01     MOVLW 0x1
46AE  0101     MOVLB 0x1
46B0  654E     CPFSGT 0x4E, BANKED
46B2  D00A     BRA 0x46C8
2299:                              {
2300:                                  k = 1;
46B4  0100     MOVLB 0x0
46B6  6FEA     MOVWF tim, BANKED
2301:                                  if(Twyzsza(3)) k = 2;
46B8  0E03     MOVLW 0x3
46BA  ECC5     CALL 0xE78A, 0
46BC  F073     NOP
46BE  E309     BNC 0x46D2
46C0  0E02     MOVLW 0x2
46C2  0100     MOVLB 0x0
46C4  6FEA     MOVWF tim, BANKED
46C6  D005     BRA 0x46D2
2302:                                  l = 0;
2303:                              }
2304:                              else
2305:                              {
2306:                                  k = 0;
46C8  0100     MOVLB 0x0
46CA  6BEA     CLRF tim, BANKED
2307:                                  l++;
46CC  0101     MOVLB 0x1
46CE  2B4E     INCF 0x4E, F, BANKED
2308:                              }
2309:                          }
2310:                      }
46D0  D003     BRA 0x46D8
2311:                      else l = 0;
46D2  0101     MOVLB 0x1
46D4  6B4E     CLRF 0x4E, BANKED
46D6  D000     BRA 0x46D8
2312:                      if(rgl.srp - k < PWM.MDMOD) rgl.srp = PWM.MDMOD;
46D8  0100     MOVLB 0x0
46DA  5167     MOVF _PFNf_b_set_ncw, W, BANKED
46DC  6FE2     MOVWF divisor, BANKED
46DE  6BE3     CLRF a, BANKED
46E0  C0EA     MOVFF tim, k
46E2  F0E4     NOP
46E4  6BE5     CLRF k, BANKED
46E6  BFE4     BTFSC k, 7, BANKED
46E8  07E5     DECF k, F, BANKED
46EA  1FE4     COMF k, F, BANKED
46EC  1FE5     COMF k, F, BANKED
46EE  4BE4     INFSNZ k, F, BANKED
46F0  2BE5     INCF k, F, BANKED
46F2  503B     MOVF 0x3B, W, ACCESS
46F4  6FE6     MOVWF counter, BANKED
46F6  6BE7     CLRF sign, BANKED
46F8  51E4     MOVF k, W, BANKED
46FA  27E6     ADDWF counter, F, BANKED
46FC  51E5     MOVF k, W, BANKED
46FE  23E7     ADDWFC sign, F, BANKED
4700  51E2     MOVF divisor, W, BANKED
4702  5DE6     SUBWF counter, W, BANKED
4704  51E7     MOVF sign, W, BANKED
4706  0A80     XORLW 0x80
4708  6FE8     MOVWF quotient, BANKED
470A  51E3     MOVF a, W, BANKED
470C  0A80     XORLW 0x80
470E  59E8     SUBWFB quotient, W, BANKED
4710  E203     BC 0x4718
4712  C067     MOVFF _PFNf_b_set_ncw, 0x3B
4714  F03B     NOP
4716  D003     BRA 0x471E
2313:                      else rgl.srp -= k;
4718  0100     MOVLB 0x0
471A  51EA     MOVF tim, W, BANKED
471C  5E3B     SUBWF 0x3B, F, ACCESS
2314:                      if(rgl.srp > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
471E  503B     MOVF 0x3B, W, ACCESS
4720  0100     MOVLB 0x0
4722  5D7E     SUBWF _PFNf_obgCW, W, BANKED
4724  E203     BC 0x472C
4726  C07E     MOVFF _PFNf_obgCW, 0x3B
4728  F03B     NOP
472A  D000     BRA 0x472C
2315:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
472C  503B     MOVF 0x3B, W, ACCESS
472E  5C3C     SUBWF 0x3C, W, ACCESS
4730  B0D8     BTFSC STATUS, 0, ACCESS
4732  0012     RETURN 0
4734  C03B     MOVFF 0x3B, 0x3C
4736  F03C     NOP
2316:                      return;
2317:                  }
4738  0012     RETURN 0
2318:                  else //Tcw<Tnst
2319:                  {
2320:                      k = 0;
473A  0100     MOVLB 0x0
473C  6BEA     CLRF tim, BANKED
2321:                      if(TFrosnie(0) && o >= 2) //(Trosnie(0)||TFrosnie(0))
473E  0E00     MOVLW 0x0
4740  ECF6     CALL 0xEFEC, 0
4742  F077     NOP
4744  E312     BNC 0x476A
4746  0E01     MOVLW 0x1
4748  0101     MOVLB 0x1
474A  6550     CPFSGT 0x50, BANKED
474C  D00E     BRA 0x476A
2322:                      {
2323:                          o = 0;
474E  0E00     MOVLW 0x0
4750  6F50     MOVWF 0x50, BANKED
2324:                          p = 0;
4752  6F51     MOVWF 0x51, BANKED
2325:                          l = 0;
4754  6F4E     MOVWF 0x4E, BANKED
2326:                          m = 0;
4756  6F4F     MOVWF 0x4F, BANKED
2327:                          k = -3;
4758  0EFD     MOVLW 0xFD
475A  0100     MOVLB 0x0
475C  6FEA     MOVWF tim, BANKED
2328:                          if(Trowna()) k = -2;
475E  ECA5     CALL 0xF34A, 0
4760  F079     NOP
4762  E349     BNC 0x47F6
4764  0EFE     MOVLW 0xFE
4766  D02B     BRA 0x47BE
2329:                      }
4768  D046     BRA 0x47F6
2330:                      else
2331:                          if(TFmaleje(0) && p >= 2)
476A  0E00     MOVLW 0x0
476C  EC8D     CALL 0xE71A, 0
476E  F073     NOP
4770  E312     BNC 0x4796
4772  0E01     MOVLW 0x1
4774  0101     MOVLB 0x1
4776  6551     CPFSGT 0x51, BANKED
4778  D00E     BRA 0x4796
2332:                      {
2333:                          p = 0;
477A  0E00     MOVLW 0x0
477C  6F51     MOVWF 0x51, BANKED
2334:                          o = 0;
477E  6F50     MOVWF 0x50, BANKED
2335:                          l = 0;
4780  6F4E     MOVWF 0x4E, BANKED
2336:                          m = 0;
4782  6F4F     MOVWF 0x4F, BANKED
2337:                          k = 2; //3
4784  0E02     MOVLW 0x2
4786  0100     MOVLB 0x0
4788  6FEA     MOVWF tim, BANKED
2338:                          if(Trowna()) k = 1;
478A  ECA5     CALL 0xF34A, 0
478C  F079     NOP
478E  E333     BNC 0x47F6
4790  0E01     MOVLW 0x1
4792  D015     BRA 0x47BE
2339:                      }
4794  D030     BRA 0x47F6
2340:                      else
2341:                          if(Tmaleje(0) && m >= 2)
4796  0E00     MOVLW 0x0
4798  ECA9     CALL 0xE752, 0
479A  F073     NOP
479C  E313     BNC 0x47C4
479E  0E01     MOVLW 0x1
47A0  0101     MOVLB 0x1
47A2  654F     CPFSGT 0x4F, BANKED
47A4  D00F     BRA 0x47C4
2342:                      {
2343:                          p = 0;
47A6  6B51     CLRF 0x51, BANKED
2344:                          o = 0;
47A8  6B50     CLRF 0x50, BANKED
2345:                          l = 0;
47AA  6B4E     CLRF 0x4E, BANKED
2346:                          m = 0;
47AC  6B4F     CLRF 0x4F, BANKED
2347:                          k = 2;
47AE  0E02     MOVLW 0x2
47B0  0100     MOVLB 0x0
47B2  6FEA     MOVWF tim, BANKED
2348:                          if(Tnizsza(0)) k = 3; //3
47B4  0E00     MOVLW 0x0
47B6  ECDA     CALL 0xEFB4, 0
47B8  F077     NOP
47BA  E31D     BNC 0x47F6
47BC  0E03     MOVLW 0x3
47BE  0100     MOVLB 0x0
47C0  6FEA     MOVWF tim, BANKED
2349:                      }
47C2  D019     BRA 0x47F6
2350:                      else
2351:                          if(Tnizsza(1))
47C4  0E01     MOVLW 0x1
47C6  ECDA     CALL 0xEFB4, 0
47C8  F077     NOP
47CA  E312     BNC 0x47F0
2352:                      {
2353:                          if(Tstoi() && TFstoi())
47CC  ECAC     CALL 0xF358, 0
47CE  F079     NOP
47D0  E312     BNC 0x47F6
47D2  EC9E     CALL 0xF33C, 0
47D4  F079     NOP
47D6  E30F     BNC 0x47F6
2354:                          {
2355:                              if(l >= 3)
47D8  0E02     MOVLW 0x2
47DA  0101     MOVLB 0x1
47DC  654E     CPFSGT 0x4E, BANKED
47DE  D003     BRA 0x47E6
2356:                              {
2357:                                  k = 2;
47E0  0100     MOVLB 0x0
47E2  6FEA     MOVWF tim, BANKED
47E4  D005     BRA 0x47F0
2358:                                  l = 0;
2359:                              }
2360:                              else
2361:                              {
2362:                                  k = 0;
47E6  0100     MOVLB 0x0
47E8  6BEA     CLRF tim, BANKED
2363:                                  l++;
47EA  0101     MOVLB 0x1
47EC  2B4E     INCF 0x4E, F, BANKED
2364:                              }
2365:                          }
2366:                      }
47EE  D003     BRA 0x47F6
2367:                      else l = 0;
47F0  0101     MOVLB 0x1
47F2  6B4E     CLRF 0x4E, BANKED
47F4  D000     BRA 0x47F6
2368:                      if(PWM.MMAXCW > PWM.MGMOD)
47F6  0100     MOVLB 0x0
47F8  517E     MOVF _PFNf_obgCW, W, BANKED
47FA  5D6A     SUBWF _PFNf_blkcs, W, BANKED
47FC  E21F     BC 0x483C
2369:                      {
2370:                          if(rgl.srp + k > PWM.MGMOD) rgl.srp = PWM.MGMOD;
47FE  C0EA     MOVFF tim, divisor
4800  F0E2     NOP
4802  6BE3     CLRF a, BANKED
4804  BFE2     BTFSC divisor, 7, BANKED
4806  07E3     DECF a, F, BANKED
4808  503B     MOVF 0x3B, W, ACCESS
480A  6FE4     MOVWF k, BANKED
480C  6BE5     CLRF k, BANKED
480E  51E2     MOVF divisor, W, BANKED
4810  27E4     ADDWF k, F, BANKED
4812  51E3     MOVF a, W, BANKED
4814  23E5     ADDWFC k, F, BANKED
4816  516A     MOVF _PFNf_blkcs, W, BANKED
4818  6FE6     MOVWF counter, BANKED
481A  6BE7     CLRF sign, BANKED
481C  51E4     MOVF k, W, BANKED
481E  5DE6     SUBWF counter, W, BANKED
4820  51E7     MOVF sign, W, BANKED
4822  0A80     XORLW 0x80
4824  6FE8     MOVWF quotient, BANKED
4826  51E5     MOVF k, W, BANKED
4828  0A80     XORLW 0x80
482A  59E8     SUBWFB quotient, W, BANKED
482C  E203     BC 0x4834
482E  C06A     MOVFF _PFNf_blkcs, 0x3B
4830  F03B     NOP
4832  D024     BRA 0x487C
2371:                          else rgl.srp += k;
4834  0100     MOVLB 0x0
4836  51EA     MOVF tim, W, BANKED
4838  263B     ADDWF 0x3B, F, ACCESS
2372:                      }
483A  D020     BRA 0x487C
2373:                      else
2374:                      {
2375:                          if(rgl.srp + k > PWM.MMAXCW) rgl.srp = PWM.MMAXCW;
483C  C0EA     MOVFF tim, divisor
483E  F0E2     NOP
4840  0100     MOVLB 0x0
4842  6BE3     CLRF a, BANKED
4844  BFE2     BTFSC divisor, 7, BANKED
4846  07E3     DECF a, F, BANKED
4848  503B     MOVF 0x3B, W, ACCESS
484A  6FE4     MOVWF k, BANKED
484C  6BE5     CLRF k, BANKED
484E  51E2     MOVF divisor, W, BANKED
4850  27E4     ADDWF k, F, BANKED
4852  51E3     MOVF a, W, BANKED
4854  23E5     ADDWFC k, F, BANKED
4856  517E     MOVF _PFNf_obgCW, W, BANKED
4858  6FE6     MOVWF counter, BANKED
485A  6BE7     CLRF sign, BANKED
485C  51E4     MOVF k, W, BANKED
485E  5DE6     SUBWF counter, W, BANKED
4860  51E7     MOVF sign, W, BANKED
4862  0A80     XORLW 0x80
4864  6FE8     MOVWF quotient, BANKED
4866  51E5     MOVF k, W, BANKED
4868  0A80     XORLW 0x80
486A  59E8     SUBWFB quotient, W, BANKED
486C  E203     BC 0x4874
486E  C07E     MOVFF _PFNf_obgCW, 0x3B
4870  F03B     NOP
4872  D004     BRA 0x487C
2376:                          else rgl.srp += k;
4874  0100     MOVLB 0x0
4876  51EA     MOVF tim, W, BANKED
4878  263B     ADDWF 0x3B, F, ACCESS
487A  D000     BRA 0x487C
2377:                      }
2378:                      if(rgl.xmod < rgl.srp) rgl.xmod = rgl.srp;
487C  503B     MOVF 0x3B, W, ACCESS
487E  5C3C     SUBWF 0x3C, W, ACCESS
4880  B0D8     BTFSC STATUS, 0, ACCESS
4882  0012     RETURN 0
4884  C03B     MOVFF 0x3B, 0x3C
4886  F03C     NOP
2379:                      return;
2380:                  }
4888  0012     RETURN 0
2381:              }
2382:          }
488A  0012     RETURN 0
2383:          //-------------------------------------------------------------
2384:          //inkrementacja maksymalnej wartosci mocy na palniku
2385:          //wykonywane co krok czasowy
2386:          
2387:          void IncMaxCW2(void)
2388:          {
2389:              unsigned char k;
2390:          
2391:              //kontrola maksimum mocy dla fazy 2
2392:              if(rglf_fz) //faza 2 ?
CC82  A815     BTFSS rglf_btcw, 4, ACCESS
CC84  D013     BRA 0xCCAC
2393:              {
2394:                  if(PWM.MMAXCW > PWM.MGMOD)
CC86  0100     MOVLB 0x0
CC88  517E     MOVF _PFNf_obgCW, W, BANKED
CC8A  5D6A     SUBWF _PFNf_blkcs, W, BANKED
CC8C  E207     BC 0xCC9C
2395:                  {
2396:                      if(rgl.xmod > PWM.MGMOD) rgl.xmod = PWM.MGMOD;
CC8E  503C     MOVF 0x3C, W, ACCESS
CC90  5D6A     SUBWF _PFNf_blkcs, W, BANKED
CC92  B0D8     BTFSC STATUS, 0, ACCESS
CC94  0012     RETURN 0
CC96  C06A     MOVFF _PFNf_blkcs, 0x3C
CC98  F03C     NOP
2397:                  }
CC9A  0012     RETURN 0
2398:                  else
2399:                  {
2400:                      if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
CC9C  503C     MOVF 0x3C, W, ACCESS
CC9E  0100     MOVLB 0x0
CCA0  5D7E     SUBWF _PFNf_obgCW, W, BANKED
CCA2  B0D8     BTFSC STATUS, 0, ACCESS
CCA4  0012     RETURN 0
CCA6  C07E     MOVFF _PFNf_obgCW, 0x3C
CCA8  F03C     NOP
2401:                  }
2402:                  return;
CCAA  0012     RETURN 0
2403:              }
2404:              //kontrolowany narost mocy dla fazy 1
2405:              if(Trosnie(1) || TFrosnie(1)) return; //(Tcw lub Tco rosnie szybciej niz 1K/sek)?
CCAC  0E01     MOVLW 0x1
CCAE  ECE8     CALL 0xEFD0, 0
CCB0  F077     NOP
CCB2  B0D8     BTFSC STATUS, 0, ACCESS
CCB4  0012     RETURN 0
CCB6  0E01     MOVLW 0x1
CCB8  ECF6     CALL 0xEFEC, 0
CCBA  F077     NOP
CCBC  B0D8     BTFSC STATUS, 0, ACCESS
CCBE  0012     RETURN 0
CCC0  D001     BRA 0xCCC4
CCC2  0012     RETURN 0
2406:              k = 5;
CCC4  0E05     MOVLW 0x5
CCC6  0100     MOVLB 0x0
CCC8  6FE1     MOVWF GIE_BIT_VAL, BANKED
2407:              if(rgl.xmod + k > _MG2_MOD) rgl.xmod = _MG2_MOD;
CCCA  0100     MOVLB 0x0
CCCC  51E1     MOVF GIE_BIT_VAL, W, BANKED
CCCE  C03C     MOVFF 0x3C, pco
CCD0  F0DF     NOP
CCD2  6BE0     CLRF bdat, BANKED
CCD4  27DF     ADDWF pco, F, BANKED
CCD6  0E00     MOVLW 0x0
CCD8  23E0     ADDWFC bdat, F, BANKED
CCDA  BFE0     BTFSC bdat, 7, BANKED
CCDC  D008     BRA 0xCCEE
CCDE  51E0     MOVF bdat, W, BANKED
CCE0  E103     BNZ 0xCCE8
CCE2  0EF1     MOVLW 0xF1
CCE4  5DDF     SUBWF pco, W, BANKED
CCE6  E303     BNC 0xCCEE
CCE8  0EF0     MOVLW 0xF0
CCEA  6E3C     MOVWF 0x3C, ACCESS
CCEC  D003     BRA 0xCCF4
2408:              else rgl.xmod += k;
CCEE  0100     MOVLB 0x0
CCF0  51E1     MOVF GIE_BIT_VAL, W, BANKED
CCF2  263C     ADDWF 0x3C, F, ACCESS
2409:              if(rgl.xmod > PWM.MMAXCW) rgl.xmod = PWM.MMAXCW;
CCF4  503C     MOVF 0x3C, W, ACCESS
CCF6  0100     MOVLB 0x0
CCF8  5D7E     SUBWF _PFNf_obgCW, W, BANKED
CCFA  A0D8     BTFSS STATUS, 0, ACCESS
CCFC  C07E     MOVFF _PFNf_obgCW, 0x3C
CCFE  F03C     NOP
CD00  0012     RETURN 0
2410:          }
CD02  0012     RETURN 0
2411:          //-------------------------------------------------------------
2412:          //reakcja superwizyjna
2413:          
2414:          void ModPrzCW2(void)
2415:          {
2416:              if(!rglf_nmod) //nie jest w trybie nmod?
DCBC  BE15     BTFSC rglf_btcw, 7, ACCESS
DCBE  D00C     BRA 0xDCD8
2417:              {
2418:                  if(!Tmaleje(0) && Twyzsza(3)) //(Tcw nie maleje ?)
DCC0  0E00     MOVLW 0x0
DCC2  ECA9     CALL 0xE752, 0
DCC4  F073     NOP
DCC6  B0D8     BTFSC STATUS, 0, ACCESS
DCC8  0012     RETURN 0
DCCA  0E03     MOVLW 0x3
DCCC  ECC5     CALL 0xE78A, 0
DCCE  F073     NOP
DCD0  A0D8     BTFSS STATUS, 0, ACCESS
DCD2  0012     RETURN 0
2419:                  {
2420:                      rglf_nmod = 1; //wejdz w tryb nmod
DCD4  8E15     BSF rglf_btcw, 7, ACCESS
2421:                  }
2422:              }
DCD6  0012     RETURN 0
2423:              else //jest w trybie nmod?
2424:              {
2425:                  if(!Twyzsza(3))
DCD8  0E03     MOVLW 0x3
DCDA  ECC5     CALL 0xE78A, 0
DCDC  F073     NOP
DCDE  B0D8     BTFSC STATUS, 0, ACCESS
DCE0  0012     RETURN 0
2426:                  {
2427:                      if(Tmaleje(0)) rglf_nmod = 0; //jezeli Tcw maleje wyjdz z trybu nmod
DCE2  0E00     MOVLW 0x0
DCE4  ECA9     CALL 0xE752, 0
DCE6  F073     NOP
DCE8  E302     BNC 0xDCEE
DCEA  9E15     BCF rglf_btcw, 7, ACCESS
DCEC  D000     BRA 0xDCEE
2428:                      if(Tstoi() && TFmaleje(0)) rglf_nmod = 0; //(Tcw stoi i Tco maleje) wyjdz z trybu nmod
DCEE  ECAC     CALL 0xF358, 0
DCF0  F079     NOP
DCF2  E306     BNC 0xDD00
DCF4  0E00     MOVLW 0x0
DCF6  EC8D     CALL 0xE71A, 0
DCF8  F073     NOP
DCFA  E302     BNC 0xDD00
DCFC  9E15     BCF rglf_btcw, 7, ACCESS
DCFE  D000     BRA 0xDD00
2429:                      if(Tnizsza(3)) rglf_nmod = 0;
DD00  0E03     MOVLW 0x3
DD02  ECDA     CALL 0xEFB4, 0
DD04  F077     NOP
DD06  A0D8     BTFSS STATUS, 0, ACCESS
DD08  0012     RETURN 0
DD0A  9E15     BCF rglf_btcw, 7, ACCESS
2430:                  }
DD0C  0012     RETURN 0
2431:              }
2432:          }
DD0E  0012     RETURN 0
2433:          //------------------------------------------------------------
2434:          //Zabezpieczenie od przegrzania w obwodzie CO
2435:          
2436:          void PropCO2(void)
2437:          {
2438:              if(!rglf_nmod) //nie jest w trybie nmod?
D87C  BE15     BTFSC rglf_btcw, 7, ACCESS
D87E  D02B     BRA 0xD8D6
2439:              {
2440:                  if(rgl.x_f == 3) //=86C ?
D880  0E03     MOVLW 0x3
D882  1837     XORWF 0x37, W, ACCESS
D884  E107     BNZ 0xD894
2441:                  {
2442:                      if(rgl.tmp_pwm > PWM.MGMOD)
D886  503D     MOVF 0x3D, W, ACCESS
D888  0100     MOVLB 0x0
D88A  5D6A     SUBWF _PFNf_blkcs, W, BANKED
D88C  E221     BC 0xD8D0
2443:                          rgl.tmp_pwm = PWM.MGMOD; //=MGMOD
D88E  C06A     MOVFF _PFNf_blkcs, 0x3D
D890  F03D     NOP
2444:                  }
D892  D01E     BRA 0xD8D0
2445:                  else
2446:                      if(rgl.x_f == 2) //=87C ?
D894  0E02     MOVLW 0x2
D896  1837     XORWF 0x37, W, ACCESS
D898  E107     BNZ 0xD8A8
2447:                  {
2448:                      if(rgl.tmp_pwm > PWM.PROP1)
D89A  503D     MOVF 0x3D, W, ACCESS
D89C  0100     MOVLB 0x0
D89E  5D79     SUBWF _PFNf_newPCO, W, BANKED
D8A0  E217     BC 0xD8D0
2449:                          rgl.tmp_pwm = PWM.PROP1; //-1/7
D8A2  C079     MOVFF _PFNf_newPCO, 0x3D
D8A4  F03D     NOP
2450:                  }
D8A6  D014     BRA 0xD8D0
2451:                  else
2452:                      if(rgl.x_f == 1) //=88C ?
D8A8  0437     DECF 0x37, W, ACCESS
D8AA  E107     BNZ 0xD8BA
2453:                  {
2454:                      if(rgl.tmp_pwm > PWM.PROP2)
D8AC  503D     MOVF 0x3D, W, ACCESS
D8AE  0100     MOVLB 0x0
D8B0  5D7A     SUBWF _PFNf_newPCW, W, BANKED
D8B2  E20E     BC 0xD8D0
2455:                          rgl.tmp_pwm = PWM.PROP2; //-2/7
D8B4  C07A     MOVFF _PFNf_newPCW, 0x3D
D8B6  F03D     NOP
2456:                  }
D8B8  D00B     BRA 0xD8D0
2457:                  else
2458:                      if(rgl.x_f <= 0) //>=89C ?
D8BA  5037     MOVF 0x37, W, ACCESS
D8BC  0A80     XORLW 0x80
D8BE  0F7F     ADDLW 0x7F
D8C0  E207     BC 0xD8D0
2459:                  {
2460:                      if(rgl.tmp_pwm > PWM.PROP3)
D8C2  503D     MOVF 0x3D, W, ACCESS
D8C4  0100     MOVLB 0x0
D8C6  5D7B     SUBWF _PFNf_newPFN, W, BANKED
D8C8  E203     BC 0xD8D0
2461:                          rgl.tmp_pwm = PWM.PROP3; //-3/7
D8CA  C07B     MOVFF _PFNf_newPFN, 0x3D
D8CC  F03D     NOP
2462:                  }
2463:                  WriteOPWM(rgl.tmp_pwm);
D8CE  D000     BRA 0xD8D0
D8D0  503D     MOVF 0x3D, W, ACCESS
D8D2  EF6C     GOTO 0xA4D8
D8D4  F052     NOP
2464:                  //PWM.BufPWM=rgl.tmp_pwm;
2465:              }
2466:              else WriteOPWM(PWM.MDMOD); //PWM.BufPWM=PWM.MDMOD;			//wymus minimum plomienia
D8D6  0100     MOVLB 0x0
D8D8  5167     MOVF _PFNf_b_set_ncw, W, BANKED
D8DA  EF6C     GOTO 0xA4D8
D8DC  F052     NOP
2467:          }
D8DE  0012     RETURN 0
2468:          //************************************************************
2469:          //------------------------------------------------------------
2470:          //------------------------------------------------------------
2471:          //------Minimax z zasobnikiem, Unico
2472:          //------------------------------------------------------------
2473:          //------------------------------------------------------------								
2474:          //-------------------------------------------------------------
2475:          //-------------------------------------------------------------
2476:          //zmien obieg na CW
2477:          
2478:          void ModToCW3(void)
2479:          {
2480:              rglf_btcw = 1;
DE58  8015     BSF rglf_btcw, 0, ACCESS
2481:              if(rglf_btco) //aktywny jest obieg CO?
DE5A  AE14     BTFSS UADtf_RData, 7, ACCESS
DE5C  0012     RETURN 0
2482:              {
2483:                  rglf_btco = 0;
DE5E  9E14     BCF UADtf_RData, 7, ACCESS
2484:                  //wstepne obnizenie mocy palnika
2485:                  if(!Tnizsza(0))
DE60  0E00     MOVLW 0x0
DE62  ECDA     CALL 0xEFB4, 0
DE64  F077     NOP
DE66  B0D8     BTFSC STATUS, 0, ACCESS
DE68  0012     RETURN 0
2486:                  {
2487:                      if(rgl.srp - 10 < PWM.MDMOD) rgl.srp = PWM.MDMOD;
DE6A  0100     MOVLB 0x0
DE6C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
DE6E  6FDF     MOVWF pco, BANKED
DE70  6BE0     CLRF bdat, BANKED
DE72  0EF6     MOVLW 0xF6
DE74  6FE1     MOVWF GIE_BIT_VAL, BANKED
DE76  69E2     SETF divisor, BANKED
DE78  503B     MOVF 0x3B, W, ACCESS
DE7A  6FE3     MOVWF a, BANKED
DE7C  6BE4     CLRF k, BANKED
DE7E  51E1     MOVF GIE_BIT_VAL, W, BANKED
DE80  27E3     ADDWF a, F, BANKED
DE82  51E2     MOVF divisor, W, BANKED
DE84  23E4     ADDWFC k, F, BANKED
DE86  51DF     MOVF pco, W, BANKED
DE88  5DE3     SUBWF a, W, BANKED
DE8A  51E4     MOVF k, W, BANKED
DE8C  0A80     XORLW 0x80
DE8E  6FE5     MOVWF k, BANKED
DE90  51E0     MOVF bdat, W, BANKED
DE92  0A80     XORLW 0x80
DE94  59E5     SUBWFB k, W, BANKED
DE96  E203     BC 0xDE9E
DE98  C067     MOVFF _PFNf_b_set_ncw, 0x3B
DE9A  F03B     NOP
DE9C  0012     RETURN 0
2488:                      else rgl.srp -= 10;
DE9E  0E0A     MOVLW 0xA
DEA0  5E3B     SUBWF 0x3B, F, ACCESS
2489:                  }
DEA2  0012     RETURN 0
2490:              }
2491:          }
DEA4  0012     RETURN 0
2492:          //-------------------------------------------------------------
2493:          //zmien obieg na CO
2494:          
2495:          void ModToCO3(void)
2496:          {
2497:              rglf_btco = 1;
F40C  8E14     BSF UADtf_RData, 7, ACCESS
2498:              rglf_btcw = 0;
F40E  9015     BCF rglf_btcw, 0, ACCESS
2499:          }
F410  0012     RETURN 0
2500:          //-------------------------------------------------------------
2501:          //parametry startowe - kociol z zasobnikiem.
2502:          
2503:          void StartMCO3(void)
2504:          {
2505:              if(rglf_btco || rglf_btcw) return; //praca w dowolnym obiegu CO?
E1DE  AE14     BTFSS UADtf_RData, 7, ACCESS
E1E0  B015     BTFSC rglf_btcw, 0, ACCESS
E1E2  0012     RETURN 0
E1E4  D001     BRA 0xE1E8
E1E6  0012     RETURN 0
2506:              StartRTdS(_RTMOD);
E1E8  0E02     MOVLW 0x2
E1EA  ECA0     CALL 0xE540, 0
E1EC  F072     NOP
2507:              DtCO.dDCO = 0;
E1EE  0100     MOVLB 0x0
E1F0  6BD6     CLRF 0xD6, BANKED
2508:              DtCO.indCO = 0;
E1F2  0100     MOVLB 0x0
E1F4  6BD7     CLRF 0xD7, BANKED
2509:              rglf_fz = 0;
E1F6  9815     BCF rglf_btcw, 4, ACCESS
2510:              rglf_med_up = 0;
E1F8  9C15     BCF rglf_btcw, 6, ACCESS
2511:              rglf_fast_up = 0;
E1FA  9615     BCF rglf_btcw, 3, ACCESS
2512:              //CO - dobor wartosci pierwszego pobudzenia (moment startu modulacji)
2513:              if(PWM.MAXPWM > PWM.FIRSTPB)
E1FC  0100     MOVLB 0x0
E1FE  5181     MOVF _PFNf_ofnserw, W, BANKED
E200  5D78     SUBWF _PFNf_mod_ncw, W, BANKED
E202  E203     BC 0xE20A
2514:              {
2515:                  rgl.xmod = PWM.FIRSTPB;
E204  C078     MOVFF _PFNf_mod_ncw, 0x3C
E206  F03C     NOP
2516:              }
E208  D003     BRA 0xE210
2517:              else
2518:              {
2519:                  rgl.xmod = PWM.MAXPWM;
E20A  C081     MOVFF _PFNf_ofnserw, 0x3C
E20C  F03C     NOP
E20E  D000     BRA 0xE210
2520:              }
2521:              rgl.srp = 0;
E210  0E00     MOVLW 0x0
E212  6A3B     CLRF 0x3B, ACCESS
2522:              rgl.ytmp = 0;
E214  6A3A     CLRF 0x3A, ACCESS
2523:              rglf_nmod = 0; //wyjdz z trybu nmod
E216  9E15     BCF rglf_btcw, 7, ACCESS
2524:              rglf_btcw = 0;
E218  9015     BCF rglf_btcw, 0, ACCESS
2525:              rglf_btco = 1;
E21A  8E14     BSF UADtf_RData, 7, ACCESS
2526:              rglf_del1s = 0;
E21C  9215     BCF rglf_btcw, 1, ACCESS
2527:              rglf_deln1 = 0;
E21E  9415     BCF rglf_btcw, 2, ACCESS
2528:              rglf_inv_mod = 0;
E220  9A15     BCF rglf_btcw, 5, ACCESS
2529:          }
E222  0012     RETURN 0
2530:          //************************************************************
2531:          //------------------------------------------------------------
2532:          //------------------------------------------------------------
2533:          //------------------------------------------------------------
2534:          //------------------------------------------------------------
2535:          //zwraca wartosc 1 przy stwierdzonym wzroscie temperatury
2536:          //(w obiegu CW)
2537:          //dla t=0 zwraca wartosc jeden przy dowolnym wzroscie temp.
2538:          //dla t>0 zwraca wartosc jeden przy wroscie > od t [C/sek].
2539:          
2540:          bit Trosnie(const unsigned char t)
EFD0  0100     MOVLB 0x0
EFD2  6FDE     MOVWF __pcstackBANK0, BANKED
2541:          {
2542:              return(rgl.x_dt > t);
EFD4  0100     MOVLB 0x0
EFD6  51DE     MOVF __pcstackBANK0, W, BANKED
EFD8  BE38     BTFSC 0x38, 7, ACCESS
EFDA  D003     BRA 0xEFE2
EFDC  0AFF     XORLW 0xFF
EFDE  2438     ADDWF 0x38, W, ACCESS
EFE0  E202     BC 0xEFE6
EFE2  90D8     BCF STATUS, 0, ACCESS
EFE4  0012     RETURN 0
EFE6  80D8     BSF STATUS, 0, ACCESS
EFE8  0012     RETURN 0
2543:          }
EFEA  0012     RETURN 0
2544:          //------------------------------------------------------------
2545:          //zwraca wartosc 1 przy stwierdzonym spadku temperatury
2546:          //(w obiegu CW)
2547:          //dla t=0 zwraca wartosc jeden przy dowolnym spadku temp.
2548:          //dla t>0 zwraca wartosc jeden przy spadku > od t [C/sek].
2549:          
2550:          bit Tmaleje(const unsigned char t)
E752  0100     MOVLB 0x0
E754  6FE1     MOVWF GIE_BIT_VAL, BANKED
2551:          {
2552:              return(rgl.x_dt < (-1 * t));
E756  0100     MOVLB 0x0
E758  51E1     MOVF GIE_BIT_VAL, W, BANKED
E75A  0D01     MULLW 0x1
E75C  1EF3     COMF PROD, F, ACCESS
E75E  1EF4     COMF PRODH, F, ACCESS
E760  4AF3     INFSNZ PROD, F, ACCESS
E762  2AF4     INCF PRODH, F, ACCESS
E764  C038     MOVFF 0x38, __pcstackBANK0
E766  F0DE     NOP
E768  6BDF     CLRF pco, BANKED
E76A  BFDE     BTFSC __pcstackBANK0, 7, BANKED
E76C  07DF     DECF pco, F, BANKED
E76E  50F3     MOVF PROD, W, ACCESS
E770  5DDE     SUBWF __pcstackBANK0, W, BANKED
E772  51DF     MOVF pco, W, BANKED
E774  0A80     XORLW 0x80
E776  6FE0     MOVWF bdat, BANKED
E778  50F4     MOVF PRODH, W, ACCESS
E77A  0A80     XORLW 0x80
E77C  59E0     SUBWFB bdat, W, BANKED
E77E  E302     BNC 0xE784
E780  90D8     BCF STATUS, 0, ACCESS
E782  0012     RETURN 0
E784  80D8     BSF STATUS, 0, ACCESS
E786  0012     RETURN 0
2553:          }
E788  0012     RETURN 0
2554:          //------------------------------------------------------------
2555:          //zwraca wartosc 1 jezeli temperatura sie nie zmienia
2556:          //(w obiegu CW)
2557:          
2558:          bit Tstoi(void)
2559:          {
2560:              return !rgl.x_dt;
F358  5038     MOVF 0x38, W, ACCESS
F35A  E002     BZ 0xF360
F35C  90D8     BCF STATUS, 0, ACCESS
F35E  0012     RETURN 0
F360  80D8     BSF STATUS, 0, ACCESS
F362  0012     RETURN 0
2561:          }
F364  0012     RETURN 0
2562:          
2563:          //------------------------------------------------------------
2564:          //zwraca wartosc 1 temperatura jes nizsza od nastawy o wartosc parametru t
2565:          //(w obiegu CW)
2566:          //dla t=0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy.
2567:          //dla t>0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy o >= t.
2568:          
2569:          bit Tnizsza(const unsigned char t)
EFB4  0100     MOVLB 0x0
EFB6  6FDE     MOVWF __pcstackBANK0, BANKED
2570:          {
2571:              return(rgl.x_t > t);
EFB8  0100     MOVLB 0x0
EFBA  51DE     MOVF __pcstackBANK0, W, BANKED
EFBC  BE36     BTFSC rgl, 7, ACCESS
EFBE  D003     BRA 0xEFC6
EFC0  0AFF     XORLW 0xFF
EFC2  2436     ADDWF rgl, W, ACCESS
EFC4  E202     BC 0xEFCA
EFC6  90D8     BCF STATUS, 0, ACCESS
EFC8  0012     RETURN 0
EFCA  80D8     BSF STATUS, 0, ACCESS
EFCC  0012     RETURN 0
2572:          }
EFCE  0012     RETURN 0
2573:          //------------------------------------------------------------
2574:          //zwraca wartosc 1 temperatura jes nizsza od nastawy o wartosc parametru t
2575:          //(w obiegu CW)
2576:          //dla t=0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy.
2577:          //dla t>0 zwraca wartosc jeden jezeli temp. jest nizsza od nastawy o >= t.
2578:          
2579:          bit Twyzsza(const unsigned char t)
E78A  0100     MOVLB 0x0
E78C  6FE1     MOVWF GIE_BIT_VAL, BANKED
2580:          {
2581:              return(rgl.x_t < (-1 * t));
E78E  0100     MOVLB 0x0
E790  51E1     MOVF GIE_BIT_VAL, W, BANKED
E792  0D01     MULLW 0x1
E794  1EF3     COMF PROD, F, ACCESS
E796  1EF4     COMF PRODH, F, ACCESS
E798  4AF3     INFSNZ PROD, F, ACCESS
E79A  2AF4     INCF PRODH, F, ACCESS
E79C  C036     MOVFF rgl, __pcstackBANK0
E79E  F0DE     NOP
E7A0  6BDF     CLRF pco, BANKED
E7A2  BFDE     BTFSC __pcstackBANK0, 7, BANKED
E7A4  07DF     DECF pco, F, BANKED
E7A6  50F3     MOVF PROD, W, ACCESS
E7A8  5DDE     SUBWF __pcstackBANK0, W, BANKED
E7AA  51DF     MOVF pco, W, BANKED
E7AC  0A80     XORLW 0x80
E7AE  6FE0     MOVWF bdat, BANKED
E7B0  50F4     MOVF PRODH, W, ACCESS
E7B2  0A80     XORLW 0x80
E7B4  59E0     SUBWFB bdat, W, BANKED
E7B6  E302     BNC 0xE7BC
E7B8  90D8     BCF STATUS, 0, ACCESS
E7BA  0012     RETURN 0
E7BC  80D8     BSF STATUS, 0, ACCESS
E7BE  0012     RETURN 0
2582:          }
E7C0  0012     RETURN 0
2583:          //------------------------------------------------------------
2584:          //zwraca wartosc 1 jezeli temperatura = nastawa.
2585:          //(w obiegu CW)
2586:          
2587:          bit Trowna(void)
2588:          {
2589:              return !rgl.x_t;
F34A  5036     MOVF rgl, W, ACCESS
F34C  E002     BZ 0xF352
F34E  90D8     BCF STATUS, 0, ACCESS
F350  0012     RETURN 0
F352  80D8     BSF STATUS, 0, ACCESS
F354  0012     RETURN 0
2590:          }
F356  0012     RETURN 0
2591:          //------------------------------------------------------------
2592:          //zwraca wartosc 1 przy stwierdzonym wzroscie temperatury
2593:          //(w obiegu CO)
2594:          //dla t=0 zwraca wartosc jeden przy dowolnym wzroscie temp.
2595:          //dla t>0 zwraca wartosc jeden przy wroscie > od t [C/sek].
2596:          
2597:          bit TFrosnie(const unsigned char t)
EFEC  0100     MOVLB 0x0
EFEE  6FDE     MOVWF __pcstackBANK0, BANKED
2598:          {
2599:              return(rgl.x_df > t);
EFF0  0100     MOVLB 0x0
EFF2  51DE     MOVF __pcstackBANK0, W, BANKED
EFF4  BE39     BTFSC 0x39, 7, ACCESS
EFF6  D003     BRA 0xEFFE
EFF8  0AFF     XORLW 0xFF
EFFA  2439     ADDWF 0x39, W, ACCESS
EFFC  E202     BC 0xF002
EFFE  90D8     BCF STATUS, 0, ACCESS
F000  0012     RETURN 0
F002  80D8     BSF STATUS, 0, ACCESS
F004  0012     RETURN 0
2600:          }
F006  0012     RETURN 0
2601:          //------------------------------------------------------------
2602:          //zwraca wartosc 1 przy stwierdzonym spadku temperatury
2603:          //(w obiegu CO)
2604:          //dla t=0 zwraca wartosc jeden przy dowolnym spadku temp.
2605:          //dla t>0 zwraca wartosc jeden przy spadku > od t [C/sek].
2606:          
2607:          bit TFmaleje(const unsigned char t)
E71A  0100     MOVLB 0x0
E71C  6FE1     MOVWF GIE_BIT_VAL, BANKED
2608:          {
2609:              return(rgl.x_df < (-1 * t));
E71E  0100     MOVLB 0x0
E720  51E1     MOVF GIE_BIT_VAL, W, BANKED
E722  0D01     MULLW 0x1
E724  1EF3     COMF PROD, F, ACCESS
E726  1EF4     COMF PRODH, F, ACCESS
E728  4AF3     INFSNZ PROD, F, ACCESS
E72A  2AF4     INCF PRODH, F, ACCESS
E72C  C039     MOVFF 0x39, __pcstackBANK0
E72E  F0DE     NOP
E730  6BDF     CLRF pco, BANKED
E732  BFDE     BTFSC __pcstackBANK0, 7, BANKED
E734  07DF     DECF pco, F, BANKED
E736  50F3     MOVF PROD, W, ACCESS
E738  5DDE     SUBWF __pcstackBANK0, W, BANKED
E73A  51DF     MOVF pco, W, BANKED
E73C  0A80     XORLW 0x80
E73E  6FE0     MOVWF bdat, BANKED
E740  50F4     MOVF PRODH, W, ACCESS
E742  0A80     XORLW 0x80
E744  59E0     SUBWFB bdat, W, BANKED
E746  E302     BNC 0xE74C
E748  90D8     BCF STATUS, 0, ACCESS
E74A  0012     RETURN 0
E74C  80D8     BSF STATUS, 0, ACCESS
E74E  0012     RETURN 0
2610:          }
E750  0012     RETURN 0
2611:          //------------------------------------------------------------
2612:          //zwraca wartosc 1 jezeli temperatura sie nie zmienia
2613:          //(w obiegu CO)
2614:          
2615:          bit TFstoi(void)
2616:          {
2617:              return !rgl.x_df;
F33C  5039     MOVF 0x39, W, ACCESS
F33E  E002     BZ 0xF344
F340  90D8     BCF STATUS, 0, ACCESS
F342  0012     RETURN 0
F344  80D8     BSF STATUS, 0, ACCESS
F346  0012     RETURN 0
2618:          }
F348  0012     RETURN 0
2619:          //------------------------------------------------------------
2620:          //Restart procedury modulatora
2621:          
2622:          void RestartMod(void)
2623:          {
2624:              rglf_btco = 0;
F1A6  9E14     BCF UADtf_RData, 7, ACCESS
2625:              rglf_btcw = 0;
F1A8  9015     BCF rglf_btcw, 0, ACCESS
2626:              rglf_fz = 0;
F1AA  9815     BCF rglf_btcw, 4, ACCESS
2627:              rglf_med_up = 0;
F1AC  9C15     BCF rglf_btcw, 6, ACCESS
2628:              rglf_fast_up = 0;
F1AE  9615     BCF rglf_btcw, 3, ACCESS
2629:              rglf_nmod = 0;
F1B0  9E15     BCF rglf_btcw, 7, ACCESS
2630:              rglf_del1s = 0;
F1B2  9215     BCF rglf_btcw, 1, ACCESS
2631:              rglf_deln1 = 0;
F1B4  9415     BCF rglf_btcw, 2, ACCESS
2632:              rglf_inv_mod = 0;
F1B6  9A15     BCF rglf_btcw, 5, ACCESS
2633:          }
F1B8  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/readdtal.c  ------------------------------
1:             /*readdta.c*/
2:             //Funkcja odczytu danej z keypadu
3:             // (!) Bazuje na funkcjach z plikow: rtimer.c /RTS(1)/, lcd8.c, keypad.c
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include <stdio.h>
7:             #include "global.h"			//parametry globalne
8:             #include "readdtal.h"		//parametry lokalne
9:             
10:            extern volatile StPin xxky[];
11:            //extern unsigned char x;
12:            /*---------------------------------------------------------------------------------*/
13:            //Odczyt danej z keypadu z potwierdzeniem
14:            //dt - wskaznik do modyfikowanego parametru
15:            //min - minimalna wartosc jaka moze przyjac parametr
16:            //max - maksymalna wartosc jaka moze przyjac parametr
17:            //step - krok z jakim odbywa sie inkrementacja/dekrementacja
18:            //np. akceptacja=ReadData(&x,1,3,1,wr);
19:            #if (_ENRDT)
20:            
21:            unsigned char ReadData(unsigned char k, volatile StPin *ky, volatile unsigned char *dt, unsigned char min, unsigned char max, const unsigned char step, unsigned char wrn)
22:            {
23:                static unsigned char bd;
24:                static bit dtmo = 0, okvi = 0;
25:            
26:                if(!dtmo) //pierwsze uruchomienie procedury
27:                {
28:                    bd = *dt;
29:                    dtmo = 1;
30:                    okvi = 0;
31:                }
32:                if(!okvi) //akceptacja danej?
33:                {
34:                    if(bd < min) bd = min;
35:                    if(ExPresKey(k, ky, _RDTOFS, _RDKRFS))
36:                    {
37:                        bd = bd + step;
38:                    }
39:                    if(bd > max) bd = min;
40:                    PrintCO(bd);
41:            
42:                    if(wrn) okvi = 1; //spelniony warunek wyjscia?
43:                }
44:                else
45:                {
46:                    dtmo = 0;
47:                    okvi = 0;
48:                    *dt = bd;
49:                    return 1; //zwroc znacznik potwierdzenia
50:                }
51:                return 0x00;
52:            }
53:            #endif
54:            /*---------------------------------------------------------------------------------*/
55:            //Odczyt danej z keypadu z potwierdzeniem /regulowany krok - wersja dla danych o duzych wartosciach/
56:            //dt - wskaznik do modyfikowanego parametru
57:            //min - minimalna wartosc jaka moze przyjac parametr
58:            //max - maksymalna wartosc jaka moze przyjac parametr
59:            //step - krok z jakim odbywa sie inkrementacja/dekrementacja przy pojedynczym nacisnieciu przycisku
60:            //step2 - krok z jakim odbywa sie inkrementacja/dekrementacja przy wcisnietym przycisku
61:            //np. akceptacja=ReadDataX(&x,1,100,1,5,wr);
62:            #if (_ENRDTX)
63:            
64:            unsigned char ReadDataX(unsigned char k, volatile StPin *ky, volatile unsigned char *dt, unsigned char min, unsigned char max, const unsigned char step, const unsigned char step2, unsigned char wrn)
65:            {
66:                static bit dtmo = 0, okvi = 0;
67:                static unsigned char bd, iu;
68:                static unsigned char ktu;
69:                char key = 0;
70:            
71:                if(!dtmo) //pierwsze uruchomienie procedury
72:                {
73:                    iu = 0;
74:                    ktu = 0;
75:                    dtmo = 1;
76:                    okvi = 0;
77:                    bd = *dt;
78:                }
79:                if(!okvi) //akceptacja danej?
80:                {
81:                    if(bd < min) bd = min;
82:                    if(key = ExxPresKey1(k, ky, _RDTOFSX, ktu))
83:                    {
84:                        if(key == 1)
85:                        {
86:                            iu = 0;
87:                            ktu = 5;
88:                            bd = bd + step;
89:                        }
90:                        if(key == 2)
91:                        {
92:                            if(iu < (_RDKRFSX - 1) * _VKRFSX) iu++;
93:                            ktu = _RDKRFSX - iu / _VKRFSX;
94:                            bd = bd + step2;
95:                        }
96:                    }
97:                    else
98:                    {
99:                        iu = 0;
100:                       ktu = 5;
101:                   }
102:                   if(bd > max) bd = min;
103:                   PrintCO(bd);
104:           
105:                   if(wrn) okvi = 1; //spelniony warunek wyjscia?
106:               }
107:               else
108:               {
109:                   dtmo = 0;
110:                   okvi = 0;
111:                   *dt = bd;
112:                   return 1; //zwroc znacznik potwierdzenia
113:               }
114:               return 0x00;
115:           }
116:           #endif
117:           /*---------------------------------------------------------------------------------*/
118:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie")
119:           //dt - wskaznik do modyfikowanego parametru
120:           //min - minimalna wartosc jaka moze przyjac parametr
121:           //max - maksymalna wartosc jaka moze przyjac parametr
122:           //step - krok z jakim odbywa sie inkrementacja/dekrementacja
123:           //np. akceptacja=ReadData(&x,1,100,1,wr);
124:           #if (_ENRDTONL)
125:           
126:           unsigned char ReadDataONL(unsigned char k, volatile StPin *ky, volatile unsigned char *dt, unsigned char min, unsigned char max, const unsigned char step, unsigned char wrn)
127:           {
128:               if(*dt < min) *dt = min;
129:               if(ExPresKey(k, ky, _RDTOFSNL, _RDKRFSNL))
130:               {
131:                   if(*dt >= max) *dt = min;
132:                   else
133:                       if(*dt + step <= max) *dt = *dt + step;
134:               }
135:               if(*dt > max) *dt = min;
136:               if(wrn) return 1; //spelniony warunek wyjscia?
137:               return 0x00;
138:           }
139:           #endif
140:           /*---------------------------------------------------------------------------------*/
141:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
142:           //dt - wskaznik do modyfikowanego parametru
143:           //min - minimalna wartosc jaka moze przyjac parametr
144:           //max - maksymalna wartosc jaka moze przyjac parametr
145:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
146:           //step2 - krok z jakim odbywa sie inkrementacja przy wcisnietym przycisku
147:           //np. akceptacja=ReadDataXONL(&x,1,100,1,5,wr);
148:           #if (_ENRDTOXL)
149:           
150:           unsigned char ReadDataXONL(unsigned char k, volatile StPin *ky, volatile unsigned char *dt, unsigned char min, unsigned char max, const unsigned char step, const unsigned char step2, unsigned char wrn)
151:           {
152:               static bit dtmo = 0;
153:               static unsigned char ktu, iu;
154:               char key = 0;
155:           
156:               if(!dtmo) //pierwsze uruchomienie procedury
157:               {
158:                   dtmo = 1;
159:                   ktu = 0;
160:                   iu = 0;
161:               }
162:               if(*dt < min) *dt = min;
163:               if(key = ExxPresKey(k, ky, _RDTOFSXL, ktu))
164:               {
165:                   if(key == 1)
166:                   {
167:                       iu = 0;
168:                       ktu = 5;
169:                       if(*dt >= max) *dt = min;
170:                       else
171:                           if(*dt + step <= max) *dt = *dt + step;
172:                   }
173:                   if(key == 2)
174:                   {
175:                       if(iu <= (_RDKRFSXL - 1) * _VKRFSXL) iu++;
176:                       ktu = _RDKRFSXL - iu / _VKRFSXL; //czas miedzy kolejnymi impulsami inkrementacji
177:                       if(*dt >= max) *dt = min;
178:                       else
179:                           if(*dt + step2 <= max) *dt = *dt + step2;
180:                   }
181:               }
182:               else
183:               {
184:                   iu = 0;
185:                   ktu = 5;
186:               }
187:               if(*dt > max) *dt = min;
188:               if(wrn) //spelniony warunek wyjscia?
189:               {
190:                   dtmo = 0;
191:                   return 1; //OK key?
192:               }
193:               return 0x00;
194:           }
195:           #endif
196:           /*---------------------------------------------------------------------------------*/
197:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
198:           //dt - wskaznik do modyfikowanego parametru
199:           //ovf - dla 1 inkrementacja/dekrementacja na okraglo
200:           //min - minimalna wartosc jaka moze przyjac parametr
201:           //max - maksymalna wartosc jaka moze przyjac parametr
202:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
203:           //step2 - krok z jakim docelowo odbywa sie inkrementacja przy wcisnietym przycisku (dla fst=1)
204:           //fst - aktywacja funkcji zwiekszania czestotliwosci kroków oraz zwiekszania ich amplitudy z poziomu step do step2 przy wcisnietym przycisku
205:           //ReadDataXONLI(RdPrt(S_KUP),&xxky[S_KUP],&param,&ov,max,1,stp,1);
206:           //ReadDataXONLD(RdPrt(S_KDW),&xxky[S_KDW],&param,&ov,min,1,stp,1);
207:           #if (_ENRDTOXLI!=0)
208:           //INKREMENTACJA
209:           
210:           unsigned char ReadDataXONLI(unsigned char k, volatile StPin *ky, volatile unsigned int *dt, volatile unsigned char *ovf, unsigned int max, const unsigned char step, const unsigned char step2, const unsigned char fst)
211:           {
212:               static bit dtmo = 0;
213:               static unsigned char ktu, iu, pp, es2;
214:               char key = 0;
215:           
216:               if(!dtmo) //pierwsze uruchomienie procedury
217:               {
218:                   dtmo = 1;
219:                   ktu = 0;
220:                   iu = 0;
221:                   es2 = 0;
222:                   pp = step;
223:               }
224:               //-------
225:               if(key = ExxPresKey(k, ky, _RDTOFSXLI, ktu))
226:               {
227:                   if(key == 1 || ((key == 2) && !fst))
228:                   {
229:                       iu = 0;
230:                       ktu = 5;
231:                       es2 = 0;
232:                       pp = step;
233:                       if((*dt + pp) > max) *ovf = 1;
234:                       else *ovf = 0;
235:                       if(*dt + pp <= max) *dt = *dt + pp;
236:                       else *dt = max;
237:           
238:                   }
239:                   if(key == 2 && fst)
240:                   {
241:                       if(iu <= (_RDKRFSXLI - 1) * _VKRFSXLI) iu++;
242:                       ktu = _RDKRFSXLI - iu / _VKRFSXLI; //czas miedzy kolejnymi impulsami inkrementacji
243:                       if(iu > (_RDKRFSXLI - 1) * _VKRFSXLI) //przytrzymany przycisk przez dluzszy czas?
244:                       {
245:                           if(es2)
246:                           {
247:                               if(pp < step2) pp++;
248:                           }
249:                           else pp = step;
250:                           if((*dt % 10) == 0) es2 = 1;
251:                       }
252:                       else
253:                       {
254:                           es2 = 0;
255:                           pp = step;
256:                       }
257:                       if((*dt + pp) > max) *ovf = 1;
258:                       else *ovf = 0;
259:                       if(*dt + pp <= max) *dt = *dt + pp;
260:                       else *dt = max;
261:                   }
262:                   if(*dt > max) *dt = max;
263:                   return 1;
264:               }
265:               else
266:               {
267:                   iu = 0;
268:                   ktu = 5;
269:                   es2 = 0;
270:                   pp = step;
271:               }
272:               return 0x00;
273:           }
274:           #endif
275:           #if (_ENRDTOXLD!=0)
276:           //DEKREMENTACJA
277:           
278:           unsigned char ReadDataXONLD(unsigned char k, volatile StPin *ky, volatile unsigned int *dt, volatile unsigned char *ovf, unsigned int min, const unsigned char step, const unsigned char step2, const unsigned char fst)
279:           {
280:               static bit dtmo = 0;
281:               static unsigned char ktu, iu, pp, es2;
282:               char key = 0;
283:           
284:               if(!dtmo) //pierwsze uruchomienie procedury
285:               {
286:                   dtmo = 1;
287:                   ktu = 0;
288:                   iu = 0;
289:                   es2 = 0;
290:                   pp = step;
291:               }
292:               //-------
293:               if(key = ExxPresKey(k, ky, _RDTOFSXLD, ktu))
294:               {
295:                   if(key == 1 || ((key == 2) && !fst))
296:                   {
297:                       iu = 0;
298:                       ktu = 5;
299:                       es2 = 0;
300:                       pp = step;
301:                       if(!*dt || ((*dt - pp) < min)) *ovf = 1;
302:                       else *ovf = 0;
303:                       if(*dt && ((*dt - pp) > min)) *dt = *dt - pp;
304:                       else *dt = min;
305:                   }
306:                   if(key == 2 && fst)
307:                   {
308:                       if(iu <= (_RDKRFSXLD - 1) * _VKRFSXLD) iu++;
309:                       ktu = _RDKRFSXLD - iu / _VKRFSXLD; //czas miedzy kolejnymi impulsami inkrementacji
310:                       if(iu > (_RDKRFSXLD - 1) * _VKRFSXLD)
311:                       {
312:                           if(es2)
313:                           {
314:                               if(pp < step2) pp++;
315:                           }
316:                           else pp = step;
317:                           if((*dt % 10) == 0) es2 = 1;
318:                       }
319:                       else
320:                       {
321:                           es2 = 0;
322:                           pp = step;
323:                       }
324:                       if(!*dt || ((*dt - pp) < min)) *ovf = 1;
325:                       else *ovf = 0;
326:                       if(*dt && ((*dt - pp) > min)) *dt = *dt - pp;
327:                       else *dt = min;
328:                   }
329:                   if(*dt < min) *dt = min;
330:                   return 1;
331:               }
332:               else
333:               {
334:                   iu = 0;
335:                   ktu = 5;
336:                   es2 = 0;
337:                   pp = step;
338:               }
339:               return 0x00;
340:           }
341:           #endif
342:           /*---------------------------------------------------------------------------------*/
343:           //Odczyt danej z keypadu (modyfikacja zmiennej dt "w locie") /regulowany krok - wersja dla danych o duzych wartosciach/
344:           //dt - wskaznik do modyfikowanego parametru
345:           //min - minimalna wartosc jaka moze przyjac parametr
346:           //max - maksymalna wartosc jaka moze przyjac parametr
347:           //ovf - dla 1 inkrementacja/dekrementacja na okraglo
348:           //tid - dla 1 inkrementacja dla 0 dekrementacja
349:           //step - krok z jakim odbywa sie inkrementacja przy pojedynczym nacisnieciu przycisku
350:           //step2 - krok z jakim docelowo odbywa sie inkrementacja przy wcisnietym przycisku (dla fst=1)
351:           //fst - aktywacja funkcji zwiekszania czestotliwosci kroków oraz zwiekszania ich amplitudy z poziomu step do step2 przy wcisnietym przycisku
352:           //ReadDataXONLID(RdPrt(S_KDW),&xxky[S_KDW],param,&ov,0,min,max,1,stp,fst);
353:           #if (_ENRDTOXLID!=0)
354:           
355:           unsigned char ReadDataXONLID(unsigned char k, volatile StPin *ky, volatile unsigned int *dt, volatile unsigned char *ovf, unsigned char tid, unsigned int min, unsigned int max, const unsigned char step, const unsigned char step2, const unsigned char fst)
33A2  0100     MOVLB 0x0
33A4  6FFE     MOVWF k, BANKED
356:           {
357:               volatile static bit dtmo = 0;
358:               volatile static unsigned char ktu, iu, pp, es2;
359:               volatile char key = 0;
33A6  0E00     MOVLW 0x0
33A8  0100     MOVLB 0x0
33AA  6FFF     MOVWF key, BANKED
360:           
361:               if(!dtmo) //pierwsze uruchomienie procedury
33AC  B401     BTFSC DtCOf_err_CO, 2, ACCESS
33AE  D00B     BRA 0x33C6
362:               {
363:                   dtmo = 1;
33B0  8401     BSF DtCOf_err_CO, 2, ACCESS
364:                   ktu = 0;
33B2  0E00     MOVLW 0x0
33B4  0101     MOVLB 0x1
33B6  6F73     MOVWF _PFNf_fmsg, BANKED
365:                   iu = 0;
33B8  0100     MOVLB 0x0
33BA  6FC9     MOVWF iu, BANKED
366:                   es2 = 0;
33BC  0101     MOVLB 0x1
33BE  6F72     MOVWF _PFNf_ferr, BANKED
367:                   pp = step;
33C0  C0F7     MOVFF step, pp
33C2  F0CA     NOP
33C4  D000     BRA 0x33C6
368:               }
369:               //-------
370:               if(key = ExxPresKey(k, ky, _RDTOFSXLID, ktu))
33C6  C0EC     MOVFF dt, bdat
33C8  F0E0     NOP
33CA  C0ED     MOVFF min, GIE_BIT_VAL
33CC  F0E1     NOP
33CE  0E05     MOVLW 0x5
33D0  0100     MOVLB 0x0
33D2  6FE2     MOVWF divisor, BANKED
33D4  C173     MOVFF ktu, a
33D6  F0E3     NOP
33D8  51FE     MOVF k, W, BANKED
33DA  EC17     CALL 0x9E2E, 0
33DC  F04F     NOP
33DE  0100     MOVLB 0x0
33E0  6FFF     MOVWF key, BANKED
33E2  51FF     MOVF key, W, BANKED
33E4  E101     BNZ 0x33E8
33E6  D203     BRA 0x37EE
371:               {
372:                   if(key == 1 || ((key == 2) && !fst))
33E8  05FF     DECF key, W, BANKED
33EA  E007     BZ 0x33FA
33EC  0E02     MOVLW 0x2
33EE  19FF     XORWF key, W, BANKED
33F0  E001     BZ 0x33F4
33F2  D0CE     BRA 0x3590
33F4  51F9     MOVF fst, W, BANKED
33F6  E001     BZ 0x33FA
33F8  D0CB     BRA 0x3590
373:                   {
374:                       iu = 0;
33FA  0E00     MOVLW 0x0
33FC  0100     MOVLB 0x0
33FE  6FC9     MOVWF iu, BANKED
375:                       ktu = 5;
3400  0E05     MOVLW 0x5
3402  0101     MOVLB 0x1
3404  6F73     MOVWF _PFNf_fmsg, BANKED
376:                       es2 = 0;
3406  0E00     MOVLW 0x0
3408  6F72     MOVWF _PFNf_ferr, BANKED
377:                       pp = step;
340A  C0F7     MOVFF step, pp
340C  F0CA     NOP
378:                       if(!tid)
340E  0100     MOVLB 0x0
3410  51F2     MOVF tid, W, BANKED
3412  E165     BNZ 0x34DE
379:                       {
380:                           if(!*dt || ((*dt - pp) < min)) *ovf = 1;
3414  C0EE     MOVFF dt, FSR2
3416  FFD9     NOP
3418  C0EF     MOVFF 0xEF, FSR2H
341A  FFDA     NOP
341C  50DE     MOVF POSTINC2, W, ACCESS
341E  10DE     IORWF POSTINC2, W, ACCESS
3420  E018     BZ 0x3452
3422  C0EE     MOVFF dt, FSR2
3424  FFD9     NOP
3426  C0EF     MOVFF 0xEF, FSR2H
3428  FFDA     NOP
342A  CFDE     MOVFF POSTINC2, pco
342C  F0FA     NOP
342E  CFDD     MOVFF POSTDEC2, d
3430  F0FB     NOP
3432  51CA     MOVF pp, W, BANKED
3434  6FFC     MOVWF 0xFC, BANKED
3436  6BFD     CLRF 0xFD, BANKED
3438  1FFC     COMF 0xFC, F, BANKED
343A  1FFD     COMF 0xFD, F, BANKED
343C  4BFC     INFSNZ 0xFC, F, BANKED
343E  2BFD     INCF 0xFD, F, BANKED
3440  51FA     MOVF pco, W, BANKED
3442  27FC     ADDWF 0xFC, F, BANKED
3444  51FB     MOVF d, W, BANKED
3446  23FD     ADDWFC 0xFD, F, BANKED
3448  51F3     MOVF min, W, BANKED
344A  5DFC     SUBWF 0xFC, W, BANKED
344C  51F4     MOVF pco, W, BANKED
344E  59FD     SUBWFB 0xFD, W, BANKED
3450  E206     BC 0x345E
3452  C0F0     MOVFF p, FSR2
3454  FFD9     NOP
3456  C0F1     MOVFF m, FSR2H
3458  FFDA     NOP
345A  0E01     MOVLW 0x1
345C  D005     BRA 0x3468
381:                           else *ovf = 0;
345E  C0F0     MOVFF p, FSR2
3460  FFD9     NOP
3462  C0F1     MOVFF m, FSR2H
3464  FFDA     NOP
3466  0E00     MOVLW 0x0
3468  6EDF     MOVWF INDF2, ACCESS
346A  D000     BRA 0x346C
382:                           if(*dt && ((*dt - pp) > min)) *dt = *dt - pp;
346C  C0EE     MOVFF dt, FSR2
346E  FFD9     NOP
3470  C0EF     MOVFF 0xEF, FSR2H
3472  FFDA     NOP
3474  50DE     MOVF POSTINC2, W, ACCESS
3476  10DE     IORWF POSTINC2, W, ACCESS
3478  E029     BZ 0x34CC
347A  C0EE     MOVFF dt, FSR2
347C  FFD9     NOP
347E  C0EF     MOVFF 0xEF, FSR2H
3480  FFDA     NOP
3482  CFDE     MOVFF POSTINC2, pco
3484  F0FA     NOP
3486  CFDD     MOVFF POSTDEC2, d
3488  F0FB     NOP
348A  0100     MOVLB 0x0
348C  51CA     MOVF pp, W, BANKED
348E  6FFC     MOVWF 0xFC, BANKED
3490  6BFD     CLRF 0xFD, BANKED
3492  1FFC     COMF 0xFC, F, BANKED
3494  1FFD     COMF 0xFD, F, BANKED
3496  4BFC     INFSNZ 0xFC, F, BANKED
3498  2BFD     INCF 0xFD, F, BANKED
349A  51FA     MOVF pco, W, BANKED
349C  27FC     ADDWF 0xFC, F, BANKED
349E  51FB     MOVF d, W, BANKED
34A0  23FD     ADDWFC 0xFD, F, BANKED
34A2  51FC     MOVF 0xFC, W, BANKED
34A4  5DF3     SUBWF min, W, BANKED
34A6  51FD     MOVF 0xFD, W, BANKED
34A8  59F4     SUBWFB pco, W, BANKED
34AA  E210     BC 0x34CC
34AC  C0EE     MOVFF dt, FSR2
34AE  FFD9     NOP
34B0  C0EF     MOVFF 0xEF, FSR2H
34B2  FFDA     NOP
34B4  CFDE     MOVFF POSTINC2, pco
34B6  F0FA     NOP
34B8  CFDD     MOVFF POSTDEC2, d
34BA  F0FB     NOP
34BC  51CA     MOVF pp, W, BANKED
34BE  6FFC     MOVWF 0xFC, BANKED
34C0  6BFD     CLRF 0xFD, BANKED
34C2  1FFC     COMF 0xFC, F, BANKED
34C4  1FFD     COMF 0xFD, F, BANKED
34C6  4BFC     INFSNZ 0xFC, F, BANKED
34C8  2BFD     INCF 0xFD, F, BANKED
34CA  D04B     BRA 0x3562
383:                           else *dt = min;
34CC  C0EE     MOVFF dt, FSR2
34CE  FFD9     NOP
34D0  C0EF     MOVFF 0xEF, FSR2H
34D2  FFDA     NOP
34D4  C0F3     MOVFF min, POSTINC2
34D6  FFDE     NOP
34D8  C0F4     MOVFF pco, POSTDEC2
34DA  FFDD     NOP
384:                       }
34DC  D059     BRA 0x3590
385:                       else
386:                       {
387:                           if((*dt + pp) > max) *ovf = 1;
34DE  C0EE     MOVFF dt, FSR2
34E0  FFD9     NOP
34E2  C0EF     MOVFF 0xEF, FSR2H
34E4  FFDA     NOP
34E6  CFDE     MOVFF POSTINC2, pco
34E8  F0FA     NOP
34EA  CFDD     MOVFF POSTDEC2, d
34EC  F0FB     NOP
34EE  0100     MOVLB 0x0
34F0  51CA     MOVF pp, W, BANKED
34F2  6FFC     MOVWF 0xFC, BANKED
34F4  6BFD     CLRF 0xFD, BANKED
34F6  51FA     MOVF pco, W, BANKED
34F8  27FC     ADDWF 0xFC, F, BANKED
34FA  51FB     MOVF d, W, BANKED
34FC  23FD     ADDWFC 0xFD, F, BANKED
34FE  51FC     MOVF 0xFC, W, BANKED
3500  5DF5     SUBWF max, W, BANKED
3502  51FD     MOVF 0xFD, W, BANKED
3504  59F6     SUBWFB ehi, W, BANKED
3506  E206     BC 0x3514
3508  C0F0     MOVFF p, FSR2
350A  FFD9     NOP
350C  C0F1     MOVFF m, FSR2H
350E  FFDA     NOP
3510  0E01     MOVLW 0x1
3512  D005     BRA 0x351E
388:                           else *ovf = 0;
3514  C0F0     MOVFF p, FSR2
3516  FFD9     NOP
3518  C0F1     MOVFF m, FSR2H
351A  FFDA     NOP
351C  0E00     MOVLW 0x0
351E  6EDF     MOVWF INDF2, ACCESS
3520  D000     BRA 0x3522
389:                           if(*dt + pp <= max) *dt = *dt + pp;
3522  C0EE     MOVFF dt, FSR2
3524  FFD9     NOP
3526  C0EF     MOVFF 0xEF, FSR2H
3528  FFDA     NOP
352A  CFDE     MOVFF POSTINC2, pco
352C  F0FA     NOP
352E  CFDD     MOVFF POSTDEC2, d
3530  F0FB     NOP
3532  0100     MOVLB 0x0
3534  51CA     MOVF pp, W, BANKED
3536  6FFC     MOVWF 0xFC, BANKED
3538  6BFD     CLRF 0xFD, BANKED
353A  51FA     MOVF pco, W, BANKED
353C  27FC     ADDWF 0xFC, F, BANKED
353E  51FB     MOVF d, W, BANKED
3540  23FD     ADDWFC 0xFD, F, BANKED
3542  51FC     MOVF 0xFC, W, BANKED
3544  5DF5     SUBWF max, W, BANKED
3546  51FD     MOVF 0xFD, W, BANKED
3548  59F6     SUBWFB ehi, W, BANKED
354A  E319     BNC 0x357E
354C  C0EE     MOVFF dt, FSR2
354E  FFD9     NOP
3550  C0EF     MOVFF 0xEF, FSR2H
3552  FFDA     NOP
3554  CFDE     MOVFF POSTINC2, pco
3556  F0FA     NOP
3558  CFDD     MOVFF POSTDEC2, d
355A  F0FB     NOP
355C  51CA     MOVF pp, W, BANKED
355E  6FFC     MOVWF 0xFC, BANKED
3560  6BFD     CLRF 0xFD, BANKED
3562  0100     MOVLB 0x0
3564  51FA     MOVF pco, W, BANKED
3566  27FC     ADDWF 0xFC, F, BANKED
3568  51FB     MOVF d, W, BANKED
356A  23FD     ADDWFC 0xFD, F, BANKED
356C  C0EE     MOVFF dt, FSR2
356E  FFD9     NOP
3570  C0EF     MOVFF 0xEF, FSR2H
3572  FFDA     NOP
3574  C0FC     MOVFF 0xFC, POSTINC2
3576  FFDE     NOP
3578  C0FD     MOVFF 0xFD, POSTDEC2
357A  FFDD     NOP
357C  D009     BRA 0x3590
390:                           else *dt = max;
357E  C0EE     MOVFF dt, FSR2
3580  FFD9     NOP
3582  C0EF     MOVFF 0xEF, FSR2H
3584  FFDA     NOP
3586  C0F5     MOVFF max, POSTINC2
3588  FFDE     NOP
358A  C0F6     MOVFF ehi, POSTDEC2
358C  FFDD     NOP
391:                       }
358E  D000     BRA 0x3590
392:                   }
393:                   if(key == 2 && fst)
3590  0E02     MOVLW 0x2
3592  0100     MOVLB 0x0
3594  19FF     XORWF key, W, BANKED
3596  E001     BZ 0x359A
3598  D103     BRA 0x37A0
359A  51F9     MOVF fst, W, BANKED
359C  E101     BNZ 0x35A0
359E  D100     BRA 0x37A0
394:                   {
395:                       if(iu <= (_RDKRFSXLID - 1) * _VKRFSXLID) iu++;
35A0  0E0D     MOVLW 0xD
35A2  61C9     CPFSLT iu, BANKED
35A4  D002     BRA 0x35AA
35A6  2BC9     INCF iu, F, BANKED
35A8  D000     BRA 0x35AA
396:                       ktu = _RDKRFSXLID - iu / _VKRFSXLID; //czas miedzy kolejnymi impulsami inkrementacji
35AA  C0C9     MOVFF iu, k
35AC  F0E4     NOP
35AE  0100     MOVLB 0x0
35B0  6BE5     CLRF k, BANKED
35B2  6BE7     CLRF sign, BANKED
35B4  0E03     MOVLW 0x3
35B6  6FE6     MOVWF counter, BANKED
35B8  EC09     CALL 0xC212, 0
35BA  F061     NOP
35BC  0100     MOVLB 0x0
35BE  51E4     MOVF k, W, BANKED
35C0  0800     SUBLW 0x0
35C2  0F05     ADDLW 0x5
35C4  0101     MOVLB 0x1
35C6  6F73     MOVWF _PFNf_fmsg, BANKED
397:                       if(iu > (_RDKRFSXLID - 1) * _VKRFSXLID)
35C8  0E0C     MOVLW 0xC
35CA  0100     MOVLB 0x0
35CC  65C9     CPFSGT iu, BANKED
35CE  D022     BRA 0x3614
398:                       {
399:                           if(es2)
35D0  0101     MOVLB 0x1
35D2  5172     MOVF _PFNf_ferr, W, BANKED
35D4  E006     BZ 0x35E2
400:                           {
401:                               if(pp < step2) pp++;
35D6  0100     MOVLB 0x0
35D8  51F8     MOVF step2, W, BANKED
35DA  5DCA     SUBWF pp, W, BANKED
35DC  E205     BC 0x35E8
35DE  2BCA     INCF pp, F, BANKED
402:                           }
35E0  D003     BRA 0x35E8
403:                           else pp = step;
35E2  C0F7     MOVFF step, pp
35E4  F0CA     NOP
35E6  D000     BRA 0x35E8
404:                           if((*dt % 10) == 0) es2 = 1;
35E8  C0EE     MOVFF dt, FSR2
35EA  FFD9     NOP
35EC  C0EF     MOVFF 0xEF, FSR2H
35EE  FFDA     NOP
35F0  CFDE     MOVFF POSTINC2, __pcstackBANK0
35F2  F0DE     NOP
35F4  CFDD     MOVFF POSTDEC2, pco
35F6  F0DF     NOP
35F8  0100     MOVLB 0x0
35FA  6BE1     CLRF GIE_BIT_VAL, BANKED
35FC  0E0A     MOVLW 0xA
35FE  6FE0     MOVWF bdat, BANKED
3600  EC88     CALL 0xDD10, 0
3602  F06E     NOP
3604  0100     MOVLB 0x0
3606  51DE     MOVF __pcstackBANK0, W, BANKED
3608  11DF     IORWF pco, W, BANKED
360A  E109     BNZ 0x361E
360C  0E01     MOVLW 0x1
360E  0101     MOVLB 0x1
3610  6F72     MOVWF _PFNf_ferr, BANKED
405:                       }
3612  D005     BRA 0x361E
406:                       else
407:                       {
408:                           es2 = 0;
3614  0E00     MOVLW 0x0
3616  0101     MOVLB 0x1
3618  6F72     MOVWF _PFNf_ferr, BANKED
409:                           pp = step;
361A  C0F7     MOVFF step, pp
361C  F0CA     NOP
410:                       }
411:                       if(!tid)
361E  0100     MOVLB 0x0
3620  51F2     MOVF tid, W, BANKED
3622  E165     BNZ 0x36EE
412:                       {
413:                           if(!*dt || ((*dt - pp) < min)) *ovf = 1;
3624  C0EE     MOVFF dt, FSR2
3626  FFD9     NOP
3628  C0EF     MOVFF 0xEF, FSR2H
362A  FFDA     NOP
362C  50DE     MOVF POSTINC2, W, ACCESS
362E  10DE     IORWF POSTINC2, W, ACCESS
3630  E018     BZ 0x3662
3632  C0EE     MOVFF dt, FSR2
3634  FFD9     NOP
3636  C0EF     MOVFF 0xEF, FSR2H
3638  FFDA     NOP
363A  CFDE     MOVFF POSTINC2, pco
363C  F0FA     NOP
363E  CFDD     MOVFF POSTDEC2, d
3640  F0FB     NOP
3642  51CA     MOVF pp, W, BANKED
3644  6FFC     MOVWF 0xFC, BANKED
3646  6BFD     CLRF 0xFD, BANKED
3648  1FFC     COMF 0xFC, F, BANKED
364A  1FFD     COMF 0xFD, F, BANKED
364C  4BFC     INFSNZ 0xFC, F, BANKED
364E  2BFD     INCF 0xFD, F, BANKED
3650  51FA     MOVF pco, W, BANKED
3652  27FC     ADDWF 0xFC, F, BANKED
3654  51FB     MOVF d, W, BANKED
3656  23FD     ADDWFC 0xFD, F, BANKED
3658  51F3     MOVF min, W, BANKED
365A  5DFC     SUBWF 0xFC, W, BANKED
365C  51F4     MOVF pco, W, BANKED
365E  59FD     SUBWFB 0xFD, W, BANKED
3660  E206     BC 0x366E
3662  C0F0     MOVFF p, FSR2
3664  FFD9     NOP
3666  C0F1     MOVFF m, FSR2H
3668  FFDA     NOP
366A  0E01     MOVLW 0x1
366C  D005     BRA 0x3678
414:                           else *ovf = 0;
366E  C0F0     MOVFF p, FSR2
3670  FFD9     NOP
3672  C0F1     MOVFF m, FSR2H
3674  FFDA     NOP
3676  0E00     MOVLW 0x0
3678  6EDF     MOVWF INDF2, ACCESS
367A  D000     BRA 0x367C
415:                           if(*dt && ((*dt - pp) > min)) *dt = *dt - pp;
367C  C0EE     MOVFF dt, FSR2
367E  FFD9     NOP
3680  C0EF     MOVFF 0xEF, FSR2H
3682  FFDA     NOP
3684  50DE     MOVF POSTINC2, W, ACCESS
3686  10DE     IORWF POSTINC2, W, ACCESS
3688  E029     BZ 0x36DC
368A  C0EE     MOVFF dt, FSR2
368C  FFD9     NOP
368E  C0EF     MOVFF 0xEF, FSR2H
3690  FFDA     NOP
3692  CFDE     MOVFF POSTINC2, pco
3694  F0FA     NOP
3696  CFDD     MOVFF POSTDEC2, d
3698  F0FB     NOP
369A  0100     MOVLB 0x0
369C  51CA     MOVF pp, W, BANKED
369E  6FFC     MOVWF 0xFC, BANKED
36A0  6BFD     CLRF 0xFD, BANKED
36A2  1FFC     COMF 0xFC, F, BANKED
36A4  1FFD     COMF 0xFD, F, BANKED
36A6  4BFC     INFSNZ 0xFC, F, BANKED
36A8  2BFD     INCF 0xFD, F, BANKED
36AA  51FA     MOVF pco, W, BANKED
36AC  27FC     ADDWF 0xFC, F, BANKED
36AE  51FB     MOVF d, W, BANKED
36B0  23FD     ADDWFC 0xFD, F, BANKED
36B2  51FC     MOVF 0xFC, W, BANKED
36B4  5DF3     SUBWF min, W, BANKED
36B6  51FD     MOVF 0xFD, W, BANKED
36B8  59F4     SUBWFB pco, W, BANKED
36BA  E210     BC 0x36DC
36BC  C0EE     MOVFF dt, FSR2
36BE  FFD9     NOP
36C0  C0EF     MOVFF 0xEF, FSR2H
36C2  FFDA     NOP
36C4  CFDE     MOVFF POSTINC2, pco
36C6  F0FA     NOP
36C8  CFDD     MOVFF POSTDEC2, d
36CA  F0FB     NOP
36CC  51CA     MOVF pp, W, BANKED
36CE  6FFC     MOVWF 0xFC, BANKED
36D0  6BFD     CLRF 0xFD, BANKED
36D2  1FFC     COMF 0xFC, F, BANKED
36D4  1FFD     COMF 0xFD, F, BANKED
36D6  4BFC     INFSNZ 0xFC, F, BANKED
36D8  2BFD     INCF 0xFD, F, BANKED
36DA  D04B     BRA 0x3772
416:                           else *dt = min;
36DC  C0EE     MOVFF dt, FSR2
36DE  FFD9     NOP
36E0  C0EF     MOVFF 0xEF, FSR2H
36E2  FFDA     NOP
36E4  C0F3     MOVFF min, POSTINC2
36E6  FFDE     NOP
36E8  C0F4     MOVFF pco, POSTDEC2
36EA  FFDD     NOP
417:                       }
36EC  D059     BRA 0x37A0
418:                       else
419:                       {
420:                           if((*dt + pp) > max) *ovf = 1;
36EE  C0EE     MOVFF dt, FSR2
36F0  FFD9     NOP
36F2  C0EF     MOVFF 0xEF, FSR2H
36F4  FFDA     NOP
36F6  CFDE     MOVFF POSTINC2, pco
36F8  F0FA     NOP
36FA  CFDD     MOVFF POSTDEC2, d
36FC  F0FB     NOP
36FE  0100     MOVLB 0x0
3700  51CA     MOVF pp, W, BANKED
3702  6FFC     MOVWF 0xFC, BANKED
3704  6BFD     CLRF 0xFD, BANKED
3706  51FA     MOVF pco, W, BANKED
3708  27FC     ADDWF 0xFC, F, BANKED
370A  51FB     MOVF d, W, BANKED
370C  23FD     ADDWFC 0xFD, F, BANKED
370E  51FC     MOVF 0xFC, W, BANKED
3710  5DF5     SUBWF max, W, BANKED
3712  51FD     MOVF 0xFD, W, BANKED
3714  59F6     SUBWFB ehi, W, BANKED
3716  E206     BC 0x3724
3718  C0F0     MOVFF p, FSR2
371A  FFD9     NOP
371C  C0F1     MOVFF m, FSR2H
371E  FFDA     NOP
3720  0E01     MOVLW 0x1
3722  D005     BRA 0x372E
421:                           else *ovf = 0;
3724  C0F0     MOVFF p, FSR2
3726  FFD9     NOP
3728  C0F1     MOVFF m, FSR2H
372A  FFDA     NOP
372C  0E00     MOVLW 0x0
372E  6EDF     MOVWF INDF2, ACCESS
3730  D000     BRA 0x3732
422:                           if(*dt + pp <= max) *dt = *dt + pp;
3732  C0EE     MOVFF dt, FSR2
3734  FFD9     NOP
3736  C0EF     MOVFF 0xEF, FSR2H
3738  FFDA     NOP
373A  CFDE     MOVFF POSTINC2, pco
373C  F0FA     NOP
373E  CFDD     MOVFF POSTDEC2, d
3740  F0FB     NOP
3742  0100     MOVLB 0x0
3744  51CA     MOVF pp, W, BANKED
3746  6FFC     MOVWF 0xFC, BANKED
3748  6BFD     CLRF 0xFD, BANKED
374A  51FA     MOVF pco, W, BANKED
374C  27FC     ADDWF 0xFC, F, BANKED
374E  51FB     MOVF d, W, BANKED
3750  23FD     ADDWFC 0xFD, F, BANKED
3752  51FC     MOVF 0xFC, W, BANKED
3754  5DF5     SUBWF max, W, BANKED
3756  51FD     MOVF 0xFD, W, BANKED
3758  59F6     SUBWFB ehi, W, BANKED
375A  E319     BNC 0x378E
375C  C0EE     MOVFF dt, FSR2
375E  FFD9     NOP
3760  C0EF     MOVFF 0xEF, FSR2H
3762  FFDA     NOP
3764  CFDE     MOVFF POSTINC2, pco
3766  F0FA     NOP
3768  CFDD     MOVFF POSTDEC2, d
376A  F0FB     NOP
376C  51CA     MOVF pp, W, BANKED
376E  6FFC     MOVWF 0xFC, BANKED
3770  6BFD     CLRF 0xFD, BANKED
3772  0100     MOVLB 0x0
3774  51FA     MOVF pco, W, BANKED
3776  27FC     ADDWF 0xFC, F, BANKED
3778  51FB     MOVF d, W, BANKED
377A  23FD     ADDWFC 0xFD, F, BANKED
377C  C0EE     MOVFF dt, FSR2
377E  FFD9     NOP
3780  C0EF     MOVFF 0xEF, FSR2H
3782  FFDA     NOP
3784  C0FC     MOVFF 0xFC, POSTINC2
3786  FFDE     NOP
3788  C0FD     MOVFF 0xFD, POSTDEC2
378A  FFDD     NOP
378C  D009     BRA 0x37A0
423:                           else *dt = max;
378E  C0EE     MOVFF dt, FSR2
3790  FFD9     NOP
3792  C0EF     MOVFF 0xEF, FSR2H
3794  FFDA     NOP
3796  C0F5     MOVFF max, POSTINC2
3798  FFDE     NOP
379A  C0F6     MOVFF ehi, POSTDEC2
379C  FFDD     NOP
424:                       }
379E  D000     BRA 0x37A0
425:           
426:                   }
427:                   if(*dt < min) *dt = min;
37A0  C0EE     MOVFF dt, FSR2
37A2  FFD9     NOP
37A4  C0EF     MOVFF 0xEF, FSR2H
37A6  FFDA     NOP
37A8  0100     MOVLB 0x0
37AA  51F3     MOVF min, W, BANKED
37AC  5CDE     SUBWF POSTINC2, W, ACCESS
37AE  51F4     MOVF pco, W, BANKED
37B0  58DE     SUBWFB POSTINC2, W, ACCESS
37B2  E209     BC 0x37C6
37B4  C0EE     MOVFF dt, FSR2
37B6  FFD9     NOP
37B8  C0EF     MOVFF 0xEF, FSR2H
37BA  FFDA     NOP
37BC  C0F3     MOVFF min, POSTINC2
37BE  FFDE     NOP
37C0  C0F4     MOVFF pco, POSTDEC2
37C2  FFDD     NOP
37C4  D000     BRA 0x37C6
428:                   if(*dt > max) *dt = max;
37C6  C0EE     MOVFF dt, FSR2
37C8  FFD9     NOP
37CA  C0EF     MOVFF 0xEF, FSR2H
37CC  FFDA     NOP
37CE  50DE     MOVF POSTINC2, W, ACCESS
37D0  0100     MOVLB 0x0
37D2  5DF5     SUBWF max, W, BANKED
37D4  50DE     MOVF POSTINC2, W, ACCESS
37D6  59F6     SUBWFB ehi, W, BANKED
37D8  B0D8     BTFSC STATUS, 0, ACCESS
37DA  0012     RETURN 0
37DC  C0EE     MOVFF dt, FSR2
37DE  FFD9     NOP
37E0  C0EF     MOVFF 0xEF, FSR2H
37E2  FFDA     NOP
37E4  C0F5     MOVFF max, POSTINC2
37E6  FFDE     NOP
37E8  C0F6     MOVFF ehi, POSTDEC2
37EA  FFDD     NOP
429:                   return 1;
430:               }
37EC  0012     RETURN 0
431:               else
432:               {
433:                   iu = 0;
37EE  0E00     MOVLW 0x0
37F0  0100     MOVLB 0x0
37F2  6FC9     MOVWF iu, BANKED
434:                   ktu = 5;
37F4  0E05     MOVLW 0x5
37F6  0101     MOVLB 0x1
37F8  6F73     MOVWF _PFNf_fmsg, BANKED
435:                   es2 = 0;
37FA  0E00     MOVLW 0x0
37FC  6F72     MOVWF _PFNf_ferr, BANKED
436:                   pp = step;
37FE  C0F7     MOVFF step, pp
3800  F0CA     NOP
437:               }
3802  0012     RETURN 0
438:               return 0x00;
439:           }
3804  0012     RETURN 0
440:           #endif
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/pwron.c  ---------------------------------
1:             /*pwron.c*/
2:             #include <pic18.h>
3:             #include "global.h"			//parametry globalne
4:             #include "pwron.h"			//parametry lokalne
5:             
6:             //Procedura oparta o zegar RTdS(_RTON) ktory musi byc zadeklarowany w pliku rtimer.c/h
7:             
8:             void PwrOnDelay(void)
9:             {
10:                StartRTdS(_RTON);
DB64  0E00     MOVLW 0x0
DB66  ECA0     CALL 0xE540, 0
DB68  F072     NOP
11:                while(RTdS(_RTON) < _TPWRON)
DB6A  D01D     BRA 0xDBA6
DBA6  0E00     MOVLW 0x0
DBA8  ECD7     CALL 0xEBAE, 0
DBAA  F075     NOP
DBAC  0100     MOVLB 0x0
DBAE  6FEE     MOVWF dt, BANKED
DBB0  0E0E     MOVLW 0xE
DBB2  65EE     CPFSGT dt, BANKED
DBB4  D7DB     BRA 0xDB6C
DBB6  0C0E     RETLW 0xE
12:                {
13:                    CLRWDT();
DB6C  0004     CLRWDT
14:            		if(RTdS(_RTON)<=7) WritePWM2(ProcToPmpPwm(80));		//dioda srednio rozswietlona	
DB6E  0E00     MOVLW 0x0
DB70  ECD7     CALL 0xEBAE, 0
DB72  F075     NOP
DB74  0100     MOVLB 0x0
DB76  6FEE     MOVWF dt, BANKED
DB78  0E08     MOVLW 0x8
DB7A  61EE     CPFSLT dt, BANKED
DB7C  D006     BRA 0xDB8A
DB7E  0E50     MOVLW 0x50
DB80  EC04     CALL 0xDE08, 0
DB82  F06F     NOP
DB84  EC6D     CALL 0xF2DA, 0
DB86  F079     NOP
DB88  D000     BRA 0xDB8A
15:            		if(RTdS(_RTON)<15) WritePWM2(ProcToPmpPwm(100)); 	//dioda wygaszona        
DB8A  0E00     MOVLW 0x0
DB8C  ECD7     CALL 0xEBAE, 0
DB8E  F075     NOP
DB90  0100     MOVLB 0x0
DB92  6FEE     MOVWF dt, BANKED
DB94  0E0F     MOVLW 0xF
DB96  61EE     CPFSLT dt, BANKED
DB98  D006     BRA 0xDBA6
DB9A  0E64     MOVLW 0x64
DB9C  EC04     CALL 0xDE08, 0
DB9E  F06F     NOP
DBA0  EC6D     CALL 0xF2DA, 0
DBA2  F079     NOP
DBA4  D000     BRA 0xDBA6
16:                };
17:            
18:            }
DBB8  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/pwm.c  -----------------------------------
1:             /*pwm.c*/
2:             //Procedury zwiazane z modulem CCP (tryb pracy = PWM)
3:             /*---------------------------------------------------------------------------------*/
4:             #include <pic18.h>
5:             #include "global.h"					//parametry globalne
6:             #include "pwm.h"					//parametry lokalne
7:             
8:             volatile DtPWM PWM; //czeste operacje na danych
9:             /*---------------------------------------------------------------------------------*/
10:            
11:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
12:            void InitPWM(void)
13:            {
14:                //pwm1 (modulator,vnt)
15:                CCP1CON = 0; //reset CCP1 module
E832  6ABD     CLRF CCP1CON, ACCESS
16:                CCPR1L = 0;
E834  6ABE     CLRF CCPR1, ACCESS
17:                CCPR1H = 0;
E836  6ABF     CLRF CCPR1H, ACCESS
18:                CCP1CON = 0b00001100; //set PWM mode
E838  0E0C     MOVLW 0xC
E83A  6EBD     MOVWF CCP1CON, ACCESS
19:                //pwm2 (pompa)
20:                CCP2CON = 0; //reset CCP2 module
E83C  6ABA     CLRF CCP2CON, ACCESS
21:                CCPR2L = 0;
E83E  6ABB     CLRF CCPR2, ACCESS
22:                CCPR2H = 0;
E840  6ABC     CLRF CCPR2H, ACCESS
23:                CCP2CON = 0b00001100; //set PWM mode, single output
E842  6EBA     MOVWF CCP2CON, ACCESS
24:                //timer2
25:                TMR2 = 0;
E844  6ACC     CLRF TMR2, ACCESS
26:                T2CON = _WT2CON; //new timer2 prescale value
E846  0E02     MOVLW 0x2
E848  6ECA     MOVWF T2CON, ACCESS
27:                PR2 = _WPR2; //PWM period
E84A  0E7C     MOVLW 0x7C
E84C  6ECB     MOVWF PR2, ACCESS
28:                TMR2IE = 1; //enable interrupt timer2
E84E  829D     BSF PIE1, 1, ACCESS
29:                TMR2ON = 1; //start timer2
E850  84CA     BSF T2CON, 2, ACCESS
30:                //nalezy jeszcze ustawic pin CCP1 jako wyjscie
31:            
32:            #if(_WPR2<0x40)
33:            #if(((_WPR2+1)<<2)<0xFF)
34:                PWM.HIPWM = (_WPR2 + 1) << 2; //gorna bezwgledna granica wypelnienia
35:            #else
36:                PWM.HIPWM = 0xFF; //gorna bezwgledna granica wypelnienia
37:            #endif
38:            #endif
39:            #if(_WPR2>0x40 && _WPR2<0x80)
40:            #if(((_WPR2+1)<<1)<0xFF)
41:                PWM.HIPWM = (_WPR2 + 1) << 1; //gorna bezwgledna granica wypelnienia
E852  0EFA     MOVLW 0xFA
E854  0100     MOVLB 0x0
E856  6F66     MOVWF 0x66, BANKED
42:            #else
43:                PWM.HIPWM = 0xFF; //gorna bezwgledna granica wypelnienia
44:            #endif
45:            #endif
46:            #if(_WPR2>0x80)
47:            #if((_WPR2+1)<0xFF)
48:                PWM.HIPWM = (_WPR2 + 1); //gorna bezwgledna granica wypelnienia
49:            #else
50:                PWM.HIPWM = 0xFF; //gorna bezwgledna granica wypelnienia
51:            #endif
52:            #endif
53:            
54:                PWM.BufPWM = 0;
E858  0E00     MOVLW 0x0
E85A  6B60     CLRF PWM, BANKED
55:                PWM.NewPWM = 0;
E85C  6B63     CLRF 0x63, BANKED
56:                PWM.BufOSC = 0;
E85E  6B61     CLRF 0x61, BANKED
57:                PWM.NewOSC = 0;
E860  6B62     CLRF 0x62, BANKED
58:                PWM.BufPWM2 = 0;
E862  6B64     CLRF 0x64, BANKED
59:                PWM.NewPWM2 = 0;
E864  6B65     CLRF 0x65, BANKED
60:            }
E866  0012     RETURN 0
61:            /*---------------------------------------------------------------------------------*/
62:            /*---------------------------------------------------------------------------------*/
63:            //Podstawowe parametry modulatora (uwaga: wywolywoac gdy wybrano typ kotla)
64:            //tpk - typ kotla
65:            //tpg - rodzaj gazu
66:            unsigned char MocProc(unsigned char nst);
67:            void ModParam(const unsigned char tpk, const unsigned char tpg)
5086  0100     MOVLB 0x0
5088  6FE1     MOVWF GIE_BIT_VAL, BANKED
68:            {
69:                PWMf_tpGZ = (tpg != 0);
508A  0100     MOVLB 0x0
508C  51E0     MOVF bdat, W, BANKED
508E  E002     BZ 0x5094
5090  8E13     BSF PFNf_zima, 7, ACCESS
5092  D001     BRA 0x5096
5094  9E13     BCF PFNf_zima, 7, ACCESS
70:            
71:                //parametry zalezne od typu kotla i wybranego rodzaju gazu
72:                if(!PWMf_tpGZ) //gaz ziemny
5096  AE13     BTFSS PFNf_zima, 7, ACCESS
5098  D0DE     BRA 0x5256
509A  D1C8     BRA 0x542C
73:                {
74:                    switch(tpk) //typ kotla
509C  D0DC     BRA 0x5256
5256  0100     MOVLB 0x0
5258  51E1     MOVF GIE_BIT_VAL, W, BANKED
525A  E101     BNZ 0x525E
525C  D720     BRA 0x509E
525E  0A01     XORLW 0x1
5260  E101     BNZ 0x5264
5262  D749     BRA 0x50F6
5264  0A03     XORLW 0x3
5266  E101     BNZ 0x526A
5268  D772     BRA 0x514E
526A  0A01     XORLW 0x1
526C  E09C     BZ 0x51A6
526E  D7C7     BRA 0x51FE
75:                    {
76:                        case _UNICO: //jednofunkcyjny
77:                        {
78:                            PWMf_ENOSC = (_EN_OSC0 != 0);
509E  8813     BSF PFNf_zima, 4, ACCESS
79:                            PWM.MDMOD = _MD_MOD0;
50A0  0E30     MOVLW 0x30
50A2  0100     MOVLB 0x0
50A4  6F67     MOVWF _PFNf_b_set_ncw, BANKED
80:                            PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
50A6  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
50A8  F068     NOP
81:                            PWM.MGMOD = _MG_MOD0;
50AA  0E9F     MOVLW 0x9F
50AC  0100     MOVLB 0x0
50AE  6F6A     MOVWF _PFNf_blkcs, BANKED
82:                            PWM.MAXOSC = _MAX_OSC_PWM0;
50B0  0E14     MOVLW 0x14
50B2  6F6B     MOVWF _PFNf_csn, BANKED
83:                            PWM.MINOSC = _MIN_OSC_PWM0;
50B4  0E05     MOVLW 0x5
50B6  6F6C     MOVWF _PFNf_enKNF, BANKED
84:                            PWM.MAD_MOD = _MAD_MOD0;
50B8  0E14     MOVLW 0x14
50BA  6F6D     MOVWF _PFNf_errCO, BANKED
85:                            PWM.MAG_MOD = _MAG_MOD0;
50BC  0EF7     MOVLW 0xF7
50BE  6F6E     MOVWF _PFNf_errCS, BANKED
86:                            PWM.GWMSTART = _GWMSTART0;
50C0  0E63     MOVLW 0x63
50C2  6F6F     MOVWF _PFNf_errCW, BANKED
87:                            PWM.MDSTART = _MDSTART0;
50C4  0E30     MOVLW 0x30
50C6  6F70     MOVWF _PFNf_errIN, BANKED
88:                            PWM.MGSTART = _MGSTART0;
50C8  0EA9     MOVLW 0xA9
50CA  6F71     MOVWF _PFNf_fL3, BANKED
89:                            PWM.GWMMAXCO = _GWMMAXCO0;
50CC  0E63     MOVLW 0x63
50CE  6F72     MOVWF _PFNf_ferr, BANKED
90:                            PWM.MDMAXCO = _MDMMAXCO0;
50D0  0E30     MOVLW 0x30
50D2  6F73     MOVWF _PFNf_fmsg, BANKED
91:                            PWM.MGMAXCO = _MGMMAXCO0;
50D4  0EA9     MOVLW 0xA9
50D6  6F74     MOVWF _PFNf_fnoCS, BANKED
92:                            PWM.GWMMAXCW = _GWMMAXCW0;
50D8  0E63     MOVLW 0x63
50DA  6F75     MOVWF _PFNf_fns_max, BANKED
93:                            PWM.MDMAXCW = _MDMMAXCW0;
50DC  0E30     MOVLW 0x30
50DE  6F76     MOVWF _PFNf_fnserw, BANKED
94:                            PWM.MGMAXCW = _MGMMAXCW0;
50E0  0EA9     MOVLW 0xA9
50E2  6F77     MOVWF _PFNf_lato, BANKED
95:                            PWM.FIRSTPB = _I80_MOD0;
50E4  0E75     MOVLW 0x75
50E6  6F78     MOVWF _PFNf_mod_ncw, BANKED
96:                            PWM.PROP1 = _MG_MOD0 - 1 * ((_MG_MOD0 - _MD_MOD0) / 7);
50E8  0E90     MOVLW 0x90
50EA  6F79     MOVWF _PFNf_newPCO, BANKED
97:                            PWM.PROP2 = _MG_MOD0 - 2 * ((_MG_MOD0 - _MD_MOD0) / 7);
50EC  0E81     MOVLW 0x81
50EE  6F7A     MOVWF _PFNf_newPCW, BANKED
98:                            PWM.PROP3 = _MG_MOD0 - 3 * ((_MG_MOD0 - _MD_MOD0) / 7);
50F0  0E72     MOVLW 0x72
50F2  6F7B     MOVWF _PFNf_newPFN, BANKED
99:                            break;
50F4  0C72     RETLW 0x72
100:                       }
101:                       case _BITERM: //bitermiczny (miniterm)
102:                       {
103:                           PWMf_ENOSC = (_EN_OSC1 != 0);
50F6  8813     BSF PFNf_zima, 4, ACCESS
104:                           PWM.MDMOD = _MD_MOD1;
50F8  0E20     MOVLW 0x20
50FA  0100     MOVLB 0x0
50FC  6F67     MOVWF _PFNf_b_set_ncw, BANKED
105:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
50FE  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
5100  F068     NOP
106:                           PWM.MGMOD = _MG_MOD1;
5102  0E9F     MOVLW 0x9F
5104  0100     MOVLB 0x0
5106  6F6A     MOVWF _PFNf_blkcs, BANKED
107:                           PWM.MAXOSC = _MAX_OSC_PWM1;
5108  0E1E     MOVLW 0x1E
510A  6F6B     MOVWF _PFNf_csn, BANKED
108:                           PWM.MINOSC = _MIN_OSC_PWM1;
510C  0E05     MOVLW 0x5
510E  6F6C     MOVWF _PFNf_enKNF, BANKED
109:                           PWM.MAD_MOD = _MAD_MOD1;
5110  0E14     MOVLW 0x14
5112  6F6D     MOVWF _PFNf_errCO, BANKED
110:                           PWM.MAG_MOD = _MAG_MOD1;
5114  0EF7     MOVLW 0xF7
5116  6F6E     MOVWF _PFNf_errCS, BANKED
111:                           PWM.GWMSTART = _GWMSTART1;
5118  0E63     MOVLW 0x63
511A  6F6F     MOVWF _PFNf_errCW, BANKED
112:                           PWM.MDSTART = _MDSTART1;
511C  0E20     MOVLW 0x20
511E  6F70     MOVWF _PFNf_errIN, BANKED
113:                           PWM.MGSTART = _MGSTART1;
5120  0EA9     MOVLW 0xA9
5122  6F71     MOVWF _PFNf_fL3, BANKED
114:                           PWM.GWMMAXCO = _GWMMAXCO1;
5124  0E63     MOVLW 0x63
5126  6F72     MOVWF _PFNf_ferr, BANKED
115:                           PWM.MDMAXCO = _MDMMAXCO1;
5128  0E20     MOVLW 0x20
512A  6F73     MOVWF _PFNf_fmsg, BANKED
116:                           PWM.MGMAXCO = _MGMMAXCO1;
512C  0EA9     MOVLW 0xA9
512E  6F74     MOVWF _PFNf_fnoCS, BANKED
117:                           PWM.GWMMAXCW = _GWMMAXCW1;
5130  0E63     MOVLW 0x63
5132  6F75     MOVWF _PFNf_fns_max, BANKED
118:                           PWM.MDMAXCW = _MDMMAXCW1;
5134  0E20     MOVLW 0x20
5136  6F76     MOVWF _PFNf_fnserw, BANKED
119:                           PWM.MGMAXCW = _MGMMAXCW1;
5138  0EA9     MOVLW 0xA9
513A  6F77     MOVWF _PFNf_lato, BANKED
120:                           PWM.FIRSTPB = _I80_MOD1;
513C  0E75     MOVLW 0x75
513E  6F78     MOVWF _PFNf_mod_ncw, BANKED
121:                           PWM.PROP1 = _MG_MOD1 - 1 * ((_MG_MOD1 - _MD_MOD1) / 7);
5140  0E8D     MOVLW 0x8D
5142  6F79     MOVWF _PFNf_newPCO, BANKED
122:                           PWM.PROP2 = _MG_MOD1 - 2 * ((_MG_MOD1 - _MD_MOD1) / 7);
5144  0E7B     MOVLW 0x7B
5146  6F7A     MOVWF _PFNf_newPCW, BANKED
123:                           PWM.PROP3 = _MG_MOD1 - 3 * ((_MG_MOD1 - _MD_MOD1) / 7);
5148  0E69     MOVLW 0x69
514A  6F7B     MOVWF _PFNf_newPFN, BANKED
124:                           break;
514C  0C69     RETLW 0x69
125:                       }
126:                           /*
127:                                                   case _MONOTERM:		//monotermiczny
128:                                                   case _ZASOBNIK:		//zasobnikowy
129:                                                   {
130:                                                           PWMf_ENOSC=(_EN_OSC2!=0);
131:                                                           PWM.MDMOD=_MD_MOD2;
132:                                                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
133:                                                           PWM.MGMOD=_MG_MOD2;
134:                                                           PWM.MAXOSC=_MAX_OSC_PWM2;
135:                                                           PWM.MINOSC=_MIN_OSC_PWM2;
136:                                                           PWM.MAD_MOD=_MAD_MOD2;
137:                                                           PWM.MAG_MOD=_MAG_MOD2;
138:                                                           PWM.GWMSTART=_GWMSTART2;
139:                                                           PWM.MDSTART=_MDSTART2;
140:                                                           PWM.MGSTART=_MGSTART2;
141:                                                           PWM.GWMMAXCO=_GWMMAXCO2;
142:                                                           PWM.MDMAXCO=_MDMMAXCO2;
143:                                                           PWM.MGMAXCO=_MGMMAXCO2;
144:                                                           PWM.GWMMAXCW=_GWMMAXCW2;
145:                                                           PWM.MDMAXCW=_MDMMAXCW2;
146:                                                           PWM.MGMAXCW=_MGMMAXCW2;
147:                                                           PWM.FIRSTPB=_I80_MOD2;
148:                                                           PWM.PROP1=_MG_MOD2-1*((_MG_MOD2-_MD_MOD2)/7);
149:                                                           PWM.PROP2=_MG_MOD2-2*((_MG_MOD2-_MD_MOD2)/7);
150:                                                           PWM.PROP3=_MG_MOD2-3*((_MG_MOD2-_MD_MOD2)/7);
151:                                                           break;
152:                                                   }
153:                            */
154:                       case _BITERM2: //bitermiczny (maxiterm)
155:                       {
156:                           PWMf_ENOSC = (_EN_OSC3 != 0);
514E  8813     BSF PFNf_zima, 4, ACCESS
157:                           PWM.MDMOD = _MD_MOD3;
5150  0E30     MOVLW 0x30
5152  0100     MOVLB 0x0
5154  6F67     MOVWF _PFNf_b_set_ncw, BANKED
158:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
5156  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
5158  F068     NOP
159:                           PWM.MGMOD = _MG_MOD3;
515A  0EA0     MOVLW 0xA0
515C  0100     MOVLB 0x0
515E  6F6A     MOVWF _PFNf_blkcs, BANKED
160:                           PWM.MAXOSC = _MAX_OSC_PWM3;
5160  0E19     MOVLW 0x19
5162  6F6B     MOVWF _PFNf_csn, BANKED
161:                           PWM.MINOSC = _MIN_OSC_PWM3;
5164  0E05     MOVLW 0x5
5166  6F6C     MOVWF _PFNf_enKNF, BANKED
162:                           PWM.MAD_MOD = _MAD_MOD3;
5168  0E14     MOVLW 0x14
516A  6F6D     MOVWF _PFNf_errCO, BANKED
163:                           PWM.MAG_MOD = _MAG_MOD3;
516C  0EF7     MOVLW 0xF7
516E  6F6E     MOVWF _PFNf_errCS, BANKED
164:                           PWM.GWMSTART = _GWMSTART3;
5170  0E63     MOVLW 0x63
5172  6F6F     MOVWF _PFNf_errCW, BANKED
165:                           PWM.MDSTART = _MDSTART3;
5174  0E30     MOVLW 0x30
5176  6F70     MOVWF _PFNf_errIN, BANKED
166:                           PWM.MGSTART = _MGSTART3;
5178  0EAA     MOVLW 0xAA
517A  6F71     MOVWF _PFNf_fL3, BANKED
167:                           PWM.GWMMAXCO = _GWMMAXCO3;
517C  0E63     MOVLW 0x63
517E  6F72     MOVWF _PFNf_ferr, BANKED
168:                           PWM.MDMAXCO = _MDMMAXCO3;
5180  0E30     MOVLW 0x30
5182  6F73     MOVWF _PFNf_fmsg, BANKED
169:                           PWM.MGMAXCO = _MGMMAXCO3;
5184  0EAA     MOVLW 0xAA
5186  6F74     MOVWF _PFNf_fnoCS, BANKED
170:                           PWM.GWMMAXCW = _GWMMAXCW3;
5188  0E63     MOVLW 0x63
518A  6F75     MOVWF _PFNf_fns_max, BANKED
171:                           PWM.MDMAXCW = _MDMMAXCW3;
518C  0E30     MOVLW 0x30
518E  6F76     MOVWF _PFNf_fnserw, BANKED
172:                           PWM.MGMAXCW = _MGMMAXCW3;
5190  0EAA     MOVLW 0xAA
5192  6F77     MOVWF _PFNf_lato, BANKED
173:                           PWM.FIRSTPB = _I80_MOD3;
5194  0E6E     MOVLW 0x6E
5196  6F78     MOVWF _PFNf_mod_ncw, BANKED
174:                           PWM.PROP1 = _MG_MOD3 - 1 * ((_MG_MOD3 - _MD_MOD3) / 7);
5198  0E90     MOVLW 0x90
519A  6F79     MOVWF _PFNf_newPCO, BANKED
175:                           PWM.PROP2 = _MG_MOD3 - 2 * ((_MG_MOD3 - _MD_MOD3) / 7);
519C  0E80     MOVLW 0x80
519E  6F7A     MOVWF _PFNf_newPCW, BANKED
176:                           PWM.PROP3 = _MG_MOD3 - 3 * ((_MG_MOD3 - _MD_MOD3) / 7);
51A0  0E70     MOVLW 0x70
51A2  6F7B     MOVWF _PFNf_newPFN, BANKED
177:                           break;
51A4  0C70     RETLW 0x70
178:                       }
179:                       case _MONOHB: //monotermiczny z hydroblokiem (minimax hb)
180:                       {
181:                           PWMf_ENOSC = (_EN_OSC4 != 0);
51A6  8813     BSF PFNf_zima, 4, ACCESS
182:                           PWM.MDMOD = _MD_MOD4;
51A8  0E2D     MOVLW 0x2D
51AA  0100     MOVLB 0x0
51AC  6F67     MOVWF _PFNf_b_set_ncw, BANKED
183:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
51AE  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
51B0  F068     NOP
184:                           PWM.MGMOD = _MG_MOD4;
51B2  0E9F     MOVLW 0x9F
51B4  0100     MOVLB 0x0
51B6  6F6A     MOVWF _PFNf_blkcs, BANKED
185:                           PWM.MAXOSC = _MAX_OSC_PWM4;
51B8  0E0F     MOVLW 0xF
51BA  6F6B     MOVWF _PFNf_csn, BANKED
186:                           PWM.MINOSC = _MIN_OSC_PWM4;
51BC  0E05     MOVLW 0x5
51BE  6F6C     MOVWF _PFNf_enKNF, BANKED
187:                           PWM.MAD_MOD = _MAD_MOD4;
51C0  0E14     MOVLW 0x14
51C2  6F6D     MOVWF _PFNf_errCO, BANKED
188:                           PWM.MAG_MOD = _MAG_MOD4;
51C4  0EF7     MOVLW 0xF7
51C6  6F6E     MOVWF _PFNf_errCS, BANKED
189:                           PWM.GWMSTART = _GWMSTART4;
51C8  0E63     MOVLW 0x63
51CA  6F6F     MOVWF _PFNf_errCW, BANKED
190:                           PWM.MDSTART = _MDSTART4;
51CC  0E2D     MOVLW 0x2D
51CE  6F70     MOVWF _PFNf_errIN, BANKED
191:                           PWM.MGSTART = _MGSTART4;
51D0  0EA9     MOVLW 0xA9
51D2  6F71     MOVWF _PFNf_fL3, BANKED
192:                           PWM.GWMMAXCO = _GWMMAXCO4;
51D4  0E63     MOVLW 0x63
51D6  6F72     MOVWF _PFNf_ferr, BANKED
193:                           PWM.MDMAXCO = _MDMMAXCO4;
51D8  0E2D     MOVLW 0x2D
51DA  6F73     MOVWF _PFNf_fmsg, BANKED
194:                           PWM.MGMAXCO = _MGMMAXCO4;
51DC  0EA9     MOVLW 0xA9
51DE  6F74     MOVWF _PFNf_fnoCS, BANKED
195:                           PWM.GWMMAXCW = _GWMMAXCW4;
51E0  0E63     MOVLW 0x63
51E2  6F75     MOVWF _PFNf_fns_max, BANKED
196:                           PWM.MDMAXCW = _MDMMAXCW4;
51E4  0E2D     MOVLW 0x2D
51E6  6F76     MOVWF _PFNf_fnserw, BANKED
197:                           PWM.MGMAXCW = _MGMMAXCW4;
51E8  0EA9     MOVLW 0xA9
51EA  6F77     MOVWF _PFNf_lato, BANKED
198:                           PWM.FIRSTPB = _I80_MOD4;
51EC  0E6E     MOVLW 0x6E
51EE  6F78     MOVWF _PFNf_mod_ncw, BANKED
199:                           PWM.PROP1 = _MG_MOD4 - 1 * ((_MG_MOD4 - _MD_MOD4) / 7);
51F0  0E8F     MOVLW 0x8F
51F2  6F79     MOVWF _PFNf_newPCO, BANKED
200:                           PWM.PROP2 = _MG_MOD4 - 2 * ((_MG_MOD4 - _MD_MOD4) / 7);
51F4  0E7F     MOVLW 0x7F
51F6  6F7A     MOVWF _PFNf_newPCW, BANKED
201:                           PWM.PROP3 = _MG_MOD4 - 3 * ((_MG_MOD4 - _MD_MOD4) / 7);
51F8  0E6F     MOVLW 0x6F
51FA  6F7B     MOVWF _PFNf_newPFN, BANKED
202:                           break;
51FC  0C6F     RETLW 0x6F
203:                       }
204:                       default: //domyslny monotermiczny
205:                       {
206:                           PWMf_ENOSC = (_EN_OSC4 != 0);
51FE  8813     BSF PFNf_zima, 4, ACCESS
207:                           PWM.MDMOD = _MD_MOD4;
5200  0E2D     MOVLW 0x2D
5202  0100     MOVLB 0x0
5204  6F67     MOVWF _PFNf_b_set_ncw, BANKED
208:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
5206  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
5208  F068     NOP
209:                           PWM.MGMOD = _MG_MOD4;
520A  0E9F     MOVLW 0x9F
520C  0100     MOVLB 0x0
520E  6F6A     MOVWF _PFNf_blkcs, BANKED
210:                           PWM.MAXOSC = _MAX_OSC_PWM4;
5210  0E0F     MOVLW 0xF
5212  6F6B     MOVWF _PFNf_csn, BANKED
211:                           PWM.MINOSC = _MIN_OSC_PWM4;
5214  0E05     MOVLW 0x5
5216  6F6C     MOVWF _PFNf_enKNF, BANKED
212:                           PWM.MAD_MOD = _MAD_MOD4;
5218  0E14     MOVLW 0x14
521A  6F6D     MOVWF _PFNf_errCO, BANKED
213:                           PWM.MAG_MOD = _MAG_MOD4;
521C  0EF7     MOVLW 0xF7
521E  6F6E     MOVWF _PFNf_errCS, BANKED
214:                           PWM.GWMSTART = _GWMSTART4;
5220  0E63     MOVLW 0x63
5222  6F6F     MOVWF _PFNf_errCW, BANKED
215:                           PWM.MDSTART = _MDSTART4;
5224  0E2D     MOVLW 0x2D
5226  6F70     MOVWF _PFNf_errIN, BANKED
216:                           PWM.MGSTART = _MGSTART4;
5228  0EA9     MOVLW 0xA9
522A  6F71     MOVWF _PFNf_fL3, BANKED
217:                           PWM.GWMMAXCO = _GWMMAXCO4;
522C  0E63     MOVLW 0x63
522E  6F72     MOVWF _PFNf_ferr, BANKED
218:                           PWM.MDMAXCO = _MDMMAXCO4;
5230  0E2D     MOVLW 0x2D
5232  6F73     MOVWF _PFNf_fmsg, BANKED
219:                           PWM.MGMAXCO = _MGMMAXCO4;
5234  0EA9     MOVLW 0xA9
5236  6F74     MOVWF _PFNf_fnoCS, BANKED
220:                           PWM.GWMMAXCW = _GWMMAXCW4;
5238  0E63     MOVLW 0x63
523A  6F75     MOVWF _PFNf_fns_max, BANKED
221:                           PWM.MDMAXCW = _MDMMAXCW4;
523C  0E2D     MOVLW 0x2D
523E  6F76     MOVWF _PFNf_fnserw, BANKED
222:                           PWM.MGMAXCW = _MGMMAXCW4;
5240  0EA9     MOVLW 0xA9
5242  6F77     MOVWF _PFNf_lato, BANKED
223:                           PWM.FIRSTPB = _I80_MOD4;
5244  0E6E     MOVLW 0x6E
5246  6F78     MOVWF _PFNf_mod_ncw, BANKED
224:                           PWM.PROP1 = _MG_MOD4 - 1 * ((_MG_MOD4 - _MD_MOD4) / 7);
5248  0E8F     MOVLW 0x8F
524A  6F79     MOVWF _PFNf_newPCO, BANKED
225:                           PWM.PROP2 = _MG_MOD4 - 2 * ((_MG_MOD4 - _MD_MOD4) / 7);
524C  0E7F     MOVLW 0x7F
524E  6F7A     MOVWF _PFNf_newPCW, BANKED
226:                           PWM.PROP3 = _MG_MOD4 - 3 * ((_MG_MOD4 - _MD_MOD4) / 7);
5250  0E6F     MOVLW 0x6F
5252  6F7B     MOVWF _PFNf_newPFN, BANKED
227:                           break;
228:                       }
229:                   }
5254  0012     RETURN 0
230:               }
5270  0012     RETURN 0
231:               else //gaz plynny
232:               {
233:                   switch(tpk) //typ kotla
5272  D0DC     BRA 0x542C
542C  0100     MOVLB 0x0
542E  51E1     MOVF GIE_BIT_VAL, W, BANKED
5430  E101     BNZ 0x5434
5432  D720     BRA 0x5274
5434  0A01     XORLW 0x1
5436  E101     BNZ 0x543A
5438  D749     BRA 0x52CC
543A  0A03     XORLW 0x3
543C  E101     BNZ 0x5440
543E  D772     BRA 0x5324
5440  0A01     XORLW 0x1
5442  E09C     BZ 0x537C
5444  D7C7     BRA 0x53D4
234:                   {
235:                       case _UNICO: //jednofunkcyjny
236:                       {
237:                           PWMf_ENOSC = (_EN_OSC0 != 0);
5274  8813     BSF PFNf_zima, 4, ACCESS
238:                           PWM.MDMOD = _MD_PMOD0;
5276  0E48     MOVLW 0x48
5278  0100     MOVLB 0x0
527A  6F67     MOVWF _PFNf_b_set_ncw, BANKED
239:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
527C  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
527E  F068     NOP
240:                           PWM.MGMOD = _MG_PMOD0;
5280  0EEB     MOVLW 0xEB
5282  0100     MOVLB 0x0
5284  6F6A     MOVWF _PFNf_blkcs, BANKED
241:                           PWM.MAXOSC = _MAX_OSC_PWM0;
5286  0E14     MOVLW 0x14
5288  6F6B     MOVWF _PFNf_csn, BANKED
242:                           PWM.MINOSC = _MIN_OSC_PWM0;
528A  0E05     MOVLW 0x5
528C  6F6C     MOVWF _PFNf_enKNF, BANKED
243:                           PWM.MAD_MOD = _MAD_MOD0;
528E  0E14     MOVLW 0x14
5290  6F6D     MOVWF _PFNf_errCO, BANKED
244:                           PWM.MAG_MOD = _MAG_MOD0;
5292  0EF7     MOVLW 0xF7
5294  6F6E     MOVWF _PFNf_errCS, BANKED
245:                           PWM.GWMSTART = _GWMSTART0;
5296  0E63     MOVLW 0x63
5298  6F6F     MOVWF _PFNf_errCW, BANKED
246:                           PWM.MDSTART = _MDSTARTP0;
529A  0E48     MOVLW 0x48
529C  6F70     MOVWF _PFNf_errIN, BANKED
247:                           PWM.MGSTART = _MGSTARTP0;
529E  0EF5     MOVLW 0xF5
52A0  6F71     MOVWF _PFNf_fL3, BANKED
248:                           PWM.GWMMAXCO = _GWMMAXCO0;
52A2  0E63     MOVLW 0x63
52A4  6F72     MOVWF _PFNf_ferr, BANKED
249:                           PWM.MDMAXCO = _MDMMAXCOP0;
52A6  0E48     MOVLW 0x48
52A8  6F73     MOVWF _PFNf_fmsg, BANKED
250:                           PWM.MGMAXCO = _MGMMAXCOP0;
52AA  0EF5     MOVLW 0xF5
52AC  6F74     MOVWF _PFNf_fnoCS, BANKED
251:                           PWM.GWMMAXCW = _GWMMAXCW0;
52AE  0E63     MOVLW 0x63
52B0  6F75     MOVWF _PFNf_fns_max, BANKED
252:                           PWM.MDMAXCW = _MDMMAXCWP0;
52B2  0E48     MOVLW 0x48
52B4  6F76     MOVWF _PFNf_fnserw, BANKED
253:                           PWM.MGMAXCW = _MGMMAXCWP0;
52B6  0EF5     MOVLW 0xF5
52B8  6F77     MOVWF _PFNf_lato, BANKED
254:                           PWM.FIRSTPB = _I80_PMOD0;
52BA  0EAA     MOVLW 0xAA
52BC  6F78     MOVWF _PFNf_mod_ncw, BANKED
255:                           PWM.PROP1 = _MG_PMOD0 - 1 * ((_MG_PMOD0 - _MD_PMOD0) / 7);
52BE  0ED4     MOVLW 0xD4
52C0  6F79     MOVWF _PFNf_newPCO, BANKED
256:                           PWM.PROP2 = _MG_PMOD0 - 2 * ((_MG_PMOD0 - _MD_PMOD0) / 7);
52C2  0EBD     MOVLW 0xBD
52C4  6F7A     MOVWF _PFNf_newPCW, BANKED
257:                           PWM.PROP3 = _MG_PMOD0 - 3 * ((_MG_PMOD0 - _MD_PMOD0) / 7);
52C6  0EA6     MOVLW 0xA6
52C8  6F7B     MOVWF _PFNf_newPFN, BANKED
258:                           break;
52CA  0CA6     RETLW 0xA6
259:                       }
260:                       case _BITERM: //bitermiczny (miniterm)
261:                       {
262:                           PWMf_ENOSC = (_EN_OSC1 != 0);
52CC  8813     BSF PFNf_zima, 4, ACCESS
263:                           PWM.MDMOD = _MD_PMOD1;
52CE  0E40     MOVLW 0x40
52D0  0100     MOVLB 0x0
52D2  6F67     MOVWF _PFNf_b_set_ncw, BANKED
264:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
52D4  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
52D6  F068     NOP
265:                           PWM.MGMOD = _MG_PMOD1;
52D8  0EE0     MOVLW 0xE0
52DA  0100     MOVLB 0x0
52DC  6F6A     MOVWF _PFNf_blkcs, BANKED
266:                           PWM.MAXOSC = _MAX_OSC_PWM1;
52DE  0E1E     MOVLW 0x1E
52E0  6F6B     MOVWF _PFNf_csn, BANKED
267:                           PWM.MINOSC = _MIN_OSC_PWM1;
52E2  0E05     MOVLW 0x5
52E4  6F6C     MOVWF _PFNf_enKNF, BANKED
268:                           PWM.MAD_MOD = _MAD_MOD1;
52E6  0E14     MOVLW 0x14
52E8  6F6D     MOVWF _PFNf_errCO, BANKED
269:                           PWM.MAG_MOD = _MAG_MOD1;
52EA  0EF7     MOVLW 0xF7
52EC  6F6E     MOVWF _PFNf_errCS, BANKED
270:                           PWM.GWMSTART = _GWMSTART1;
52EE  0E63     MOVLW 0x63
52F0  6F6F     MOVWF _PFNf_errCW, BANKED
271:                           PWM.MDSTART = _MDSTARTP1;
52F2  0E40     MOVLW 0x40
52F4  6F70     MOVWF _PFNf_errIN, BANKED
272:                           PWM.MGSTART = _MGSTARTP1;
52F6  0EEA     MOVLW 0xEA
52F8  6F71     MOVWF _PFNf_fL3, BANKED
273:                           PWM.GWMMAXCO = _GWMMAXCO1;
52FA  0E63     MOVLW 0x63
52FC  6F72     MOVWF _PFNf_ferr, BANKED
274:                           PWM.MDMAXCO = _MDMMAXCOP1;
52FE  0E40     MOVLW 0x40
5300  6F73     MOVWF _PFNf_fmsg, BANKED
275:                           PWM.MGMAXCO = _MGMMAXCOP1;
5302  0EEA     MOVLW 0xEA
5304  6F74     MOVWF _PFNf_fnoCS, BANKED
276:                           PWM.GWMMAXCW = _GWMMAXCW1;
5306  0E63     MOVLW 0x63
5308  6F75     MOVWF _PFNf_fns_max, BANKED
277:                           PWM.MDMAXCW = _MDMMAXCWP1;
530A  0E40     MOVLW 0x40
530C  6F76     MOVWF _PFNf_fnserw, BANKED
278:                           PWM.MGMAXCW = _MGMMAXCWP1;
530E  0EEA     MOVLW 0xEA
5310  6F77     MOVWF _PFNf_lato, BANKED
279:                           PWM.FIRSTPB = _I80_PMOD1;
5312  0EA3     MOVLW 0xA3
5314  6F78     MOVWF _PFNf_mod_ncw, BANKED
280:                           PWM.PROP1 = _MG_PMOD1 - 1 * ((_MG_PMOD1 - _MD_PMOD1) / 7);
5316  0ECA     MOVLW 0xCA
5318  6F79     MOVWF _PFNf_newPCO, BANKED
281:                           PWM.PROP2 = _MG_PMOD1 - 2 * ((_MG_PMOD1 - _MD_PMOD1) / 7);
531A  0EB4     MOVLW 0xB4
531C  6F7A     MOVWF _PFNf_newPCW, BANKED
282:                           PWM.PROP3 = _MG_PMOD1 - 3 * ((_MG_PMOD1 - _MD_PMOD1) / 7);
531E  0E9E     MOVLW 0x9E
5320  6F7B     MOVWF _PFNf_newPFN, BANKED
283:                           break;
5322  0C9E     RETLW 0x9E
284:                       }
285:                           /*
286:                                                   case _MONOTERM:		//monotermiczny
287:                                                   case _ZASOBNIK:		//zasobnikowy
288:                                                   {
289:                                                           PWMf_ENOSC=(_EN_OSC2!=0);
290:                                                           PWM.MDMOD=_MD_PMOD2;
291:                                                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
292:                                                           PWM.MGMOD=_MG_PMOD2;
293:                                                           PWM.MAXOSC=_MAX_OSC_PWM2;
294:                                                           PWM.MINOSC=_MIN_OSC_PWM2;
295:                                                           PWM.MAD_MOD=_MAD_MOD2;
296:                                                           PWM.MAG_MOD=_MAG_MOD2;
297:                                                           PWM.GWMSTART=_GWMSTART2;
298:                                                           PWM.MDSTART=_MDSTARTP2;
299:                                                           PWM.MGSTART=_MGSTARTP2;
300:                                                           PWM.GWMMAXCO=_GWMMAXCO2;
301:                                                           PWM.MDMAXCO=_MDMMAXCOP2;
302:                                                           PWM.MGMAXCO=_MGMMAXCOP2;
303:                                                           PWM.GWMMAXCW=_GWMMAXCW2;
304:                                                           PWM.MDMAXCW=_MDMMAXCWP2;
305:                                                           PWM.MGMAXCW=_MGMMAXCWP2;
306:                                                           PWM.FIRSTPB=_I80_PMOD2;
307:                                                           PWM.PROP1=_MG_PMOD2-1*((_MG_PMOD2-_MD_PMOD2)/7);
308:                                                           PWM.PROP2=_MG_PMOD2-2*((_MG_PMOD2-_MD_PMOD2)/7);
309:                                                           PWM.PROP3=_MG_PMOD2-3*((_MG_PMOD2-_MD_PMOD2)/7);
310:                                                           break;
311:                                                   }
312:                            */
313:                       case _BITERM2: //bitermiczny (maxiterm)
314:                       {
315:                           PWMf_ENOSC = (_EN_OSC3 != 0);
5324  8813     BSF PFNf_zima, 4, ACCESS
316:                           PWM.MDMOD = _MD_PMOD3;
5326  0E5A     MOVLW 0x5A
5328  0100     MOVLB 0x0
532A  6F67     MOVWF _PFNf_b_set_ncw, BANKED
317:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
532C  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
532E  F068     NOP
318:                           PWM.MGMOD = _MG_PMOD3;
5330  0ECD     MOVLW 0xCD
5332  0100     MOVLB 0x0
5334  6F6A     MOVWF _PFNf_blkcs, BANKED
319:                           PWM.MAXOSC = _MAX_OSC_PWM3;
5336  0E19     MOVLW 0x19
5338  6F6B     MOVWF _PFNf_csn, BANKED
320:                           PWM.MINOSC = _MIN_OSC_PWM3;
533A  0E05     MOVLW 0x5
533C  6F6C     MOVWF _PFNf_enKNF, BANKED
321:                           PWM.MAD_MOD = _MAD_MOD3;
533E  0E14     MOVLW 0x14
5340  6F6D     MOVWF _PFNf_errCO, BANKED
322:                           PWM.MAG_MOD = _MAG_MOD3;
5342  0EF7     MOVLW 0xF7
5344  6F6E     MOVWF _PFNf_errCS, BANKED
323:                           PWM.GWMSTART = _GWMSTART3;
5346  0E63     MOVLW 0x63
5348  6F6F     MOVWF _PFNf_errCW, BANKED
324:                           PWM.MDSTART = _MDSTARTP3;
534A  0E5A     MOVLW 0x5A
534C  6F70     MOVWF _PFNf_errIN, BANKED
325:                           PWM.MGSTART = _MGSTARTP3;
534E  0ED7     MOVLW 0xD7
5350  6F71     MOVWF _PFNf_fL3, BANKED
326:                           PWM.GWMMAXCO = _GWMMAXCO3;
5352  0E63     MOVLW 0x63
5354  6F72     MOVWF _PFNf_ferr, BANKED
327:                           PWM.MDMAXCO = _MDMMAXCOP3;
5356  0E5A     MOVLW 0x5A
5358  6F73     MOVWF _PFNf_fmsg, BANKED
328:                           PWM.MGMAXCO = _MGMMAXCOP3;
535A  0ED7     MOVLW 0xD7
535C  6F74     MOVWF _PFNf_fnoCS, BANKED
329:                           PWM.GWMMAXCW = _GWMMAXCW3;
535E  0E63     MOVLW 0x63
5360  6F75     MOVWF _PFNf_fns_max, BANKED
330:                           PWM.MDMAXCW = _MDMMAXCWP3;
5362  0E5A     MOVLW 0x5A
5364  6F76     MOVWF _PFNf_fnserw, BANKED
331:                           PWM.MGMAXCW = _MGMMAXCWP3;
5366  0ED7     MOVLW 0xD7
5368  6F77     MOVWF _PFNf_lato, BANKED
332:                           PWM.FIRSTPB = _I80_PMOD3;
536A  0E9B     MOVLW 0x9B
536C  6F78     MOVWF _PFNf_mod_ncw, BANKED
333:                           PWM.PROP1 = _MG_PMOD3 - 1 * ((_MG_PMOD3 - _MD_PMOD3) / 7);
536E  0EBD     MOVLW 0xBD
5370  6F79     MOVWF _PFNf_newPCO, BANKED
334:                           PWM.PROP2 = _MG_PMOD3 - 2 * ((_MG_PMOD3 - _MD_PMOD3) / 7);
5372  0EAD     MOVLW 0xAD
5374  6F7A     MOVWF _PFNf_newPCW, BANKED
335:                           PWM.PROP3 = _MG_PMOD3 - 3 * ((_MG_PMOD3 - _MD_PMOD3) / 7);
5376  0E9D     MOVLW 0x9D
5378  6F7B     MOVWF _PFNf_newPFN, BANKED
336:                           break;
537A  0C9D     RETLW 0x9D
337:                       }
338:                       case _MONOHB: //monotermiczny z hydroblokiem (minimax hb)
339:                       {
340:                           PWMf_ENOSC = (_EN_OSC4 != 0);
537C  8813     BSF PFNf_zima, 4, ACCESS
341:                           PWM.MDMOD = _MD_PMOD4;
537E  0E35     MOVLW 0x35
5380  0100     MOVLB 0x0
5382  6F67     MOVWF _PFNf_b_set_ncw, BANKED
342:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
5384  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
5386  F068     NOP
343:                           PWM.MGMOD = _MG_PMOD4;
5388  0EF0     MOVLW 0xF0
538A  0100     MOVLB 0x0
538C  6F6A     MOVWF _PFNf_blkcs, BANKED
344:                           PWM.MAXOSC = _MAX_OSC_PWM4;
538E  0E0F     MOVLW 0xF
5390  6F6B     MOVWF _PFNf_csn, BANKED
345:                           PWM.MINOSC = _MIN_OSC_PWM4;
5392  0E05     MOVLW 0x5
5394  6F6C     MOVWF _PFNf_enKNF, BANKED
346:                           PWM.MAD_MOD = _MAD_MOD4;
5396  0E14     MOVLW 0x14
5398  6F6D     MOVWF _PFNf_errCO, BANKED
347:                           PWM.MAG_MOD = _MAG_MOD4;
539A  0EF7     MOVLW 0xF7
539C  6F6E     MOVWF _PFNf_errCS, BANKED
348:                           PWM.GWMSTART = _GWMSTART4;
539E  0E63     MOVLW 0x63
53A0  6F6F     MOVWF _PFNf_errCW, BANKED
349:                           PWM.MDSTART = _MDSTARTP4;
53A2  0E35     MOVLW 0x35
53A4  6F70     MOVWF _PFNf_errIN, BANKED
350:                           PWM.MGSTART = _MGSTARTP4;
53A6  0EFA     MOVLW 0xFA
53A8  6F71     MOVWF _PFNf_fL3, BANKED
351:                           PWM.GWMMAXCO = _GWMMAXCO4;
53AA  0E63     MOVLW 0x63
53AC  6F72     MOVWF _PFNf_ferr, BANKED
352:                           PWM.MDMAXCO = _MDMMAXCOP4;
53AE  0E35     MOVLW 0x35
53B0  6F73     MOVWF _PFNf_fmsg, BANKED
353:                           PWM.MGMAXCO = _MGMMAXCOP4;
53B2  0EFA     MOVLW 0xFA
53B4  6F74     MOVWF _PFNf_fnoCS, BANKED
354:                           PWM.GWMMAXCW = _GWMMAXCW4;
53B6  0E63     MOVLW 0x63
53B8  6F75     MOVWF _PFNf_fns_max, BANKED
355:                           PWM.MDMAXCW = _MDMMAXCWP4;
53BA  0E35     MOVLW 0x35
53BC  6F76     MOVWF _PFNf_fnserw, BANKED
356:                           PWM.MGMAXCW = _MGMMAXCWP4;
53BE  0EFA     MOVLW 0xFA
53C0  6F77     MOVWF _PFNf_lato, BANKED
357:                           PWM.FIRSTPB = _I80_PMOD4;
53C2  0EA5     MOVLW 0xA5
53C4  6F78     MOVWF _PFNf_mod_ncw, BANKED
358:                           PWM.PROP1 = _MG_PMOD4 - 1 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
53C6  0ED6     MOVLW 0xD6
53C8  6F79     MOVWF _PFNf_newPCO, BANKED
359:                           PWM.PROP2 = _MG_PMOD4 - 2 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
53CA  0EBC     MOVLW 0xBC
53CC  6F7A     MOVWF _PFNf_newPCW, BANKED
360:                           PWM.PROP3 = _MG_PMOD4 - 3 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
53CE  0EA2     MOVLW 0xA2
53D0  6F7B     MOVWF _PFNf_newPFN, BANKED
361:                           break;
53D2  0CA2     RETLW 0xA2
362:                       }
363:                       default: //domyslny monotermiczny
364:                       {
365:                           PWMf_ENOSC = (_EN_OSC4 != 0);
53D4  8813     BSF PFNf_zima, 4, ACCESS
366:                           PWM.MDMOD = _MD_PMOD4;
53D6  0E35     MOVLW 0x35
53D8  0100     MOVLB 0x0
53DA  6F67     MOVWF _PFNf_b_set_ncw, BANKED
367:                           PWM.DKNF_MDMOD=PWM.MDMOD; //domyslna wartosc minimum
53DC  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_nco
53DE  F068     NOP
368:                           PWM.MGMOD = _MG_PMOD4;
53E0  0EF0     MOVLW 0xF0
53E2  0100     MOVLB 0x0
53E4  6F6A     MOVWF _PFNf_blkcs, BANKED
369:                           PWM.MAXOSC = _MAX_OSC_PWM4;
53E6  0E0F     MOVLW 0xF
53E8  6F6B     MOVWF _PFNf_csn, BANKED
370:                           PWM.MINOSC = _MIN_OSC_PWM4;
53EA  0E05     MOVLW 0x5
53EC  6F6C     MOVWF _PFNf_enKNF, BANKED
371:                           PWM.MAD_MOD = _MAD_MOD4;
53EE  0E14     MOVLW 0x14
53F0  6F6D     MOVWF _PFNf_errCO, BANKED
372:                           PWM.MAG_MOD = _MAG_MOD4;
53F2  0EF7     MOVLW 0xF7
53F4  6F6E     MOVWF _PFNf_errCS, BANKED
373:                           PWM.GWMSTART = _GWMSTART4;
53F6  0E63     MOVLW 0x63
53F8  6F6F     MOVWF _PFNf_errCW, BANKED
374:                           PWM.MDSTART = _MDSTARTP4;
53FA  0E35     MOVLW 0x35
53FC  6F70     MOVWF _PFNf_errIN, BANKED
375:                           PWM.MGSTART = _MGSTARTP4;
53FE  0EFA     MOVLW 0xFA
5400  6F71     MOVWF _PFNf_fL3, BANKED
376:                           PWM.GWMMAXCO = _GWMMAXCO4;
5402  0E63     MOVLW 0x63
5404  6F72     MOVWF _PFNf_ferr, BANKED
377:                           PWM.MDMAXCO = _MDMMAXCOP4;
5406  0E35     MOVLW 0x35
5408  6F73     MOVWF _PFNf_fmsg, BANKED
378:                           PWM.MGMAXCO = _MGMMAXCOP4;
540A  0EFA     MOVLW 0xFA
540C  6F74     MOVWF _PFNf_fnoCS, BANKED
379:                           PWM.GWMMAXCW = _GWMMAXCW4;
540E  0E63     MOVLW 0x63
5410  6F75     MOVWF _PFNf_fns_max, BANKED
380:                           PWM.MDMAXCW = _MDMMAXCWP4;
5412  0E35     MOVLW 0x35
5414  6F76     MOVWF _PFNf_fnserw, BANKED
381:                           PWM.MGMAXCW = _MGMMAXCWP4;
5416  0EFA     MOVLW 0xFA
5418  6F77     MOVWF _PFNf_lato, BANKED
382:                           PWM.FIRSTPB = _I80_PMOD4;
541A  0EA5     MOVLW 0xA5
541C  6F78     MOVWF _PFNf_mod_ncw, BANKED
383:                           PWM.PROP1 = _MG_PMOD4 - 1 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
541E  0ED6     MOVLW 0xD6
5420  6F79     MOVWF _PFNf_newPCO, BANKED
384:                           PWM.PROP2 = _MG_PMOD4 - 2 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
5422  0EBC     MOVLW 0xBC
5424  6F7A     MOVWF _PFNf_newPCW, BANKED
385:                           PWM.PROP3 = _MG_PMOD4 - 3 * ((_MG_PMOD4 - _MD_PMOD4) / 7);
5426  0EA2     MOVLW 0xA2
5428  6F7B     MOVWF _PFNf_newPFN, BANKED
386:                           break;
387:                       }
388:                   }
542A  0012     RETURN 0
5446  0012     RETURN 0
389:               }
390:           }
5448  0012     RETURN 0
391:           /*---------------------------------------------------------------------------------*/
392:           /*---------------------------------------------------------------------------------*/
393:           //Zapisz wartosc do PWM bez formatowania (amplituda oscylacji=0).
394:           
395:           void WritePWM(const unsigned char tpwm)
F1BA  0100     MOVLB 0x0
F1BC  6FDE     MOVWF __pcstackBANK0, BANKED
396:           {
397:               PWMf_ENPWM = 0;
F1BE  9A13     BCF PFNf_zima, 5, ACCESS
398:               PWM.BufPWM = tpwm;
F1C0  C0DE     MOVFF __pcstackBANK0, PWM
F1C2  F060     NOP
399:               PWM.BufOSC = 0;
F1C4  0E00     MOVLW 0x0
F1C6  0100     MOVLB 0x0
F1C8  6B61     CLRF 0x61, BANKED
400:               PWMf_ENPWM = 1;
F1CA  8A13     BSF PFNf_zima, 5, ACCESS
401:           }
F1CC  0012     RETURN 0
402:           /*---------------------------------------------------------------------------------*/
403:           /*---------------------------------------------------------------------------------*/
404:           //Zapisz wartosc do PWM2
405:           
406:           void WritePWM2(const unsigned char tpwm)
F2DA  0100     MOVLB 0x0
F2DC  6FDE     MOVWF __pcstackBANK0, BANKED
407:           {
408:               PWMf_ENPWM2 = 0;
F2DE  9C13     BCF PFNf_zima, 6, ACCESS
409:               PWM.BufPWM2 = tpwm;
F2E0  C0DE     MOVFF __pcstackBANK0, 0x64
F2E2  F064     NOP
410:               PWMf_ENPWM2 = 1;
F2E4  8C13     BSF PFNf_zima, 6, ACCESS
411:           }
F2E6  0012     RETURN 0
412:           /*---------------------------------------------------------------------------------*/
413:           /*---------------------------------------------------------------------------------*/
414:           //Zapisz wartosc do PWM z formatowaniem (oblicza wartosc amplitudy oscylacji).
415:           
416:           void WriteOPWM(unsigned char tpwm)
A4D8  0100     MOVLB 0x0
A4DA  6FF5     MOVWF max, BANKED
417:           {
418:               unsigned char aosc;
419:               unsigned int tmp;
420:           
421:               //kontrola czy wartosc PWM miesci sie w oczekiwanym zakresie
422:           #if _SRVTRB==1	
423:               if(PWMf_ENOSC)
424:               { //aktywny tryb serwisowy kompilacji?
425:                   if(tpwm < PWM.MDMOD) tpwm = PWM.MDMOD;
426:               }
427:           #else
428:               if(tpwm < PWM.MDMOD) tpwm = PWM.MDMOD;
A4DC  0100     MOVLB 0x0
A4DE  5167     MOVF _PFNf_b_set_ncw, W, BANKED
A4E0  5DF5     SUBWF max, W, BANKED
A4E2  E203     BC 0xA4EA
A4E4  C067     MOVFF _PFNf_b_set_ncw, max
A4E6  F0F5     NOP
A4E8  D000     BRA 0xA4EA
429:           #endif
430:               if(tpwm > _MG2_MOD) tpwm = _MG2_MOD;
A4EA  0EF0     MOVLW 0xF0
A4EC  0100     MOVLB 0x0
A4EE  65F5     CPFSGT max, BANKED
A4F0  D002     BRA 0xA4F6
A4F2  6FF5     MOVWF max, BANKED
A4F4  D000     BRA 0xA4F6
431:               if(PWMf_ENOSC)
A4F6  A813     BTFSS PFNf_zima, 4, ACCESS
A4F8  D0AB     BRA 0xA650
432:               {
433:                   //obliczenie amplitudy osculacji
434:                   if(tpwm >= PWM.MGMOD) aosc = PWM.MINOSC;
A4FA  0100     MOVLB 0x0
A4FC  516A     MOVF _PFNf_blkcs, W, BANKED
A4FE  5DF5     SUBWF max, W, BANKED
A500  E25E     BC 0xA5BE
435:                   else
436:                   {
437:                       tmp = (tpwm - PWM.MDMOD)*100;
A502  0100     MOVLB 0x0
A504  5167     MOVF _PFNf_b_set_ncw, W, BANKED
A506  6FEB     MOVWF pop, BANKED
A508  6BEC     CLRF dt, BANKED
A50A  1FEB     COMF pop, F, BANKED
A50C  1FEC     COMF dt, F, BANKED
A50E  4BEB     INFSNZ pop, F, BANKED
A510  2BEC     INCF dt, F, BANKED
A512  51F5     MOVF max, W, BANKED
A514  25EB     ADDWF pop, W, BANKED
A516  6FDE     MOVWF __pcstackBANK0, BANKED
A518  0E00     MOVLW 0x0
A51A  21EC     ADDWFC dt, W, BANKED
A51C  6FDF     MOVWF pco, BANKED
A51E  6BE1     CLRF GIE_BIT_VAL, BANKED
A520  0E64     MOVLW 0x64
A522  6FE0     MOVWF bdat, BANKED
A524  EC5B     CALL 0xECB6, 0
A526  F076     NOP
A528  C0DE     MOVFF __pcstackBANK0, min
A52A  F0F3     NOP
A52C  C0DF     MOVFF pco, pco
A52E  F0F4     NOP
438:                       tmp /= (PWM.MGMOD - PWM.MDMOD);
A530  C0F3     MOVFF min, k
A532  F0E4     NOP
A534  C0F4     MOVFF pco, k
A536  F0E5     NOP
A538  0100     MOVLB 0x0
A53A  5167     MOVF _PFNf_b_set_ncw, W, BANKED
A53C  6FEB     MOVWF pop, BANKED
A53E  6BEC     CLRF dt, BANKED
A540  1FEB     COMF pop, F, BANKED
A542  1FEC     COMF dt, F, BANKED
A544  4BEB     INFSNZ pop, F, BANKED
A546  2BEC     INCF dt, F, BANKED
A548  516A     MOVF _PFNf_blkcs, W, BANKED
A54A  25EB     ADDWF pop, W, BANKED
A54C  6FE6     MOVWF counter, BANKED
A54E  0E00     MOVLW 0x0
A550  21EC     ADDWFC dt, W, BANKED
A552  6FE7     MOVWF sign, BANKED
A554  EC0B     CALL 0xD816, 0
A556  F06C     NOP
A558  C0E4     MOVFF k, min
A55A  F0F3     NOP
A55C  C0E5     MOVFF k, pco
A55E  F0F4     NOP
439:                       tmp *= (PWM.MAXOSC - PWM.MINOSC);
A560  C0F3     MOVFF min, __pcstackBANK0
A562  F0DE     NOP
A564  C0F4     MOVFF pco, pco
A566  F0DF     NOP
A568  0100     MOVLB 0x0
A56A  516C     MOVF _PFNf_enKNF, W, BANKED
A56C  6FEB     MOVWF pop, BANKED
A56E  6BEC     CLRF dt, BANKED
A570  1FEB     COMF pop, F, BANKED
A572  1FEC     COMF dt, F, BANKED
A574  4BEB     INFSNZ pop, F, BANKED
A576  2BEC     INCF dt, F, BANKED
A578  516B     MOVF _PFNf_csn, W, BANKED
A57A  25EB     ADDWF pop, W, BANKED
A57C  6FE0     MOVWF bdat, BANKED
A57E  0E00     MOVLW 0x0
A580  21EC     ADDWFC dt, W, BANKED
A582  6FE1     MOVWF GIE_BIT_VAL, BANKED
A584  EC5B     CALL 0xECB6, 0
A586  F076     NOP
A588  C0DE     MOVFF __pcstackBANK0, min
A58A  F0F3     NOP
A58C  C0DF     MOVFF pco, pco
A58E  F0F4     NOP
440:                       tmp /= 100;
A590  C0F3     MOVFF min, k
A592  F0E4     NOP
A594  C0F4     MOVFF pco, k
A596  F0E5     NOP
A598  0100     MOVLB 0x0
A59A  6BE7     CLRF sign, BANKED
A59C  0E64     MOVLW 0x64
A59E  6FE6     MOVWF counter, BANKED
A5A0  EC0B     CALL 0xD816, 0
A5A2  F06C     NOP
A5A4  C0E4     MOVFF k, min
A5A6  F0F3     NOP
A5A8  C0E5     MOVFF k, pco
A5AA  F0F4     NOP
441:                       if(tmp > PWM.MAXOSC) aosc = PWM.MINOSC;
A5AC  0100     MOVLB 0x0
A5AE  516B     MOVF _PFNf_csn, W, BANKED
A5B0  6FEB     MOVWF pop, BANKED
A5B2  6BEC     CLRF dt, BANKED
A5B4  51F3     MOVF min, W, BANKED
A5B6  5DEB     SUBWF pop, W, BANKED
A5B8  51F4     MOVF pco, W, BANKED
A5BA  59EC     SUBWFB dt, W, BANKED
A5BC  E203     BC 0xA5C4
A5BE  C06C     MOVFF _PFNf_enKNF, tid
A5C0  F0F2     NOP
A5C2  D006     BRA 0xA5D0
442:                       else aosc = PWM.MAXOSC - (unsigned char)tmp; //amplituda oscylacji maleje ze wzrostem wartosci PWM
A5C4  0100     MOVLB 0x0
A5C6  51F3     MOVF min, W, BANKED
A5C8  0800     SUBLW 0x0
A5CA  256B     ADDWF _PFNf_csn, W, BANKED
A5CC  6FF2     MOVWF tid, BANKED
A5CE  D000     BRA 0xA5D0
443:                   }
444:                   //---------
445:                   if(aosc > (PWM.MAG_MOD - tpwm)) aosc = PWM.MAG_MOD - tpwm;
A5D0  0100     MOVLB 0x0
A5D2  51F2     MOVF tid, W, BANKED
A5D4  6FEB     MOVWF pop, BANKED
A5D6  6BEC     CLRF dt, BANKED
A5D8  51F5     MOVF max, W, BANKED
A5DA  6FED     MOVWF min, BANKED
A5DC  6BEE     CLRF dt, BANKED
A5DE  1FED     COMF min, F, BANKED
A5E0  1FEE     COMF dt, F, BANKED
A5E2  4BED     INFSNZ min, F, BANKED
A5E4  2BEE     INCF dt, F, BANKED
A5E6  516E     MOVF _PFNf_errCS, W, BANKED
A5E8  6FEF     MOVWF 0xEF, BANKED
A5EA  6BF0     CLRF p, BANKED
A5EC  51ED     MOVF min, W, BANKED
A5EE  27EF     ADDWF 0xEF, F, BANKED
A5F0  51EE     MOVF dt, W, BANKED
A5F2  23F0     ADDWFC p, F, BANKED
A5F4  51EB     MOVF pop, W, BANKED
A5F6  5DEF     SUBWF 0xEF, W, BANKED
A5F8  51F0     MOVF p, W, BANKED
A5FA  0A80     XORLW 0x80
A5FC  6FF1     MOVWF m, BANKED
A5FE  51EC     MOVF dt, W, BANKED
A600  0A80     XORLW 0x80
A602  59F1     SUBWFB m, W, BANKED
A604  E204     BC 0xA60E
A606  51F5     MOVF max, W, BANKED
A608  0800     SUBLW 0x0
A60A  256E     ADDWF _PFNf_errCS, W, BANKED
A60C  D01E     BRA 0xA64A
446:                   else
447:                       if(aosc > (tpwm - PWM.MAD_MOD)) aosc = tpwm - PWM.MAD_MOD;
A60E  0100     MOVLB 0x0
A610  51F2     MOVF tid, W, BANKED
A612  6FEB     MOVWF pop, BANKED
A614  6BEC     CLRF dt, BANKED
A616  516D     MOVF _PFNf_errCO, W, BANKED
A618  6FED     MOVWF min, BANKED
A61A  6BEE     CLRF dt, BANKED
A61C  1FED     COMF min, F, BANKED
A61E  1FEE     COMF dt, F, BANKED
A620  4BED     INFSNZ min, F, BANKED
A622  2BEE     INCF dt, F, BANKED
A624  51F5     MOVF max, W, BANKED
A626  6FEF     MOVWF 0xEF, BANKED
A628  6BF0     CLRF p, BANKED
A62A  51ED     MOVF min, W, BANKED
A62C  27EF     ADDWF 0xEF, F, BANKED
A62E  51EE     MOVF dt, W, BANKED
A630  23F0     ADDWFC p, F, BANKED
A632  51EB     MOVF pop, W, BANKED
A634  5DEF     SUBWF 0xEF, W, BANKED
A636  51F0     MOVF p, W, BANKED
A638  0A80     XORLW 0x80
A63A  6FF1     MOVWF m, BANKED
A63C  51EC     MOVF dt, W, BANKED
A63E  0A80     XORLW 0x80
A640  59F1     SUBWFB m, W, BANKED
A642  E206     BC 0xA650
A644  516D     MOVF _PFNf_errCO, W, BANKED
A646  0800     SUBLW 0x0
A648  25F5     ADDWF max, W, BANKED
A64A  0100     MOVLB 0x0
A64C  6FF2     MOVWF tid, BANKED
448:               }
A64E  D000     BRA 0xA650
449:               //---------
450:               //zapamietanie obliczonych wartosci
451:               PWMf_ENPWM = 0;
A650  9A13     BCF PFNf_zima, 5, ACCESS
452:               PWM.BufPWM = tpwm;
A652  C0F5     MOVFF max, PWM
A654  F060     NOP
453:               if(PWMf_ENOSC) PWM.BufOSC = aosc;
A656  A813     BTFSS PFNf_zima, 4, ACCESS
A658  D003     BRA 0xA660
A65A  C0F2     MOVFF tid, 0x61
A65C  F061     NOP
A65E  D004     BRA 0xA668
454:               else PWM.BufOSC = 0;
A660  0E00     MOVLW 0x0
A662  0100     MOVLB 0x0
A664  6B61     CLRF 0x61, BANKED
A666  D000     BRA 0xA668
455:               PWMf_ENPWM = 1;
A668  8A13     BSF PFNf_zima, 5, ACCESS
456:           }
A66A  0012     RETURN 0
457:           /*---------------------------------------------------------------------------------*/
458:           /*---------------------------------------------------------------------------------*/
459:           //Moc minimalna (uwaga: wywolywac po ModParam)
460:           //nst - parametr z zakresu od 0 do 99
461:           unsigned char MocProc(unsigned char nst)
CB7A  0100     MOVLB 0x0
CB7C  6FF0     MOVWF p, BANKED
462:           {
463:           	unsigned int tmp;
464:           
465:           	if(nst>99) nst=99;
CB7E  0E63     MOVLW 0x63
CB80  0100     MOVLB 0x0
CB82  65F0     CPFSGT p, BANKED
CB84  D002     BRA 0xCB8A
CB86  6FF0     MOVWF p, BANKED
CB88  D000     BRA 0xCB8A
466:           	tmp=((PWM.MGMOD-PWM.MDMOD)*10)/99;
CB8A  0100     MOVLB 0x0
CB8C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
CB8E  6FEC     MOVWF dt, BANKED
CB90  6BED     CLRF min, BANKED
CB92  1FEC     COMF dt, F, BANKED
CB94  1FED     COMF min, F, BANKED
CB96  4BEC     INFSNZ dt, F, BANKED
CB98  2BED     INCF min, F, BANKED
CB9A  516A     MOVF _PFNf_blkcs, W, BANKED
CB9C  25EC     ADDWF dt, W, BANKED
CB9E  6FDE     MOVWF __pcstackBANK0, BANKED
CBA0  0E00     MOVLW 0x0
CBA2  21ED     ADDWFC min, W, BANKED
CBA4  6FDF     MOVWF pco, BANKED
CBA6  6BE1     CLRF GIE_BIT_VAL, BANKED
CBA8  0E0A     MOVLW 0xA
CBAA  6FE0     MOVWF bdat, BANKED
CBAC  EC5B     CALL 0xECB6, 0
CBAE  F076     NOP
CBB0  C0DE     MOVFF __pcstackBANK0, k
CBB2  F0E4     NOP
CBB4  C0DF     MOVFF pco, k
CBB6  F0E5     NOP
CBB8  0100     MOVLB 0x0
CBBA  6BE7     CLRF sign, BANKED
CBBC  0E63     MOVLW 0x63
CBBE  6FE6     MOVWF counter, BANKED
CBC0  EC09     CALL 0xC212, 0
CBC2  F061     NOP
CBC4  C0E4     MOVFF k, dt
CBC6  F0EE     NOP
CBC8  C0E5     MOVFF k, 0xEF
CBCA  F0EF     NOP
467:           	return (PWM.MDMOD+(unsigned char)((nst*tmp)/10));
CBCC  C0F0     MOVFF p, __pcstackBANK0
CBCE  F0DE     NOP
CBD0  0100     MOVLB 0x0
CBD2  6BDF     CLRF pco, BANKED
CBD4  C0EE     MOVFF dt, bdat
CBD6  F0E0     NOP
CBD8  C0EF     MOVFF 0xEF, GIE_BIT_VAL
CBDA  F0E1     NOP
CBDC  EC5B     CALL 0xECB6, 0
CBDE  F076     NOP
CBE0  C0DE     MOVFF __pcstackBANK0, k
CBE2  F0E4     NOP
CBE4  C0DF     MOVFF pco, k
CBE6  F0E5     NOP
CBE8  0100     MOVLB 0x0
CBEA  6BE7     CLRF sign, BANKED
CBEC  0E0A     MOVLW 0xA
CBEE  6FE6     MOVWF counter, BANKED
CBF0  EC0B     CALL 0xD816, 0
CBF2  F06C     NOP
CBF4  0100     MOVLB 0x0
CBF6  51E4     MOVF k, W, BANKED
CBF8  2567     ADDWF _PFNf_b_set_ncw, W, BANKED
CBFA  0012     RETURN 0
468:           }
CBFC  0012     RETURN 0
469:           /*---------------------------------------------------------------------------------*/
470:           /*---------------------------------------------------------------------------------*/
471:           //Moc startowa (uwaga: wywolywac po ModParam)
472:           //nst - parametr z zakresu od 0 do _GWMSTART
473:           
474:           void MocStart(unsigned char nst)
BDE0  0100     MOVLB 0x0
BDE2  6FF5     MOVWF max, BANKED
475:           {
476:               unsigned int tmp;
477:           
478:               if(nst > PWM.GWMSTART) nst = PWM.GWMSTART;
BDE4  0100     MOVLB 0x0
BDE6  51F5     MOVF max, W, BANKED
BDE8  5D6F     SUBWF _PFNf_errCW, W, BANKED
BDEA  E203     BC 0xBDF2
BDEC  C06F     MOVFF _PFNf_errCW, max
BDEE  F0F5     NOP
BDF0  D000     BRA 0xBDF2
479:               tmp = ((PWM.MGSTART - PWM.MDSTART)*10) / PWM.GWMSTART;
BDF2  0100     MOVLB 0x0
BDF4  5170     MOVF _PFNf_errIN, W, BANKED
BDF6  6FF1     MOVWF m, BANKED
BDF8  6BF2     CLRF tid, BANKED
BDFA  1FF1     COMF m, F, BANKED
BDFC  1FF2     COMF tid, F, BANKED
BDFE  4BF1     INFSNZ m, F, BANKED
BE00  2BF2     INCF tid, F, BANKED
BE02  5171     MOVF _PFNf_fL3, W, BANKED
BE04  25F1     ADDWF m, W, BANKED
BE06  6FDE     MOVWF __pcstackBANK0, BANKED
BE08  0E00     MOVLW 0x0
BE0A  21F2     ADDWFC tid, W, BANKED
BE0C  6FDF     MOVWF pco, BANKED
BE0E  6BE1     CLRF GIE_BIT_VAL, BANKED
BE10  0E0A     MOVLW 0xA
BE12  6FE0     MOVWF bdat, BANKED
BE14  EC5B     CALL 0xECB6, 0
BE16  F076     NOP
BE18  C0DE     MOVFF __pcstackBANK0, k
BE1A  F0E4     NOP
BE1C  C0DF     MOVFF pco, k
BE1E  F0E5     NOP
BE20  C06F     MOVFF _PFNf_errCW, counter
BE22  F0E6     NOP
BE24  0100     MOVLB 0x0
BE26  6BE7     CLRF sign, BANKED
BE28  EC09     CALL 0xC212, 0
BE2A  F061     NOP
BE2C  C0E4     MOVFF k, min
BE2E  F0F3     NOP
BE30  C0E5     MOVFF k, pco
BE32  F0F4     NOP
480:               PWM.MSTART = PWM.MDSTART + (unsigned char)((nst * tmp) / 10);
BE34  C0F5     MOVFF max, __pcstackBANK0
BE36  F0DE     NOP
BE38  0100     MOVLB 0x0
BE3A  6BDF     CLRF pco, BANKED
BE3C  C0F3     MOVFF min, bdat
BE3E  F0E0     NOP
BE40  C0F4     MOVFF pco, GIE_BIT_VAL
BE42  F0E1     NOP
BE44  EC5B     CALL 0xECB6, 0
BE46  F076     NOP
BE48  C0DE     MOVFF __pcstackBANK0, k
BE4A  F0E4     NOP
BE4C  C0DF     MOVFF pco, k
BE4E  F0E5     NOP
BE50  0100     MOVLB 0x0
BE52  6BE7     CLRF sign, BANKED
BE54  0E0A     MOVLW 0xA
BE56  6FE6     MOVWF counter, BANKED
BE58  EC0B     CALL 0xD816, 0
BE5A  F06C     NOP
BE5C  0100     MOVLB 0x0
BE5E  51E4     MOVF k, W, BANKED
BE60  2570     ADDWF _PFNf_errIN, W, BANKED
BE62  6F7C     MOVWF _PFNf_oaleg, BANKED
481:           
482:               //casowa moc minimalna nie mniejsza od 25% i nie wieksza od 50%
483:               PWM.DV16_MDMOD=MocProc(25);								//czasowa wartosc minimum
BE64  0E19     MOVLW 0x19
BE66  ECBD     CALL 0xCB7A, 0
BE68  F065     NOP
BE6A  0100     MOVLB 0x0
BE6C  6F69     MOVWF _PFNf_b_str_ncw, BANKED
484:               if(PWM.MSTART>PWM.DV16_MDMOD)
BE6E  0100     MOVLB 0x0
BE70  517C     MOVF _PFNf_oaleg, W, BANKED
BE72  5D69     SUBWF _PFNf_b_str_ncw, W, BANKED
BE74  E20C     BC 0xBE8E
485:               {
486:                       PWM.DV16_MDMOD=MocProc(50);						//czasowa wartosc minimum
BE76  0E32     MOVLW 0x32
BE78  ECBD     CALL 0xCB7A, 0
BE7A  F065     NOP
BE7C  0100     MOVLB 0x0
BE7E  6F69     MOVWF _PFNf_b_str_ncw, BANKED
487:                       if(PWM.MSTART<PWM.DV16_MDMOD) PWM.DV16_MDMOD=PWM.MSTART;
BE80  0100     MOVLB 0x0
BE82  5169     MOVF _PFNf_b_str_ncw, W, BANKED
BE84  5D7C     SUBWF _PFNf_oaleg, W, BANKED
BE86  E203     BC 0xBE8E
BE88  C07C     MOVFF _PFNf_oaleg, _PFNf_b_str_ncw
BE8A  F069     NOP
BE8C  D000     BRA 0xBE8E
488:               }
489:               if(PWM.DV16_MDMOD<PWM.MDMOD) PWM.DV16_MDMOD=PWM.MDMOD;
BE8E  0100     MOVLB 0x0
BE90  5167     MOVF _PFNf_b_set_ncw, W, BANKED
BE92  5D69     SUBWF _PFNf_b_str_ncw, W, BANKED
BE94  A0D8     BTFSS STATUS, 0, ACCESS
BE96  C067     MOVFF _PFNf_b_set_ncw, _PFNf_b_str_ncw
BE98  F069     NOP
BE9A  0012     RETURN 0
490:           }
BE9C  0012     RETURN 0
491:           /*---------------------------------------------------------------------------------*/
492:           /*---------------------------------------------------------------------------------*/
493:           //Moc maksymalna wpdy grzewczej (uwaga: wywolywac po ModParam)
494:           //nst - parametr z zakresu od 0 do _GWMMAXCO
495:           
496:           void MocMaksCO(unsigned char nst)
CAF4  0100     MOVLB 0x0
CAF6  6FF0     MOVWF p, BANKED
497:           {
498:               unsigned int tmp;
499:           
500:               if(nst > PWM.GWMMAXCO) nst = PWM.GWMMAXCO;
CAF8  0100     MOVLB 0x0
CAFA  51F0     MOVF p, W, BANKED
CAFC  5D72     SUBWF _PFNf_ferr, W, BANKED
CAFE  E203     BC 0xCB06
CB00  C072     MOVFF _PFNf_ferr, p
CB02  F0F0     NOP
CB04  D000     BRA 0xCB06
501:               tmp = ((PWM.MGMAXCO - PWM.MDMAXCO)*10) / PWM.GWMMAXCO;
CB06  0100     MOVLB 0x0
CB08  5173     MOVF _PFNf_fmsg, W, BANKED
CB0A  6FEC     MOVWF dt, BANKED
CB0C  6BED     CLRF min, BANKED
CB0E  1FEC     COMF dt, F, BANKED
CB10  1FED     COMF min, F, BANKED
CB12  4BEC     INFSNZ dt, F, BANKED
CB14  2BED     INCF min, F, BANKED
CB16  5174     MOVF _PFNf_fnoCS, W, BANKED
CB18  25EC     ADDWF dt, W, BANKED
CB1A  6FDE     MOVWF __pcstackBANK0, BANKED
CB1C  0E00     MOVLW 0x0
CB1E  21ED     ADDWFC min, W, BANKED
CB20  6FDF     MOVWF pco, BANKED
CB22  6BE1     CLRF GIE_BIT_VAL, BANKED
CB24  0E0A     MOVLW 0xA
CB26  6FE0     MOVWF bdat, BANKED
CB28  EC5B     CALL 0xECB6, 0
CB2A  F076     NOP
CB2C  C0DE     MOVFF __pcstackBANK0, k
CB2E  F0E4     NOP
CB30  C0DF     MOVFF pco, k
CB32  F0E5     NOP
CB34  C072     MOVFF _PFNf_ferr, counter
CB36  F0E6     NOP
CB38  0100     MOVLB 0x0
CB3A  6BE7     CLRF sign, BANKED
CB3C  EC09     CALL 0xC212, 0
CB3E  F061     NOP
CB40  C0E4     MOVFF k, dt
CB42  F0EE     NOP
CB44  C0E5     MOVFF k, 0xEF
CB46  F0EF     NOP
502:               PWM.MMAXCO = PWM.MDMAXCO + (unsigned char)((nst * tmp) / 10);
CB48  C0F0     MOVFF p, __pcstackBANK0
CB4A  F0DE     NOP
CB4C  0100     MOVLB 0x0
CB4E  6BDF     CLRF pco, BANKED
CB50  C0EE     MOVFF dt, bdat
CB52  F0E0     NOP
CB54  C0EF     MOVFF 0xEF, GIE_BIT_VAL
CB56  F0E1     NOP
CB58  EC5B     CALL 0xECB6, 0
CB5A  F076     NOP
CB5C  C0DE     MOVFF __pcstackBANK0, k
CB5E  F0E4     NOP
CB60  C0DF     MOVFF pco, k
CB62  F0E5     NOP
CB64  0100     MOVLB 0x0
CB66  6BE7     CLRF sign, BANKED
CB68  0E0A     MOVLW 0xA
CB6A  6FE6     MOVWF counter, BANKED
CB6C  EC0B     CALL 0xD816, 0
CB6E  F06C     NOP
CB70  0100     MOVLB 0x0
CB72  51E4     MOVF k, W, BANKED
CB74  2573     ADDWF _PFNf_fmsg, W, BANKED
CB76  6F7D     MOVWF _PFNf_obgCO, BANKED
503:           }
CB78  0012     RETURN 0
504:           /*---------------------------------------------------------------------------------*/
505:           /*---------------------------------------------------------------------------------*/
506:           //Moc maksymalna wpdy uzytkowej (uwaga: wywolywac po ModParam) 
507:           //nst - parametr z zakresu od 0 do _GWMMAXCW
508:           
509:           void MocMaksCW(unsigned char nst)
CA6E  0100     MOVLB 0x0
CA70  6FF0     MOVWF p, BANKED
510:           {
511:               unsigned int tmp;
512:           
513:               if(nst > PWM.GWMMAXCW) nst = PWM.GWMMAXCW;
CA72  0100     MOVLB 0x0
CA74  51F0     MOVF p, W, BANKED
CA76  5D75     SUBWF _PFNf_fns_max, W, BANKED
CA78  E203     BC 0xCA80
CA7A  C075     MOVFF _PFNf_fns_max, p
CA7C  F0F0     NOP
CA7E  D000     BRA 0xCA80
514:               tmp = ((PWM.MGMAXCW - PWM.MDMAXCW)*10) / PWM.GWMMAXCW;
CA80  0100     MOVLB 0x0
CA82  5176     MOVF _PFNf_fnserw, W, BANKED
CA84  6FEC     MOVWF dt, BANKED
CA86  6BED     CLRF min, BANKED
CA88  1FEC     COMF dt, F, BANKED
CA8A  1FED     COMF min, F, BANKED
CA8C  4BEC     INFSNZ dt, F, BANKED
CA8E  2BED     INCF min, F, BANKED
CA90  5177     MOVF _PFNf_lato, W, BANKED
CA92  25EC     ADDWF dt, W, BANKED
CA94  6FDE     MOVWF __pcstackBANK0, BANKED
CA96  0E00     MOVLW 0x0
CA98  21ED     ADDWFC min, W, BANKED
CA9A  6FDF     MOVWF pco, BANKED
CA9C  6BE1     CLRF GIE_BIT_VAL, BANKED
CA9E  0E0A     MOVLW 0xA
CAA0  6FE0     MOVWF bdat, BANKED
CAA2  EC5B     CALL 0xECB6, 0
CAA4  F076     NOP
CAA6  C0DE     MOVFF __pcstackBANK0, k
CAA8  F0E4     NOP
CAAA  C0DF     MOVFF pco, k
CAAC  F0E5     NOP
CAAE  C075     MOVFF _PFNf_fns_max, counter
CAB0  F0E6     NOP
CAB2  0100     MOVLB 0x0
CAB4  6BE7     CLRF sign, BANKED
CAB6  EC09     CALL 0xC212, 0
CAB8  F061     NOP
CABA  C0E4     MOVFF k, dt
CABC  F0EE     NOP
CABE  C0E5     MOVFF k, 0xEF
CAC0  F0EF     NOP
515:               PWM.MMAXCW = PWM.MDMAXCW + (unsigned char)((nst * tmp) / 10);
CAC2  C0F0     MOVFF p, __pcstackBANK0
CAC4  F0DE     NOP
CAC6  0100     MOVLB 0x0
CAC8  6BDF     CLRF pco, BANKED
CACA  C0EE     MOVFF dt, bdat
CACC  F0E0     NOP
CACE  C0EF     MOVFF 0xEF, GIE_BIT_VAL
CAD0  F0E1     NOP
CAD2  EC5B     CALL 0xECB6, 0
CAD4  F076     NOP
CAD6  C0DE     MOVFF __pcstackBANK0, k
CAD8  F0E4     NOP
CADA  C0DF     MOVFF pco, k
CADC  F0E5     NOP
CADE  0100     MOVLB 0x0
CAE0  6BE7     CLRF sign, BANKED
CAE2  0E0A     MOVLW 0xA
CAE4  6FE6     MOVWF counter, BANKED
CAE6  EC0B     CALL 0xD816, 0
CAE8  F06C     NOP
CAEA  0100     MOVLB 0x0
CAEC  51E4     MOVF k, W, BANKED
CAEE  2576     ADDWF _PFNf_fnserw, W, BANKED
CAF0  6F7E     MOVWF _PFNf_obgCW, BANKED
516:           }
CAF2  0012     RETURN 0
517:           /*---------------------------------------------------------------------------------*/
518:           /*-----------------------------PROTECTED DATA--------------------------------------*/
519:           /*---------------------------------------------------------------------------------*/
520:           //Modyfikacja stanu wyjscia PWM
521:           //UWAGA - procedura wykonywana w przerwaniu
522:           
523:           /*if((TMR2IF)&&(TMR2IE))
524:                   {
525:                           TMR2IF=0;
526:                           IntPwm();			//nowe wypelnienie PWM
527:                   }*/
528:           void IntPWM(void)
529:           {
530:               static bit btOsc = 0;
531:           
532:               if(PWMf_ENPWM) //nowa wartosc PWM gotowa do pobrania?
E0BC  AA13     BTFSS PFNf_zima, 5, ACCESS
E0BE  D004     BRA 0xE0C8
533:               {
534:                   PWM.NewPWM = PWM.BufPWM;
E0C0  C060     MOVFF PWM, 0x63
E0C2  F063     NOP
535:                   PWM.NewOSC = PWM.BufOSC;
E0C4  C061     MOVFF 0x61, 0x62
E0C6  F062     NOP
536:               }
537:               if(PWMf_ENOSC) //aktywny modul oscylacji?
E0C8  A813     BTFSS PFNf_zima, 4, ACCESS
E0CA  D00C     BRA 0xE0E4
538:               {
539:           
540:                   if(!btOsc)
E0CC  B201     BTFSC DtCOf_err_CO, 1, ACCESS
E0CE  D005     BRA 0xE0DA
541:                   {
542:                       btOsc = 1;
E0D0  8201     BSF DtCOf_err_CO, 1, ACCESS
543:                       PWM.NewPWM -= PWM.NewOSC;
E0D2  0100     MOVLB 0x0
E0D4  5162     MOVF 0x62, W, BANKED
E0D6  5F63     SUBWF 0x63, F, BANKED
544:                   }
E0D8  D005     BRA 0xE0E4
545:                   else
546:                   {
547:                       btOsc = 0;
E0DA  9201     BCF DtCOf_err_CO, 1, ACCESS
548:                       PWM.NewPWM += PWM.NewOSC;
E0DC  0100     MOVLB 0x0
E0DE  5162     MOVF 0x62, W, BANKED
E0E0  2763     ADDWF 0x63, F, BANKED
E0E2  D000     BRA 0xE0E4
549:                   }
550:               }
551:           
552:               if(PWM.NewPWM > PWM.HIPWM) PWM.NewPWM = PWM.HIPWM;
E0E4  0100     MOVLB 0x0
E0E6  5163     MOVF 0x63, W, BANKED
E0E8  5D66     SUBWF 0x66, W, BANKED
E0EA  A0D8     BTFSS STATUS, 0, ACCESS
E0EC  C066     MOVFF 0x66, 0x63
E0EE  F063     NOP
553:           
554:           #if _PSHIFT>=2
555:               DC1B1 = ((PWM.NewPWM & 0b00000010) > 0) ? 1 : 0;
556:               DC1B0 = ((PWM.NewPWM & 0b00000001) > 0) ? 1 : 0;
557:               CCPR1L = PWM.NewPWM >> 2;
558:           #endif
559:           #if _PSHIFT==1
560:               DC1B1 = ((PWM.NewPWM & 0b00000001) > 0) ? 1 : 0;
E0F0  A163     BTFSS 0x63, 0, BANKED
E0F2  D002     BRA 0xE0F8
E0F4  8ABD     BSF CCP1CON, 5, ACCESS
E0F6  D001     BRA 0xE0FA
E0F8  9ABD     BCF CCP1CON, 5, ACCESS
561:               DC1B0 = 0;
E0FA  98BD     BCF CCP1CON, 4, ACCESS
562:               CCPR1L = PWM.NewPWM >> 1;
E0FC  0100     MOVLB 0x0
E0FE  90D8     BCF STATUS, 0, ACCESS
E100  3163     RRCF 0x63, W, BANKED
E102  6EBE     MOVWF CCPR1, ACCESS
563:           #endif
564:           #if _PSHIFT==0
565:               DC1B1 = 0;
566:               DC1B0 = 0;
567:               CCPR1L = PWM.NewPWM;
568:           #endif
569:           }
E104  0012     RETURN 0
570:           //---------------------------------------
571:           //PWM2 - pompa
572:           
573:           void IntPWM2(void)
574:           {
575:               static bit btOsc = 0;
576:           
577:               if(PWMf_ENPWM2) //nowa wartosc PWM gotowa do pobrania?
ECE0  BC13     BTFSC PFNf_zima, 6, ACCESS
578:               {
579:                   PWM.NewPWM2 = PWM.BufPWM2;
ECE2  C064     MOVFF 0x64, 0x65
ECE4  F065     NOP
ECE6  D000     BRA 0xECE8
580:               }
581:               if(PWM.NewPWM2 > PWM.HIPWM) PWM.NewPWM2 = PWM.HIPWM;
ECE8  0100     MOVLB 0x0
ECEA  5165     MOVF 0x65, W, BANKED
ECEC  5D66     SUBWF 0x66, W, BANKED
ECEE  A0D8     BTFSS STATUS, 0, ACCESS
ECF0  C066     MOVFF 0x66, 0x65
ECF2  F065     NOP
582:           #if _NEG_PWM2==1
583:               PWM.NewPWM2 = ~PWM.NewPWM2;
584:           #endif	
585:           #if _PSHIFT>=2
586:               DC2B1 = ((PWM.NewPWM2 & 0b00000010) > 0) ? 1 : 0;
587:               DC2B0 = ((PWM.NewPWM2 & 0b00000001) > 0) ? 1 : 0;
588:               CCPR2L = PWM.NewPWM2 >> 2;
589:           #endif
590:           #if _PSHIFT==1
591:               DC2B1 = ((PWM.NewPWM2 & 0b00000001) > 0) ? 1 : 0;
ECF4  A165     BTFSS 0x65, 0, BANKED
ECF6  D002     BRA 0xECFC
ECF8  8ABA     BSF CCP2CON, 5, ACCESS
ECFA  D001     BRA 0xECFE
ECFC  9ABA     BCF CCP2CON, 5, ACCESS
592:               DC2B0 = 0;
ECFE  98BA     BCF CCP2CON, 4, ACCESS
593:               CCPR2L = PWM.NewPWM2 >> 1;
ED00  0100     MOVLB 0x0
ED02  90D8     BCF STATUS, 0, ACCESS
ED04  3165     RRCF 0x65, W, BANKED
ED06  6EBB     MOVWF CCPR2, ACCESS
594:           #endif
595:           #if _PSHIFT==0
596:               DC2B1 = 0;
597:               DC2B0 = 0;
598:               CCPR2L = PWM.NewPWM2;
599:           #endif
600:           }
ED08  0012     RETURN 0
601:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/print.c  ---------------------------------
1:             /*---------------------------------------------------------------------------------*/
2:             /*print.c*/
3:             /*Funkcje zapisu danych do 2 segmentowego wyswietlacza typu LED*/
4:             /*w oparciu o procedury obslugi wyswietlacza zawarte w pliku wsw.c*/
5:             /*Sposob reprezentacji danych - ITALY*/
6:             /*---------------------------------------------------------------------------------*/
7:             #include <pic18.h>
8:             #include "global.h"				//parametry globalne
9:             #include "print.h"				//parametry lokalne
10:            #include "pomiar.tp.h"
11:            #include "main.tp.h"
12:            //wsw.c
13:            extern WPack PWD[]; //tablica priorytetow wyswietlania PWD[n] (n=0 - najwyzszy priorytet)
14:            extern WPack DWD[]; //tablica danych modyfikowanych dynamicznie wystepujacych wylacznie w kolejkach
15:            extern const unsigned char Znak[];
16:            extern DataCO DtCO; //pomiar.c
17:            extern DataPFN PFN;
18:            //---------------------------------------------------------
19:            //---------------------------------------------------------
20:            //Funkcje wyswietlania wg waznosci.
21:            //ClsScr
22:            //-PrintErr
23:            //--PrintPR,PrintWPR
24:            //---PrintNstCW
25:            //----PrintNstCO
26:            //----PrintNstKT
27:            //-----PrintMsg
28:            //------PrintTDZ
29:            //-------PrintOFF
30:            //--------PrintCS
31:            //---------PrintCW
32:            //----------PrintCO
33:            
34:            //---------------------------------------------------------
35:            //---------------------------------------------------------
36:            //Deaktywacja (wygaszenie) wyswietlacza
37:            
38:            void ClsScr(void)
39:            {
40:                WswOff();
F418  EC0F     CALL 0xF41E, 0
F41A  F07A     NOP
41:            }
F41C  0012     RETURN 0
42:            //Aktywacja wyswietlacza, ustawienie wszystkich kolejek na pozycji pierwszej
43:            
44:            void EndClsScr(void)
45:            {
46:                AllKolToFirstPoz();
F3B8  ECD3     CALL 0xD5A6, 0
F3BA  F06A     NOP
47:                WswOn();
F3BC  EC09     CALL 0xF412, 0
F3BE  F07A     NOP
48:            }
F3C0  0012     RETURN 0
49:            //---------------------------------------------------------
50:            //---------------------------------------------------------
51:            //Ustaw znacznik kodu bledu dla procedury DecWsw()
52:            
53:            void SetErr(const unsigned char kod)
F38E  0100     MOVLB 0x0
F390  6FDE     MOVWF __pcstackBANK0, BANKED
54:            {
55:                PFNf_ferr = 1;
F392  840E     BSF PFNf_lato, 2, ACCESS
56:                PFN.KERR = kod;
F394  C0DE     MOVFF __pcstackBANK0, 0x1E6
F396  F1E6     NOP
57:            }
F398  0012     RETURN 0
58:            //---------------------------------------------------------
59:            //---------------------------------------------------------
60:            //Ustaw znacznik komunikatu awaryjnego dla procedury DecWsw()
61:            
62:            void SetMsg(const unsigned char kod)
F382  0100     MOVLB 0x0
F384  6FDE     MOVWF __pcstackBANK0, BANKED
63:            {
64:                PFNf_fmsg = 1;
F386  860E     BSF PFNf_lato, 3, ACCESS
65:                PFN.KAWR = kod;
F388  C0DE     MOVFF __pcstackBANK0, 0x1E5
F38A  F1E5     NOP
66:            }
F38C  0012     RETURN 0
67:            //---------------------------------------------------------
68:            //---------------------------------------------------------
69:            //wyswietla migajacy kod bledu
70:            //kod - parametr okreslajacy migajacy kod bledu do wyswietlenia
71:            //pls - dla 1 dioda error miga, dla 0 dioda error zapalona
72:            //cw - kropka przy mlodszej cyfrze
73:            void PrintErr(const unsigned char kod, const unsigned char pls)
C4A4  0100     MOVLB 0x0
C4A6  6FE7     MOVWF sign, BANKED
74:            {
75:                SetData(&DWD[0], 0, kod);
C4A8  0E7E     MOVLW 0x7E
C4AA  0100     MOVLB 0x0
C4AC  6FDE     MOVWF __pcstackBANK0, BANKED
C4AE  0E01     MOVLW 0x1
C4B0  6FDF     MOVWF pco, BANKED
C4B2  6BE0     CLRF bdat, BANKED
C4B4  C0E7     MOVFF sign, GIE_BIT_VAL
C4B6  F0E1     NOP
C4B8  EC22     CALL 0xEE44, 0
C4BA  F077     NOP
76:                SetData(&DWD[1], 0, kod);
C4BC  0E82     MOVLW 0x82
C4BE  0100     MOVLB 0x0
C4C0  6FDE     MOVWF __pcstackBANK0, BANKED
C4C2  0E01     MOVLW 0x1
C4C4  6FDF     MOVWF pco, BANKED
C4C6  6BE0     CLRF bdat, BANKED
C4C8  C0E7     MOVFF sign, GIE_BIT_VAL
C4CA  F0E1     NOP
C4CC  EC22     CALL 0xEE44, 0
C4CE  F077     NOP
77:                SetStatus(&DWD[0], tHEX | tSDID | _DKM, tALL);
C4D0  0E7E     MOVLW 0x7E
C4D2  0100     MOVLB 0x0
C4D4  6FDE     MOVWF __pcstackBANK0, BANKED
C4D6  0E01     MOVLW 0x1
C4D8  6FDF     MOVWF pco, BANKED
C4DA  0E20     MOVLW 0x20
C4DC  6FE1     MOVWF GIE_BIT_VAL, BANKED
C4DE  0E24     MOVLW 0x24
C4E0  6FE0     MOVWF bdat, BANKED
C4E2  0EFF     MOVLW 0xFF
C4E4  69E3     SETF a, BANKED
C4E6  69E2     SETF divisor, BANKED
C4E8  ECE7     CALL 0x7BCE, 0
C4EA  F03D     NOP
78:                if(pls) SetStatus(&DWD[1], tHEX | tRDID | _DKM, tALL); //migajacy kod bledu
C4EC  0100     MOVLB 0x0
C4EE  51E6     MOVF counter, W, BANKED
C4F0  E00E     BZ 0xC50E
C4F2  0E82     MOVLW 0x82
C4F4  6FDE     MOVWF __pcstackBANK0, BANKED
C4F6  0E01     MOVLW 0x1
C4F8  6FDF     MOVWF pco, BANKED
C4FA  0E20     MOVLW 0x20
C4FC  6FE1     MOVWF GIE_BIT_VAL, BANKED
C4FE  0E14     MOVLW 0x14
C500  6FE0     MOVWF bdat, BANKED
C502  0EFF     MOVLW 0xFF
C504  69E3     SETF a, BANKED
C506  69E2     SETF divisor, BANKED
C508  ECE7     CALL 0x7BCE, 0
C50A  F03D     NOP
C50C  D00F     BRA 0xC52C
79:                else SetStatus(&DWD[1], tHEX | tSDID | _DKM, tALL); //staly kod bledu
C50E  0E82     MOVLW 0x82
C510  0100     MOVLB 0x0
C512  6FDE     MOVWF __pcstackBANK0, BANKED
C514  0E01     MOVLW 0x1
C516  6FDF     MOVWF pco, BANKED
C518  0E20     MOVLW 0x20
C51A  6FE1     MOVWF GIE_BIT_VAL, BANKED
C51C  0E24     MOVLW 0x24
C51E  6FE0     MOVWF bdat, BANKED
C520  0EFF     MOVLW 0xFF
C522  69E3     SETF a, BANKED
C524  69E2     SETF divisor, BANKED
C526  ECE7     CALL 0x7BCE, 0
C528  F03D     NOP
C52A  D000     BRA 0xC52C
80:                SetPoz(_WS_ERR, 0);
C52C  0E00     MOVLW 0x0
C52E  0100     MOVLB 0x0
C530  6BDE     CLRF __pcstackBANK0, BANKED
C532  ECAC     CALL 0xC958, 0
C534  F064     NOP
81:                SetPoz(_WS_ERR, 1);
C536  0E01     MOVLW 0x1
C538  0100     MOVLB 0x0
C53A  6FDE     MOVWF __pcstackBANK0, BANKED
C53C  0E00     MOVLW 0x0
C53E  ECAC     CALL 0xC958, 0
C540  F064     NOP
82:            }
C542  0012     RETURN 0
83:            
84:            void PrintErrCs(const unsigned char kod, const unsigned char cs, const unsigned char pls)
C404  0100     MOVLB 0x0
C406  6FE8     MOVWF quotient, BANKED
85:            {
86:                SetData(&DWD[0], 0, kod);
C408  0E7E     MOVLW 0x7E
C40A  0100     MOVLB 0x0
C40C  6FDE     MOVWF __pcstackBANK0, BANKED
C40E  0E01     MOVLW 0x1
C410  6FDF     MOVWF pco, BANKED
C412  6BE0     CLRF bdat, BANKED
C414  C0E8     MOVFF quotient, GIE_BIT_VAL
C416  F0E1     NOP
C418  EC22     CALL 0xEE44, 0
C41A  F077     NOP
87:                SetData(&DWD[1], 0, cs);
C41C  0E82     MOVLW 0x82
C41E  0100     MOVLB 0x0
C420  6FDE     MOVWF __pcstackBANK0, BANKED
C422  0E01     MOVLW 0x1
C424  6FDF     MOVWF pco, BANKED
C426  6BE0     CLRF bdat, BANKED
C428  C0E6     MOVFF counter, GIE_BIT_VAL
C42A  F0E1     NOP
C42C  EC22     CALL 0xEE44, 0
C42E  F077     NOP
88:                SetStatus(&DWD[0], tHEX | tSDID | _DKM, tALL); //kod bledu/cisnienie
C430  0E7E     MOVLW 0x7E
C432  0100     MOVLB 0x0
C434  6FDE     MOVWF __pcstackBANK0, BANKED
C436  0E01     MOVLW 0x1
C438  6FDF     MOVWF pco, BANKED
C43A  0E20     MOVLW 0x20
C43C  6FE1     MOVWF GIE_BIT_VAL, BANKED
C43E  0E24     MOVLW 0x24
C440  6FE0     MOVWF bdat, BANKED
C442  0EFF     MOVLW 0xFF
C444  69E3     SETF a, BANKED
C446  69E2     SETF divisor, BANKED
C448  ECE7     CALL 0x7BCE, 0
C44A  F03D     NOP
89:            
90:                if(pls) SetStatus(&DWD[1], tDEC | tKROPKA1 | tRDID | _DKM, tALL); //cisnienie
C44C  0100     MOVLB 0x0
C44E  51E7     MOVF sign, W, BANKED
C450  E00E     BZ 0xC46E
C452  0E82     MOVLW 0x82
C454  6FDE     MOVWF __pcstackBANK0, BANKED
C456  0E01     MOVLW 0x1
C458  6FDF     MOVWF pco, BANKED
C45A  0E44     MOVLW 0x44
C45C  6FE1     MOVWF GIE_BIT_VAL, BANKED
C45E  0E14     MOVLW 0x14
C460  6FE0     MOVWF bdat, BANKED
C462  0EFF     MOVLW 0xFF
C464  69E3     SETF a, BANKED
C466  69E2     SETF divisor, BANKED
C468  ECE7     CALL 0x7BCE, 0
C46A  F03D     NOP
C46C  D00F     BRA 0xC48C
91:                else SetStatus(&DWD[1], tDEC | tKROPKA1 | tSDID | _DKM, tALL);
C46E  0E82     MOVLW 0x82
C470  0100     MOVLB 0x0
C472  6FDE     MOVWF __pcstackBANK0, BANKED
C474  0E01     MOVLW 0x1
C476  6FDF     MOVWF pco, BANKED
C478  0E44     MOVLW 0x44
C47A  6FE1     MOVWF GIE_BIT_VAL, BANKED
C47C  0E24     MOVLW 0x24
C47E  6FE0     MOVWF bdat, BANKED
C480  0EFF     MOVLW 0xFF
C482  69E3     SETF a, BANKED
C484  69E2     SETF divisor, BANKED
C486  ECE7     CALL 0x7BCE, 0
C488  F03D     NOP
C48A  D000     BRA 0xC48C
92:                SetPoz(_WS_ERR, 0);
C48C  0E00     MOVLW 0x0
C48E  0100     MOVLB 0x0
C490  6BDE     CLRF __pcstackBANK0, BANKED
C492  ECAC     CALL 0xC958, 0
C494  F064     NOP
93:                SetPoz(_WS_ERR, 1);
C496  0E01     MOVLW 0x1
C498  0100     MOVLB 0x0
C49A  6FDE     MOVWF __pcstackBANK0, BANKED
C49C  0E00     MOVLW 0x0
C49E  ECAC     CALL 0xC958, 0
C4A0  F064     NOP
94:            }
C4A2  0012     RETURN 0
95:            
96:            void PrintErrTm(const unsigned char kod, const unsigned char tm, const unsigned char pls, const unsigned char cw)
BE9E  0100     MOVLB 0x0
BEA0  6FE9     MOVWF p, BANKED
97:            {
98:                unsigned int fl;
99:                fl=(cw)?tKROPKA0:0;
BEA2  0100     MOVLB 0x0
BEA4  51E8     MOVF quotient, W, BANKED
BEA6  0E00     MOVLW 0x0
BEA8  A4D8     BTFSS STATUS, 2, ACCESS
BEAA  0E08     MOVLW 0x8
BEAC  D000     BRA 0xBEAE
BEAE  0100     MOVLB 0x0
BEB0  6FEB     MOVWF pop, BANKED
BEB2  6BEA     CLRF tim, BANKED
BEB4  D000     BRA 0xBEB6
100:               SetData(&DWD[0], 0, kod);
BEB6  0E7E     MOVLW 0x7E
BEB8  0100     MOVLB 0x0
BEBA  6FDE     MOVWF __pcstackBANK0, BANKED
BEBC  0E01     MOVLW 0x1
BEBE  6FDF     MOVWF pco, BANKED
BEC0  6BE0     CLRF bdat, BANKED
BEC2  C0E9     MOVFF p, GIE_BIT_VAL
BEC4  F0E1     NOP
BEC6  EC22     CALL 0xEE44, 0
BEC8  F077     NOP
101:               SetData(&DWD[1], 0, tm);
BECA  0E82     MOVLW 0x82
BECC  0100     MOVLB 0x0
BECE  6FDE     MOVWF __pcstackBANK0, BANKED
BED0  0E01     MOVLW 0x1
BED2  6FDF     MOVWF pco, BANKED
BED4  6BE0     CLRF bdat, BANKED
BED6  C0E6     MOVFF counter, GIE_BIT_VAL
BED8  F0E1     NOP
BEDA  EC22     CALL 0xEE44, 0
BEDC  F077     NOP
102:               SetStatus(&DWD[0], tHEX | tSDID | _DKM, tALL); //kod bledu/temperatura
BEDE  0E7E     MOVLW 0x7E
BEE0  0100     MOVLB 0x0
BEE2  6FDE     MOVWF __pcstackBANK0, BANKED
BEE4  0E01     MOVLW 0x1
BEE6  6FDF     MOVWF pco, BANKED
BEE8  0E20     MOVLW 0x20
BEEA  6FE1     MOVWF GIE_BIT_VAL, BANKED
BEEC  0E24     MOVLW 0x24
BEEE  6FE0     MOVWF bdat, BANKED
BEF0  0EFF     MOVLW 0xFF
BEF2  69E3     SETF a, BANKED
BEF4  69E2     SETF divisor, BANKED
BEF6  ECE7     CALL 0x7BCE, 0
BEF8  F03D     NOP
103:               if(pls) SetStatus(&DWD[1], fl | tDEC | tRDID | _DKM, tALL); //temperatura
BEFA  0100     MOVLB 0x0
BEFC  51E7     MOVF sign, W, BANKED
BEFE  E010     BZ 0xBF20
BF00  0E82     MOVLW 0x82
BF02  6FDE     MOVWF __pcstackBANK0, BANKED
BF04  0E01     MOVLW 0x1
BF06  6FDF     MOVWF pco, BANKED
BF08  0E14     MOVLW 0x14
BF0A  11EA     IORWF tim, W, BANKED
BF0C  6FE0     MOVWF bdat, BANKED
BF0E  0E40     MOVLW 0x40
BF10  11EB     IORWF pop, W, BANKED
BF12  6FE1     MOVWF GIE_BIT_VAL, BANKED
BF14  0EFF     MOVLW 0xFF
BF16  69E3     SETF a, BANKED
BF18  69E2     SETF divisor, BANKED
BF1A  ECE7     CALL 0x7BCE, 0
BF1C  F03D     NOP
BF1E  D011     BRA 0xBF42
104:               else SetStatus(&DWD[1], fl | tDEC | tSDID | _DKM, tALL);
BF20  0E82     MOVLW 0x82
BF22  0100     MOVLB 0x0
BF24  6FDE     MOVWF __pcstackBANK0, BANKED
BF26  0E01     MOVLW 0x1
BF28  6FDF     MOVWF pco, BANKED
BF2A  0E24     MOVLW 0x24
BF2C  11EA     IORWF tim, W, BANKED
BF2E  6FE0     MOVWF bdat, BANKED
BF30  0E40     MOVLW 0x40
BF32  11EB     IORWF pop, W, BANKED
BF34  6FE1     MOVWF GIE_BIT_VAL, BANKED
BF36  0EFF     MOVLW 0xFF
BF38  69E3     SETF a, BANKED
BF3A  69E2     SETF divisor, BANKED
BF3C  ECE7     CALL 0x7BCE, 0
BF3E  F03D     NOP
BF40  D000     BRA 0xBF42
105:               SetPoz(_WS_ERR, 0);
BF42  0E00     MOVLW 0x0
BF44  0100     MOVLB 0x0
BF46  6BDE     CLRF __pcstackBANK0, BANKED
BF48  ECAC     CALL 0xC958, 0
BF4A  F064     NOP
106:               SetPoz(_WS_ERR, 1);
BF4C  0E01     MOVLW 0x1
BF4E  0100     MOVLB 0x0
BF50  6FDE     MOVWF __pcstackBANK0, BANKED
BF52  0E00     MOVLW 0x0
BF54  ECAC     CALL 0xC958, 0
BF56  F064     NOP
107:           }
BF58  0012     RETURN 0
108:           //usuwa migajacy kod bledu
109:           
110:           void EndErr(void)
111:           {
112:               PFNf_fmsg = 0;
F286  960E     BCF PFNf_lato, 3, ACCESS
113:               PFNf_ferr = 0;
F288  940E     BCF PFNf_lato, 2, ACCESS
114:               PFN.KERR = 0;
F28A  0101     MOVLB 0x1
F28C  6BE6     CLRF counter, BANKED
115:               PFN.KAWR = 0;
F28E  6BE5     CLRF k, BANKED
116:               ResetKol(_WS_ERR);
F290  0E00     MOVLW 0x0
F292  ECD6     CALL 0xEDAC, 0
F294  F076     NOP
117:           }
F296  0012     RETURN 0
118:           //---------------------------------------------------------
119:           //---------------------------------------------------------
120:           //Wyswietla wskaz skladajacy sie z oznaczenia literowego i cyfry od 0 do 9
121:           //lkod - dowolny znak w kodzie led wyswietlany na starszej cyfrze
122:           //dla tryb=0:
123:           //nkod - liczba zakresu 0-F wyswietlana na mlodszej cyfrze
124:           //dla tryb=1:
125:           //nkod - dowolny znak w kodzie led wyswietlany na mlodszej cyfrze
126:           
127:           void PrintPR(const unsigned char lkod, unsigned char nkod, unsigned char tryb)
AF64  0100     MOVLB 0x0
AF66  6FEC     MOVWF dt, BANKED
128:           {
129:               //if((nkod > 0xf) && !tryb) nkod = 0xf;
130:               //SetData(&DWD[2], lkod, (!tryb) ? Znak[nkod] : nkod);
131:               if(nkod < 10)
AF68  0E0A     MOVLW 0xA
AF6A  0100     MOVLB 0x0
AF6C  61E6     CPFSLT counter, BANKED
AF6E  D056     BRA 0xB01C
132:               {
133:                   SetData(&DWD[2], lkod, (!tryb) ? Znak[nkod] : nkod);
AF70  51E7     MOVF sign, W, BANKED
AF72  E003     BZ 0xAF7A
AF74  C0E6     MOVFF counter, quotient
AF76  F0E8     NOP
AF78  D00C     BRA 0xAF92
AF7A  0100     MOVLB 0x0
AF7C  51E6     MOVF counter, W, BANKED
AF7E  0D01     MULLW 0x1
AF80  0E35     MOVLW 0x35
AF82  24F3     ADDWF PROD, W, ACCESS
AF84  6EF6     MOVWF TBLPTR, ACCESS
AF86  0E10     MOVLW 0x10
AF88  20F4     ADDWFC PRODH, W, ACCESS
AF8A  6EF7     MOVWF TBLPTRH, ACCESS
AF8C  0008     TBLRD*
AF8E  50F5     MOVF TABLAT, W, ACCESS
AF90  6FE8     MOVWF quotient, BANKED
AF92  6BE9     CLRF p, BANKED
AF94  D000     BRA 0xAF96
AF96  0E86     MOVLW 0x86
AF98  0100     MOVLB 0x0
AF9A  6FDE     MOVWF __pcstackBANK0, BANKED
AF9C  0E01     MOVLW 0x1
AF9E  6FDF     MOVWF pco, BANKED
AFA0  C0EC     MOVFF dt, bdat
AFA2  F0E0     NOP
AFA4  C0E8     MOVFF quotient, GIE_BIT_VAL
AFA6  F0E1     NOP
AFA8  EC22     CALL 0xEE44, 0
AFAA  F077     NOP
134:                   SetData(&DWD[3], lkod, (!tryb) ? Znak[nkod] : nkod);
AFAC  0100     MOVLB 0x0
AFAE  51E7     MOVF sign, W, BANKED
AFB0  E003     BZ 0xAFB8
AFB2  C0E6     MOVFF counter, tim
AFB4  F0EA     NOP
AFB6  D00C     BRA 0xAFD0
AFB8  0100     MOVLB 0x0
AFBA  51E6     MOVF counter, W, BANKED
AFBC  0D01     MULLW 0x1
AFBE  0E35     MOVLW 0x35
AFC0  24F3     ADDWF PROD, W, ACCESS
AFC2  6EF6     MOVWF TBLPTR, ACCESS
AFC4  0E10     MOVLW 0x10
AFC6  20F4     ADDWFC PRODH, W, ACCESS
AFC8  6EF7     MOVWF TBLPTRH, ACCESS
AFCA  0008     TBLRD*
AFCC  50F5     MOVF TABLAT, W, ACCESS
AFCE  6FEA     MOVWF tim, BANKED
AFD0  6BEB     CLRF pop, BANKED
AFD2  D000     BRA 0xAFD4
AFD4  0E8A     MOVLW 0x8A
AFD6  0100     MOVLB 0x0
AFD8  6FDE     MOVWF __pcstackBANK0, BANKED
AFDA  0E01     MOVLW 0x1
AFDC  6FDF     MOVWF pco, BANKED
AFDE  C0EC     MOVFF dt, bdat
AFE0  F0E0     NOP
AFE2  C0EA     MOVFF tim, GIE_BIT_VAL
AFE4  F0E1     NOP
AFE6  EC22     CALL 0xEE44, 0
AFE8  F077     NOP
135:                   SetStatus(&DWD[2], tLED, tALL);
AFEA  0E86     MOVLW 0x86
AFEC  0100     MOVLB 0x0
AFEE  6FDE     MOVWF __pcstackBANK0, BANKED
AFF0  0E01     MOVLW 0x1
AFF2  6FDF     MOVWF pco, BANKED
AFF4  6BE1     CLRF GIE_BIT_VAL, BANKED
AFF6  6BE0     CLRF bdat, BANKED
AFF8  0EFF     MOVLW 0xFF
AFFA  69E3     SETF a, BANKED
AFFC  69E2     SETF divisor, BANKED
AFFE  ECE7     CALL 0x7BCE, 0
B000  F03D     NOP
136:                   SetStatus(&DWD[3], tLED, tALL);
B002  0E8A     MOVLW 0x8A
B004  0100     MOVLB 0x0
B006  6FDE     MOVWF __pcstackBANK0, BANKED
B008  0E01     MOVLW 0x1
B00A  6FDF     MOVWF pco, BANKED
B00C  6BE1     CLRF GIE_BIT_VAL, BANKED
B00E  6BE0     CLRF bdat, BANKED
B010  0EFF     MOVLW 0xFF
B012  69E3     SETF a, BANKED
B014  69E2     SETF divisor, BANKED
B016  ECE7     CALL 0x7BCE, 0
B018  F03D     NOP
137:               }
B01A  D02E     BRA 0xB078
138:               else
139:               {
140:                   SetData(&DWD[3], lkod, BLACK);
B01C  0E8A     MOVLW 0x8A
B01E  0100     MOVLB 0x0
B020  6FDE     MOVWF __pcstackBANK0, BANKED
B022  0E01     MOVLW 0x1
B024  6FDF     MOVWF pco, BANKED
B026  C0EC     MOVFF dt, bdat
B028  F0E0     NOP
B02A  69E1     SETF GIE_BIT_VAL, BANKED
B02C  EC22     CALL 0xEE44, 0
B02E  F077     NOP
141:                   SetData(&DWD[2],0 ,nkod);
B030  0E86     MOVLW 0x86
B032  0100     MOVLB 0x0
B034  6FDE     MOVWF __pcstackBANK0, BANKED
B036  0E01     MOVLW 0x1
B038  6FDF     MOVWF pco, BANKED
B03A  6BE0     CLRF bdat, BANKED
B03C  C0E6     MOVFF counter, GIE_BIT_VAL
B03E  F0E1     NOP
B040  EC22     CALL 0xEE44, 0
B042  F077     NOP
142:                   SetStatus(&DWD[3], tLED, tALL);
B044  0E8A     MOVLW 0x8A
B046  0100     MOVLB 0x0
B048  6FDE     MOVWF __pcstackBANK0, BANKED
B04A  0E01     MOVLW 0x1
B04C  6FDF     MOVWF pco, BANKED
B04E  6BE1     CLRF GIE_BIT_VAL, BANKED
B050  6BE0     CLRF bdat, BANKED
B052  0EFF     MOVLW 0xFF
B054  69E3     SETF a, BANKED
B056  69E2     SETF divisor, BANKED
B058  ECE7     CALL 0x7BCE, 0
B05A  F03D     NOP
143:                   SetStatus(&DWD[2], tDEC, tALL);
B05C  0E86     MOVLW 0x86
B05E  0100     MOVLB 0x0
B060  6FDE     MOVWF __pcstackBANK0, BANKED
B062  0E01     MOVLW 0x1
B064  6FDF     MOVWF pco, BANKED
B066  0E40     MOVLW 0x40
B068  6FE1     MOVWF GIE_BIT_VAL, BANKED
B06A  6BE0     CLRF bdat, BANKED
B06C  0EFF     MOVLW 0xFF
B06E  69E3     SETF a, BANKED
B070  69E2     SETF divisor, BANKED
B072  ECE7     CALL 0x7BCE, 0
B074  F03D     NOP
B076  D000     BRA 0xB078
144:               }
145:               SetPoz(_WS_PRM, 0);
B078  0100     MOVLB 0x0
B07A  6BDE     CLRF __pcstackBANK0, BANKED
B07C  0E01     MOVLW 0x1
B07E  ECAC     CALL 0xC958, 0
B080  F064     NOP
146:               SetPoz(_WS_PRM, 1);
B082  0E01     MOVLW 0x1
B084  0100     MOVLB 0x0
B086  6FDE     MOVWF __pcstackBANK0, BANKED
B088  ECAC     CALL 0xC958, 0
B08A  F064     NOP
147:           }
B08C  0012     RETURN 0
148:           //----------
149:           //wyswietla wartosc parametru
150:           
151:           void PrintWPR(const unsigned char wr)
D156  0100     MOVLB 0x0
D158  6FE6     MOVWF counter, BANKED
152:           {
153:               SetData(&DWD[2], 0, wr);
D15A  0E86     MOVLW 0x86
D15C  0100     MOVLB 0x0
D15E  6FDE     MOVWF __pcstackBANK0, BANKED
D160  0E01     MOVLW 0x1
D162  6FDF     MOVWF pco, BANKED
D164  6BE0     CLRF bdat, BANKED
D166  C0E6     MOVFF counter, GIE_BIT_VAL
D168  F0E1     NOP
D16A  EC22     CALL 0xEE44, 0
D16C  F077     NOP
154:               SetData(&DWD[3], 0, wr);
D16E  0E8A     MOVLW 0x8A
D170  0100     MOVLB 0x0
D172  6FDE     MOVWF __pcstackBANK0, BANKED
D174  0E01     MOVLW 0x1
D176  6FDF     MOVWF pco, BANKED
D178  6BE0     CLRF bdat, BANKED
D17A  C0E6     MOVFF counter, GIE_BIT_VAL
D17C  F0E1     NOP
D17E  EC22     CALL 0xEE44, 0
D180  F077     NOP
155:               SetStatus(&DWD[2], tDEC, tALL);
D182  0E86     MOVLW 0x86
D184  0100     MOVLB 0x0
D186  6FDE     MOVWF __pcstackBANK0, BANKED
D188  0E01     MOVLW 0x1
D18A  6FDF     MOVWF pco, BANKED
D18C  0E40     MOVLW 0x40
D18E  6FE1     MOVWF GIE_BIT_VAL, BANKED
D190  6BE0     CLRF bdat, BANKED
D192  0EFF     MOVLW 0xFF
D194  69E3     SETF a, BANKED
D196  69E2     SETF divisor, BANKED
D198  ECE7     CALL 0x7BCE, 0
D19A  F03D     NOP
156:               SetStatus(&DWD[3], tDEC, tALL);  
D19C  0E8A     MOVLW 0x8A
D19E  0100     MOVLB 0x0
D1A0  6FDE     MOVWF __pcstackBANK0, BANKED
D1A2  0E01     MOVLW 0x1
D1A4  6FDF     MOVWF pco, BANKED
D1A6  0E40     MOVLW 0x40
D1A8  6FE1     MOVWF GIE_BIT_VAL, BANKED
D1AA  6BE0     CLRF bdat, BANKED
D1AC  0EFF     MOVLW 0xFF
D1AE  69E3     SETF a, BANKED
D1B0  69E2     SETF divisor, BANKED
D1B2  ECE7     CALL 0x7BCE, 0
D1B4  F03D     NOP
157:               SetPoz(_WS_PRM, 0);
D1B6  0100     MOVLB 0x0
D1B8  6BDE     CLRF __pcstackBANK0, BANKED
D1BA  0E01     MOVLW 0x1
D1BC  ECAC     CALL 0xC958, 0
D1BE  F064     NOP
158:               SetPoz(_WS_PRM, 1);
D1C0  0E01     MOVLW 0x1
D1C2  0100     MOVLB 0x0
D1C4  6FDE     MOVWF __pcstackBANK0, BANKED
D1C6  ECAC     CALL 0xC958, 0
D1C8  F064     NOP
159:           }
D1CA  0012     RETURN 0
160:           //----------
161:           //restartuje kolejke wskazu parametru
162:           void RestartPR(void)
163:           {
164:               RestartKol(_WS_PRM);
F3CC  0E01     MOVLW 0x1
F3CE  ECC2     CALL 0xED84, 0
F3D0  F076     NOP
165:           }
F3D2  0012     RETURN 0
166:           //----------
167:           //usuwa wskaz parametru
168:           void EndPR(void)
169:           {
170:               ResetKol(_WS_PRM);
F3D4  0E01     MOVLW 0x1
F3D6  ECD6     CALL 0xEDAC, 0
F3D8  F076     NOP
171:           }
F3DA  0012     RETURN 0
172:           //---------------------------------------------------------
173:           //---------------------------------------------------------
174:           //natychmiastowa aktualizacja wskazu nastawy
175:           
176:           void RNst(const unsigned char nst)
177:           {
178:               SetData(&DWD[4], 0, nst); //nastawa CO/CW/Kt
179:               SetData(&DWD[5], 0, nst); //nastawa CO/CW/Kt
180:           }
181:           //wyswietla nastawe temp. CW
182:           
183:           void PrintNstCW(const unsigned char nst)
D38E  0100     MOVLB 0x0
D390  6FE6     MOVWF counter, BANKED
184:           {
185:               SetData(&DWD[4], 0, nst); //nastawa CW
D392  0E8E     MOVLW 0x8E
D394  0100     MOVLB 0x0
D396  6FDE     MOVWF __pcstackBANK0, BANKED
D398  0E01     MOVLW 0x1
D39A  6FDF     MOVWF pco, BANKED
D39C  6BE0     CLRF bdat, BANKED
D39E  C0E6     MOVFF counter, GIE_BIT_VAL
D3A0  F0E1     NOP
D3A2  EC22     CALL 0xEE44, 0
D3A4  F077     NOP
186:               SetData(&DWD[5], 0, nst); //nastawa CW
D3A6  0E92     MOVLW 0x92
D3A8  0100     MOVLB 0x0
D3AA  6FDE     MOVWF __pcstackBANK0, BANKED
D3AC  0E01     MOVLW 0x1
D3AE  6FDF     MOVWF pco, BANKED
D3B0  6BE0     CLRF bdat, BANKED
D3B2  C0E6     MOVFF counter, GIE_BIT_VAL
D3B4  F0E1     NOP
D3B6  EC22     CALL 0xEE44, 0
D3B8  F077     NOP
187:               SetStatus(&DWD[4], tDEC | tKROPKA0 | tSDID | _DCW, tALL);
D3BA  0E8E     MOVLW 0x8E
D3BC  0100     MOVLB 0x0
D3BE  6FDE     MOVWF __pcstackBANK0, BANKED
D3C0  0E01     MOVLW 0x1
D3C2  6FDF     MOVWF pco, BANKED
D3C4  0E48     MOVLW 0x48
D3C6  6FE1     MOVWF GIE_BIT_VAL, BANKED
D3C8  0E28     MOVLW 0x28
D3CA  6FE0     MOVWF bdat, BANKED
D3CC  0EFF     MOVLW 0xFF
D3CE  69E3     SETF a, BANKED
D3D0  69E2     SETF divisor, BANKED
D3D2  ECE7     CALL 0x7BCE, 0
D3D4  F03D     NOP
188:               SetStatus(&DWD[5], tDEC | tKROPKA0 | tRDID | _DCW, tALL);
D3D6  0E92     MOVLW 0x92
D3D8  0100     MOVLB 0x0
D3DA  6FDE     MOVWF __pcstackBANK0, BANKED
D3DC  0E01     MOVLW 0x1
D3DE  6FDF     MOVWF pco, BANKED
D3E0  0E48     MOVLW 0x48
D3E2  6FE1     MOVWF GIE_BIT_VAL, BANKED
D3E4  0E18     MOVLW 0x18
D3E6  6FE0     MOVWF bdat, BANKED
D3E8  0EFF     MOVLW 0xFF
D3EA  69E3     SETF a, BANKED
D3EC  69E2     SETF divisor, BANKED
D3EE  ECE7     CALL 0x7BCE, 0
D3F0  F03D     NOP
189:               RestartKol(_WS_NCWCO);
D3F2  0E02     MOVLW 0x2
D3F4  ECC2     CALL 0xED84, 0
D3F6  F076     NOP
190:           }
D3F8  0012     RETURN 0
191:           //wyswietla nastawe temp. CO
192:           
193:           void PrintNstCO(const unsigned char nst)
D3FA  0100     MOVLB 0x0
D3FC  6FE6     MOVWF counter, BANKED
194:           {
195:               SetData(&DWD[4], 0, nst); //nastawa CO
D3FE  0E8E     MOVLW 0x8E
D400  0100     MOVLB 0x0
D402  6FDE     MOVWF __pcstackBANK0, BANKED
D404  0E01     MOVLW 0x1
D406  6FDF     MOVWF pco, BANKED
D408  6BE0     CLRF bdat, BANKED
D40A  C0E6     MOVFF counter, GIE_BIT_VAL
D40C  F0E1     NOP
D40E  EC22     CALL 0xEE44, 0
D410  F077     NOP
196:               SetData(&DWD[5], 0, nst); //nastawa CO
D412  0E92     MOVLW 0x92
D414  0100     MOVLB 0x0
D416  6FDE     MOVWF __pcstackBANK0, BANKED
D418  0E01     MOVLW 0x1
D41A  6FDF     MOVWF pco, BANKED
D41C  6BE0     CLRF bdat, BANKED
D41E  C0E6     MOVFF counter, GIE_BIT_VAL
D420  F0E1     NOP
D422  EC22     CALL 0xEE44, 0
D424  F077     NOP
197:               SetStatus(&DWD[4], tDEC | tSDID | _DCO, tALL);
D426  0E8E     MOVLW 0x8E
D428  0100     MOVLB 0x0
D42A  6FDE     MOVWF __pcstackBANK0, BANKED
D42C  0E01     MOVLW 0x1
D42E  6FDF     MOVWF pco, BANKED
D430  0E40     MOVLW 0x40
D432  6FE1     MOVWF GIE_BIT_VAL, BANKED
D434  0E22     MOVLW 0x22
D436  6FE0     MOVWF bdat, BANKED
D438  0EFF     MOVLW 0xFF
D43A  69E3     SETF a, BANKED
D43C  69E2     SETF divisor, BANKED
D43E  ECE7     CALL 0x7BCE, 0
D440  F03D     NOP
198:               SetStatus(&DWD[5], tDEC | tRDID | _DCO, tALL);
D442  0E92     MOVLW 0x92
D444  0100     MOVLB 0x0
D446  6FDE     MOVWF __pcstackBANK0, BANKED
D448  0E01     MOVLW 0x1
D44A  6FDF     MOVWF pco, BANKED
D44C  0E40     MOVLW 0x40
D44E  6FE1     MOVWF GIE_BIT_VAL, BANKED
D450  0E12     MOVLW 0x12
D452  6FE0     MOVWF bdat, BANKED
D454  0EFF     MOVLW 0xFF
D456  69E3     SETF a, BANKED
D458  69E2     SETF divisor, BANKED
D45A  ECE7     CALL 0x7BCE, 0
D45C  F03D     NOP
199:               RestartKol(_WS_NCWCO);
D45E  0E02     MOVLW 0x2
D460  ECC2     CALL 0xED84, 0
D462  F076     NOP
200:           }
D464  0012     RETURN 0
201:           //wyswietla nastawe Kt
202:           
203:           void PrintNstKt(const unsigned char nst)
D322  0100     MOVLB 0x0
D324  6FE6     MOVWF counter, BANKED
204:           {
205:               SetData(&DWD[4], 0, nst); //nastawa Kt
D326  0E8E     MOVLW 0x8E
D328  0100     MOVLB 0x0
D32A  6FDE     MOVWF __pcstackBANK0, BANKED
D32C  0E01     MOVLW 0x1
D32E  6FDF     MOVWF pco, BANKED
D330  6BE0     CLRF bdat, BANKED
D332  C0E6     MOVFF counter, GIE_BIT_VAL
D334  F0E1     NOP
D336  EC22     CALL 0xEE44, 0
D338  F077     NOP
206:               SetData(&DWD[5], 0, nst); //nastawa Kt
D33A  0E92     MOVLW 0x92
D33C  0100     MOVLB 0x0
D33E  6FDE     MOVWF __pcstackBANK0, BANKED
D340  0E01     MOVLW 0x1
D342  6FDF     MOVWF pco, BANKED
D344  6BE0     CLRF bdat, BANKED
D346  C0E6     MOVFF counter, GIE_BIT_VAL
D348  F0E1     NOP
D34A  EC22     CALL 0xEE44, 0
D34C  F077     NOP
207:               SetStatus(&DWD[4], tDEC | tKROPKA1 | tSDID | _DCO, tALL);
D34E  0E8E     MOVLW 0x8E
D350  0100     MOVLB 0x0
D352  6FDE     MOVWF __pcstackBANK0, BANKED
D354  0E01     MOVLW 0x1
D356  6FDF     MOVWF pco, BANKED
D358  0E44     MOVLW 0x44
D35A  6FE1     MOVWF GIE_BIT_VAL, BANKED
D35C  0E22     MOVLW 0x22
D35E  6FE0     MOVWF bdat, BANKED
D360  0EFF     MOVLW 0xFF
D362  69E3     SETF a, BANKED
D364  69E2     SETF divisor, BANKED
D366  ECE7     CALL 0x7BCE, 0
D368  F03D     NOP
208:               SetStatus(&DWD[5], tDEC | tKROPKA1 | tRDID | _DCO, tALL);
D36A  0E92     MOVLW 0x92
D36C  0100     MOVLB 0x0
D36E  6FDE     MOVWF __pcstackBANK0, BANKED
D370  0E01     MOVLW 0x1
D372  6FDF     MOVWF pco, BANKED
D374  0E44     MOVLW 0x44
D376  6FE1     MOVWF GIE_BIT_VAL, BANKED
D378  0E12     MOVLW 0x12
D37A  6FE0     MOVWF bdat, BANKED
D37C  0EFF     MOVLW 0xFF
D37E  69E3     SETF a, BANKED
D380  69E2     SETF divisor, BANKED
D382  ECE7     CALL 0x7BCE, 0
D384  F03D     NOP
209:               RestartKol(_WS_NCWCO);
D386  0E02     MOVLW 0x2
D388  ECC2     CALL 0xED84, 0
D38A  F076     NOP
210:           }
D38C  0012     RETURN 0
211:           //usuwa wskaz nastawy CW/CO
212:           
213:           void EndNst(void)
214:           {
215:               ResetKol(_WS_NCWCO);
F3F4  0E02     MOVLW 0x2
F3F6  ECD6     CALL 0xEDAC, 0
F3F8  F076     NOP
216:           }
F3FA  0012     RETURN 0
217:           //---------------------------------------------------------
218:           //---------------------------------------------------------
219:           
220:           void SetL3(void)
221:           {
222:               PFNf_fL3 = 1;
F424  820E     BSF PFNf_lato, 1, ACCESS
223:           }
F426  0012     RETURN 0
224:           //---------------------------------------------------------
225:           //---------------------------------------------------------
226:           //wyswietla kod L3 naprzemiennie z temperatura CO
227:           
228:           void PrintL3(void)
229:           {
230:               SetData(&DWD[6], led_L, led_3);
C0BA  0E96     MOVLW 0x96
C0BC  0100     MOVLB 0x0
C0BE  6FDE     MOVWF __pcstackBANK0, BANKED
C0C0  0E01     MOVLW 0x1
C0C2  6FDF     MOVWF pco, BANKED
C0C4  0ED6     MOVLW 0xD6
C0C6  6FE0     MOVWF bdat, BANKED
C0C8  0E31     MOVLW 0x31
C0CA  6FE1     MOVWF GIE_BIT_VAL, BANKED
C0CC  EC22     CALL 0xEE44, 0
C0CE  F077     NOP
231:               SetStatus(&DWD[6], tLED | tFOCUS, tALL); //L
C0D0  0E96     MOVLW 0x96
C0D2  0100     MOVLB 0x0
C0D4  6FDE     MOVWF __pcstackBANK0, BANKED
C0D6  0E01     MOVLW 0x1
C0D8  6FDF     MOVWF pco, BANKED
C0DA  0E80     MOVLW 0x80
C0DC  6FE1     MOVWF GIE_BIT_VAL, BANKED
C0DE  6BE0     CLRF bdat, BANKED
C0E0  0EFF     MOVLW 0xFF
C0E2  69E3     SETF a, BANKED
C0E4  69E2     SETF divisor, BANKED
C0E6  ECE7     CALL 0x7BCE, 0
C0E8  F03D     NOP
232:               if(DtCOf_err_CO)
C0EA  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
C0EC  D019     BRA 0xC120
233:               {
234:                   SetData(&DWD[7], led_L, led_3);
C0EE  0E9A     MOVLW 0x9A
C0F0  0100     MOVLB 0x0
C0F2  6FDE     MOVWF __pcstackBANK0, BANKED
C0F4  0E01     MOVLW 0x1
C0F6  6FDF     MOVWF pco, BANKED
C0F8  0ED6     MOVLW 0xD6
C0FA  6FE0     MOVWF bdat, BANKED
C0FC  0E31     MOVLW 0x31
C0FE  6FE1     MOVWF GIE_BIT_VAL, BANKED
C100  EC22     CALL 0xEE44, 0
C102  F077     NOP
235:                   SetStatus(&DWD[7], tLED | tFOCUS, tALL); //3
C104  0E9A     MOVLW 0x9A
C106  0100     MOVLB 0x0
C108  6FDE     MOVWF __pcstackBANK0, BANKED
C10A  0E01     MOVLW 0x1
C10C  6FDF     MOVWF pco, BANKED
C10E  0E80     MOVLW 0x80
C110  6FE1     MOVWF GIE_BIT_VAL, BANKED
C112  6BE0     CLRF bdat, BANKED
C114  0EFF     MOVLW 0xFF
C116  69E3     SETF a, BANKED
C118  69E2     SETF divisor, BANKED
C11A  ECE7     CALL 0x7BCE, 0
C11C  F03D     NOP
236:               }
C11E  D018     BRA 0xC150
237:               else
238:               {
239:                   SetData(&DWD[7], 0, DtCO.SCO);
C120  0E9A     MOVLW 0x9A
C122  0100     MOVLB 0x0
C124  6FDE     MOVWF __pcstackBANK0, BANKED
C126  0E01     MOVLW 0x1
C128  6FDF     MOVWF pco, BANKED
C12A  6BE0     CLRF bdat, BANKED
C12C  C0D8     MOVFF 0xD8, GIE_BIT_VAL
C12E  F0E1     NOP
C130  EC22     CALL 0xEE44, 0
C132  F077     NOP
240:                   SetStatus(&DWD[7], tDEC | tFOCUS, tALL); //3
C134  0E9A     MOVLW 0x9A
C136  0100     MOVLB 0x0
C138  6FDE     MOVWF __pcstackBANK0, BANKED
C13A  0E01     MOVLW 0x1
C13C  6FDF     MOVWF pco, BANKED
C13E  0EC0     MOVLW 0xC0
C140  6FE1     MOVWF GIE_BIT_VAL, BANKED
C142  6BE0     CLRF bdat, BANKED
C144  0EFF     MOVLW 0xFF
C146  69E3     SETF a, BANKED
C148  69E2     SETF divisor, BANKED
C14A  ECE7     CALL 0x7BCE, 0
C14C  F03D     NOP
C14E  D000     BRA 0xC150
241:               }
242:               SetPoz(_WS_MSG, 0);
C150  0100     MOVLB 0x0
C152  6BDE     CLRF __pcstackBANK0, BANKED
C154  0E03     MOVLW 0x3
C156  ECAC     CALL 0xC958, 0
C158  F064     NOP
243:               SetPoz(_WS_MSG, 1);
C15A  0E01     MOVLW 0x1
C15C  0100     MOVLB 0x0
C15E  6FDE     MOVWF __pcstackBANK0, BANKED
C160  0E03     MOVLW 0x3
C162  ECAC     CALL 0xC958, 0
C164  F064     NOP
244:           }
C166  0012     RETURN 0
245:           //----------
246:           //usuwa wskaz komunikatu
247:           
248:           void EndL3(void)
249:           {
250:               PFNf_fL3 = 0;
F3C2  920E     BCF PFNf_lato, 1, ACCESS
251:               ResetKol(_WS_MSG);
F3C4  0E03     MOVLW 0x3
F3C6  ECD6     CALL 0xEDAC, 0
F3C8  F076     NOP
252:           }
F3CA  0012     RETURN 0
253:           //---------------------------------------------------------
254:           //---------------------------------------------------------
255:           //wyswietla temperature dyzurna dla CO (do zastosowania przy realizacji funkcji temp. dyzurnej)
256:           
257:           /*void PrintTdzCO(const unsigned char tm)
258:           {
259:                   SetStatus(&PWD[_WS_TDCO],tDEC|tFOCUS,tALL);
260:                   SetData(&PWD[_WS_TDCO],0,tm);
261:           }
262:           //usuwa wskaz TdzCO
263:           void EndTdzCO(void)
264:           {
265:                   SetStatus(&PWD[_WS_TDCO],tDEC,tALL);
266:           }*/
267:           void PrintAL(void)
268:           {
269:               SetStatus(&PWD[_WS_TDCO], tLED | tFOCUS, tALL);
E9A0  0E54     MOVLW 0x54
E9A2  0100     MOVLB 0x0
E9A4  6FDE     MOVWF __pcstackBANK0, BANKED
E9A6  0E02     MOVLW 0x2
E9A8  6FDF     MOVWF pco, BANKED
E9AA  0E80     MOVLW 0x80
E9AC  6FE1     MOVWF GIE_BIT_VAL, BANKED
E9AE  6BE0     CLRF bdat, BANKED
E9B0  0EFF     MOVLW 0xFF
E9B2  69E3     SETF a, BANKED
E9B4  69E2     SETF divisor, BANKED
E9B6  ECE7     CALL 0x7BCE, 0
E9B8  F03D     NOP
270:               SetData(&PWD[_WS_TDCO], led_A, led_L);
E9BA  0E54     MOVLW 0x54
E9BC  0100     MOVLB 0x0
E9BE  6FDE     MOVWF __pcstackBANK0, BANKED
E9C0  0E02     MOVLW 0x2
E9C2  6FDF     MOVWF pco, BANKED
E9C4  0E18     MOVLW 0x18
E9C6  6FE0     MOVWF bdat, BANKED
E9C8  0ED6     MOVLW 0xD6
E9CA  6FE1     MOVWF GIE_BIT_VAL, BANKED
E9CC  EC22     CALL 0xEE44, 0
E9CE  F077     NOP
271:           }
E9D0  0012     RETURN 0
272:           //usuwa wskaz AL
273:           void EndAL(void)
274:           {
275:               SetStatus(&PWD[_WS_TDCO], tLED, tALL);
F0AC  0E54     MOVLW 0x54
F0AE  0100     MOVLB 0x0
F0B0  6FDE     MOVWF __pcstackBANK0, BANKED
F0B2  0E02     MOVLW 0x2
F0B4  6FDF     MOVWF pco, BANKED
F0B6  6BE1     CLRF GIE_BIT_VAL, BANKED
F0B8  6BE0     CLRF bdat, BANKED
F0BA  0EFF     MOVLW 0xFF
F0BC  69E3     SETF a, BANKED
F0BE  69E2     SETF divisor, BANKED
F0C0  ECE7     CALL 0x7BCE, 0
F0C2  F03D     NOP
276:           }
F0C4  0012     RETURN 0
277:           void PrintALTm(const unsigned char tm, const unsigned char pls)
278:           {
279:               SetData(&DWD[6], led_A, led_L);
280:               SetData(&DWD[7], 0, tm);
281:               SetStatus(&DWD[6], tLED | tSDID | _DKM, tALL); //kod bledu/temperatura
282:               if(pls) SetStatus(&DWD[7], tKROPKA0 | tDEC | tRDID | _DKM, tALL); //temperatura
283:               else SetStatus(&DWD[7], tKROPKA0 | tDEC | tSDID | _DKM, tALL);
284:               SetPoz(_WS_MSG, 0);
285:               SetPoz(_WS_MSG, 1);
286:           }
287:           void EndALTm(void)
288:           {
289:               ResetKol(_WS_MSG);
290:           }
291:           //---------------------------------------------------------
292:           //---------------------------------------------------------
293:           //wyswietla temperature dyzurna dla CO (do zastosowania przy realizacji funkcji temp. dyzurnej)
294:           
295:           /*void PrintTdzCW(const unsigned char tm)
296:           {
297:                   SetStatus(&PWD[_WS_TDCW],tDEC|tFOCUS,tALL);
298:                   SetData(&PWD[_WS_TDCW],0,tm);
299:           }
300:           //usuwa wskaz TdzCO
301:           void EndTdzCW(void)
302:           {
303:                   SetStatus(&PWD[_WS_TDCW],tDEC,tALL);
304:           }*/
305:           void PrintSR(void)
306:           {
307:               SetStatus(&PWD[_WS_TDCW], tLED | tFOCUS, tALL);
E5BE  0E58     MOVLW 0x58
E5C0  0100     MOVLB 0x0
E5C2  6FDE     MOVWF __pcstackBANK0, BANKED
E5C4  0E02     MOVLW 0x2
E5C6  6FDF     MOVWF pco, BANKED
E5C8  0E80     MOVLW 0x80
E5CA  6FE1     MOVWF GIE_BIT_VAL, BANKED
E5CC  6BE0     CLRF bdat, BANKED
E5CE  0EFF     MOVLW 0xFF
E5D0  69E3     SETF a, BANKED
E5D2  69E2     SETF divisor, BANKED
E5D4  ECE7     CALL 0x7BCE, 0
E5D6  F03D     NOP
308:               SetData(&PWD[_WS_TDCW], Znak[5], led_r);
E5D8  0E58     MOVLW 0x58
E5DA  0100     MOVLB 0x0
E5DC  6FDE     MOVWF __pcstackBANK0, BANKED
E5DE  0E02     MOVLW 0x2
E5E0  6FDF     MOVWF pco, BANKED
E5E2  0E3A     MOVLW 0x3A
E5E4  6EF6     MOVWF TBLPTR, ACCESS
E5E6  0E10     MOVLW 0x10
E5E8  6EF7     MOVWF TBLPTRH, ACCESS
E5EA  0008     TBLRD*
E5EC  CFF5     MOVFF TABLAT, bdat
E5EE  F0E0     NOP
E5F0  0EBE     MOVLW 0xBE
E5F2  6FE1     MOVWF GIE_BIT_VAL, BANKED
E5F4  EC22     CALL 0xEE44, 0
E5F6  F077     NOP
309:           }
E5F8  0012     RETURN 0
310:           //usuwa wskaz TdzCO
311:           
312:           void EndSR(void)
313:           {
314:               SetStatus(&PWD[_WS_TDCW], tLED, tALL);
F092  0E58     MOVLW 0x58
F094  0100     MOVLB 0x0
F096  6FDE     MOVWF __pcstackBANK0, BANKED
F098  0E02     MOVLW 0x2
F09A  6FDF     MOVWF pco, BANKED
F09C  6BE1     CLRF GIE_BIT_VAL, BANKED
F09E  6BE0     CLRF bdat, BANKED
F0A0  0EFF     MOVLW 0xFF
F0A2  69E3     SETF a, BANKED
F0A4  69E2     SETF divisor, BANKED
F0A6  ECE7     CALL 0x7BCE, 0
F0A8  F03D     NOP
315:           }
F0AA  0012     RETURN 0
316:           void PrintSRTm(const unsigned char tm, const unsigned char pls)
317:           {
318:               SetData(&DWD[6], Znak[5], led_r);
319:               SetData(&DWD[7], 0, tm);
320:               SetStatus(&DWD[6], tLED | tSDID | _DKM, tALL); //kod bledu/temperatura
321:               if(pls) SetStatus(&DWD[7], tDEC | tRDID | _DKM, tALL); //temperatura
322:               else SetStatus(&DWD[7], tDEC | tSDID | _DKM, tALL);
323:               SetPoz(_WS_MSG, 0);
324:               SetPoz(_WS_MSG, 1);
325:           }
326:           void EndSRTm(void)
327:           {
328:               ResetKol(_WS_MSG);
329:           }
330:           //---------------------------------------------------------
331:           //---------------------------------------------------------
332:           //wyswietla dwie kreski na wyswietlaczu
333:           
334:           void PrintOFF(void)
335:           {
336:               SetStatus(&PWD[_WS_OFF], tLED1 | tLED0 | tFOCUS, tALL);
E96E  0E5C     MOVLW 0x5C
E970  0100     MOVLB 0x0
E972  6FDE     MOVWF __pcstackBANK0, BANKED
E974  0E02     MOVLW 0x2
E976  6FDF     MOVWF pco, BANKED
E978  0E80     MOVLW 0x80
E97A  6FE1     MOVWF GIE_BIT_VAL, BANKED
E97C  0EC0     MOVLW 0xC0
E97E  6FE0     MOVWF bdat, BANKED
E980  0EFF     MOVLW 0xFF
E982  69E3     SETF a, BANKED
E984  69E2     SETF divisor, BANKED
E986  ECE7     CALL 0x7BCE, 0
E988  F03D     NOP
337:               SetData(&PWD[_WS_OFF], KRESKA, KRESKA);
E98A  0E5C     MOVLW 0x5C
E98C  0100     MOVLB 0x0
E98E  6FDE     MOVWF __pcstackBANK0, BANKED
E990  0E02     MOVLW 0x2
E992  6FDF     MOVWF pco, BANKED
E994  0EBF     MOVLW 0xBF
E996  6FE0     MOVWF bdat, BANKED
E998  6FE1     MOVWF GIE_BIT_VAL, BANKED
E99A  EC22     CALL 0xEE44, 0
E99C  F077     NOP
338:           }
E99E  0012     RETURN 0
339:           //usuwa dwie kreski z wyswietlacza
340:           
341:           void EndOFF(void)
342:           {
343:               SetStatus(&PWD[_WS_OFF], tLED1 | tLED0, tALL);
F008  0E5C     MOVLW 0x5C
F00A  0100     MOVLB 0x0
F00C  6FDE     MOVWF __pcstackBANK0, BANKED
F00E  0E02     MOVLW 0x2
F010  6FDF     MOVWF pco, BANKED
F012  6BE1     CLRF GIE_BIT_VAL, BANKED
F014  0EC0     MOVLW 0xC0
F016  6FE0     MOVWF bdat, BANKED
F018  0EFF     MOVLW 0xFF
F01A  69E3     SETF a, BANKED
F01C  69E2     SETF divisor, BANKED
F01E  ECE7     CALL 0x7BCE, 0
F020  F03D     NOP
344:           }
F022  0012     RETURN 0
345:           //---------------------------------------------------------
346:           //---------------------------------------------------------
347:           //wyswietla cisnienie CS
348:           
349:           void PrintCS(const unsigned char cs)
E906  0100     MOVLB 0x0
E908  6FE6     MOVWF counter, BANKED
350:           {
351:               SetStatus(&PWD[_WS_CS], tDEC | tKROPKA1 | tFOCUS, tALL); //cisnienie
E90A  0E60     MOVLW 0x60
E90C  0100     MOVLB 0x0
E90E  6FDE     MOVWF __pcstackBANK0, BANKED
E910  0E02     MOVLW 0x2
E912  6FDF     MOVWF pco, BANKED
E914  0EC4     MOVLW 0xC4
E916  6FE1     MOVWF GIE_BIT_VAL, BANKED
E918  6BE0     CLRF bdat, BANKED
E91A  0EFF     MOVLW 0xFF
E91C  69E3     SETF a, BANKED
E91E  69E2     SETF divisor, BANKED
E920  ECE7     CALL 0x7BCE, 0
E922  F03D     NOP
352:               SetData(&PWD[_WS_CS], 0, cs);
E924  0E60     MOVLW 0x60
E926  0100     MOVLB 0x0
E928  6FDE     MOVWF __pcstackBANK0, BANKED
E92A  0E02     MOVLW 0x2
E92C  6FDF     MOVWF pco, BANKED
E92E  6BE0     CLRF bdat, BANKED
E930  C0E6     MOVFF counter, GIE_BIT_VAL
E932  F0E1     NOP
E934  EC22     CALL 0xEE44, 0
E936  F077     NOP
353:           }
E938  0012     RETURN 0
354:           //usuwa wskaz CS
355:           
356:           void EndCS(void)
357:           {
358:               SetStatus(&PWD[_WS_CS], tDEC | tKROPKA1, tALL);
F040  0E60     MOVLW 0x60
F042  0100     MOVLB 0x0
F044  6FDE     MOVWF __pcstackBANK0, BANKED
F046  0E02     MOVLW 0x2
F048  6FDF     MOVWF pco, BANKED
F04A  0E44     MOVLW 0x44
F04C  6FE1     MOVWF GIE_BIT_VAL, BANKED
F04E  6BE0     CLRF bdat, BANKED
F050  0EFF     MOVLW 0xFF
F052  69E3     SETF a, BANKED
F054  69E2     SETF divisor, BANKED
F056  ECE7     CALL 0x7BCE, 0
F058  F03D     NOP
359:           }
F05A  0012     RETURN 0
360:           //---------------------------------------------------------
361:           //---------------------------------------------------------
362:           //wyswietla temperature CW gdy aktywne grznie w obiegu CW
363:           //ustawia diode grzania CW w stan aktywny
364:           
365:           void PrintCW(const unsigned char tm)
E8D2  0100     MOVLB 0x0
E8D4  6FE6     MOVWF counter, BANKED
366:           {
367:               SetStatus(&PWD[_WS_TCW], tDEC | tKROPKA0 | tFOCUS, tALL);
E8D6  0E64     MOVLW 0x64
E8D8  0100     MOVLB 0x0
E8DA  6FDE     MOVWF __pcstackBANK0, BANKED
E8DC  0E02     MOVLW 0x2
E8DE  6FDF     MOVWF pco, BANKED
E8E0  0EC8     MOVLW 0xC8
E8E2  6FE1     MOVWF GIE_BIT_VAL, BANKED
E8E4  6BE0     CLRF bdat, BANKED
E8E6  0EFF     MOVLW 0xFF
E8E8  69E3     SETF a, BANKED
E8EA  69E2     SETF divisor, BANKED
E8EC  ECE7     CALL 0x7BCE, 0
E8EE  F03D     NOP
368:               SetData(&PWD[_WS_TCW], 0, tm); //tempetratura CW
E8F0  0E64     MOVLW 0x64
E8F2  0100     MOVLB 0x0
E8F4  6FDE     MOVWF __pcstackBANK0, BANKED
E8F6  0E02     MOVLW 0x2
E8F8  6FDF     MOVWF pco, BANKED
E8FA  6BE0     CLRF bdat, BANKED
E8FC  C0E6     MOVFF counter, GIE_BIT_VAL
E8FE  F0E1     NOP
E900  EC22     CALL 0xEE44, 0
E902  F077     NOP
369:           }
E904  0012     RETURN 0
370:           //usuwa wskaz CW
371:           
372:           void EndCW(void)
373:           {
374:               SetStatus(&PWD[_WS_TCW], tDEC, tALL);
F024  0E64     MOVLW 0x64
F026  0100     MOVLB 0x0
F028  6FDE     MOVWF __pcstackBANK0, BANKED
F02A  0E02     MOVLW 0x2
F02C  6FDF     MOVWF pco, BANKED
F02E  0E40     MOVLW 0x40
F030  6FE1     MOVWF GIE_BIT_VAL, BANKED
F032  6BE0     CLRF bdat, BANKED
F034  0EFF     MOVLW 0xFF
F036  69E3     SETF a, BANKED
F038  69E2     SETF divisor, BANKED
F03A  ECE7     CALL 0x7BCE, 0
F03C  F03D     NOP
375:           }
F03E  0012     RETURN 0
376:           //---------------------------------------------------------
377:           //---------------------------------------------------------
378:           //Wskazy o najnizszym priorytecie wyswietlania
379:           //wyswietla temperature CO
380:           
381:           void PrintCO(const unsigned char tm)
E93A  0100     MOVLB 0x0
E93C  6FE6     MOVWF counter, BANKED
382:           {
383:               SetStatus(&PWD[_WS_TCO], tDEC, tALL);
E93E  0E68     MOVLW 0x68
E940  0100     MOVLB 0x0
E942  6FDE     MOVWF __pcstackBANK0, BANKED
E944  0E02     MOVLW 0x2
E946  6FDF     MOVWF pco, BANKED
E948  0E40     MOVLW 0x40
E94A  6FE1     MOVWF GIE_BIT_VAL, BANKED
E94C  6BE0     CLRF bdat, BANKED
E94E  0EFF     MOVLW 0xFF
E950  69E3     SETF a, BANKED
E952  69E2     SETF divisor, BANKED
E954  ECE7     CALL 0x7BCE, 0
E956  F03D     NOP
384:               SetData(&PWD[_WS_TCO], 0, tm); //tempetratura CO
E958  0E68     MOVLW 0x68
E95A  0100     MOVLB 0x0
E95C  6FDE     MOVWF __pcstackBANK0, BANKED
E95E  0E02     MOVLW 0x2
E960  6FDF     MOVWF pco, BANKED
E962  6BE0     CLRF bdat, BANKED
E964  C0E6     MOVFF counter, GIE_BIT_VAL
E966  F0E1     NOP
E968  EC22     CALL 0xEE44, 0
E96A  F077     NOP
385:           }
E96C  0012     RETURN 0
386:           //---------------------------------------------------------
387:           //---------------------------------------------------------
388:           //Funkcja na potrzeby testow oprogramowania
389:           
390:           void PrintHex(const unsigned char tm)
391:           {
392:               SetStatus(&PWD[_WS_TCO], tHEX, tALL);
393:               SetData(&PWD[_WS_TCO], 0, tm); //tempetratura CO
394:           }
395:           //---------------------------------------------------------
396:           //---------------------------------------------------------
397:           //Wysterowanie wszystkich elementow swietlnych wyswietlacza
398:           void SetDiode(unsigned char nrd, unsigned char stn);
399:           
400:           void TestScr(void)
401:           {
402:               SetStatus(&PWD[_WS_TCO], tLED | tKROPKA1 | tKROPKA0, tALL);
E5FA  0E68     MOVLW 0x68
E5FC  0100     MOVLB 0x0
E5FE  6FDE     MOVWF __pcstackBANK0, BANKED
E600  0E02     MOVLW 0x2
E602  6FDF     MOVWF pco, BANKED
E604  0E0C     MOVLW 0xC
E606  6FE1     MOVWF GIE_BIT_VAL, BANKED
E608  6BE0     CLRF bdat, BANKED
E60A  0EFF     MOVLW 0xFF
E60C  69E3     SETF a, BANKED
E60E  69E2     SETF divisor, BANKED
E610  ECE7     CALL 0x7BCE, 0
E612  F03D     NOP
403:               SetData(&PWD[_WS_TCO], FULL, FULL);
E614  0E68     MOVLW 0x68
E616  0100     MOVLB 0x0
E618  6FDE     MOVWF __pcstackBANK0, BANKED
E61A  0E02     MOVLW 0x2
E61C  6FDF     MOVWF pco, BANKED
E61E  6BE0     CLRF bdat, BANKED
E620  6BE1     CLRF GIE_BIT_VAL, BANKED
E622  EC22     CALL 0xEE44, 0
E624  F077     NOP
404:           #if SER_WSW!=0
405:               SetDiode(_DCO | _DCW | _DPL | _DKM, 1);
E626  0E01     MOVLW 0x1
E628  0100     MOVLB 0x0
E62A  6FDF     MOVWF pco, BANKED
E62C  0E0F     MOVLW 0xF
E62E  EC3C     CALL 0xF078, 0
E630  F078     NOP
406:           #endif
407:           }
E632  0012     RETURN 0
408:           
409:           void EndTestScr(void)
410:           {
411:               SetStatus(&PWD[_WS_TCO], tDEC, tALL);
E6A8  0E68     MOVLW 0x68
E6AA  0100     MOVLB 0x0
E6AC  6FDE     MOVWF __pcstackBANK0, BANKED
E6AE  0E02     MOVLW 0x2
E6B0  6FDF     MOVWF pco, BANKED
E6B2  0E40     MOVLW 0x40
E6B4  6FE1     MOVWF GIE_BIT_VAL, BANKED
E6B6  6BE0     CLRF bdat, BANKED
E6B8  0EFF     MOVLW 0xFF
E6BA  69E3     SETF a, BANKED
E6BC  69E2     SETF divisor, BANKED
E6BE  ECE7     CALL 0x7BCE, 0
E6C0  F03D     NOP
412:               SetData(&PWD[_WS_TCO], 0, 0);
E6C2  0E68     MOVLW 0x68
E6C4  0100     MOVLB 0x0
E6C6  6FDE     MOVWF __pcstackBANK0, BANKED
E6C8  0E02     MOVLW 0x2
E6CA  6FDF     MOVWF pco, BANKED
E6CC  6BE0     CLRF bdat, BANKED
E6CE  6BE1     CLRF GIE_BIT_VAL, BANKED
E6D0  EC22     CALL 0xEE44, 0
E6D2  F077     NOP
413:           #if SER_WSW!=0
414:               SetDiode(_DCO | _DCW | _DPL | _DKM, 0);
E6D4  0E00     MOVLW 0x0
E6D6  0100     MOVLB 0x0
E6D8  6FDF     MOVWF pco, BANKED
E6DA  0E0F     MOVLW 0xF
E6DC  EC3C     CALL 0xF078, 0
E6DE  F078     NOP
415:           #endif
416:           }
E6E0  0012     RETURN 0
417:           //---------------------------------------------------------
418:           //---------------------------------------------------------
419:           #if SER_WSW!=0
420:           //Zapala/gasi wybrane diody z 4 umieszczonych na module wyswietlacza
421:           //wd-slowo 4 bitowe gdzie wartosc 1 oznacza wybor konkretnej diody
422:           //stn-stan jaki maja przyjac wybrane diody (1-zapalona, 0-wygaszona)
423:           
424:           void SetDiode(unsigned char wd, unsigned char stn)
F078  0100     MOVLB 0x0
F07A  6FE0     MOVWF bdat, BANKED
425:           {
426:               if(stn) Swsdid(wd);
F07C  0100     MOVLB 0x0
F07E  51DF     MOVF pco, W, BANKED
F080  E003     BZ 0xF088
F082  51E0     MOVF bdat, W, BANKED
F084  EF31     GOTO 0xF262
F086  F079     NOP
427:               else Rwsdid(wd);
F088  0100     MOVLB 0x0
F08A  51E0     MOVF bdat, W, BANKED
F08C  EF3A     GOTO 0xF274
F08E  F079     NOP
428:           }
F090  0012     RETURN 0
429:           #endif
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/port.c  ----------------------------------
1:             /*port.c*/
2:             //Konfiguracja portow fizycznych mikrokontrolera
3:             //Stabilizacja stanow wejsciowych
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"			//parametry globalne
7:             #include "port.h"			//parametry lokalne
8:             #include "pomiar.h"		//typy danych pomiar.c
9:             //pomiar.c
10:            extern DataCO DtCO;
11:            extern DataCW DtCW;
12:            extern DataCSN DtCS;
13:            extern DataZW DtZW;
14:            /*---------------------------------------------------------------------------------*/
15:            /*-----------------------------PUBLIC DATA-----------------------------------------*/
16:            // Podaj liczbe portow fizycznych oraz wirtualnych ktore maja byc poddane procesowi 
17:            // filtracji czasowej.
18:            
19:            #define	_NVPORT	26		/*liczba obslugiwanych portow/sygnalow*/
20:            
21:            /*---------------------------------------------------------------------------------*/
22:            // Podaj przypadajace na kazdy port dwie WARTOSCI OPOZNIENIA dla zmian stanu  
23:            // lo/hi oraz hi/lo (wartosci z zakresu [0..0x3F] co daje maks. czas =[3F*0.05 sek.]/[10/_TKRPR])
24:            
25:            #if (_NVPORT!=0)
26:            static const Opoznienie Nastawa[_NVPORT] = {
27:                1, 1, //port nr 0 czas lo/hi oraz hi\lo
28:                20, 20, //port nr 1 czas lo/hi oraz hi\lo
29:                2, 4, //port nr 2 czas lo/hi oraz hi\lo
30:                2, 2, //port nr 3 czas lo/hi oraz hi\lo
31:                2, 2, //port nr 4 czas lo/hi oraz hi\lo
32:                4, 8, //port nr 5 czas lo/hi oraz hi\lo
33:                2, 2, //port nr 6 czas lo/hi oraz hi\lo
34:                2, 2, //port nr 7 czas lo/hi oraz hi\lo
35:                2, 2, //port nr 8 czas lo/hi oraz hi\lo
36:                20, 1, //port nr 9 czas lo/hi oraz hi\lo
37:                20, 1, //port nr 10 czas lo/hi oraz hi\lo
38:                2, 2, //port nr 11 czas lo/hi oraz hi\lo
39:                20, 20, //port nr 12 czas lo/hi oraz hi\lo
40:                20, 20, //port nr 13 czas lo/hi oraz hi\lo
41:                5, 5, //port nr 14 czas lo/hi oraz hi\lo
42:                5, 20, //port nr 15 czas lo/hi oraz hi\lo
43:                10, 10, //port nr 16 czas lo/hi oraz hi\lo
44:                20, 20, //port nr 17 czas lo/hi oraz hi\lo
45:                5, 5, //port nr 18 czas lo/hi oraz hi\lo
46:                8, 8, //port nr 19 czas lo/hi oraz hi\lo
47:                20, 20, //port nr 20 czas lo/hi oraz hi\lo
48:                2, 10, //port nr 21 czas lo/hi oraz hi\lo
49:                1, 1, //port nr 22 czas lo/hi oraz hi\lo
50:                1, 1, //port nr 23 czas lo/hi oraz hi\lo
51:                0, 0, //port nr 24 czas lo/hi oraz hi\lo
52:                0, 0 //port nr 25 czas lo/hi oraz hi\lo
53:            };
54:            /*---------------------------------------------------------------------------------*/
55:            static volatile IOPort SPort[_NVPORT]; //protected volatile
56:            
57:            /*---------------------------------------------------------------------------------*/
58:            //Port fizyczny nalezy przypisac polu SPort[n].Input gdzie 0<=n<_NVPORT.
59:            
60:            void RefStan(void)
61:            {
62:                //port 0
63:                SPort[0].Input = 0; //_KEY port/sygnal poddany filtracji
96CC  0101     MOVLB 0x1
96CE  9100     BCF tm, 0, BANKED
9C6E  0101     MOVLB 0x1
64:                //port 1
65:                SPort[1].Input = (_PRZ_CO) ? 1 : 0; //port/sygnal poddany filtracji
96D0  AA81     BTFSS PORTB, 5, ACCESS
96D2  D002     BRA 0x96D8
96D4  8101     BSF DtCOf_err_CO, 0, BANKED
96D6  D002     BRA 0x96DC
96D8  0101     MOVLB 0x1
96DA  9101     BCF DtCOf_err_CO, 0, BANKED
9C72  AA81     BTFSS PORTB, 5, ACCESS
9C74  D002     BRA 0x9C7A
9C76  8101     BSF DtCOf_err_CO, 0, BANKED
9C78  D002     BRA 0x9C7E
9C7A  0101     MOVLB 0x1
9C7C  9101     BCF DtCOf_err_CO, 0, BANKED
66:                //port 2
67:                SPort[2].Input = (_CIG_NC && _STB) ? 1 : 0; //port/sygnal poddany filtracji
96DC  0100     MOVLB 0x0
96DE  6BDF     CLRF pco, BANKED
96E0  B082     BTFSC PORTC, 0, ACCESS
96E2  AE80     BTFSS PORTA, 7, ACCESS
96E4  D004     BRA 0x96EE
96E6  0E01     MOVLW 0x1
96E8  0100     MOVLB 0x0
96EA  6FDF     MOVWF pco, BANKED
96EC  D000     BRA 0x96EE
96EE  0100     MOVLB 0x0
96F0  B1DF     BTFSC pco, 0, BANKED
96F2  D003     BRA 0x96FA
96F4  0101     MOVLB 0x1
96F6  9102     BCF DtCOf_su_CO, 0, BANKED
96F8  D002     BRA 0x96FE
96FA  0101     MOVLB 0x1
96FC  8102     BSF DtCOf_su_CO, 0, BANKED
9C7E  6A17     CLRF _DtCOf_su_CO, ACCESS
9C80  B082     BTFSC PORTC, 0, ACCESS
9C82  AE80     BTFSS PORTA, 7, ACCESS
9C84  D003     BRA 0x9C8C
9C86  0E01     MOVLW 0x1
9C88  6E17     MOVWF _DtCOf_su_CO, ACCESS
9C8A  D000     BRA 0x9C8C
9C8C  B017     BTFSC _DtCOf_su_CO, 0, ACCESS
9C8E  D003     BRA 0x9C96
9C90  0101     MOVLB 0x1
9C92  9102     BCF DtCOf_su_CO, 0, BANKED
9C94  D002     BRA 0x9C9A
9C96  0101     MOVLB 0x1
9C98  8102     BSF DtCOf_su_CO, 0, BANKED
68:                //port 3
69:                SPort[3].Input = (_CIG_NO && _STB) ? 1 : 0; //port/sygnal poddany filtracji
96FE  0100     MOVLB 0x0
9700  6BE0     CLRF bdat, BANKED
9702  BC80     BTFSC PORTA, 6, ACCESS
9704  AE80     BTFSS PORTA, 7, ACCESS
9706  D004     BRA 0x9710
9708  0E01     MOVLW 0x1
970A  0100     MOVLB 0x0
970C  6FE0     MOVWF bdat, BANKED
970E  D000     BRA 0x9710
9710  0100     MOVLB 0x0
9712  B1E0     BTFSC bdat, 0, BANKED
9714  D003     BRA 0x971C
9716  0101     MOVLB 0x1
9718  9103     BCF DtCOf_su_SRW_CO, 0, BANKED
971A  D002     BRA 0x9720
971C  0101     MOVLB 0x1
971E  8103     BSF DtCOf_su_SRW_CO, 0, BANKED
9C9A  6A18     CLRF _DtCOf_su_DZ_CO, ACCESS
9C9C  BC80     BTFSC PORTA, 6, ACCESS
9C9E  AE80     BTFSS PORTA, 7, ACCESS
9CA0  D003     BRA 0x9CA8
9CA2  0E01     MOVLW 0x1
9CA4  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
9CA6  D000     BRA 0x9CA8
9CA8  B018     BTFSC _DtCOf_su_DZ_CO, 0, ACCESS
9CAA  D003     BRA 0x9CB2
9CAC  0101     MOVLB 0x1
9CAE  9103     BCF DtCOf_su_SRW_CO, 0, BANKED
9CB0  D002     BRA 0x9CB6
9CB2  0101     MOVLB 0x1
9CB4  8103     BSF DtCOf_su_SRW_CO, 0, BANKED
70:                //port 4
71:                SPort[4].Input = (_STB) ? 1 : 0; //port/sygnal poddany filtracji
9720  AE80     BTFSS PORTA, 7, ACCESS
9722  D003     BRA 0x972A
9724  0101     MOVLB 0x1
9726  8104     BSF DtCWf_err_CW, 0, BANKED
9728  D002     BRA 0x972E
972A  0101     MOVLB 0x1
972C  9104     BCF DtCWf_err_CW, 0, BANKED
9CB6  AE80     BTFSS PORTA, 7, ACCESS
9CB8  D003     BRA 0x9CC0
9CBA  0101     MOVLB 0x1
9CBC  8104     BSF DtCWf_err_CW, 0, BANKED
9CBE  D002     BRA 0x9CC4
9CC0  0101     MOVLB 0x1
9CC2  9104     BCF DtCWf_err_CW, 0, BANKED
72:                //port 5
73:                SPort[5].Input = (_PLOMIEN) ? 0 : 1; //port/sygnal poddany filtracji
972E  B883     BTFSC PORTD, 4, ACCESS
9730  D004     BRA 0x973A
9732  0100     MOVLB 0x0
9734  6BDE     CLRF __pcstackBANK0, BANKED
9736  2BDE     INCF __pcstackBANK0, F, BANKED
9738  D002     BRA 0x973E
973A  0100     MOVLB 0x0
973C  6BDE     CLRF __pcstackBANK0, BANKED
973E  0101     MOVLB 0x1
9740  5105     MOVF DtKNFf_enknf, W, BANKED
9742  0100     MOVLB 0x0
9744  19DE     XORWF __pcstackBANK0, W, BANKED
9746  0BFE     ANDLW 0xFE
9748  19DE     XORWF __pcstackBANK0, W, BANKED
974A  0101     MOVLB 0x1
974C  6F05     MOVWF DtKNFf_enknf, BANKED
9CC4  B883     BTFSC PORTD, 4, ACCESS
9CC6  D003     BRA 0x9CCE
9CC8  6A16     CLRF _DtCOf_resPCO, ACCESS
9CCA  2A16     INCF _DtCOf_resPCO, F, ACCESS
9CCC  D001     BRA 0x9CD0
9CCE  6A16     CLRF _DtCOf_resPCO, ACCESS
9CD0  0101     MOVLB 0x1
9CD2  5105     MOVF DtKNFf_enknf, W, BANKED
9CD4  1816     XORWF _DtCOf_resPCO, W, ACCESS
9CD6  0BFE     ANDLW 0xFE
9CD8  1816     XORWF _DtCOf_resPCO, W, ACCESS
9CDA  6F05     MOVWF DtKNFf_enknf, BANKED
74:                //port 6
75:                SPort[6].Input = 0; //port/sygnal poddany filtracji
974E  0101     MOVLB 0x1
9750  9106     BCF DtKNFf_wymCO, 0, BANKED
9CDC  0101     MOVLB 0x1
9CDE  9106     BCF DtKNFf_wymCO, 0, BANKED
76:                //port 7
77:                SPort[7].Input = 0; //port/sygnal poddany filtracji
9752  0101     MOVLB 0x1
9754  9107     BCF Mf_BLOKUJ_3M, 0, BANKED
9CE0  0101     MOVLB 0x1
9CE2  9107     BCF Mf_BLOKUJ_3M, 0, BANKED
78:                //port 8
79:                SPort[8].Input = (_MOD_ON) ? 0 : 1; //port/sygnal poddany filtracji
9756  BA82     BTFSC PORTC, 5, ACCESS
9758  D004     BRA 0x9762
975A  0100     MOVLB 0x0
975C  6BDE     CLRF __pcstackBANK0, BANKED
975E  2BDE     INCF __pcstackBANK0, F, BANKED
9760  D002     BRA 0x9766
9762  0100     MOVLB 0x0
9764  6BDE     CLRF __pcstackBANK0, BANKED
9766  0101     MOVLB 0x1
9768  5108     MOVF Mf_ROZRUCH, W, BANKED
976A  0100     MOVLB 0x0
976C  19DE     XORWF __pcstackBANK0, W, BANKED
976E  0BFE     ANDLW 0xFE
9770  19DE     XORWF __pcstackBANK0, W, BANKED
9772  0101     MOVLB 0x1
9774  6F08     MOVWF Mf_ROZRUCH, BANKED
9CE4  BA82     BTFSC PORTC, 5, ACCESS
9CE6  D003     BRA 0x9CEE
9CE8  6A16     CLRF _DtCOf_resPCO, ACCESS
9CEA  2A16     INCF _DtCOf_resPCO, F, ACCESS
9CEC  D001     BRA 0x9CF0
9CEE  6A16     CLRF _DtCOf_resPCO, ACCESS
9CF0  0101     MOVLB 0x1
9CF2  5108     MOVF Mf_ROZRUCH, W, BANKED
9CF4  1816     XORWF _DtCOf_resPCO, W, ACCESS
9CF6  0BFE     ANDLW 0xFE
9CF8  1816     XORWF _DtCOf_resPCO, W, ACCESS
9CFA  6F08     MOVWF Mf_ROZRUCH, BANKED
80:                //port 9
81:                SPort[9].Input = (DtCOf_on_DZ_CO) ? 1 : 0; //port/sygnal poddany filtracji
9776  A602     BTFSS DtCOf_su_CO, 3, ACCESS
9778  D003     BRA 0x9780
977A  0101     MOVLB 0x1
977C  8109     BSF Mf_RUSZ_PWR, 0, BANKED
977E  D002     BRA 0x9784
9780  0101     MOVLB 0x1
9782  9109     BCF Mf_RUSZ_PWR, 0, BANKED
9CFC  A602     BTFSS DtCOf_su_CO, 3, ACCESS
9CFE  D003     BRA 0x9D06
9D00  0101     MOVLB 0x1
9D02  8109     BSF Mf_RUSZ_PWR, 0, BANKED
9D04  D002     BRA 0x9D0A
9D06  0101     MOVLB 0x1
9D08  9109     BCF Mf_RUSZ_PWR, 0, BANKED
82:                //port 10
83:                SPort[10].Input = (DtCWf_on_DZ_CW) ? 1 : 0; //port/sygnal poddany filtracji
9784  AE04     BTFSS DtCWf_err_CW, 7, ACCESS
9786  D003     BRA 0x978E
9788  0101     MOVLB 0x1
978A  810A     BSF Mf_pob_AL, 0, BANKED
978C  D002     BRA 0x9792
978E  0101     MOVLB 0x1
9790  910A     BCF Mf_pob_AL, 0, BANKED
9D0A  AE04     BTFSS DtCWf_err_CW, 7, ACCESS
9D0C  D003     BRA 0x9D14
9D0E  0101     MOVLB 0x1
9D10  810A     BSF Mf_pob_AL, 0, BANKED
9D12  D002     BRA 0x9D18
9D14  0101     MOVLB 0x1
9D16  910A     BCF Mf_pob_AL, 0, BANKED
84:                //port 11
85:                SPort[11].Input = (_PRZ_CW) ? 0 : 1; //port/sygnal poddany filtracji
9792  B880     BTFSC PORTA, 4, ACCESS
9794  D004     BRA 0x979E
9796  0100     MOVLB 0x0
9798  6BDE     CLRF __pcstackBANK0, BANKED
979A  2BDE     INCF __pcstackBANK0, F, BANKED
979C  D002     BRA 0x97A2
979E  0100     MOVLB 0x0
97A0  6BDE     CLRF __pcstackBANK0, BANKED
97A2  0101     MOVLB 0x1
97A4  510B     MOVF Mf_pob_KCO, W, BANKED
97A6  0100     MOVLB 0x0
97A8  19DE     XORWF __pcstackBANK0, W, BANKED
97AA  0BFE     ANDLW 0xFE
97AC  19DE     XORWF __pcstackBANK0, W, BANKED
97AE  0101     MOVLB 0x1
97B0  6F0B     MOVWF Mf_pob_KCO, BANKED
9D18  B880     BTFSC PORTA, 4, ACCESS
9D1A  D003     BRA 0x9D22
9D1C  6A16     CLRF _DtCOf_resPCO, ACCESS
9D1E  2A16     INCF _DtCOf_resPCO, F, ACCESS
9D20  D001     BRA 0x9D24
9D22  6A16     CLRF _DtCOf_resPCO, ACCESS
9D24  0101     MOVLB 0x1
9D26  510B     MOVF Mf_pob_KCO, W, BANKED
9D28  1816     XORWF _DtCOf_resPCO, W, ACCESS
9D2A  0BFE     ANDLW 0xFE
9D2C  1816     XORWF _DtCOf_resPCO, W, ACCESS
9D2E  6F0B     MOVWF Mf_pob_KCO, BANKED
86:                //port 12
87:                SPort[12].Input = (_RT) ? 1 : 0; //port/sygnal poddany filtracji
97B2  AA83     BTFSS PORTD, 5, ACCESS
97B4  D003     BRA 0x97BC
97B6  0101     MOVLB 0x1
97B8  810C     BSF PFNf_b_set_nco, 0, BANKED
97BA  D002     BRA 0x97C0
97BC  0101     MOVLB 0x1
97BE  910C     BCF PFNf_b_set_nco, 0, BANKED
9D30  AA83     BTFSS PORTD, 5, ACCESS
9D32  D003     BRA 0x9D3A
9D34  0101     MOVLB 0x1
9D36  810C     BSF PFNf_b_set_nco, 0, BANKED
9D38  D002     BRA 0x9D3E
9D3A  0101     MOVLB 0x1
9D3C  910C     BCF PFNf_b_set_nco, 0, BANKED
88:                //port 13
89:                SPort[13].Input = (DtCOf_cold_CO || DtCOf_hot_CO) ? 1 : 0; //port/sygnal poddany filtracji
97C0  0E01     MOVLW 0x1
97C2  0100     MOVLB 0x0
97C4  6FE1     MOVWF GIE_BIT_VAL, BANKED
97C6  AC01     BTFSS DtCOf_err_CO, 6, ACCESS
97C8  B002     BTFSC DtCOf_su_CO, 0, ACCESS
97CA  D004     BRA 0x97D4
97CC  0E00     MOVLW 0x0
97CE  0100     MOVLB 0x0
97D0  6FE1     MOVWF GIE_BIT_VAL, BANKED
97D2  D000     BRA 0x97D4
97D4  0100     MOVLB 0x0
97D6  B1E1     BTFSC GIE_BIT_VAL, 0, BANKED
97D8  D003     BRA 0x97E0
97DA  0101     MOVLB 0x1
97DC  910D     BCF PFNf_b_str_nco, 0, BANKED
97DE  D002     BRA 0x97E4
97E0  0101     MOVLB 0x1
97E2  810D     BSF PFNf_b_str_nco, 0, BANKED
9D3E  0E01     MOVLW 0x1
9D40  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
9D42  AC01     BTFSS DtCOf_err_CO, 6, ACCESS
9D44  B002     BTFSC DtCOf_su_CO, 0, ACCESS
9D46  D003     BRA 0x9D4E
9D48  0E00     MOVLW 0x0
9D4A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
9D4C  D000     BRA 0x9D4E
9D4E  B019     BTFSC _DtCOf_su_SRW_CO, 0, ACCESS
9D50  D003     BRA 0x9D58
9D52  0101     MOVLB 0x1
9D54  910D     BCF PFNf_b_str_nco, 0, BANKED
9D56  D002     BRA 0x9D5C
9D58  0101     MOVLB 0x1
9D5A  810D     BSF PFNf_b_str_nco, 0, BANKED
90:                //port 14
91:                SPort[14].Input = (DtCSf_error) ? 1 : 0; //port/sygnal poddany filtracji
97E4  A603     BTFSS DtCOf_su_SRW_CO, 3, ACCESS
97E6  D003     BRA 0x97EE
97E8  0101     MOVLB 0x1
97EA  810E     BSF PFNf_lato, 0, BANKED
97EC  D002     BRA 0x97F2
97EE  0101     MOVLB 0x1
97F0  910E     BCF PFNf_lato, 0, BANKED
9D5C  A603     BTFSS DtCOf_su_SRW_CO, 3, ACCESS
9D5E  D003     BRA 0x9D66
9D60  0101     MOVLB 0x1
9D62  810E     BSF PFNf_lato, 0, BANKED
9D64  D002     BRA 0x9D6A
9D66  0101     MOVLB 0x1
9D68  910E     BCF PFNf_lato, 0, BANKED
92:                //port 15
93:                SPort[15].Input = (DtCSf_work) ? 1 : 0; //port/sygnal poddany filtracji
97F2  A004     BTFSS DtCWf_err_CW, 0, ACCESS
97F4  D003     BRA 0x97FC
97F6  0101     MOVLB 0x1
97F8  810F     BSF PFNf_off, 0, BANKED
97FA  D002     BRA 0x9800
97FC  0101     MOVLB 0x1
97FE  910F     BCF PFNf_off, 0, BANKED
9D6A  A004     BTFSS DtCWf_err_CW, 0, ACCESS
9D6C  D003     BRA 0x9D74
9D6E  0101     MOVLB 0x1
9D70  810F     BSF PFNf_off, 0, BANKED
9D72  D002     BRA 0x9D78
9D74  0101     MOVLB 0x1
9D76  910F     BCF PFNf_off, 0, BANKED
94:                //port 16
95:                SPort[16].Input = (DtCSf_lo) ? 1 : 0; //port/sygnal poddany filtracji
9800  AA03     BTFSS DtCOf_su_SRW_CO, 5, ACCESS
9802  D003     BRA 0x980A
9804  0101     MOVLB 0x1
9806  8110     BSF PFNf_ofnserw, 0, BANKED
9808  D002     BRA 0x980E
980A  0101     MOVLB 0x1
980C  9110     BCF PFNf_ofnserw, 0, BANKED
9D78  AA03     BTFSS DtCOf_su_SRW_CO, 5, ACCESS
9D7A  D003     BRA 0x9D82
9D7C  0101     MOVLB 0x1
9D7E  8110     BSF PFNf_ofnserw, 0, BANKED
9D80  D002     BRA 0x9D86
9D82  0101     MOVLB 0x1
9D84  9110     BCF PFNf_ofnserw, 0, BANKED
96:                //port 17
97:                SPort[17].Input = (DtCWf_cold_CW) ? 1 : 0; //port/sygnal poddany filtracji
980E  A604     BTFSS DtCWf_err_CW, 3, ACCESS
9810  D003     BRA 0x9818
9812  0101     MOVLB 0x1
9814  8111     BSF PFNf_prn_res, 0, BANKED
9816  D002     BRA 0x981C
9818  0101     MOVLB 0x1
981A  9111     BCF PFNf_prn_res, 0, BANKED
9D86  A604     BTFSS DtCWf_err_CW, 3, ACCESS
9D88  D003     BRA 0x9D90
9D8A  0101     MOVLB 0x1
9D8C  8111     BSF PFNf_prn_res, 0, BANKED
9D8E  D002     BRA 0x9D94
9D90  0101     MOVLB 0x1
9D92  9111     BCF PFNf_prn_res, 0, BANKED
98:                //port 18
99:                SPort[18].Input = (DtCOf_err_CO) ? 1 : 0; //port/sygnal poddany filtracji
981C  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
981E  D003     BRA 0x9826
9820  0101     MOVLB 0x1
9822  8112     BSF PFNf_str_nco, 0, BANKED
9824  D002     BRA 0x982A
9826  0101     MOVLB 0x1
9828  9112     BCF PFNf_str_nco, 0, BANKED
9D94  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
9D96  D003     BRA 0x9D9E
9D98  0101     MOVLB 0x1
9D9A  8112     BSF PFNf_str_nco, 0, BANKED
9D9C  D002     BRA 0x9DA2
9D9E  0101     MOVLB 0x1
9DA0  9112     BCF PFNf_str_nco, 0, BANKED
100:               //port 19
101:               SPort[19].Input = (DtCOf_ad_CO) ? 1 : 0; //port/sygnal poddany filtracji
982A  A601     BTFSS DtCOf_err_CO, 3, ACCESS
982C  D003     BRA 0x9834
982E  0101     MOVLB 0x1
9830  8113     BSF PFNf_zima, 0, BANKED
9832  D002     BRA 0x9838
9834  0101     MOVLB 0x1
9836  9113     BCF PFNf_zima, 0, BANKED
9DA2  A601     BTFSS DtCOf_err_CO, 3, ACCESS
9DA4  D003     BRA 0x9DAC
9DA6  0101     MOVLB 0x1
9DA8  8113     BSF PFNf_zima, 0, BANKED
9DAA  D002     BRA 0x9DB0
9DAC  0101     MOVLB 0x1
9DAE  9113     BCF PFNf_zima, 0, BANKED
102:               //port 20
103:               SPort[20].Input = (DtZWf_on_ZW) ? 1 : 0; //port/sygnal poddany filtracji
9838  A406     BTFSS DtKNFf_wymCO, 2, ACCESS
983A  D003     BRA 0x9842
983C  0101     MOVLB 0x1
983E  8114     BSF UADtf_RData, 0, BANKED
9840  D002     BRA 0x9846
9842  0101     MOVLB 0x1
9844  9114     BCF UADtf_RData, 0, BANKED
9DB0  A406     BTFSS DtKNFf_wymCO, 2, ACCESS
9DB2  D003     BRA 0x9DBA
9DB4  0101     MOVLB 0x1
9DB6  8114     BSF UADtf_RData, 0, BANKED
9DB8  D002     BRA 0x9DBE
9DBA  0101     MOVLB 0x1
9DBC  9114     BCF UADtf_RData, 0, BANKED
104:               //port 21
105:               SPort[21].Input = (_CIG_NO) ? 1 : 0; //port/sygnal poddany filtracji
9846  AC80     BTFSS PORTA, 6, ACCESS
9848  D003     BRA 0x9850
984A  0101     MOVLB 0x1
984C  8115     BSF rglf_btcw, 0, BANKED
984E  D002     BRA 0x9854
9850  0101     MOVLB 0x1
9852  9115     BCF rglf_btcw, 0, BANKED
9DBE  AC80     BTFSS PORTA, 6, ACCESS
9DC0  D003     BRA 0x9DC8
9DC2  0101     MOVLB 0x1
9DC4  8115     BSF rglf_btcw, 0, BANKED
9DC6  D002     BRA 0x9DCC
9DC8  0101     MOVLB 0x1
9DCA  9115     BCF rglf_btcw, 0, BANKED
106:               //port 22
107:               SPort[22].Input = (_OFF) ? 0 : 1; //port/sygnal poddany filtracji
9854  B281     BTFSC PORTB, 1, ACCESS
9856  D004     BRA 0x9860
9858  0100     MOVLB 0x0
985A  6BDE     CLRF __pcstackBANK0, BANKED
985C  2BDE     INCF __pcstackBANK0, F, BANKED
985E  D002     BRA 0x9864
9860  0100     MOVLB 0x0
9862  6BDE     CLRF __pcstackBANK0, BANKED
9864  0101     MOVLB 0x1
9866  5116     MOVF _DtCOf_resPCO, W, BANKED
9868  0100     MOVLB 0x0
986A  19DE     XORWF __pcstackBANK0, W, BANKED
986C  0BFE     ANDLW 0xFE
986E  19DE     XORWF __pcstackBANK0, W, BANKED
9870  0101     MOVLB 0x1
9872  6F16     MOVWF _DtCOf_resPCO, BANKED
9DCC  B281     BTFSC PORTB, 1, ACCESS
9DCE  D003     BRA 0x9DD6
9DD0  6A16     CLRF _DtCOf_resPCO, ACCESS
9DD2  2A16     INCF _DtCOf_resPCO, F, ACCESS
9DD4  D001     BRA 0x9DD8
9DD6  6A16     CLRF _DtCOf_resPCO, ACCESS
9DD8  0101     MOVLB 0x1
9DDA  5116     MOVF _DtCOf_resPCO, W, BANKED
9DDC  1816     XORWF _DtCOf_resPCO, W, ACCESS
9DDE  0BFE     ANDLW 0xFE
9DE0  1816     XORWF _DtCOf_resPCO, W, ACCESS
9DE2  6F16     MOVWF _DtCOf_resPCO, BANKED
108:               //port 23
109:               SPort[23].Input = (_SET) ? 0 : 1; //port/sygnal poddany filtracji
9874  B481     BTFSC PORTB, 2, ACCESS
9876  D004     BRA 0x9880
9878  0100     MOVLB 0x0
987A  6BDE     CLRF __pcstackBANK0, BANKED
987C  2BDE     INCF __pcstackBANK0, F, BANKED
987E  D002     BRA 0x9884
9880  0100     MOVLB 0x0
9882  6BDE     CLRF __pcstackBANK0, BANKED
9884  0101     MOVLB 0x1
9886  5117     MOVF _DtCOf_su_CO, W, BANKED
9888  0100     MOVLB 0x0
988A  19DE     XORWF __pcstackBANK0, W, BANKED
988C  0BFE     ANDLW 0xFE
988E  19DE     XORWF __pcstackBANK0, W, BANKED
9890  0101     MOVLB 0x1
9892  6F17     MOVWF _DtCOf_su_CO, BANKED
9DE4  B481     BTFSC PORTB, 2, ACCESS
9DE6  D003     BRA 0x9DEE
9DE8  6A16     CLRF _DtCOf_resPCO, ACCESS
9DEA  2A16     INCF _DtCOf_resPCO, F, ACCESS
9DEC  D001     BRA 0x9DF0
9DEE  6A16     CLRF _DtCOf_resPCO, ACCESS
9DF0  0101     MOVLB 0x1
9DF2  5117     MOVF _DtCOf_su_CO, W, BANKED
9DF4  1816     XORWF _DtCOf_resPCO, W, ACCESS
9DF6  0BFE     ANDLW 0xFE
9DF8  1816     XORWF _DtCOf_resPCO, W, ACCESS
9DFA  6F17     MOVWF _DtCOf_su_CO, BANKED
110:               //port 24
111:               SPort[24].Input = (_KUP) ? 0 : 1; //port/sygnal poddany filtracji
9894  B681     BTFSC PORTB, 3, ACCESS
9896  D004     BRA 0x98A0
9898  0100     MOVLB 0x0
989A  6BDE     CLRF __pcstackBANK0, BANKED
989C  2BDE     INCF __pcstackBANK0, F, BANKED
989E  D002     BRA 0x98A4
98A0  0100     MOVLB 0x0
98A2  6BDE     CLRF __pcstackBANK0, BANKED
98A4  0101     MOVLB 0x1
98A6  5118     MOVF _DtCOf_su_DZ_CO, W, BANKED
98A8  0100     MOVLB 0x0
98AA  19DE     XORWF __pcstackBANK0, W, BANKED
98AC  0BFE     ANDLW 0xFE
98AE  19DE     XORWF __pcstackBANK0, W, BANKED
98B0  0101     MOVLB 0x1
98B2  6F18     MOVWF _DtCOf_su_DZ_CO, BANKED
9DFC  B681     BTFSC PORTB, 3, ACCESS
9DFE  D003     BRA 0x9E06
9E00  6A16     CLRF _DtCOf_resPCO, ACCESS
9E02  2A16     INCF _DtCOf_resPCO, F, ACCESS
9E04  D001     BRA 0x9E08
9E06  6A16     CLRF _DtCOf_resPCO, ACCESS
9E08  0101     MOVLB 0x1
9E0A  5118     MOVF _DtCOf_su_DZ_CO, W, BANKED
9E0C  1816     XORWF _DtCOf_resPCO, W, ACCESS
9E0E  0BFE     ANDLW 0xFE
9E10  1816     XORWF _DtCOf_resPCO, W, ACCESS
9E12  6F18     MOVWF _DtCOf_su_DZ_CO, BANKED
112:               //port 25
113:               SPort[25].Input = (_KDW) ? 0 : 1; //port/sygnal poddany filtracji
98B4  B881     BTFSC PORTB, 4, ACCESS
98B6  D004     BRA 0x98C0
98B8  0100     MOVLB 0x0
98BA  6BDE     CLRF __pcstackBANK0, BANKED
98BC  2BDE     INCF __pcstackBANK0, F, BANKED
98BE  D002     BRA 0x98C4
98C0  0100     MOVLB 0x0
98C2  6BDE     CLRF __pcstackBANK0, BANKED
98C4  0101     MOVLB 0x1
98C6  5119     MOVF _DtCOf_su_SRW_CO, W, BANKED
98C8  0100     MOVLB 0x0
98CA  19DE     XORWF __pcstackBANK0, W, BANKED
98CC  0BFE     ANDLW 0xFE
98CE  19DE     XORWF __pcstackBANK0, W, BANKED
98D0  0101     MOVLB 0x1
98D2  6F19     MOVWF _DtCOf_su_SRW_CO, BANKED
9E14  B881     BTFSC PORTB, 4, ACCESS
9E16  D003     BRA 0x9E1E
9E18  6A16     CLRF _DtCOf_resPCO, ACCESS
9E1A  2A16     INCF _DtCOf_resPCO, F, ACCESS
9E1C  D001     BRA 0x9E20
9E1E  6A16     CLRF _DtCOf_resPCO, ACCESS
9E20  0101     MOVLB 0x1
9E22  5119     MOVF _DtCOf_su_SRW_CO, W, BANKED
9E24  1816     XORWF _DtCOf_resPCO, W, ACCESS
9E26  0BFE     ANDLW 0xFE
9E28  1816     XORWF _DtCOf_resPCO, W, ACCESS
9E2A  6F19     MOVWF _DtCOf_su_SRW_CO, BANKED
114:               //...tak do Prt[NVPORT-1]
115:           }
98D4  0012     RETURN 0
9E2C  0012     RETURN 0
116:           /*---------------------------------------------------------------------------------*/
117:           // Okreslenie stanu poczatkowego portow (procedura wykonywana jednokrotnie przy starcie
118:           // stabilizacji
119:           
120:           void FrsStan(void)
121:           {
122:               //port 0
123:               SPort[0].Output = SPort[0].Input; //stan zgodny ze stanem fizycznym
7928  0101     MOVLB 0x1
792A  A100     BTFSS tm, 0, BANKED
792C  D002     BRA 0x7932
792E  8300     BSF tm, 1, BANKED
7930  D002     BRA 0x7936
7932  0101     MOVLB 0x1
7934  9300     BCF tm, 1, BANKED
124:               SPort[0].Timer = 0;
7936  9500     BCF tm, 2, BANKED
7938  9700     BCF tm, 3, BANKED
793A  9900     BCF tm, 4, BANKED
793C  9B00     BCF tm, 5, BANKED
793E  9D00     BCF tm, 6, BANKED
7940  9F00     BCF tm, 7, BANKED
125:           
126:               //port 1
127:               SPort[1].Output = SPort[1].Input; //stan zgodny ze stanem fizycznym
7942  0101     MOVLB 0x1
7944  A101     BTFSS DtCOf_err_CO, 0, BANKED
7946  D002     BRA 0x794C
7948  8301     BSF DtCOf_err_CO, 1, BANKED
794A  D002     BRA 0x7950
794C  0101     MOVLB 0x1
794E  9301     BCF DtCOf_err_CO, 1, BANKED
128:               SPort[1].Timer = 0;
7950  9501     BCF DtCOf_err_CO, 2, BANKED
7952  9701     BCF DtCOf_err_CO, 3, BANKED
7954  9901     BCF DtCOf_err_CO, 4, BANKED
7956  9B01     BCF DtCOf_err_CO, 5, BANKED
7958  9D01     BCF DtCOf_err_CO, 6, BANKED
795A  9F01     BCF DtCOf_err_CO, 7, BANKED
129:           
130:               //port 2
131:               SPort[2].Output = SPort[2].Input; //stan zgodny ze stanem fizycznym
795C  0101     MOVLB 0x1
795E  A102     BTFSS DtCOf_su_CO, 0, BANKED
7960  D002     BRA 0x7966
7962  8302     BSF DtCOf_su_CO, 1, BANKED
7964  D002     BRA 0x796A
7966  0101     MOVLB 0x1
7968  9302     BCF DtCOf_su_CO, 1, BANKED
132:               SPort[2].Timer = 0;
796A  9502     BCF DtCOf_su_CO, 2, BANKED
796C  9702     BCF DtCOf_su_CO, 3, BANKED
796E  9902     BCF DtCOf_su_CO, 4, BANKED
7970  9B02     BCF DtCOf_su_CO, 5, BANKED
7972  9D02     BCF DtCOf_su_CO, 6, BANKED
7974  9F02     BCF DtCOf_su_CO, 7, BANKED
133:           
134:               //port 3
135:               SPort[3].Output = SPort[3].Input; //stan zgodny ze stanem fizycznym
7976  0101     MOVLB 0x1
7978  A103     BTFSS DtCOf_su_SRW_CO, 0, BANKED
797A  D002     BRA 0x7980
797C  8303     BSF DtCOf_su_SRW_CO, 1, BANKED
797E  D002     BRA 0x7984
7980  0101     MOVLB 0x1
7982  9303     BCF DtCOf_su_SRW_CO, 1, BANKED
136:               SPort[3].Timer = 0;
7984  9503     BCF DtCOf_su_SRW_CO, 2, BANKED
7986  9703     BCF DtCOf_su_SRW_CO, 3, BANKED
7988  9903     BCF DtCOf_su_SRW_CO, 4, BANKED
798A  9B03     BCF DtCOf_su_SRW_CO, 5, BANKED
798C  9D03     BCF DtCOf_su_SRW_CO, 6, BANKED
798E  9F03     BCF DtCOf_su_SRW_CO, 7, BANKED
137:           
138:               //port 4
139:               SPort[4].Output = SPort[4].Input; //stan zgodny ze stanem fizycznym
7990  0101     MOVLB 0x1
7992  A104     BTFSS DtCWf_err_CW, 0, BANKED
7994  D002     BRA 0x799A
7996  8304     BSF DtCWf_err_CW, 1, BANKED
7998  D002     BRA 0x799E
799A  0101     MOVLB 0x1
799C  9304     BCF DtCWf_err_CW, 1, BANKED
140:               SPort[4].Timer = 0;
799E  9504     BCF DtCWf_err_CW, 2, BANKED
79A0  9704     BCF DtCWf_err_CW, 3, BANKED
79A2  9904     BCF DtCWf_err_CW, 4, BANKED
79A4  9B04     BCF DtCWf_err_CW, 5, BANKED
79A6  9D04     BCF DtCWf_err_CW, 6, BANKED
79A8  9F04     BCF DtCWf_err_CW, 7, BANKED
141:           
142:               //port 5
143:               SPort[5].Output = SPort[5].Input; //stan zgodny ze stanem fizycznym
79AA  0101     MOVLB 0x1
79AC  A105     BTFSS DtKNFf_enknf, 0, BANKED
79AE  D002     BRA 0x79B4
79B0  8305     BSF DtKNFf_enknf, 1, BANKED
79B2  D002     BRA 0x79B8
79B4  0101     MOVLB 0x1
79B6  9305     BCF DtKNFf_enknf, 1, BANKED
144:               SPort[5].Timer = 0;
79B8  9505     BCF DtKNFf_enknf, 2, BANKED
79BA  9705     BCF DtKNFf_enknf, 3, BANKED
79BC  9905     BCF DtKNFf_enknf, 4, BANKED
79BE  9B05     BCF DtKNFf_enknf, 5, BANKED
79C0  9D05     BCF DtKNFf_enknf, 6, BANKED
79C2  9F05     BCF DtKNFf_enknf, 7, BANKED
145:           
146:               //port 6
147:               SPort[6].Output = SPort[6].Input; //stan zgodny ze stanem fizycznym
79C4  0101     MOVLB 0x1
79C6  A106     BTFSS DtKNFf_wymCO, 0, BANKED
79C8  D002     BRA 0x79CE
79CA  8306     BSF DtKNFf_wymCO, 1, BANKED
79CC  D002     BRA 0x79D2
79CE  0101     MOVLB 0x1
79D0  9306     BCF DtKNFf_wymCO, 1, BANKED
148:               SPort[6].Timer = 0;
79D2  9506     BCF DtKNFf_wymCO, 2, BANKED
79D4  9706     BCF DtKNFf_wymCO, 3, BANKED
79D6  9906     BCF DtKNFf_wymCO, 4, BANKED
79D8  9B06     BCF DtKNFf_wymCO, 5, BANKED
79DA  9D06     BCF DtKNFf_wymCO, 6, BANKED
79DC  9F06     BCF DtKNFf_wymCO, 7, BANKED
149:           
150:               //port 7
151:               SPort[7].Output = SPort[7].Input; //stan zgodny ze stanem fizycznym
79DE  0101     MOVLB 0x1
79E0  A107     BTFSS Mf_BLOKUJ_3M, 0, BANKED
79E2  D002     BRA 0x79E8
79E4  8307     BSF Mf_BLOKUJ_3M, 1, BANKED
79E6  D002     BRA 0x79EC
79E8  0101     MOVLB 0x1
79EA  9307     BCF Mf_BLOKUJ_3M, 1, BANKED
152:               SPort[7].Timer = 0;
79EC  9507     BCF Mf_BLOKUJ_3M, 2, BANKED
79EE  9707     BCF Mf_BLOKUJ_3M, 3, BANKED
79F0  9907     BCF Mf_BLOKUJ_3M, 4, BANKED
79F2  9B07     BCF Mf_BLOKUJ_3M, 5, BANKED
79F4  9D07     BCF Mf_BLOKUJ_3M, 6, BANKED
79F6  9F07     BCF Mf_BLOKUJ_3M, 7, BANKED
153:           
154:               //port 8
155:               SPort[8].Output = SPort[8].Input; //stan zgodny ze stanem fizycznym
79F8  0101     MOVLB 0x1
79FA  A108     BTFSS Mf_ROZRUCH, 0, BANKED
79FC  D002     BRA 0x7A02
79FE  8308     BSF Mf_ROZRUCH, 1, BANKED
7A00  D002     BRA 0x7A06
7A02  0101     MOVLB 0x1
7A04  9308     BCF Mf_ROZRUCH, 1, BANKED
156:               SPort[8].Timer = 0;
7A06  9508     BCF Mf_ROZRUCH, 2, BANKED
7A08  9708     BCF Mf_ROZRUCH, 3, BANKED
7A0A  9908     BCF Mf_ROZRUCH, 4, BANKED
7A0C  9B08     BCF Mf_ROZRUCH, 5, BANKED
7A0E  9D08     BCF Mf_ROZRUCH, 6, BANKED
7A10  9F08     BCF Mf_ROZRUCH, 7, BANKED
157:           
158:               //port 9
159:               SPort[9].Output = SPort[9].Input; //stan zgodny ze stanem fizycznym
7A12  0101     MOVLB 0x1
7A14  A109     BTFSS Mf_RUSZ_PWR, 0, BANKED
7A16  D002     BRA 0x7A1C
7A18  8309     BSF Mf_RUSZ_PWR, 1, BANKED
7A1A  D002     BRA 0x7A20
7A1C  0101     MOVLB 0x1
7A1E  9309     BCF Mf_RUSZ_PWR, 1, BANKED
160:               SPort[9].Timer = 0;
7A20  9509     BCF Mf_RUSZ_PWR, 2, BANKED
7A22  9709     BCF Mf_RUSZ_PWR, 3, BANKED
7A24  9909     BCF Mf_RUSZ_PWR, 4, BANKED
7A26  9B09     BCF Mf_RUSZ_PWR, 5, BANKED
7A28  9D09     BCF Mf_RUSZ_PWR, 6, BANKED
7A2A  9F09     BCF Mf_RUSZ_PWR, 7, BANKED
161:           
162:               //port 10
163:               SPort[10].Output = SPort[10].Input; //stan zgodny ze stanem fizycznym
7A2C  0101     MOVLB 0x1
7A2E  A10A     BTFSS Mf_pob_AL, 0, BANKED
7A30  D002     BRA 0x7A36
7A32  830A     BSF Mf_pob_AL, 1, BANKED
7A34  D002     BRA 0x7A3A
7A36  0101     MOVLB 0x1
7A38  930A     BCF Mf_pob_AL, 1, BANKED
164:               SPort[10].Timer = 0;
7A3A  950A     BCF Mf_pob_AL, 2, BANKED
7A3C  970A     BCF Mf_pob_AL, 3, BANKED
7A3E  990A     BCF Mf_pob_AL, 4, BANKED
7A40  9B0A     BCF Mf_pob_AL, 5, BANKED
7A42  9D0A     BCF Mf_pob_AL, 6, BANKED
7A44  9F0A     BCF Mf_pob_AL, 7, BANKED
165:           
166:               //port 11
167:               SPort[11].Output = SPort[11].Input; //stan zgodny ze stanem fizycznym
7A46  0101     MOVLB 0x1
7A48  A10B     BTFSS Mf_pob_KCO, 0, BANKED
7A4A  D002     BRA 0x7A50
7A4C  830B     BSF Mf_pob_KCO, 1, BANKED
7A4E  D002     BRA 0x7A54
7A50  0101     MOVLB 0x1
7A52  930B     BCF Mf_pob_KCO, 1, BANKED
168:               SPort[11].Timer = 0;
7A54  950B     BCF Mf_pob_KCO, 2, BANKED
7A56  970B     BCF Mf_pob_KCO, 3, BANKED
7A58  990B     BCF Mf_pob_KCO, 4, BANKED
7A5A  9B0B     BCF Mf_pob_KCO, 5, BANKED
7A5C  9D0B     BCF Mf_pob_KCO, 6, BANKED
7A5E  9F0B     BCF Mf_pob_KCO, 7, BANKED
169:           
170:               //port 12
171:               SPort[12].Output = SPort[12].Input; //stan zgodny ze stanem fizycznym
7A60  0101     MOVLB 0x1
7A62  A10C     BTFSS PFNf_b_set_nco, 0, BANKED
7A64  D002     BRA 0x7A6A
7A66  830C     BSF PFNf_b_set_nco, 1, BANKED
7A68  D002     BRA 0x7A6E
7A6A  0101     MOVLB 0x1
7A6C  930C     BCF PFNf_b_set_nco, 1, BANKED
172:               SPort[12].Timer = 0;
7A6E  950C     BCF PFNf_b_set_nco, 2, BANKED
7A70  970C     BCF PFNf_b_set_nco, 3, BANKED
7A72  990C     BCF PFNf_b_set_nco, 4, BANKED
7A74  9B0C     BCF PFNf_b_set_nco, 5, BANKED
7A76  9D0C     BCF PFNf_b_set_nco, 6, BANKED
7A78  9F0C     BCF PFNf_b_set_nco, 7, BANKED
173:           
174:               //port 13
175:               SPort[13].Output = SPort[13].Input; //stan zgodny ze stanem fizycznym
7A7A  0101     MOVLB 0x1
7A7C  A10D     BTFSS PFNf_b_str_nco, 0, BANKED
7A7E  D002     BRA 0x7A84
7A80  830D     BSF PFNf_b_str_nco, 1, BANKED
7A82  D002     BRA 0x7A88
7A84  0101     MOVLB 0x1
7A86  930D     BCF PFNf_b_str_nco, 1, BANKED
176:               SPort[13].Timer = 0;
7A88  950D     BCF PFNf_b_str_nco, 2, BANKED
7A8A  970D     BCF PFNf_b_str_nco, 3, BANKED
7A8C  990D     BCF PFNf_b_str_nco, 4, BANKED
7A8E  9B0D     BCF PFNf_b_str_nco, 5, BANKED
7A90  9D0D     BCF PFNf_b_str_nco, 6, BANKED
7A92  9F0D     BCF PFNf_b_str_nco, 7, BANKED
177:           
178:               //port 14
179:               SPort[14].Output = SPort[14].Input; //stan zgodny ze stanem fizycznym
7A94  0101     MOVLB 0x1
7A96  A10E     BTFSS PFNf_lato, 0, BANKED
7A98  D002     BRA 0x7A9E
7A9A  830E     BSF PFNf_lato, 1, BANKED
7A9C  D002     BRA 0x7AA2
7A9E  0101     MOVLB 0x1
7AA0  930E     BCF PFNf_lato, 1, BANKED
180:               SPort[14].Timer = 0;
7AA2  950E     BCF PFNf_lato, 2, BANKED
7AA4  970E     BCF PFNf_lato, 3, BANKED
7AA6  990E     BCF PFNf_lato, 4, BANKED
7AA8  9B0E     BCF PFNf_lato, 5, BANKED
7AAA  9D0E     BCF PFNf_lato, 6, BANKED
7AAC  9F0E     BCF PFNf_lato, 7, BANKED
181:           
182:               //port 15
183:               SPort[15].Output = SPort[15].Input; //stan zgodny ze stanem fizycznym
7AAE  0101     MOVLB 0x1
7AB0  A10F     BTFSS PFNf_off, 0, BANKED
7AB2  D002     BRA 0x7AB8
7AB4  830F     BSF PFNf_off, 1, BANKED
7AB6  D002     BRA 0x7ABC
7AB8  0101     MOVLB 0x1
7ABA  930F     BCF PFNf_off, 1, BANKED
184:               SPort[15].Timer = 0;
7ABC  950F     BCF PFNf_off, 2, BANKED
7ABE  970F     BCF PFNf_off, 3, BANKED
7AC0  990F     BCF PFNf_off, 4, BANKED
7AC2  9B0F     BCF PFNf_off, 5, BANKED
7AC4  9D0F     BCF PFNf_off, 6, BANKED
7AC6  9F0F     BCF PFNf_off, 7, BANKED
185:           
186:               //port 16
187:               SPort[16].Output = SPort[16].Input; //stan zgodny ze stanem fizycznym
7AC8  0101     MOVLB 0x1
7ACA  A110     BTFSS PFNf_ofnserw, 0, BANKED
7ACC  D002     BRA 0x7AD2
7ACE  8310     BSF PFNf_ofnserw, 1, BANKED
7AD0  D002     BRA 0x7AD6
7AD2  0101     MOVLB 0x1
7AD4  9310     BCF PFNf_ofnserw, 1, BANKED
188:               SPort[16].Timer = 0;
7AD6  9510     BCF PFNf_ofnserw, 2, BANKED
7AD8  9710     BCF PFNf_ofnserw, 3, BANKED
7ADA  9910     BCF PFNf_ofnserw, 4, BANKED
7ADC  9B10     BCF PFNf_ofnserw, 5, BANKED
7ADE  9D10     BCF PFNf_ofnserw, 6, BANKED
7AE0  9F10     BCF PFNf_ofnserw, 7, BANKED
189:           
190:               //port 17
191:               SPort[17].Output = SPort[17].Input; //stan zgodny ze stanem fizycznym
7AE2  0101     MOVLB 0x1
7AE4  A111     BTFSS PFNf_prn_res, 0, BANKED
7AE6  D002     BRA 0x7AEC
7AE8  8311     BSF PFNf_prn_res, 1, BANKED
7AEA  D002     BRA 0x7AF0
7AEC  0101     MOVLB 0x1
7AEE  9311     BCF PFNf_prn_res, 1, BANKED
192:               SPort[17].Timer = 0;
7AF0  9511     BCF PFNf_prn_res, 2, BANKED
7AF2  9711     BCF PFNf_prn_res, 3, BANKED
7AF4  9911     BCF PFNf_prn_res, 4, BANKED
7AF6  9B11     BCF PFNf_prn_res, 5, BANKED
7AF8  9D11     BCF PFNf_prn_res, 6, BANKED
7AFA  9F11     BCF PFNf_prn_res, 7, BANKED
193:           
194:               //port 18
195:               SPort[18].Output = SPort[18].Input; //stan zgodny ze stanem fizycznym
7AFC  0101     MOVLB 0x1
7AFE  A112     BTFSS PFNf_str_nco, 0, BANKED
7B00  D002     BRA 0x7B06
7B02  8312     BSF PFNf_str_nco, 1, BANKED
7B04  D002     BRA 0x7B0A
7B06  0101     MOVLB 0x1
7B08  9312     BCF PFNf_str_nco, 1, BANKED
196:               SPort[18].Timer = 0;
7B0A  9512     BCF PFNf_str_nco, 2, BANKED
7B0C  9712     BCF PFNf_str_nco, 3, BANKED
7B0E  9912     BCF PFNf_str_nco, 4, BANKED
7B10  9B12     BCF PFNf_str_nco, 5, BANKED
7B12  9D12     BCF PFNf_str_nco, 6, BANKED
7B14  9F12     BCF PFNf_str_nco, 7, BANKED
197:           
198:               //port 19
199:               SPort[19].Output = SPort[19].Input; //stan zgodny ze stanem fizycznym
7B16  0101     MOVLB 0x1
7B18  A113     BTFSS PFNf_zima, 0, BANKED
7B1A  D002     BRA 0x7B20
7B1C  8313     BSF PFNf_zima, 1, BANKED
7B1E  D002     BRA 0x7B24
7B20  0101     MOVLB 0x1
7B22  9313     BCF PFNf_zima, 1, BANKED
200:               SPort[19].Timer = 0;
7B24  9513     BCF PFNf_zima, 2, BANKED
7B26  9713     BCF PFNf_zima, 3, BANKED
7B28  9913     BCF PFNf_zima, 4, BANKED
7B2A  9B13     BCF PFNf_zima, 5, BANKED
7B2C  9D13     BCF PFNf_zima, 6, BANKED
7B2E  9F13     BCF PFNf_zima, 7, BANKED
201:           
202:               //port 20
203:               SPort[20].Output = SPort[20].Input; //stan zgodny ze stanem fizycznym
7B30  0101     MOVLB 0x1
7B32  A114     BTFSS UADtf_RData, 0, BANKED
7B34  D002     BRA 0x7B3A
7B36  8314     BSF UADtf_RData, 1, BANKED
7B38  D002     BRA 0x7B3E
7B3A  0101     MOVLB 0x1
7B3C  9314     BCF UADtf_RData, 1, BANKED
204:               SPort[20].Timer = 0;
7B3E  9514     BCF UADtf_RData, 2, BANKED
7B40  9714     BCF UADtf_RData, 3, BANKED
7B42  9914     BCF UADtf_RData, 4, BANKED
7B44  9B14     BCF UADtf_RData, 5, BANKED
7B46  9D14     BCF UADtf_RData, 6, BANKED
7B48  9F14     BCF UADtf_RData, 7, BANKED
205:           
206:               //port 21
207:               SPort[21].Output = SPort[21].Input; //stan zgodny ze stanem fizycznym
7B4A  0101     MOVLB 0x1
7B4C  A115     BTFSS rglf_btcw, 0, BANKED
7B4E  D002     BRA 0x7B54
7B50  8315     BSF rglf_btcw, 1, BANKED
7B52  D002     BRA 0x7B58
7B54  0101     MOVLB 0x1
7B56  9315     BCF rglf_btcw, 1, BANKED
208:               SPort[21].Timer = 0;
7B58  9515     BCF rglf_btcw, 2, BANKED
7B5A  9715     BCF rglf_btcw, 3, BANKED
7B5C  9915     BCF rglf_btcw, 4, BANKED
7B5E  9B15     BCF rglf_btcw, 5, BANKED
7B60  9D15     BCF rglf_btcw, 6, BANKED
7B62  9F15     BCF rglf_btcw, 7, BANKED
209:           
210:               //port 22
211:               SPort[22].Output = SPort[22].Input; //stan zgodny ze stanem fizycznym
7B64  0101     MOVLB 0x1
7B66  A116     BTFSS _DtCOf_resPCO, 0, BANKED
7B68  D002     BRA 0x7B6E
7B6A  8316     BSF _DtCOf_resPCO, 1, BANKED
7B6C  D002     BRA 0x7B72
7B6E  0101     MOVLB 0x1
7B70  9316     BCF _DtCOf_resPCO, 1, BANKED
212:               SPort[22].Timer = 0;
7B72  9516     BCF _DtCOf_resPCO, 2, BANKED
7B74  9716     BCF _DtCOf_resPCO, 3, BANKED
7B76  9916     BCF _DtCOf_resPCO, 4, BANKED
7B78  9B16     BCF _DtCOf_resPCO, 5, BANKED
7B7A  9D16     BCF _DtCOf_resPCO, 6, BANKED
7B7C  9F16     BCF _DtCOf_resPCO, 7, BANKED
213:           
214:               //port 23
215:               SPort[23].Output = SPort[23].Input; //stan zgodny ze stanem fizycznym
7B7E  0101     MOVLB 0x1
7B80  A117     BTFSS _DtCOf_su_CO, 0, BANKED
7B82  D002     BRA 0x7B88
7B84  8317     BSF _DtCOf_su_CO, 1, BANKED
7B86  D002     BRA 0x7B8C
7B88  0101     MOVLB 0x1
7B8A  9317     BCF _DtCOf_su_CO, 1, BANKED
216:               SPort[23].Timer = 0;
7B8C  9517     BCF _DtCOf_su_CO, 2, BANKED
7B8E  9717     BCF _DtCOf_su_CO, 3, BANKED
7B90  9917     BCF _DtCOf_su_CO, 4, BANKED
7B92  9B17     BCF _DtCOf_su_CO, 5, BANKED
7B94  9D17     BCF _DtCOf_su_CO, 6, BANKED
7B96  9F17     BCF _DtCOf_su_CO, 7, BANKED
217:           
218:               //port 24
219:               SPort[24].Output = SPort[24].Input; //stan zgodny ze stanem fizycznym
7B98  0101     MOVLB 0x1
7B9A  A118     BTFSS _DtCOf_su_DZ_CO, 0, BANKED
7B9C  D002     BRA 0x7BA2
7B9E  8318     BSF _DtCOf_su_DZ_CO, 1, BANKED
7BA0  D002     BRA 0x7BA6
7BA2  0101     MOVLB 0x1
7BA4  9318     BCF _DtCOf_su_DZ_CO, 1, BANKED
220:               SPort[24].Timer = 0;
7BA6  9518     BCF _DtCOf_su_DZ_CO, 2, BANKED
7BA8  9718     BCF _DtCOf_su_DZ_CO, 3, BANKED
7BAA  9918     BCF _DtCOf_su_DZ_CO, 4, BANKED
7BAC  9B18     BCF _DtCOf_su_DZ_CO, 5, BANKED
7BAE  9D18     BCF _DtCOf_su_DZ_CO, 6, BANKED
7BB0  9F18     BCF _DtCOf_su_DZ_CO, 7, BANKED
221:           
222:               //port 25
223:               SPort[25].Output = SPort[25].Input; //stan zgodny ze stanem fizycznym
7BB2  0101     MOVLB 0x1
7BB4  A119     BTFSS _DtCOf_su_SRW_CO, 0, BANKED
7BB6  D002     BRA 0x7BBC
7BB8  8319     BSF _DtCOf_su_SRW_CO, 1, BANKED
7BBA  D002     BRA 0x7BC0
7BBC  0101     MOVLB 0x1
7BBE  9319     BCF _DtCOf_su_SRW_CO, 1, BANKED
224:               SPort[25].Timer = 0;
7BC0  9519     BCF _DtCOf_su_SRW_CO, 2, BANKED
7BC2  9719     BCF _DtCOf_su_SRW_CO, 3, BANKED
7BC4  9919     BCF _DtCOf_su_SRW_CO, 4, BANKED
7BC6  9B19     BCF _DtCOf_su_SRW_CO, 5, BANKED
7BC8  9D19     BCF _DtCOf_su_SRW_CO, 6, BANKED
7BCA  9F19     BCF _DtCOf_su_SRW_CO, 7, BANKED
225:               //...tak do Prt[_NVPORT-1]
226:           }
7BCC  0012     RETURN 0
227:           #endif
228:           /*---------------------------------------------------------------------------------*/
229:           /*---------------------------------------------------------------------------------*/
230:           
231:           /*-----------------------------PROTECTED DATA--------------------------------------*/
232:           void InitPort(void)
233:           {
234:           #if _PIC_PORT==0
235:           #error _PIC_PORT - niewlasciwa wartosc parametru
236:           #endif
237:           #if _PIC_PORT==3
238:               PORTA = _VALUEA;
239:               TRISA = _DIRECTA;
240:               PORTB = _VALUEB;
241:               TRISB = _DIRECTB;
242:               PORTC = _VALUEC;
243:               TRISC = _DIRECTC;
244:           #endif
245:           #if _PIC_PORT==5
246:               PORTA = _VALUEA;
EDD4  6A80     CLRF PORTA, ACCESS
247:               TRISA = _DIRECTA;
EDD6  6892     SETF TRISA, ACCESS
248:               PORTB = _VALUEB;
EDD8  6A81     CLRF PORTB, ACCESS
249:               TRISB = _DIRECTB;
EDDA  6893     SETF TRISB, ACCESS
250:               PORTC = _VALUEC;
EDDC  6A82     CLRF PORTC, ACCESS
251:               TRISC = _DIRECTC;
EDDE  0EF9     MOVLW 0xF9
EDE0  6E94     MOVWF TRISC, ACCESS
252:               PORTD = _VALUED;
EDE2  6A83     CLRF PORTD, ACCESS
253:               TRISD = _DIRECTD;
EDE4  0E30     MOVLW 0x30
EDE6  6E95     MOVWF TRISD, ACCESS
254:               PORTE = _VALUEE;
EDE8  6A84     CLRF PORTE, ACCESS
255:               TRISE = (TRISE & 0b11111000) | (_DIRECTE & 0b00000111);
EDEA  5096     MOVF TRISE, W, ACCESS
EDEC  0BF8     ANDLW 0xF8
EDEE  6E96     MOVWF TRISE, ACCESS
256:           #endif
257:           #if _NVPORT!=0 
258:               RefStan();
EDF0  EC66     CALL 0x96CC, 0
EDF2  F04B     NOP
259:               FrsStan();
EDF4  EC94     CALL 0x7928, 0
EDF6  F03C     NOP
260:           #endif
261:           }
EDF8  0012     RETURN 0
262:           //----------------------------------------------------------------------------------
263:           #if _NVPORT!=0
264:           
265:           void StabPort(void)
266:           {
267:               static unsigned char tim = 0;
268:               unsigned char i, delay;
269:           
270:               //odliczanie czasu 100m sek (funkcja wywolywana w przerwaniu co 10m sek)
271:               if(tim++<_TKRPR) return;
98D6  0101     MOVLB 0x1
98D8  2B75     INCF _PFNf_fns_max, F, BANKED
98DA  0575     DECF _PFNf_fns_max, W, BANKED
98DC  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
98DE  0E05     MOVLW 0x5
98E0  601A     CPFSLT _DtCOf_zroPCO, ACCESS
98E2  D002     BRA 0x98E8
98E4  0C05     RETLW 0x5
98E6  0012     RETURN 0
272:               tim = 0;
98E8  0E00     MOVLW 0x0
98EA  0101     MOVLB 0x1
98EC  6F75     MOVWF _PFNf_fns_max, BANKED
273:           
274:               //odczyt stanu portow
275:               RefStan();
98EE  EC37     CALL 0x9C6E, 0
98F0  F04E     NOP
276:           
277:               //aby nowy stan zostal zaakceptowany musi trwac min. przez okreslony w polu Delay czas.
278:               for(i = 0; i < _NVPORT; i++)
98F2  0E00     MOVLW 0x0
98F4  6E1D     MOVWF _DtCSf_lo, ACCESS
98F6  0E19     MOVLW 0x19
98F8  641D     CPFSGT _DtCSf_lo, ACCESS
98FA  D002     BRA 0x9900
98FC  0C19     RETLW 0x19
98FE  0012     RETURN 0
9A9E  2A1D     INCF _DtCSf_lo, F, ACCESS
9AA0  0E19     MOVLW 0x19
9AA2  641D     CPFSGT _DtCSf_lo, ACCESS
9AA4  D72D     BRA 0x9900
9AA6  0C19     RETLW 0x19
279:               {
280:                   if(!SPort[i].Timer) //trwa odliczanie czasu?
9900  501D     MOVF _DtCSf_lo, W, ACCESS
9902  0D01     MULLW 0x1
9904  0E00     MOVLW 0x0
9906  24F3     ADDWF PROD, W, ACCESS
9908  6ED9     MOVWF FSR2, ACCESS
990A  0E01     MOVLW 0x1
990C  20F4     ADDWFC PRODH, W, ACCESS
990E  6EDA     MOVWF FSR2H, ACCESS
9910  30DF     RRCF INDF2, W, ACCESS
9912  32E8     RRCF WREG, F, ACCESS
9914  0B3F     ANDLW 0x3F
9916  E137     BNZ 0x9986
281:                   {
282:                       if(SPort[i].Output == SPort[i].Input) //stan portu bez zmian?
9918  501D     MOVF _DtCSf_lo, W, ACCESS
991A  0D01     MULLW 0x1
991C  0E00     MOVLW 0x0
991E  24F3     ADDWF PROD, W, ACCESS
9920  6ED9     MOVWF FSR2, ACCESS
9922  0E01     MOVLW 0x1
9924  20F4     ADDWFC PRODH, W, ACCESS
9926  6EDA     MOVWF FSR2H, ACCESS
9928  0E01     MOVLW 0x1
992A  A0DF     BTFSS INDF2, 0, ACCESS
992C  0E00     MOVLW 0x0
992E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
9930  501D     MOVF _DtCSf_lo, W, ACCESS
9932  0D01     MULLW 0x1
9934  0E00     MOVLW 0x0
9936  24F3     ADDWF PROD, W, ACCESS
9938  6ED9     MOVWF FSR2, ACCESS
993A  0E01     MOVLW 0x1
993C  20F4     ADDWFC PRODH, W, ACCESS
993E  6EDA     MOVWF FSR2H, ACCESS
9940  0101     MOVLB 0x1
9942  0E01     MOVLW 0x1
9944  A2DF     BTFSS INDF2, 1, ACCESS
9946  0E00     MOVLW 0x0
9948  1A1A     XORWF _DtCOf_zroPCO, F, ACCESS
994A  E101     BNZ 0x994E
994C  D0A8     BRA 0x9A9E
994E  D001     BRA 0x9952
283:                           continue;
9950  D0A6     BRA 0x9A9E
284:                       else SPort[i].Timer++; //start odliczania
9952  0E01     MOVLW 0x1
9954  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
9956  501D     MOVF _DtCSf_lo, W, ACCESS
9958  0D01     MULLW 0x1
995A  0E00     MOVLW 0x0
995C  24F3     ADDWF PROD, W, ACCESS
995E  6ED9     MOVWF FSR2, ACCESS
9960  0E01     MOVLW 0x1
9962  20F4     ADDWFC PRODH, W, ACCESS
9964  6EDA     MOVWF FSR2H, ACCESS
9966  30DF     RRCF INDF2, W, ACCESS
9968  6E1B     MOVWF _DtCSf_error, ACCESS
996A  301B     RRCF _DtCSf_error, W, ACCESS
996C  0B3F     ANDLW 0x3F
996E  6E1B     MOVWF _DtCSf_error, ACCESS
9970  501A     MOVF _DtCOf_zroPCO, W, ACCESS
9972  261B     ADDWF _DtCSf_error, F, ACCESS
9974  361B     RLCF _DtCSf_error, F, ACCESS
9976  361B     RLCF _DtCSf_error, F, ACCESS
9978  50DF     MOVF INDF2, W, ACCESS
997A  181B     XORWF _DtCSf_error, W, ACCESS
997C  0B03     ANDLW 0x3
997E  181B     XORWF _DtCSf_error, W, ACCESS
9980  0101     MOVLB 0x1
9982  6EDF     MOVWF INDF2, ACCESS
285:                   }
9984  D08C     BRA 0x9A9E
286:                   else
287:                   {
288:                       if(!SPort[i].Output) delay = Nastawa[i].Delay1;
9986  501D     MOVF _DtCSf_lo, W, ACCESS
9988  0D01     MULLW 0x1
998A  0E00     MOVLW 0x0
998C  24F3     ADDWF PROD, W, ACCESS
998E  6ED9     MOVWF FSR2, ACCESS
9990  0E01     MOVLW 0x1
9992  20F4     ADDWFC PRODH, W, ACCESS
9994  6EDA     MOVWF FSR2H, ACCESS
9996  B2DF     BTFSC INDF2, 1, ACCESS
9998  D003     BRA 0x99A0
999A  501D     MOVF _DtCSf_lo, W, ACCESS
999C  0D02     MULLW 0x2
999E  D005     BRA 0x99AA
289:                       else delay = Nastawa[i].Delay2;
99A0  501D     MOVF _DtCSf_lo, W, ACCESS
99A2  0D02     MULLW 0x2
99A4  2AF3     INCF PROD, F, ACCESS
99A6  0E00     MOVLW 0x0
99A8  22F4     ADDWFC PRODH, F, ACCESS
99AA  0E01     MOVLW 0x1
99AC  24F3     ADDWF PROD, W, ACCESS
99AE  6EF6     MOVWF TBLPTR, ACCESS
99B0  0E10     MOVLW 0x10
99B2  20F4     ADDWFC PRODH, W, ACCESS
99B4  6EF7     MOVWF TBLPTRH, ACCESS
99B6  0008     TBLRD*
99B8  CFF5     MOVFF TABLAT, _DtCSf_hi
99BA  F01C     NOP
99BC  D000     BRA 0x99BE
290:           
291:                       if(SPort[i].Timer >= delay) //minal nastawiony czas?
99BE  501D     MOVF _DtCSf_lo, W, ACCESS
99C0  0D01     MULLW 0x1
99C2  0E00     MOVLW 0x0
99C4  24F3     ADDWF PROD, W, ACCESS
99C6  6ED9     MOVWF FSR2, ACCESS
99C8  0E01     MOVLW 0x1
99CA  20F4     ADDWFC PRODH, W, ACCESS
99CC  6EDA     MOVWF FSR2H, ACCESS
99CE  30DF     RRCF INDF2, W, ACCESS
99D0  32E8     RRCF WREG, F, ACCESS
99D2  0B3F     ANDLW 0x3F
99D4  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
99D6  501C     MOVF _DtCSf_hi, W, ACCESS
99D8  5C1A     SUBWF _DtCOf_zroPCO, W, ACCESS
99DA  E31E     BNC 0x9A18
292:                       {
293:                           SPort[i].Timer = 0;
99DC  501D     MOVF _DtCSf_lo, W, ACCESS
99DE  0D01     MULLW 0x1
99E0  0E00     MOVLW 0x0
99E2  24F3     ADDWF PROD, W, ACCESS
99E4  6ED9     MOVWF FSR2, ACCESS
99E6  0E01     MOVLW 0x1
99E8  20F4     ADDWFC PRODH, W, ACCESS
99EA  6EDA     MOVWF FSR2H, ACCESS
99EC  94DF     BCF INDF2, 2, ACCESS
99EE  96DF     BCF INDF2, 3, ACCESS
99F0  98DF     BCF INDF2, 4, ACCESS
99F2  9ADF     BCF INDF2, 5, ACCESS
99F4  9CDF     BCF INDF2, 6, ACCESS
99F6  9EDF     BCF INDF2, 7, ACCESS
294:                           SPort[i].Output = SPort[i].Input; //nowa wartosc stanu wyjsciowego
99F8  501D     MOVF _DtCSf_lo, W, ACCESS
99FA  0D01     MULLW 0x1
99FC  0E00     MOVLW 0x0
99FE  24F3     ADDWF PROD, W, ACCESS
9A00  6ED9     MOVWF FSR2, ACCESS
9A02  0E01     MOVLW 0x1
9A04  20F4     ADDWFC PRODH, W, ACCESS
9A06  6EDA     MOVWF FSR2H, ACCESS
9A08  A0DF     BTFSS INDF2, 0, ACCESS
9A0A  D003     BRA 0x9A12
9A0C  0101     MOVLB 0x1
9A0E  82DF     BSF INDF2, 1, ACCESS
9A10  D046     BRA 0x9A9E
9A12  0101     MOVLB 0x1
9A14  92DF     BCF INDF2, 1, ACCESS
295:                       }
9A16  D043     BRA 0x9A9E
296:                       else
297:                       {
298:                           if(SPort[i].Output == SPort[i].Input) //powrocil do pierwotnego stanu?
9A18  501D     MOVF _DtCSf_lo, W, ACCESS
9A1A  0D01     MULLW 0x1
9A1C  0E00     MOVLW 0x0
9A1E  24F3     ADDWF PROD, W, ACCESS
9A20  6ED9     MOVWF FSR2, ACCESS
9A22  0E01     MOVLW 0x1
9A24  20F4     ADDWFC PRODH, W, ACCESS
9A26  6EDA     MOVWF FSR2H, ACCESS
9A28  0E01     MOVLW 0x1
9A2A  A0DF     BTFSS INDF2, 0, ACCESS
9A2C  0E00     MOVLW 0x0
9A2E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
9A30  501D     MOVF _DtCSf_lo, W, ACCESS
9A32  0D01     MULLW 0x1
9A34  0E00     MOVLW 0x0
9A36  24F3     ADDWF PROD, W, ACCESS
9A38  6ED9     MOVWF FSR2, ACCESS
9A3A  0E01     MOVLW 0x1
9A3C  20F4     ADDWFC PRODH, W, ACCESS
9A3E  6EDA     MOVWF FSR2H, ACCESS
9A40  0101     MOVLB 0x1
9A42  0E01     MOVLW 0x1
9A44  A2DF     BTFSS INDF2, 1, ACCESS
9A46  0E00     MOVLW 0x0
9A48  1A1A     XORWF _DtCOf_zroPCO, F, ACCESS
9A4A  E10F     BNZ 0x9A6A
299:                               SPort[i].Timer = 0; //restart odliczania
9A4C  501D     MOVF _DtCSf_lo, W, ACCESS
9A4E  0D01     MULLW 0x1
9A50  0E00     MOVLW 0x0
9A52  24F3     ADDWF PROD, W, ACCESS
9A54  6ED9     MOVWF FSR2, ACCESS
9A56  0E01     MOVLW 0x1
9A58  20F4     ADDWFC PRODH, W, ACCESS
9A5A  6EDA     MOVWF FSR2H, ACCESS
9A5C  94DF     BCF INDF2, 2, ACCESS
9A5E  96DF     BCF INDF2, 3, ACCESS
9A60  98DF     BCF INDF2, 4, ACCESS
9A62  9ADF     BCF INDF2, 5, ACCESS
9A64  9CDF     BCF INDF2, 6, ACCESS
9A66  9EDF     BCF INDF2, 7, ACCESS
9A68  D01A     BRA 0x9A9E
300:                           else SPort[i].Timer++; //kontynuacja odliczania
9A6A  0E01     MOVLW 0x1
9A6C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
9A6E  501D     MOVF _DtCSf_lo, W, ACCESS
9A70  0D01     MULLW 0x1
9A72  0E00     MOVLW 0x0
9A74  24F3     ADDWF PROD, W, ACCESS
9A76  6ED9     MOVWF FSR2, ACCESS
9A78  0E01     MOVLW 0x1
9A7A  20F4     ADDWFC PRODH, W, ACCESS
9A7C  6EDA     MOVWF FSR2H, ACCESS
9A7E  30DF     RRCF INDF2, W, ACCESS
9A80  6E1B     MOVWF _DtCSf_error, ACCESS
9A82  301B     RRCF _DtCSf_error, W, ACCESS
9A84  0B3F     ANDLW 0x3F
9A86  6E1B     MOVWF _DtCSf_error, ACCESS
9A88  501A     MOVF _DtCOf_zroPCO, W, ACCESS
9A8A  261B     ADDWF _DtCSf_error, F, ACCESS
9A8C  361B     RLCF _DtCSf_error, F, ACCESS
9A8E  361B     RLCF _DtCSf_error, F, ACCESS
9A90  50DF     MOVF INDF2, W, ACCESS
9A92  181B     XORWF _DtCSf_error, W, ACCESS
9A94  0B03     ANDLW 0x3
9A96  181B     XORWF _DtCSf_error, W, ACCESS
9A98  0101     MOVLB 0x1
9A9A  6EDF     MOVWF INDF2, ACCESS
301:                       }
302:                   }
9A9C  D000     BRA 0x9A9E
303:               }
304:           }
9AA8  0012     RETURN 0
305:           //----------------------------------------------------------------------------------
306:           //Odczyt stanu portu nr Index
307:           
308:           bit RdPrt(const unsigned char Index)
E7FA  0100     MOVLB 0x0
E7FC  6FDF     MOVWF pco, BANKED
EAC6  6E17     MOVWF _DtCOf_su_CO, ACCESS
309:           {
310:               if(Index > _NVPORT - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
E7FE  0E19     MOVLW 0x19
E800  0100     MOVLB 0x0
E802  65DF     CPFSGT pco, BANKED
E804  D002     BRA 0xE80A
E806  00FF     RESET
E808  D000     BRA 0xE80A
EAC8  0E19     MOVLW 0x19
EACA  6417     CPFSGT _DtCOf_su_CO, ACCESS
EACC  D002     BRA 0xEAD2
EACE  00FF     RESET
EAD0  D000     BRA 0xEAD2
311:               return SPort[Index].Output;
E80A  0100     MOVLB 0x0
E80C  51DF     MOVF pco, W, BANKED
E80E  0D01     MULLW 0x1
E810  0E00     MOVLW 0x0
E812  24F3     ADDWF PROD, W, ACCESS
E814  6ED9     MOVWF FSR2, ACCESS
E816  0E01     MOVLW 0x1
E818  20F4     ADDWFC PRODH, W, ACCESS
E81A  6EDA     MOVWF FSR2H, ACCESS
E81C  A2DF     BTFSS INDF2, 1, ACCESS
E81E  D003     BRA 0xE826
E820  6BDE     CLRF __pcstackBANK0, BANKED
E822  2BDE     INCF __pcstackBANK0, F, BANKED
E824  D002     BRA 0xE82A
E826  0100     MOVLB 0x0
E828  6BDE     CLRF __pcstackBANK0, BANKED
E82A  0100     MOVLB 0x0
E82C  31DE     RRCF __pcstackBANK0, W, BANKED
E82E  0012     RETURN 0
EAD2  5017     MOVF _DtCOf_su_CO, W, ACCESS
EAD4  0D01     MULLW 0x1
EAD6  0E00     MOVLW 0x0
EAD8  24F3     ADDWF PROD, W, ACCESS
EADA  6ED9     MOVWF FSR2, ACCESS
EADC  0E01     MOVLW 0x1
EADE  20F4     ADDWFC PRODH, W, ACCESS
EAE0  6EDA     MOVWF FSR2H, ACCESS
EAE2  0101     MOVLB 0x1
EAE4  A2DF     BTFSS INDF2, 1, ACCESS
EAE6  D003     BRA 0xEAEE
EAE8  6A16     CLRF _DtCOf_resPCO, ACCESS
EAEA  2A16     INCF _DtCOf_resPCO, F, ACCESS
EAEC  D001     BRA 0xEAF0
EAEE  6A16     CLRF _DtCOf_resPCO, ACCESS
EAF0  3016     RRCF _DtCOf_resPCO, W, ACCESS
EAF2  0012     RETURN 0
312:           }
E830  0012     RETURN 0
EAF4  0012     RETURN 0
313:           //----------------------------------------------------------------------------------
314:           //Ustaw stan portu nr Index
315:           
316:           void SetPrt(const unsigned char Index, const unsigned char nw)
DA02  0100     MOVLB 0x0
DA04  6FE0     MOVWF bdat, BANKED
317:           {
318:               if(Index > _NVPORT - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
DA06  0E19     MOVLW 0x19
DA08  0100     MOVLB 0x0
DA0A  65E0     CPFSGT bdat, BANKED
DA0C  D002     BRA 0xDA12
DA0E  00FF     RESET
DA10  D000     BRA 0xDA12
319:               SPort[Index].Output = ((!nw) ? 0 : 1);
DA12  0100     MOVLB 0x0
DA14  51DE     MOVF __pcstackBANK0, W, BANKED
DA16  E003     BZ 0xDA1E
DA18  6BDF     CLRF pco, BANKED
DA1A  2BDF     INCF pco, F, BANKED
DA1C  D002     BRA 0xDA22
DA1E  0100     MOVLB 0x0
DA20  6BDF     CLRF pco, BANKED
DA22  0100     MOVLB 0x0
DA24  51E0     MOVF bdat, W, BANKED
DA26  0D01     MULLW 0x1
DA28  0E00     MOVLW 0x0
DA2A  24F3     ADDWF PROD, W, ACCESS
DA2C  6ED9     MOVWF FSR2, ACCESS
DA2E  0E01     MOVLW 0x1
DA30  20F4     ADDWFC PRODH, W, ACCESS
DA32  6EDA     MOVWF FSR2H, ACCESS
DA34  47DF     RLNCF pco, F, BANKED
DA36  50DF     MOVF INDF2, W, ACCESS
DA38  19DF     XORWF pco, W, BANKED
DA3A  0BFD     ANDLW 0xFD
DA3C  19DF     XORWF pco, W, BANKED
DA3E  6EDF     MOVWF INDF2, ACCESS
320:               SPort[Index].Timer = 0;
DA40  51E0     MOVF bdat, W, BANKED
DA42  0D01     MULLW 0x1
DA44  0E00     MOVLW 0x0
DA46  24F3     ADDWF PROD, W, ACCESS
DA48  6ED9     MOVWF FSR2, ACCESS
DA4A  0E01     MOVLW 0x1
DA4C  20F4     ADDWFC PRODH, W, ACCESS
DA4E  6EDA     MOVWF FSR2H, ACCESS
DA50  94DF     BCF INDF2, 2, ACCESS
DA52  96DF     BCF INDF2, 3, ACCESS
DA54  98DF     BCF INDF2, 4, ACCESS
DA56  9ADF     BCF INDF2, 5, ACCESS
DA58  9CDF     BCF INDF2, 6, ACCESS
DA5A  9EDF     BCF INDF2, 7, ACCESS
321:           }
DA5C  0012     RETURN 0
322:           //----------------------------------------------------------------------------------
323:           //Natychmiastowa aktualizacja stanu portu nr Index
324:           
325:           void RefPrt(const unsigned char Index)
326:           {
327:               if(Index > _NVPORT - 1) asm("RESET"); //obsluga sytuacji wyjatkowej
328:               SPort[Index].Output = SPort[Index].Input;
329:               SPort[Index].Timer = 0;
330:           }
331:           //----------------------------------------------------------------------------------
332:           #endif
333:           //----------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/pompa.c  ---------------------------------
1:             /*pompa.c*/
2:             /*---------------------------------------------------------------------------------*/
3:             #include <pic18.h>
4:             #include "global.h"				//parametry globalne
5:             #include "pompa.h"			//parametry lokalne
6:             #include "main.tp.h"
7:             #include "pomiar.tp.h"			
8:             #include "konfig2.tp.h"
9:             #include "pwm.tp.h"
10:            #include "rgl.tp.h"
11:            
12:            volatile DtPMP PMP;
13:            extern DtRgl rgl;
14:            extern tpMAIN M;
15:            extern DtPWM PWM;
16:            extern DataIN DtIN;
17:            extern DtKONF DtKNF;
18:            //extern tpRSDTA1 RSDT1;
19:            extern DataCO DtCO;
20:            
21:            //extern unsigned char xxy,zzz,vvv,mmm;
22:            //--------------------------------------------------------------------------------------
23:            //--------------------------------------------------------------------------------------
24:            //Zwraca wartosc wypelnienia PWM dla podanej wartosci %
25:            
26:            unsigned char ProcToPmpPwm(unsigned char prc)
DE08  0100     MOVLB 0x0
DE0A  6FEB     MOVWF pop, BANKED
27:            {
28:                unsigned int p;
29:            
30:                if(prc > 100) prc = 100;
DE0C  0E64     MOVLW 0x64
DE0E  0100     MOVLB 0x0
DE10  65EB     CPFSGT pop, BANKED
DE12  D002     BRA 0xDE18
DE14  6FEB     MOVWF pop, BANKED
DE16  D000     BRA 0xDE18
31:                p = PWM.HIPWM;
DE18  C066     MOVFF 0x66, dt
DE1A  F0EC     NOP
DE1C  0100     MOVLB 0x0
DE1E  6BED     CLRF min, BANKED
32:                p = (prc * p) / 100; //pmppwm/100 - ziarno przypadajace na 1%
DE20  C0EB     MOVFF pop, __pcstackBANK0
DE22  F0DE     NOP
DE24  0100     MOVLB 0x0
DE26  6BDF     CLRF pco, BANKED
DE28  C0EC     MOVFF dt, bdat
DE2A  F0E0     NOP
DE2C  C0ED     MOVFF min, GIE_BIT_VAL
DE2E  F0E1     NOP
DE30  EC5B     CALL 0xECB6, 0
DE32  F076     NOP
DE34  C0DE     MOVFF __pcstackBANK0, k
DE36  F0E4     NOP
DE38  C0DF     MOVFF pco, k
DE3A  F0E5     NOP
DE3C  0100     MOVLB 0x0
DE3E  6BE7     CLRF sign, BANKED
DE40  0E64     MOVLW 0x64
DE42  6FE6     MOVWF counter, BANKED
DE44  EC0B     CALL 0xD816, 0
DE46  F06C     NOP
DE48  C0E4     MOVFF k, dt
DE4A  F0EC     NOP
DE4C  C0E5     MOVFF k, min
DE4E  F0ED     NOP
33:                return(unsigned char)p;
DE50  0100     MOVLB 0x0
DE52  51EC     MOVF dt, W, BANKED
DE54  0012     RETURN 0
34:            }
DE56  0012     RETURN 0
35:            
36:            //--------------------------------------------------------------------------------------
37:            //--------------------------------------------------------------------------------------
38:            //Modulator ze wzgledu na delta T = DtIN.DDLT
39:            
40:            unsigned char ModPmp1(unsigned char p)
70CA  0100     MOVLB 0x0
70CC  6FE9     MOVWF p, BANKED
41:            {
42:                unsigned char ppwm, tim, pup, pdw;
43:            
44:                ppwm = p;
70CE  C0E9     MOVFF p, min
70D0  F0ED     NOP
45:            
46:                if(rglf_fz || ppwm != PMP.MGPROC) //aktywny modulator pomy i faza 2 modulacji?
70D2  B815     BTFSC rglf_btcw, 4, ACCESS
70D4  D005     BRA 0x70E0
70D6  0100     MOVLB 0x0
70D8  51ED     MOVF min, W, BANKED
70DA  183E     XORWF PMP, W, ACCESS
70DC  E101     BNZ 0x70E0
70DE  D15B     BRA 0x7396
47:                {
48:            
49:                    if(DtIN.DIN2 > DtIN.DDLT)
70E0  0101     MOVLB 0x1
70E2  511D     MOVF _DtCSf_lo, W, BANKED
70E4  5D1E     SUBWF _DtCSf_no, W, BANKED
70E6  E234     BC 0x7150
50:                    {
51:                        //tim=50;
52:                        tim = 100;
70E8  0E64     MOVLW 0x64
70EA  0100     MOVLB 0x0
70EC  6FEA     MOVWF tim, BANKED
53:                        if(DtIN.DIN2 - DtIN.DDLT == 2) tim = 120; //tim=100;
70EE  0101     MOVLB 0x1
70F0  511E     MOVF _DtCSf_no, W, BANKED
70F2  0100     MOVLB 0x0
70F4  6FE2     MOVWF divisor, BANKED
70F6  6BE3     CLRF a, BANKED
70F8  1FE2     COMF divisor, F, BANKED
70FA  1FE3     COMF a, F, BANKED
70FC  4BE2     INFSNZ divisor, F, BANKED
70FE  2BE3     INCF a, F, BANKED
7100  0101     MOVLB 0x1
7102  511D     MOVF _DtCSf_lo, W, BANKED
7104  0100     MOVLB 0x0
7106  6FE4     MOVWF k, BANKED
7108  6BE5     CLRF k, BANKED
710A  51E2     MOVF divisor, W, BANKED
710C  27E4     ADDWF k, F, BANKED
710E  51E3     MOVF a, W, BANKED
7110  23E5     ADDWFC k, F, BANKED
7112  0E02     MOVLW 0x2
7114  19E4     XORWF k, W, BANKED
7116  11E5     IORWF k, W, BANKED
7118  E102     BNZ 0x711E
711A  0E78     MOVLW 0x78
711C  D016     BRA 0x714A
54:                        else
55:                            if(DtIN.DIN2 - DtIN.DDLT == 1) tim = 150; //tim=150;
711E  0101     MOVLB 0x1
7120  511E     MOVF _DtCSf_no, W, BANKED
7122  0100     MOVLB 0x0
7124  6FE2     MOVWF divisor, BANKED
7126  6BE3     CLRF a, BANKED
7128  1FE2     COMF divisor, F, BANKED
712A  1FE3     COMF a, F, BANKED
712C  4BE2     INFSNZ divisor, F, BANKED
712E  2BE3     INCF a, F, BANKED
7130  0101     MOVLB 0x1
7132  511D     MOVF _DtCSf_lo, W, BANKED
7134  0100     MOVLB 0x0
7136  6FE4     MOVWF k, BANKED
7138  6BE5     CLRF k, BANKED
713A  51E2     MOVF divisor, W, BANKED
713C  27E4     ADDWF k, F, BANKED
713E  51E3     MOVF a, W, BANKED
7140  23E5     ADDWFC k, F, BANKED
7142  05E4     DECF k, W, BANKED
7144  11E5     IORWF k, W, BANKED
7146  E137     BNZ 0x71B6
7148  D01C     BRA 0x7182
714A  0100     MOVLB 0x0
714C  6FEA     MOVWF tim, BANKED
56:                    }
714E  D033     BRA 0x71B6
57:                    else
58:                    {
59:                        //tim=80;
60:                        tim = 120;
7150  0E78     MOVLW 0x78
7152  0100     MOVLB 0x0
7154  6FEA     MOVWF tim, BANKED
61:                        if(DtIN.DDLT - DtIN.DIN2 == 2) tim = 150; //tim=100;
7156  0101     MOVLB 0x1
7158  511D     MOVF _DtCSf_lo, W, BANKED
715A  0100     MOVLB 0x0
715C  6FE2     MOVWF divisor, BANKED
715E  6BE3     CLRF a, BANKED
7160  1FE2     COMF divisor, F, BANKED
7162  1FE3     COMF a, F, BANKED
7164  4BE2     INFSNZ divisor, F, BANKED
7166  2BE3     INCF a, F, BANKED
7168  0101     MOVLB 0x1
716A  511E     MOVF _DtCSf_no, W, BANKED
716C  0100     MOVLB 0x0
716E  6FE4     MOVWF k, BANKED
7170  6BE5     CLRF k, BANKED
7172  51E2     MOVF divisor, W, BANKED
7174  27E4     ADDWF k, F, BANKED
7176  51E3     MOVF a, W, BANKED
7178  23E5     ADDWFC k, F, BANKED
717A  0E02     MOVLW 0x2
717C  19E4     XORWF k, W, BANKED
717E  11E5     IORWF k, W, BANKED
7180  E102     BNZ 0x7186
7182  0E96     MOVLW 0x96
7184  D7E2     BRA 0x714A
62:                        else
63:                            if(DtIN.DDLT - DtIN.DIN2 == 1) tim = 180; //tim=150;
7186  0101     MOVLB 0x1
7188  511D     MOVF _DtCSf_lo, W, BANKED
718A  0100     MOVLB 0x0
718C  6FE2     MOVWF divisor, BANKED
718E  6BE3     CLRF a, BANKED
7190  1FE2     COMF divisor, F, BANKED
7192  1FE3     COMF a, F, BANKED
7194  4BE2     INFSNZ divisor, F, BANKED
7196  2BE3     INCF a, F, BANKED
7198  0101     MOVLB 0x1
719A  511E     MOVF _DtCSf_no, W, BANKED
719C  0100     MOVLB 0x0
719E  6FE4     MOVWF k, BANKED
71A0  6BE5     CLRF k, BANKED
71A2  51E2     MOVF divisor, W, BANKED
71A4  27E4     ADDWF k, F, BANKED
71A6  51E3     MOVF a, W, BANKED
71A8  23E5     ADDWFC k, F, BANKED
71AA  05E4     DECF k, W, BANKED
71AC  11E5     IORWF k, W, BANKED
71AE  E103     BNZ 0x71B6
71B0  0EB4     MOVLW 0xB4
71B2  D7CB     BRA 0x714A
71B4  D000     BRA 0x71B6
64:                    }
65:                    pup = 0;
71B6  0100     MOVLB 0x0
71B8  6BEC     CLRF dt, BANKED
66:                    pdw = 0;
71BA  6BEB     CLRF pop, BANKED
67:                    if((RTdS(_RTPMOD) > tim) || (ppwm <= PMP.MDPROC) || (ppwm >= PMP.MGPROC))
71BC  0E08     MOVLW 0x8
71BE  ECD7     CALL 0xEBAE, 0
71C0  F075     NOP
71C2  0100     MOVLB 0x0
71C4  6FE2     MOVWF divisor, BANKED
71C6  51E2     MOVF divisor, W, BANKED
71C8  5DEA     SUBWF tim, W, BANKED
71CA  E307     BNC 0x71DA
71CC  51ED     MOVF min, W, BANKED
71CE  5C3F     SUBWF 0x3F, W, ACCESS
71D0  E204     BC 0x71DA
71D2  503E     MOVF PMP, W, ACCESS
71D4  5DED     SUBWF min, W, BANKED
71D6  E201     BC 0x71DA
71D8  D0E4     BRA 0x73A2
68:                    {
69:                        StartRTdS(_RTPMOD);
71DA  0E08     MOVLW 0x8
71DC  ECA0     CALL 0xE540, 0
71DE  F072     NOP
70:                        //-------------------------
71:                        if(!pup)
71E0  0100     MOVLB 0x0
71E2  51EC     MOVF dt, W, BANKED
71E4  E129     BNZ 0x7238
72:                            if(rgl.tmp_pwm <= PWM.MINPWM)
71E6  503D     MOVF 0x3D, W, ACCESS
71E8  5D80     SUBWF _PFNf_oflato, W, BANKED
71EA  E326     BNC 0x7238
73:                            {
74:                                if(Twyzsza(2) || Tnizsza(2))
71EC  0E02     MOVLW 0x2
71EE  ECC5     CALL 0xE78A, 0
71F0  F073     NOP
71F2  E204     BC 0x71FC
71F4  0E02     MOVLW 0x2
71F6  ECDA     CALL 0xEFB4, 0
71F8  F077     NOP
71FA  E31E     BNC 0x7238
75:                                {
76:                                    if(ppwm < PMP.MGPROC)
71FC  503E     MOVF PMP, W, ACCESS
71FE  0100     MOVLB 0x0
7200  5DED     SUBWF min, W, BANKED
7202  E21A     BC 0x7238
77:                                    {
78:                                        if(((ppwm + _PMPKUP) < PMP.MGPROC))
7204  503E     MOVF PMP, W, ACCESS
7206  6FE2     MOVWF divisor, BANKED
7208  6BE3     CLRF a, BANKED
720A  51ED     MOVF min, W, BANKED
720C  6FE4     MOVWF k, BANKED
720E  6BE5     CLRF k, BANKED
7210  2BE4     INCF k, F, BANKED
7212  0E00     MOVLW 0x0
7214  23E5     ADDWFC k, F, BANKED
7216  51E2     MOVF divisor, W, BANKED
7218  5DE4     SUBWF k, W, BANKED
721A  51E5     MOVF k, W, BANKED
721C  0A80     XORLW 0x80
721E  6FE6     MOVWF counter, BANKED
7220  51E3     MOVF a, W, BANKED
7222  0A80     XORLW 0x80
7224  59E6     SUBWFB counter, W, BANKED
7226  E205     BC 0x7232
79:                                        {
80:                                            ppwm += _PMPKUP;
7228  2BED     INCF min, F, BANKED
81:                                            pup = 1;
722A  0E01     MOVLW 0x1
722C  0100     MOVLB 0x0
722E  6FEC     MOVWF dt, BANKED
82:                                        }
7230  D003     BRA 0x7238
83:                                        else ppwm = PMP.MGPROC;
7232  C03E     MOVFF PMP, min
7234  F0ED     NOP
84:                                    }
85:                                }
86:                            }
7236  D000     BRA 0x7238
87:                        //-------------------------
88:                        if(rgl.tmp_pwm > PWM.MINPWM || ((rgl.tmp_pwm <= PWM.MINPWM) && !Twyzsza(1)))
7238  503D     MOVF 0x3D, W, ACCESS
723A  0100     MOVLB 0x0
723C  5D80     SUBWF _PFNf_oflato, W, BANKED
723E  E307     BNC 0x724E
7240  503D     MOVF 0x3D, W, ACCESS
7242  5D80     SUBWF _PFNf_oflato, W, BANKED
7244  E357     BNC 0x72F4
7246  0E01     MOVLW 0x1
7248  ECC5     CALL 0xE78A, 0
724A  F073     NOP
724C  E253     BC 0x72F4
89:                        {
90:                            if(DtIN.DIN < DtIN.DDLT)
724E  0101     MOVLB 0x1
7250  511E     MOVF _DtCSf_no, W, BANKED
7252  5D1C     SUBWF _DtCSf_hi, W, BANKED
7254  E24F     BC 0x72F4
91:                            {
92:                                if(!pdw)
7256  0100     MOVLB 0x0
7258  51EB     MOVF pop, W, BANKED
725A  E122     BNZ 0x72A0
93:                                    if(ppwm > PMP.MDPROC)
725C  51ED     MOVF min, W, BANKED
725E  5C3F     SUBWF 0x3F, W, ACCESS
7260  E21F     BC 0x72A0
94:                                    {
95:                                        if(((ppwm - _PMPKDW) > PMP.MDPROC))
7262  0EFE     MOVLW 0xFE
7264  6FE2     MOVWF divisor, BANKED
7266  69E3     SETF a, BANKED
7268  51ED     MOVF min, W, BANKED
726A  6FE4     MOVWF k, BANKED
726C  6BE5     CLRF k, BANKED
726E  51E2     MOVF divisor, W, BANKED
7270  27E4     ADDWF k, F, BANKED
7272  51E3     MOVF a, W, BANKED
7274  23E5     ADDWFC k, F, BANKED
7276  503F     MOVF 0x3F, W, ACCESS
7278  6FE6     MOVWF counter, BANKED
727A  6BE7     CLRF sign, BANKED
727C  51E4     MOVF k, W, BANKED
727E  5DE6     SUBWF counter, W, BANKED
7280  51E7     MOVF sign, W, BANKED
7282  0A80     XORLW 0x80
7284  6FE8     MOVWF quotient, BANKED
7286  51E5     MOVF k, W, BANKED
7288  0A80     XORLW 0x80
728A  59E8     SUBWFB quotient, W, BANKED
728C  E206     BC 0x729A
96:                                        {
97:                                            ppwm -= _PMPKDW;
728E  0E02     MOVLW 0x2
7290  5FED     SUBWF min, F, BANKED
98:                                            pdw = 1;
7292  0E01     MOVLW 0x1
7294  0100     MOVLB 0x0
7296  6FEB     MOVWF pop, BANKED
99:                                        }
7298  D003     BRA 0x72A0
100:                                       else ppwm = PMP.MDPROC;
729A  C03F     MOVFF 0x3F, min
729C  F0ED     NOP
101:                                   }
729E  D000     BRA 0x72A0
102:                               if(!pdw)
72A0  0100     MOVLB 0x0
72A2  51EB     MOVF pop, W, BANKED
72A4  E127     BNZ 0x72F4
103:                                   if(DtIN.DIN < DtIN.DIN2)
72A6  0101     MOVLB 0x1
72A8  511D     MOVF _DtCSf_lo, W, BANKED
72AA  5D1C     SUBWF _DtCSf_hi, W, BANKED
72AC  E223     BC 0x72F4
104:                                   {
105:                                       if(ppwm > PMP.MDPROC)
72AE  0100     MOVLB 0x0
72B0  51ED     MOVF min, W, BANKED
72B2  5C3F     SUBWF 0x3F, W, ACCESS
72B4  E21F     BC 0x72F4
106:                                       {
107:                                           if(((ppwm - _PMPKDW) > PMP.MDPROC))
72B6  0EFE     MOVLW 0xFE
72B8  6FE2     MOVWF divisor, BANKED
72BA  69E3     SETF a, BANKED
72BC  51ED     MOVF min, W, BANKED
72BE  6FE4     MOVWF k, BANKED
72C0  6BE5     CLRF k, BANKED
72C2  51E2     MOVF divisor, W, BANKED
72C4  27E4     ADDWF k, F, BANKED
72C6  51E3     MOVF a, W, BANKED
72C8  23E5     ADDWFC k, F, BANKED
72CA  503F     MOVF 0x3F, W, ACCESS
72CC  6FE6     MOVWF counter, BANKED
72CE  6BE7     CLRF sign, BANKED
72D0  51E4     MOVF k, W, BANKED
72D2  5DE6     SUBWF counter, W, BANKED
72D4  51E7     MOVF sign, W, BANKED
72D6  0A80     XORLW 0x80
72D8  6FE8     MOVWF quotient, BANKED
72DA  51E5     MOVF k, W, BANKED
72DC  0A80     XORLW 0x80
72DE  59E8     SUBWFB quotient, W, BANKED
72E0  E206     BC 0x72EE
108:                                           {
109:                                               ppwm -= _PMPKDW;
72E2  0E02     MOVLW 0x2
72E4  5FED     SUBWF min, F, BANKED
110:                                               pdw = 1;
72E6  0E01     MOVLW 0x1
72E8  0100     MOVLB 0x0
72EA  6FEB     MOVWF pop, BANKED
111:                                           }
72EC  D003     BRA 0x72F4
112:                                           else ppwm = PMP.MDPROC;
72EE  C03F     MOVFF 0x3F, min
72F0  F0ED     NOP
113:                                       }
114:                                   }
115:                           }
72F2  D000     BRA 0x72F4
116:                       }
117:                       //-------------------------
118:                       if(rgl.tmp_pwm < PWM.MAXPWM || ((rgl.tmp_pwm >= PWM.MAXPWM) && !Tnizsza(1)))
72F4  0100     MOVLB 0x0
72F6  5181     MOVF _PFNf_ofnserw, W, BANKED
72F8  5C3D     SUBWF 0x3D, W, ACCESS
72FA  E307     BNC 0x730A
72FC  5181     MOVF _PFNf_ofnserw, W, BANKED
72FE  5C3D     SUBWF 0x3D, W, ACCESS
7300  E350     BNC 0x73A2
7302  0E01     MOVLW 0x1
7304  ECDA     CALL 0xEFB4, 0
7306  F077     NOP
7308  E24C     BC 0x73A2
119:                       {
120:                           if(DtIN.DIN > DtIN.DDLT)
730A  0101     MOVLB 0x1
730C  511C     MOVF _DtCSf_hi, W, BANKED
730E  5D1E     SUBWF _DtCSf_no, W, BANKED
7310  E248     BC 0x73A2
121:                           {
122:                               if(!pup)
7312  0100     MOVLB 0x0
7314  51EC     MOVF dt, W, BANKED
7316  E11D     BNZ 0x7352
123:                                   if(ppwm < PMP.MGPROC)
7318  503E     MOVF PMP, W, ACCESS
731A  5DED     SUBWF min, W, BANKED
731C  E21A     BC 0x7352
124:                                   {
125:                                       if(((ppwm + _PMPKUP) < PMP.MGPROC))
731E  503E     MOVF PMP, W, ACCESS
7320  6FE2     MOVWF divisor, BANKED
7322  6BE3     CLRF a, BANKED
7324  51ED     MOVF min, W, BANKED
7326  6FE4     MOVWF k, BANKED
7328  6BE5     CLRF k, BANKED
732A  2BE4     INCF k, F, BANKED
732C  0E00     MOVLW 0x0
732E  23E5     ADDWFC k, F, BANKED
7330  51E2     MOVF divisor, W, BANKED
7332  5DE4     SUBWF k, W, BANKED
7334  51E5     MOVF k, W, BANKED
7336  0A80     XORLW 0x80
7338  6FE6     MOVWF counter, BANKED
733A  51E3     MOVF a, W, BANKED
733C  0A80     XORLW 0x80
733E  59E6     SUBWFB counter, W, BANKED
7340  E205     BC 0x734C
126:                                       {
127:                                           ppwm += _PMPKUP;
7342  2BED     INCF min, F, BANKED
128:                                           pup = 1;
7344  0E01     MOVLW 0x1
7346  0100     MOVLB 0x0
7348  6FEC     MOVWF dt, BANKED
129:                                       }
734A  D003     BRA 0x7352
130:                                       else ppwm = PMP.MGPROC;
734C  C03E     MOVFF PMP, min
734E  F0ED     NOP
131:                                   }
7350  D000     BRA 0x7352
132:                               if(!pup)
7352  0100     MOVLB 0x0
7354  51EC     MOVF dt, W, BANKED
7356  E125     BNZ 0x73A2
133:                                   if(DtIN.DIN > DtIN.DIN2)
7358  0101     MOVLB 0x1
735A  511C     MOVF _DtCSf_hi, W, BANKED
735C  5D1D     SUBWF _DtCSf_lo, W, BANKED
735E  E221     BC 0x73A2
134:                                   {
135:                                       if(ppwm < PMP.MGPROC)
7360  503E     MOVF PMP, W, ACCESS
7362  0100     MOVLB 0x0
7364  5DED     SUBWF min, W, BANKED
7366  E21D     BC 0x73A2
136:                                       {
137:                                           if(((ppwm + _PMPKUP) < PMP.MGPROC))
7368  503E     MOVF PMP, W, ACCESS
736A  6FE2     MOVWF divisor, BANKED
736C  6BE3     CLRF a, BANKED
736E  51ED     MOVF min, W, BANKED
7370  6FE4     MOVWF k, BANKED
7372  6BE5     CLRF k, BANKED
7374  2BE4     INCF k, F, BANKED
7376  0E00     MOVLW 0x0
7378  23E5     ADDWFC k, F, BANKED
737A  51E2     MOVF divisor, W, BANKED
737C  5DE4     SUBWF k, W, BANKED
737E  51E5     MOVF k, W, BANKED
7380  0A80     XORLW 0x80
7382  6FE6     MOVWF counter, BANKED
7384  51E3     MOVF a, W, BANKED
7386  0A80     XORLW 0x80
7388  59E6     SUBWFB counter, W, BANKED
738A  E208     BC 0x739C
138:                                           {
139:                                               ppwm += _PMPKUP;
738C  2BED     INCF min, F, BANKED
140:                                               pup = 1;
738E  0E01     MOVLW 0x1
7390  0100     MOVLB 0x0
7392  6FEC     MOVWF dt, BANKED
141:                                           }
142:                                           else ppwm = PMP.MGPROC;
143:                                       }
144:                                   }
145:                           }
146:                           //-------------------------
147:                       }
148:                   }
149:               }
7394  D006     BRA 0x73A2
150:               else
151:               {
152:                   StartRTdS(_RTPMOD);
7396  0E08     MOVLW 0x8
7398  ECA0     CALL 0xE540, 0
739A  F072     NOP
153:                   ppwm = PMP.MGPROC;
739C  C03E     MOVFF PMP, min
739E  F0ED     NOP
73A0  D000     BRA 0x73A2
154:               }
155:               return ppwm;
73A2  0100     MOVLB 0x0
73A4  51ED     MOVF min, W, BANKED
73A6  0012     RETURN 0
156:           }
73A8  0012     RETURN 0
157:           //--------------------------------------------------------------------------------------
158:           //-----------------------------------------------------------------------
159:           //Modulacja praca pompy w zaleznosci od wielkosci temp IN (delta zdefiniowana parametrem DtKNF.dtpm)
160:           
161:           void RglPmp1(void)
162:           {
163:               PMP.MGPROC = DtKNF.mgpm; //gorny prog procentowy predkosci
D2B6  C0A3     MOVFF _UADtf_RErrREC, PMP
D2B8  F03E     NOP
164:               PMP.MDPROC = DtKNF.mdpm; //dolny prog procentowy predkosci
D2BA  C0A2     MOVFF _UADtf_RErrBUF, 0x3F
D2BC  F03F     NOP
165:               DtIN.DDLT = DtKNF.dtpm; //docelowa granica delty
D2BE  C0A1     MOVFF _UADtf_REnd, 0x11E
D2C0  F11E     NOP
166:               if(!Mf_PRACA)
D2C2  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
D2C4  D011     BRA 0xD2E8
167:               {
168:                   DtIN.pop = 0;
D2C6  0101     MOVLB 0x1
D2C8  6B2C     CLRF _DtI2Cf_krok, BANKED
169:                   StartRTS(_RTMPMP);
D2CA  0E0E     MOVLW 0xE
D2CC  EC60     CALL 0xE4C0, 0
D2CE  F072     NOP
170:                   if(_POMPA)
D2D0  A483     BTFSS PORTD, 2, ACCESS
D2D2  D003     BRA 0xD2DA
171:                   {
172:                       PMP.APROC = PMP.MGPROC; //pelny wybieg
D2D4  C03E     MOVFF PMP, 0x40
D2D6  F040     NOP
173:                   }
D2D8  D002     BRA 0xD2DE
174:                   else
175:                   {
176:                       PMP.APROC = 0; //minimalizuj straty energii
D2DA  6A40     CLRF 0x40, ACCESS
D2DC  D000     BRA 0xD2DE
177:                   }
178:                   WritePWM2(ProcToPmpPwm(PMP.APROC));
D2DE  5040     MOVF 0x40, W, ACCESS
D2E0  EC04     CALL 0xDE08, 0
D2E2  F06F     NOP
D2E4  EF6D     GOTO 0xF2DA
D2E6  F079     NOP
179:               }
180:               else
181:               {
182:                   if(Mf_MODULUJ && !DtINf_err_IN && !Mf_RPM_CW && RTS(_RTMPMP) > _TPMPBLK) //obieg CO, po rozruchu po ustalonym czasie rozpocznij modulacje pompa
D2E8  B807     BTFSC Mf_BLOKUJ_3M, 4, ACCESS
D2EA  BA05     BTFSC DtKNFf_enknf, 5, ACCESS
D2EC  D011     BRA 0xD310
D2EE  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
D2F0  D00F     BRA 0xD310
D2F2  0E0E     MOVLW 0xE
D2F4  ECA9     CALL 0xEB52, 0
D2F6  F075     NOP
D2F8  0100     MOVLB 0x0
D2FA  6FEE     MOVWF dt, BANKED
D2FC  0E0A     MOVLW 0xA
D2FE  65EE     CPFSGT dt, BANKED
D300  D007     BRA 0xD310
183:                   {
184:                       if(rglf_fz)		//dla fazy 1 narost lub spadek obrotow w rgl.c (IncMaxCO())
D302  A815     BTFSS rglf_btcw, 4, ACCESS
D304  D008     BRA 0xD316
185:           			{
186:                           PMP.APROC = ModPmp1(PMP.APROC);
D306  5040     MOVF 0x40, W, ACCESS
D308  EC65     CALL 0x70CA, 0
D30A  F038     NOP
D30C  6E40     MOVWF 0x40, ACCESS
187:                       }
188:                   }
D30E  D003     BRA 0xD316
189:                   else
190:                   {
191:                       PMP.APROC = PMP.MGPROC;
D310  C03E     MOVFF PMP, 0x40
D312  F040     NOP
D314  D000     BRA 0xD316
192:                   }
193:                   WritePWM2(ProcToPmpPwm(PMP.APROC));
D316  5040     MOVF 0x40, W, ACCESS
D318  EC04     CALL 0xDE08, 0
D31A  F06F     NOP
D31C  EF6D     GOTO 0xF2DA
D31E  F079     NOP
194:               }
195:           }
D320  0012     RETURN 0
196:           //--------------------------------------------------------------------------------------
197:           //--------------------------------------------------------------------------------------
198:           //----------------------------------------ECO------------------------------------------
199:           //--------------------------------------------------------------------------------------
200:           //-----------------------------------------------------------------
201:           //Zswraca mnizsza wartosc
202:           
203:           signed char RetMin(signed char a, signed char b)
EF34  0100     MOVLB 0x0
EF36  6FE3     MOVWF a, BANKED
204:           {
205:               if(a <= b) return a;
EF38  0100     MOVLB 0x0
EF3A  51E1     MOVF GIE_BIT_VAL, W, BANKED
EF3C  0A80     XORLW 0x80
EF3E  6FE2     MOVWF divisor, BANKED
EF40  51E3     MOVF a, W, BANKED
EF42  0A80     XORLW 0x80
EF44  5DE2     SUBWF divisor, W, BANKED
EF46  E302     BNC 0xEF4C
EF48  51E3     MOVF a, W, BANKED
EF4A  0012     RETURN 0
206:               return b;
EF4C  0100     MOVLB 0x0
EF4E  51E1     MOVF GIE_BIT_VAL, W, BANKED
EF50  0012     RETURN 0
207:           }
EF52  0012     RETURN 0
208:           //-----------------------------------------------------------------
209:           //Zwraca wyzsza wartosc
210:           
211:           signed char RetMax(signed char a, signed char b)
EF54  0100     MOVLB 0x0
EF56  6FE0     MOVWF bdat, BANKED
212:           {
213:               if(a >= b) return a;
EF58  0100     MOVLB 0x0
EF5A  51E0     MOVF bdat, W, BANKED
EF5C  0A80     XORLW 0x80
EF5E  6FDF     MOVWF pco, BANKED
EF60  51DE     MOVF __pcstackBANK0, W, BANKED
EF62  0A80     XORLW 0x80
EF64  5DDF     SUBWF pco, W, BANKED
EF66  E302     BNC 0xEF6C
EF68  51E0     MOVF bdat, W, BANKED
EF6A  0012     RETURN 0
214:               return b;
EF6C  0100     MOVLB 0x0
EF6E  51DE     MOVF __pcstackBANK0, W, BANKED
EF70  0012     RETURN 0
215:           }
EF72  0012     RETURN 0
216:           //-----------------------------------------------------------------
217:           //Zwraca wartosc HI zmodyfikowana o wsp ECO
218:           //max - wartosc maksimum ktorej nie chcemy przekroczyc (max PPCO)
219:           
220:           unsigned char RetHI(unsigned char pco, unsigned char eco, unsigned char max)
C00A  0100     MOVLB 0x0
C00C  6FF4     MOVWF pco, BANKED
221:           {
222:               signed char w;
223:               unsigned char k, emax;
224:           
225:               if(pco > max) emax = pco;
C00E  0100     MOVLB 0x0
C010  51F4     MOVF pco, W, BANKED
C012  5DED     SUBWF min, W, BANKED
C014  E203     BC 0xC01C
C016  C0F4     MOVFF pco, ehi
C018  F0F6     NOP
C01A  D003     BRA 0xC022
226:               else emax = max;
C01C  C0ED     MOVFF min, ehi
C01E  F0F6     NOP
C020  D000     BRA 0xC022
227:           
228:               k = (emax - DtIN.Eco5HI) / _PDEKO;
C022  0101     MOVLB 0x1
C024  5124     MOVF _DtCWf_err_CW, W, BANKED
C026  0100     MOVLB 0x0
C028  6FEE     MOVWF dt, BANKED
C02A  6BEF     CLRF 0xEF, BANKED
C02C  1FEE     COMF dt, F, BANKED
C02E  1FEF     COMF 0xEF, F, BANKED
C030  4BEE     INFSNZ dt, F, BANKED
C032  2BEF     INCF 0xEF, F, BANKED
C034  51F6     MOVF ehi, W, BANKED
C036  25EE     ADDWF dt, W, BANKED
C038  6FE4     MOVWF k, BANKED
C03A  0E00     MOVLW 0x0
C03C  21EF     ADDWFC 0xEF, W, BANKED
C03E  6FE5     MOVWF k, BANKED
C040  6BE7     CLRF sign, BANKED
C042  0E04     MOVLW 0x4
C044  6FE6     MOVWF counter, BANKED
C046  EC09     CALL 0xC212, 0
C048  F061     NOP
C04A  0100     MOVLB 0x0
C04C  51E4     MOVF k, W, BANKED
C04E  6FF3     MOVWF min, BANKED
229:               w = (DtIN.Eco5HI + ((_DFEKO - eco) * k));
C050  0100     MOVLB 0x0
C052  51EC     MOVF dt, W, BANKED
C054  0800     SUBLW 0x0
C056  0F05     ADDLW 0x5
C058  03F3     MULWF min, BANKED
C05A  50F3     MOVF PROD, W, ACCESS
C05C  0101     MOVLB 0x1
C05E  2524     ADDWF _DtCWf_err_CW, W, BANKED
C060  0100     MOVLB 0x0
C062  6FF5     MOVWF max, BANKED
230:               if(w <= emax && w >= DtIN.Eco5LO) return w;
C064  0100     MOVLB 0x0
C066  51F6     MOVF ehi, W, BANKED
C068  BFF5     BTFSC max, 7, BANKED
C06A  D003     BRA 0xC072
C06C  0AFF     XORLW 0xFF
C06E  25F5     ADDWF max, W, BANKED
C070  E215     BC 0xC09C
C072  0101     MOVLB 0x1
C074  5125     MOVF _DtCWf_fpCW, W, BANKED
C076  0100     MOVLB 0x0
C078  6FEE     MOVWF dt, BANKED
C07A  6BEF     CLRF 0xEF, BANKED
C07C  C0F5     MOVFF max, p
C07E  F0F0     NOP
C080  6BF1     CLRF m, BANKED
C082  BFF0     BTFSC p, 7, BANKED
C084  07F1     DECF m, F, BANKED
C086  51EE     MOVF dt, W, BANKED
C088  5DF0     SUBWF p, W, BANKED
C08A  51F1     MOVF m, W, BANKED
C08C  0A80     XORLW 0x80
C08E  6FF2     MOVWF tid, BANKED
C090  51EF     MOVF 0xEF, W, BANKED
C092  0A80     XORLW 0x80
C094  59F2     SUBWFB tid, W, BANKED
C096  E302     BNC 0xC09C
C098  51F5     MOVF max, W, BANKED
C09A  0012     RETURN 0
231:               else
232:                   if(w > emax) return emax;
C09C  0100     MOVLB 0x0
C09E  51F6     MOVF ehi, W, BANKED
C0A0  80D8     BSF STATUS, 0, ACCESS
C0A2  84D8     BSF STATUS, 2, ACCESS
C0A4  AFF5     BTFSS max, 7, BANKED
C0A6  5DF5     SUBWF max, W, BANKED
C0A8  A0D8     BTFSS STATUS, 0, ACCESS
C0AA  84D8     BSF STATUS, 2, ACCESS
C0AC  E002     BZ 0xC0B2
C0AE  51F6     MOVF ehi, W, BANKED
C0B0  0012     RETURN 0
233:               else return DtIN.Eco5LO;
C0B2  0101     MOVLB 0x1
C0B4  5125     MOVF _DtCWf_fpCW, W, BANKED
C0B6  0012     RETURN 0
234:           }
C0B8  0012     RETURN 0
235:           //-----------------------------------------------------------------
236:           //Zwraca wartosc LO zmodyfikowana o wsp ECO
237:           //min - wartosc minimum ktorej nie chcemy przekroczyc (10C)
238:           
239:           unsigned char RetLO(unsigned char pco, unsigned char eco, unsigned char min)
BF5A  0100     MOVLB 0x0
BF5C  6FF4     MOVWF pco, BANKED
240:           {
241:               signed char w;
242:               unsigned char k, ehi;
243:           
244:               if(pco < DtIN.Eco5HI) ehi = pco;
BF5E  0101     MOVLB 0x1
BF60  5124     MOVF _DtCWf_err_CW, W, BANKED
BF62  0100     MOVLB 0x0
BF64  5DF4     SUBWF pco, W, BANKED
BF66  E203     BC 0xBF6E
BF68  C0F4     MOVFF pco, ehi
BF6A  F0F6     NOP
BF6C  D003     BRA 0xBF74
245:               else ehi = DtIN.Eco5HI;
BF6E  C124     MOVFF 0x124, ehi
BF70  F0F6     NOP
BF72  D000     BRA 0xBF74
246:           
247:               k = (ehi - DtIN.Eco5LO) / _PDEKO;
BF74  0101     MOVLB 0x1
BF76  5125     MOVF _DtCWf_fpCW, W, BANKED
BF78  0100     MOVLB 0x0
BF7A  6FEE     MOVWF dt, BANKED
BF7C  6BEF     CLRF 0xEF, BANKED
BF7E  1FEE     COMF dt, F, BANKED
BF80  1FEF     COMF 0xEF, F, BANKED
BF82  4BEE     INFSNZ dt, F, BANKED
BF84  2BEF     INCF 0xEF, F, BANKED
BF86  51F6     MOVF ehi, W, BANKED
BF88  25EE     ADDWF dt, W, BANKED
BF8A  6FE4     MOVWF k, BANKED
BF8C  0E00     MOVLW 0x0
BF8E  21EF     ADDWFC 0xEF, W, BANKED
BF90  6FE5     MOVWF k, BANKED
BF92  6BE7     CLRF sign, BANKED
BF94  0E04     MOVLW 0x4
BF96  6FE6     MOVWF counter, BANKED
BF98  EC09     CALL 0xC212, 0
BF9A  F061     NOP
BF9C  0100     MOVLB 0x0
BF9E  51E4     MOVF k, W, BANKED
BFA0  6FF3     MOVWF min, BANKED
248:               w = (DtIN.Eco5LO + ((_DFEKO - eco) * k));
BFA2  0100     MOVLB 0x0
BFA4  51EC     MOVF dt, W, BANKED
BFA6  0800     SUBLW 0x0
BFA8  0F05     ADDLW 0x5
BFAA  03F3     MULWF min, BANKED
BFAC  50F3     MOVF PROD, W, ACCESS
BFAE  0101     MOVLB 0x1
BFB0  2525     ADDWF _DtCWf_fpCW, W, BANKED
BFB2  0100     MOVLB 0x0
BFB4  6FF5     MOVWF max, BANKED
249:           
250:               if(w <= ehi && w >= min) return w;
BFB6  0100     MOVLB 0x0
BFB8  51F6     MOVF ehi, W, BANKED
BFBA  BFF5     BTFSC max, 7, BANKED
BFBC  D003     BRA 0xBFC4
BFBE  0AFF     XORLW 0xFF
BFC0  25F5     ADDWF max, W, BANKED
BFC2  E214     BC 0xBFEC
BFC4  0100     MOVLB 0x0
BFC6  51ED     MOVF min, W, BANKED
BFC8  6FEE     MOVWF dt, BANKED
BFCA  6BEF     CLRF 0xEF, BANKED
BFCC  C0F5     MOVFF max, p
BFCE  F0F0     NOP
BFD0  6BF1     CLRF m, BANKED
BFD2  BFF0     BTFSC p, 7, BANKED
BFD4  07F1     DECF m, F, BANKED
BFD6  51EE     MOVF dt, W, BANKED
BFD8  5DF0     SUBWF p, W, BANKED
BFDA  51F1     MOVF m, W, BANKED
BFDC  0A80     XORLW 0x80
BFDE  6FF2     MOVWF tid, BANKED
BFE0  51EF     MOVF 0xEF, W, BANKED
BFE2  0A80     XORLW 0x80
BFE4  59F2     SUBWFB tid, W, BANKED
BFE6  E302     BNC 0xBFEC
BFE8  51F5     MOVF max, W, BANKED
BFEA  0012     RETURN 0
251:               else
252:                   if(w > ehi) return ehi;
BFEC  0100     MOVLB 0x0
BFEE  51F6     MOVF ehi, W, BANKED
BFF0  80D8     BSF STATUS, 0, ACCESS
BFF2  84D8     BSF STATUS, 2, ACCESS
BFF4  AFF5     BTFSS max, 7, BANKED
BFF6  5DF5     SUBWF max, W, BANKED
BFF8  A0D8     BTFSS STATUS, 0, ACCESS
BFFA  84D8     BSF STATUS, 2, ACCESS
BFFC  E002     BZ 0xC002
BFFE  51F6     MOVF ehi, W, BANKED
C000  0012     RETURN 0
253:               else return min;
C002  0100     MOVLB 0x0
C004  51ED     MOVF min, W, BANKED
C006  0012     RETURN 0
254:           }
C008  0012     RETURN 0
255:           //-----------------------------------------------------------------
256:           //Zwraca wartosc delty wzgledem gornej granicy HI
257:           
258:           signed char RetDelta1(unsigned char pco, unsigned char hi)
F2BA  0100     MOVLB 0x0
F2BC  6FDF     MOVWF pco, BANKED
259:           {
260:               return(pco - hi);
F2BE  0100     MOVLB 0x0
F2C0  51DE     MOVF __pcstackBANK0, W, BANKED
F2C2  0800     SUBLW 0x0
F2C4  25DF     ADDWF pco, W, BANKED
F2C6  0012     RETURN 0
261:           }
F2C8  0012     RETURN 0
262:           //-----------------------------------------------------------------
263:           //Zwraca wartosc delty bezwzglednej zmodyfikowanej o wsp ECO
264:           //Dla ECO=5 jest to wartosc P13
265:           
266:           signed char RetDelta2(unsigned char eco, unsigned char ddlt)
EC0A  0100     MOVLB 0x0
EC0C  6FED     MOVWF min, BANKED
267:           {
268:               unsigned char kD;
269:           
270:               kD = ddlt / _PDEKO;
EC0E  C0EC     MOVFF dt, k
EC10  F0E4     NOP
EC12  0100     MOVLB 0x0
EC14  6BE5     CLRF k, BANKED
EC16  6BE7     CLRF sign, BANKED
EC18  0E04     MOVLW 0x4
EC1A  6FE6     MOVWF counter, BANKED
EC1C  EC09     CALL 0xC212, 0
EC1E  F061     NOP
EC20  0100     MOVLB 0x0
EC22  51E4     MOVF k, W, BANKED
EC24  6FEE     MOVWF dt, BANKED
271:               return(ddlt + (kD * (eco - _DFEKO)));
EC26  0100     MOVLB 0x0
EC28  51ED     MOVF min, W, BANKED
EC2A  0FFB     ADDLW 0xFB
EC2C  03EE     MULWF dt, BANKED
EC2E  50F3     MOVF PROD, W, ACCESS
EC30  25EC     ADDWF dt, W, BANKED
EC32  0012     RETURN 0
272:           }
EC34  0012     RETURN 0
273:           //-----------------------------------------------------------------
274:           //Zwraca wartosc delty wzgledem dolnej granicy LO
275:           
276:           signed char RetDelta3(unsigned char pco, unsigned char lo)
F2AA  0100     MOVLB 0x0
F2AC  6FDF     MOVWF pco, BANKED
277:           {
278:               return(pco - lo);
F2AE  0100     MOVLB 0x0
F2B0  51DE     MOVF __pcstackBANK0, W, BANKED
F2B2  0800     SUBLW 0x0
F2B4  25DF     ADDWF pco, W, BANKED
F2B6  0012     RETURN 0
279:           }
F2B8  0012     RETURN 0
280:           //-----------------------------------------------------------------
281:           //Zwraca wartosc wypadkowa delty
282:           
283:           unsigned char RetDelta4(unsigned char pco, unsigned char eco, unsigned char hi, unsigned char lo)
D8E0  0100     MOVLB 0x0
D8E2  6FFA     MOVWF pco, BANKED
284:           {
285:               signed char d;
286:           
287:               DtIN.delta1 = RetDelta1(pco, hi); //DtIN.HI);
D8E4  C0F8     MOVFF step2, __pcstackBANK0
D8E6  F0DE     NOP
D8E8  0100     MOVLB 0x0
D8EA  51FA     MOVF pco, W, BANKED
D8EC  EC5D     CALL 0xF2BA, 0
D8EE  F079     NOP
D8F0  0101     MOVLB 0x1
D8F2  6F28     MOVWF _DtCWf_su_CW, BANKED
288:               DtIN.delta2 = RetDelta2(eco, _ECODDL);
D8F4  0E14     MOVLW 0x14
D8F6  0100     MOVLB 0x0
D8F8  6FEC     MOVWF dt, BANKED
D8FA  51F7     MOVF step, W, BANKED
D8FC  EC05     CALL 0xEC0A, 0
D8FE  F076     NOP
D900  0101     MOVLB 0x1
D902  6F29     MOVWF _DtCWf_su_DZ_CW, BANKED
289:               DtIN.delta3 = RetDelta3(pco, lo); //DtIN.LO);
D904  C0F9     MOVFF fst, __pcstackBANK0
D906  F0DE     NOP
D908  0100     MOVLB 0x0
D90A  51FA     MOVF pco, W, BANKED
D90C  EC55     CALL 0xF2AA, 0
D90E  F079     NOP
D910  0101     MOVLB 0x1
D912  6F2A     MOVWF _DtCWf_wpz_CW, BANKED
290:               d = RetMin(DtIN.delta3, RetMax(DtIN.delta1, DtIN.delta2));
D914  C129     MOVFF 0x129, __pcstackBANK0
D916  F0DE     NOP
D918  0101     MOVLB 0x1
D91A  5128     MOVF _DtCWf_su_CW, W, BANKED
D91C  ECAA     CALL 0xEF54, 0
D91E  F077     NOP
D920  0100     MOVLB 0x0
D922  6FE1     MOVWF GIE_BIT_VAL, BANKED
D924  0101     MOVLB 0x1
D926  512A     MOVF _DtCWf_wpz_CW, W, BANKED
D928  EC9A     CALL 0xEF34, 0
D92A  F077     NOP
D92C  0100     MOVLB 0x0
D92E  6FFB     MOVWF d, BANKED
291:               if(d > 0) return d;
D930  0100     MOVLB 0x0
D932  51FB     MOVF d, W, BANKED
D934  0A80     XORLW 0x80
D936  0F7F     ADDLW 0x7F
D938  E302     BNC 0xD93E
D93A  51FB     MOVF d, W, BANKED
D93C  0012     RETURN 0
292:               return 0;
D93E  0C00     RETLW 0x0
293:           }
D940  0012     RETURN 0
294:           //-----------------------------------------------------------------
295:           //Zwraca sredni krok zmiany delty przy zmianie ECO o 1
296:           
297:           unsigned char RetKrkDelta(unsigned char pco)
BAD2  0102     MOVLB 0x2
BAD4  6FFA     MOVWF pco, BANKED
298:           {
299:               unsigned char i, d, min, max;
300:           
301:               max = 0;
BAD6  0102     MOVLB 0x2
BAD8  6BFC     CLRF 0xFC, BANKED
302:               min = 100;
BADA  0E64     MOVLW 0x64
BADC  6FFB     MOVWF d, BANKED
303:               for(i = 1; i < 10; i++)
BADE  0E01     MOVLW 0x1
BAE0  6FFE     MOVWF k, BANKED
BAE2  0E09     MOVLW 0x9
BAE4  0102     MOVLB 0x2
BAE6  65FE     CPFSGT k, BANKED
BAE8  D001     BRA 0xBAEC
BAEA  D02E     BRA 0xBB48
BB42  0102     MOVLB 0x2
BB44  2BFE     INCF k, F, BANKED
BB46  D7CD     BRA 0xBAE2
304:               {
305:                   d = RetDelta4(pco, i, RetHI(pco, i, _MAXT), RetLO(pco, i, _MINT));
BAEC  C2FE     MOVFF i, step
BAEE  F0F7     NOP
BAF0  C2FE     MOVFF i, dt
BAF2  F0EC     NOP
BAF4  0E50     MOVLW 0x50
BAF6  0100     MOVLB 0x0
BAF8  6FED     MOVWF min, BANKED
BAFA  0102     MOVLB 0x2
BAFC  51FA     MOVF pco, W, BANKED
BAFE  EC05     CALL 0xC00A, 0
BB00  F060     NOP
BB02  0100     MOVLB 0x0
BB04  6FF8     MOVWF step2, BANKED
BB06  C2FE     MOVFF i, dt
BB08  F0EC     NOP
BB0A  0E0A     MOVLW 0xA
BB0C  6FED     MOVWF min, BANKED
BB0E  0102     MOVLB 0x2
BB10  51FA     MOVF pco, W, BANKED
BB12  ECAD     CALL 0xBF5A, 0
BB14  F05F     NOP
BB16  0100     MOVLB 0x0
BB18  6FF9     MOVWF fst, BANKED
BB1A  0102     MOVLB 0x2
BB1C  51FA     MOVF pco, W, BANKED
BB1E  EC70     CALL 0xD8E0, 0
BB20  F06C     NOP
BB22  0102     MOVLB 0x2
BB24  6FFD     MOVWF 0xFD, BANKED
306:                   if(d > max) max = d;
BB26  0102     MOVLB 0x2
BB28  51FD     MOVF 0xFD, W, BANKED
BB2A  5DFC     SUBWF 0xFC, W, BANKED
BB2C  E203     BC 0xBB34
BB2E  C2FD     MOVFF d, max
BB30  F2FC     NOP
BB32  D000     BRA 0xBB34
307:                   if(d < min) min = d;
BB34  0102     MOVLB 0x2
BB36  51FB     MOVF d, W, BANKED
BB38  5DFD     SUBWF 0xFD, W, BANKED
BB3A  E203     BC 0xBB42
BB3C  C2FD     MOVFF d, min
BB3E  F2FB     NOP
BB40  D000     BRA 0xBB42
308:               }
309:               if(max <= min) return 0;
BB48  0102     MOVLB 0x2
BB4A  51FC     MOVF 0xFC, W, BANKED
BB4C  5DFB     SUBWF d, W, BANKED
BB4E  E302     BNC 0xBB54
BB50  0E00     MOVLW 0x0
BB52  0012     RETURN 0
310:               return((max - min)*10) / 9;
BB54  0102     MOVLB 0x2
BB56  51FB     MOVF d, W, BANKED
BB58  0100     MOVLB 0x0
BB5A  6FFC     MOVWF 0xFC, BANKED
BB5C  6BFD     CLRF 0xFD, BANKED
BB5E  1FFC     COMF 0xFC, F, BANKED
BB60  1FFD     COMF 0xFD, F, BANKED
BB62  4BFC     INFSNZ 0xFC, F, BANKED
BB64  2BFD     INCF 0xFD, F, BANKED
BB66  0102     MOVLB 0x2
BB68  51FC     MOVF 0xFC, W, BANKED
BB6A  0100     MOVLB 0x0
BB6C  25FC     ADDWF 0xFC, W, BANKED
BB6E  6FDE     MOVWF __pcstackBANK0, BANKED
BB70  0E00     MOVLW 0x0
BB72  21FD     ADDWFC 0xFD, W, BANKED
BB74  6FDF     MOVWF pco, BANKED
BB76  6BE1     CLRF GIE_BIT_VAL, BANKED
BB78  0E0A     MOVLW 0xA
BB7A  6FE0     MOVWF bdat, BANKED
BB7C  EC5B     CALL 0xECB6, 0
BB7E  F076     NOP
BB80  C0DE     MOVFF __pcstackBANK0, k
BB82  F0E4     NOP
BB84  C0DF     MOVFF pco, k
BB86  F0E5     NOP
BB88  0100     MOVLB 0x0
BB8A  6BE7     CLRF sign, BANKED
BB8C  0E09     MOVLW 0x9
BB8E  6FE6     MOVWF counter, BANKED
BB90  EC09     CALL 0xC212, 0
BB92  F061     NOP
BB94  0100     MOVLB 0x0
BB96  51E4     MOVF k, W, BANKED
BB98  0012     RETURN 0
311:           }
BB9A  0012     RETURN 0
312:           //-----------------------------------------------------------------
313:           //Zwraca wartosc delty z uwzglednieniem sredniego kroku zmiany delty
314:           
315:           unsigned char RetDelta(unsigned char pco, unsigned char eco)
E3C0  0103     MOVLB 0x3
E3C2  6F75     MOVWF _PFNf_fns_max, BANKED
316:           {
317:               unsigned char k;
318:           
319:               k = RetKrkDelta(pco);
E3C4  0103     MOVLB 0x3
E3C6  5175     MOVF _PFNf_fns_max, W, BANKED
E3C8  EC69     CALL 0xBAD2, 0
E3CA  F05D     NOP
E3CC  0103     MOVLB 0x3
E3CE  6F76     MOVWF _PFNf_fnserw, BANKED
320:               if(eco && k) return(k * (eco)) / 10;
E3D0  0100     MOVLB 0x0
E3D2  51FE     MOVF k, W, BANKED
E3D4  E012     BZ 0xE3FA
E3D6  0103     MOVLB 0x3
E3D8  5176     MOVF _PFNf_fnserw, W, BANKED
E3DA  E00F     BZ 0xE3FA
E3DC  5176     MOVF _PFNf_fnserw, W, BANKED
E3DE  0100     MOVLB 0x0
E3E0  03FE     MULWF k, BANKED
E3E2  CFF3     MOVFF PROD, k
E3E4  F0E4     NOP
E3E6  CFF4     MOVFF PRODH, k
E3E8  F0E5     NOP
E3EA  6BE7     CLRF sign, BANKED
E3EC  0E0A     MOVLW 0xA
E3EE  6FE6     MOVWF counter, BANKED
E3F0  EC09     CALL 0xC212, 0
E3F2  F061     NOP
E3F4  0100     MOVLB 0x0
E3F6  51E4     MOVF k, W, BANKED
E3F8  0012     RETURN 0
321:               else return 0;
E3FA  0E00     MOVLW 0x0
E3FC  0012     RETURN 0
322:           }
E3FE  0012     RETURN 0
323:           //--------------------------------------------------------------------------------------
324:           //--------------------------------------------------------------------------------------
325:           //Modulator - wielkosc delty uzalezniona od parametru ECO i nastawy PPCO
326:           
327:           unsigned char ModPmp2(unsigned char p)
5B38  0103     MOVLB 0x3
5B3A  6F7E     MOVWF _PFNf_obgCW, BANKED
328:           {
329:               unsigned char ppwm, tim, pup, pdw;
330:           
331:               //parametry kluczowe modulacji
332:               DtIN.Eco5LO = _ECO5LO; //dlona granica temp IN dla Eco=5
5B3C  0E19     MOVLW 0x19
5B3E  0101     MOVLB 0x1
5B40  6F25     MOVWF _DtCWf_fpCW, BANKED
333:               DtIN.Eco5HI = _ECO5HI; //gorna granica temp IN dla Eco=5
5B42  0E37     MOVLW 0x37
5B44  6F24     MOVWF _DtCWf_err_CW, BANKED
334:               if(DtIN.PPEco)
5B46  0101     MOVLB 0x1
5B48  5123     MOVF _DtCWf_cold_CW, W, BANKED
5B4A  E01B     BZ 0x5B82
335:               {
336:                   DtIN.HI = RetHI(DtCO.PPCO, DtIN.PPEco - 1, _MAXT); //dlona granica IN dla parametru ECO i nastawy PPCO
5B4C  0523     DECF _DtCWf_cold_CW, W, BANKED
5B4E  0100     MOVLB 0x0
5B50  6FEC     MOVWF dt, BANKED
5B52  0E50     MOVLW 0x50
5B54  6FED     MOVWF min, BANKED
5B56  51D1     MOVF 0xD1, W, BANKED
5B58  EC05     CALL 0xC00A, 0
5B5A  F060     NOP
5B5C  0101     MOVLB 0x1
5B5E  6F26     MOVWF _DtCWf_newPCW, BANKED
337:                   DtIN.LO = RetLO(DtCO.PPCO, DtIN.PPEco - 1, _MINT); //gorna granica IN dla parametru ECO i nastawy PPCO
5B60  0523     DECF _DtCWf_cold_CW, W, BANKED
5B62  0100     MOVLB 0x0
5B64  6FEC     MOVWF dt, BANKED
5B66  0E0A     MOVLW 0xA
5B68  6FED     MOVWF min, BANKED
5B6A  51D1     MOVF 0xD1, W, BANKED
5B6C  ECAD     CALL 0xBF5A, 0
5B6E  F05F     NOP
5B70  0101     MOVLB 0x1
5B72  6F27     MOVWF _DtCWf_on_DZ_CW, BANKED
338:                   DtIN.delta = RetDelta(DtCO.PPCO, DtIN.PPEco - 1); //wartosc delta dla parametru ECO i nastawy PPCO
5B74  0523     DECF _DtCWf_cold_CW, W, BANKED
5B76  0100     MOVLB 0x0
5B78  6FFE     MOVWF k, BANKED
5B7A  51D1     MOVF 0xD1, W, BANKED
5B7C  ECE0     CALL 0xE3C0, 0
5B7E  F071     NOP
5B80  D003     BRA 0x5B88
339:               }
340:               else
341:               {
342:                   DtIN.HI = 0;
5B82  0E00     MOVLW 0x0
5B84  0101     MOVLB 0x1
5B86  6F26     MOVWF _DtCWf_newPCW, BANKED
343:                   DtIN.LO == 0;
344:                   DtIN.delta = 0;
5B88  0101     MOVLB 0x1
5B8A  6F2B     MOVWF _DtCWf_wrtPCW, BANKED
345:               }
346:               if(!DtIN.delta) //dla delta=0 predkosc maksymalna pompy
5B8C  512B     MOVF _DtCWf_wrtPCW, W, BANKED
5B8E  E105     BNZ 0x5B9A
347:               {
348:                   StartRTdS(_RTPMOD);
5B90  0E08     MOVLW 0x8
5B92  ECA0     CALL 0xE540, 0
5B94  F072     NOP
349:                   return PMP.MGPROC;
5B96  503E     MOVF PMP, W, ACCESS
5B98  0012     RETURN 0
350:               }
351:           
352:               //modulacja praca pompy
353:               ppwm = p;
5B9A  C37E     MOVFF p, ppwm
5B9C  F382     NOP
354:           
355:               if(rglf_fz || ppwm != PMP.MGPROC) //aktywny modulator pompy i faza 2 modulacji?
5B9E  B815     BTFSC rglf_btcw, 4, ACCESS
5BA0  D005     BRA 0x5BAC
5BA2  0103     MOVLB 0x3
5BA4  5182     MOVF M, W, BANKED
5BA6  183E     XORWF PMP, W, ACCESS
5BA8  E101     BNZ 0x5BAC
5BAA  D151     BRA 0x5E4E
356:               {
357:                   //wielkosc delty uzalezniona od parametru ECO i nastawy PPCO
358:                   DtIN.cDLT = DtIN.delta;
5BAC  C12B     MOVFF 0x12B, 0x11F
5BAE  F11F     NOP
359:           
360:                   //dobor kroku czasowego dla modyfikacji
361:                   if(DtIN.DIN2 > DtIN.cDLT)
5BB0  0101     MOVLB 0x1
5BB2  511D     MOVF _DtCSf_lo, W, BANKED
5BB4  5D1F     SUBWF _DtCSf_no_mont, W, BANKED
5BB6  E228     BC 0x5C08
362:                   {
363:                       tim = 50;
5BB8  0E32     MOVLW 0x32
5BBA  0103     MOVLB 0x3
5BBC  6F7F     MOVWF _PFNf_off, BANKED
364:                       if(DtIN.DIN2 - DtIN.cDLT == 2) tim = 100;
5BBE  0101     MOVLB 0x1
5BC0  511F     MOVF _DtCSf_no_mont, W, BANKED
5BC2  0103     MOVLB 0x3
5BC4  6F77     MOVWF _PFNf_lato, BANKED
5BC6  6B78     CLRF _PFNf_mod_ncw, BANKED
5BC8  1F77     COMF _PFNf_lato, F, BANKED
5BCA  1F78     COMF _PFNf_mod_ncw, F, BANKED
5BCC  4B77     INFSNZ _PFNf_lato, F, BANKED
5BCE  2B78     INCF _PFNf_mod_ncw, F, BANKED
5BD0  0101     MOVLB 0x1
5BD2  511D     MOVF _DtCSf_lo, W, BANKED
5BD4  0103     MOVLB 0x3
5BD6  6F79     MOVWF _PFNf_newPCO, BANKED
5BD8  6B7A     CLRF _PFNf_newPCW, BANKED
5BDA  5177     MOVF _PFNf_lato, W, BANKED
5BDC  2779     ADDWF _PFNf_newPCO, F, BANKED
5BDE  5178     MOVF _PFNf_mod_ncw, W, BANKED
5BE0  237A     ADDWFC _PFNf_newPCW, F, BANKED
5BE2  0E02     MOVLW 0x2
5BE4  1979     XORWF _PFNf_newPCO, W, BANKED
5BE6  117A     IORWF _PFNf_newPCW, W, BANKED
5BE8  E102     BNZ 0x5BEE
5BEA  0E64     MOVLW 0x64
5BEC  D03C     BRA 0x5C66
365:                       else
366:                           if(DtIN.DIN2 - DtIN.cDLT == 1) tim = 150;
5BEE  0101     MOVLB 0x1
5BF0  511F     MOVF _DtCSf_no_mont, W, BANKED
5BF2  0103     MOVLB 0x3
5BF4  6F77     MOVWF _PFNf_lato, BANKED
5BF6  6B78     CLRF _PFNf_mod_ncw, BANKED
5BF8  1F77     COMF _PFNf_lato, F, BANKED
5BFA  1F78     COMF _PFNf_mod_ncw, F, BANKED
5BFC  4B77     INFSNZ _PFNf_lato, F, BANKED
5BFE  2B78     INCF _PFNf_mod_ncw, F, BANKED
5C00  0101     MOVLB 0x1
5C02  511D     MOVF _DtCSf_lo, W, BANKED
5C04  D025     BRA 0x5C50
367:                   }
5C06  D032     BRA 0x5C6C
368:                   else
369:                   {
370:                       tim = 80;
5C08  0E50     MOVLW 0x50
5C0A  0103     MOVLB 0x3
5C0C  6F7F     MOVWF _PFNf_off, BANKED
371:                       if(DtIN.cDLT - DtIN.DIN2 == 2) tim = 100;
5C0E  0101     MOVLB 0x1
5C10  511D     MOVF _DtCSf_lo, W, BANKED
5C12  0103     MOVLB 0x3
5C14  6F77     MOVWF _PFNf_lato, BANKED
5C16  6B78     CLRF _PFNf_mod_ncw, BANKED
5C18  1F77     COMF _PFNf_lato, F, BANKED
5C1A  1F78     COMF _PFNf_mod_ncw, F, BANKED
5C1C  4B77     INFSNZ _PFNf_lato, F, BANKED
5C1E  2B78     INCF _PFNf_mod_ncw, F, BANKED
5C20  0101     MOVLB 0x1
5C22  511F     MOVF _DtCSf_no_mont, W, BANKED
5C24  0103     MOVLB 0x3
5C26  6F79     MOVWF _PFNf_newPCO, BANKED
5C28  6B7A     CLRF _PFNf_newPCW, BANKED
5C2A  5177     MOVF _PFNf_lato, W, BANKED
5C2C  2779     ADDWF _PFNf_newPCO, F, BANKED
5C2E  5178     MOVF _PFNf_mod_ncw, W, BANKED
5C30  237A     ADDWFC _PFNf_newPCW, F, BANKED
5C32  0E02     MOVLW 0x2
5C34  1979     XORWF _PFNf_newPCO, W, BANKED
5C36  117A     IORWF _PFNf_newPCW, W, BANKED
5C38  E0D8     BZ 0x5BEA
372:                       else
373:                           if(DtIN.cDLT - DtIN.DIN2 == 1) tim = 150;
5C3A  0101     MOVLB 0x1
5C3C  511D     MOVF _DtCSf_lo, W, BANKED
5C3E  0103     MOVLB 0x3
5C40  6F77     MOVWF _PFNf_lato, BANKED
5C42  6B78     CLRF _PFNf_mod_ncw, BANKED
5C44  1F77     COMF _PFNf_lato, F, BANKED
5C46  1F78     COMF _PFNf_mod_ncw, F, BANKED
5C48  4B77     INFSNZ _PFNf_lato, F, BANKED
5C4A  2B78     INCF _PFNf_mod_ncw, F, BANKED
5C4C  0101     MOVLB 0x1
5C4E  511F     MOVF _DtCSf_no_mont, W, BANKED
5C50  0103     MOVLB 0x3
5C52  6F79     MOVWF _PFNf_newPCO, BANKED
5C54  6B7A     CLRF _PFNf_newPCW, BANKED
5C56  5177     MOVF _PFNf_lato, W, BANKED
5C58  2779     ADDWF _PFNf_newPCO, F, BANKED
5C5A  5178     MOVF _PFNf_mod_ncw, W, BANKED
5C5C  237A     ADDWFC _PFNf_newPCW, F, BANKED
5C5E  0579     DECF _PFNf_newPCO, W, BANKED
5C60  117A     IORWF _PFNf_newPCW, W, BANKED
5C62  E104     BNZ 0x5C6C
5C64  0E96     MOVLW 0x96
5C66  0103     MOVLB 0x3
5C68  6F7F     MOVWF _PFNf_off, BANKED
5C6A  D000     BRA 0x5C6C
374:                   }
375:           
376:                   //dobor wypelnienia PWM w zaleznosci od delta T
377:                   pup = 0;
5C6C  0103     MOVLB 0x3
5C6E  6B81     CLRF _PFNf_ofnserw, BANKED
378:                   pdw = 0;
5C70  6B80     CLRF _PFNf_oflato, BANKED
379:                   if((RTdS(_RTPMOD) > tim) || (ppwm <= PMP.MDPROC) || (ppwm >= PMP.MGPROC))
5C72  0E08     MOVLW 0x8
5C74  ECD7     CALL 0xEBAE, 0
5C76  F075     NOP
5C78  0103     MOVLB 0x3
5C7A  6F77     MOVWF _PFNf_lato, BANKED
5C7C  5177     MOVF _PFNf_lato, W, BANKED
5C7E  5D7F     SUBWF _PFNf_off, W, BANKED
5C80  E307     BNC 0x5C90
5C82  5182     MOVF M, W, BANKED
5C84  5C3F     SUBWF 0x3F, W, ACCESS
5C86  E204     BC 0x5C90
5C88  503E     MOVF PMP, W, ACCESS
5C8A  5D82     SUBWF M, W, BANKED
5C8C  E201     BC 0x5C90
5C8E  D0E5     BRA 0x5E5A
380:                   {
381:                       StartRTdS(_RTPMOD);
5C90  0E08     MOVLW 0x8
5C92  ECA0     CALL 0xE540, 0
5C94  F072     NOP
382:                       //-------------------------
383:                       if(!pup)
5C96  0103     MOVLB 0x3
5C98  5181     MOVF _PFNf_ofnserw, W, BANKED
5C9A  E12A     BNZ 0x5CF0
384:                           if(rgl.tmp_pwm <= PWM.MINPWM)
5C9C  503D     MOVF 0x3D, W, ACCESS
5C9E  0100     MOVLB 0x0
5CA0  5D80     SUBWF _PFNf_oflato, W, BANKED
5CA2  E326     BNC 0x5CF0
385:                           {
386:                               if(Twyzsza(2) || Tnizsza(2))
5CA4  0E02     MOVLW 0x2
5CA6  ECC5     CALL 0xE78A, 0
5CA8  F073     NOP
5CAA  E204     BC 0x5CB4
5CAC  0E02     MOVLW 0x2
5CAE  ECDA     CALL 0xEFB4, 0
5CB0  F077     NOP
5CB2  E31E     BNC 0x5CF0
387:                               {
388:                                   if(ppwm < PMP.MGPROC)
5CB4  503E     MOVF PMP, W, ACCESS
5CB6  0103     MOVLB 0x3
5CB8  5D82     SUBWF M, W, BANKED
5CBA  E21A     BC 0x5CF0
389:                                   {
390:                                       if(((ppwm + _PMPKUP) < PMP.MGPROC))
5CBC  503E     MOVF PMP, W, ACCESS
5CBE  6F77     MOVWF _PFNf_lato, BANKED
5CC0  6B78     CLRF _PFNf_mod_ncw, BANKED
5CC2  5182     MOVF M, W, BANKED
5CC4  6F79     MOVWF _PFNf_newPCO, BANKED
5CC6  6B7A     CLRF _PFNf_newPCW, BANKED
5CC8  2B79     INCF _PFNf_newPCO, F, BANKED
5CCA  0E00     MOVLW 0x0
5CCC  237A     ADDWFC _PFNf_newPCW, F, BANKED
5CCE  5177     MOVF _PFNf_lato, W, BANKED
5CD0  5D79     SUBWF _PFNf_newPCO, W, BANKED
5CD2  517A     MOVF _PFNf_newPCW, W, BANKED
5CD4  0A80     XORLW 0x80
5CD6  6F7B     MOVWF _PFNf_newPFN, BANKED
5CD8  5178     MOVF _PFNf_mod_ncw, W, BANKED
5CDA  0A80     XORLW 0x80
5CDC  597B     SUBWFB _PFNf_newPFN, W, BANKED
5CDE  E205     BC 0x5CEA
391:                                       {
392:                                           ppwm += _PMPKUP;
5CE0  2B82     INCF M, F, BANKED
393:                                           pup = 1;
5CE2  0E01     MOVLW 0x1
5CE4  0103     MOVLB 0x3
5CE6  6F81     MOVWF _PFNf_ofnserw, BANKED
394:                                       }
5CE8  D003     BRA 0x5CF0
395:                                       else ppwm = PMP.MGPROC;
5CEA  C03E     MOVFF PMP, ppwm
5CEC  F382     NOP
396:                                   }
397:                               }
398:                           }
5CEE  D000     BRA 0x5CF0
399:                       //-------------------------
400:                       if(rgl.tmp_pwm > PWM.MINPWM || ((rgl.tmp_pwm <= PWM.MINPWM) && !Twyzsza(1)))
5CF0  503D     MOVF 0x3D, W, ACCESS
5CF2  0100     MOVLB 0x0
5CF4  5D80     SUBWF _PFNf_oflato, W, BANKED
5CF6  E307     BNC 0x5D06
5CF8  503D     MOVF 0x3D, W, ACCESS
5CFA  5D80     SUBWF _PFNf_oflato, W, BANKED
5CFC  E357     BNC 0x5DAC
5CFE  0E01     MOVLW 0x1
5D00  ECC5     CALL 0xE78A, 0
5D02  F073     NOP
5D04  E253     BC 0x5DAC
401:                       {
402:                           if(DtIN.DIN < DtIN.cDLT)
5D06  0101     MOVLB 0x1
5D08  511F     MOVF _DtCSf_no_mont, W, BANKED
5D0A  5D1C     SUBWF _DtCSf_hi, W, BANKED
5D0C  E24F     BC 0x5DAC
403:                           {
404:                               if(!pdw)
5D0E  0103     MOVLB 0x3
5D10  5180     MOVF _PFNf_oflato, W, BANKED
5D12  E122     BNZ 0x5D58
405:                                   if(ppwm > PMP.MDPROC)
5D14  5182     MOVF M, W, BANKED
5D16  5C3F     SUBWF 0x3F, W, ACCESS
5D18  E21F     BC 0x5D58
406:                                   {
407:                                       if(((ppwm - _PMPKDW) > PMP.MDPROC))
5D1A  0EFE     MOVLW 0xFE
5D1C  6F77     MOVWF _PFNf_lato, BANKED
5D1E  6978     SETF _PFNf_mod_ncw, BANKED
5D20  5182     MOVF M, W, BANKED
5D22  6F79     MOVWF _PFNf_newPCO, BANKED
5D24  6B7A     CLRF _PFNf_newPCW, BANKED
5D26  5177     MOVF _PFNf_lato, W, BANKED
5D28  2779     ADDWF _PFNf_newPCO, F, BANKED
5D2A  5178     MOVF _PFNf_mod_ncw, W, BANKED
5D2C  237A     ADDWFC _PFNf_newPCW, F, BANKED
5D2E  503F     MOVF 0x3F, W, ACCESS
5D30  6F7B     MOVWF _PFNf_newPFN, BANKED
5D32  6B7C     CLRF _PFNf_oaleg, BANKED
5D34  5179     MOVF _PFNf_newPCO, W, BANKED
5D36  5D7B     SUBWF _PFNf_newPFN, W, BANKED
5D38  517C     MOVF _PFNf_oaleg, W, BANKED
5D3A  0A80     XORLW 0x80
5D3C  6F7D     MOVWF _PFNf_obgCO, BANKED
5D3E  517A     MOVF _PFNf_newPCW, W, BANKED
5D40  0A80     XORLW 0x80
5D42  597D     SUBWFB _PFNf_obgCO, W, BANKED
5D44  E206     BC 0x5D52
408:                                       {
409:                                           ppwm -= _PMPKDW;
5D46  0E02     MOVLW 0x2
5D48  5F82     SUBWF M, F, BANKED
410:                                           pdw = 1;
5D4A  0E01     MOVLW 0x1
5D4C  0103     MOVLB 0x3
5D4E  6F80     MOVWF _PFNf_oflato, BANKED
411:                                       }
5D50  D003     BRA 0x5D58
412:                                       else ppwm = PMP.MDPROC;
5D52  C03F     MOVFF 0x3F, ppwm
5D54  F382     NOP
413:                                   }
5D56  D000     BRA 0x5D58
414:                               if(!pdw)
5D58  0103     MOVLB 0x3
5D5A  5180     MOVF _PFNf_oflato, W, BANKED
5D5C  E127     BNZ 0x5DAC
415:                                   if(DtIN.DIN < DtIN.DIN2)
5D5E  0101     MOVLB 0x1
5D60  511D     MOVF _DtCSf_lo, W, BANKED
5D62  5D1C     SUBWF _DtCSf_hi, W, BANKED
5D64  E223     BC 0x5DAC
416:                                   {
417:                                       if(ppwm > PMP.MDPROC)
5D66  0103     MOVLB 0x3
5D68  5182     MOVF M, W, BANKED
5D6A  5C3F     SUBWF 0x3F, W, ACCESS
5D6C  E21F     BC 0x5DAC
418:                                       {
419:                                           if(((ppwm - _PMPKDW) > PMP.MDPROC))
5D6E  0EFE     MOVLW 0xFE
5D70  6F77     MOVWF _PFNf_lato, BANKED
5D72  6978     SETF _PFNf_mod_ncw, BANKED
5D74  5182     MOVF M, W, BANKED
5D76  6F79     MOVWF _PFNf_newPCO, BANKED
5D78  6B7A     CLRF _PFNf_newPCW, BANKED
5D7A  5177     MOVF _PFNf_lato, W, BANKED
5D7C  2779     ADDWF _PFNf_newPCO, F, BANKED
5D7E  5178     MOVF _PFNf_mod_ncw, W, BANKED
5D80  237A     ADDWFC _PFNf_newPCW, F, BANKED
5D82  503F     MOVF 0x3F, W, ACCESS
5D84  6F7B     MOVWF _PFNf_newPFN, BANKED
5D86  6B7C     CLRF _PFNf_oaleg, BANKED
5D88  5179     MOVF _PFNf_newPCO, W, BANKED
5D8A  5D7B     SUBWF _PFNf_newPFN, W, BANKED
5D8C  517C     MOVF _PFNf_oaleg, W, BANKED
5D8E  0A80     XORLW 0x80
5D90  6F7D     MOVWF _PFNf_obgCO, BANKED
5D92  517A     MOVF _PFNf_newPCW, W, BANKED
5D94  0A80     XORLW 0x80
5D96  597D     SUBWFB _PFNf_obgCO, W, BANKED
5D98  E206     BC 0x5DA6
420:                                           {
421:                                               ppwm -= _PMPKDW;
5D9A  0E02     MOVLW 0x2
5D9C  5F82     SUBWF M, F, BANKED
422:                                               pdw = 1;
5D9E  0E01     MOVLW 0x1
5DA0  0103     MOVLB 0x3
5DA2  6F80     MOVWF _PFNf_oflato, BANKED
423:                                           }
5DA4  D003     BRA 0x5DAC
424:                                           else ppwm = PMP.MDPROC;
5DA6  C03F     MOVFF 0x3F, ppwm
5DA8  F382     NOP
425:                                       }
426:                                   }
427:                           }
5DAA  D000     BRA 0x5DAC
428:                       }
429:                       //-------------------------
430:                       if(rgl.tmp_pwm < PWM.MAXPWM || ((rgl.tmp_pwm >= PWM.MAXPWM) && !Tnizsza(1)))
5DAC  0100     MOVLB 0x0
5DAE  5181     MOVF _PFNf_ofnserw, W, BANKED
5DB0  5C3D     SUBWF 0x3D, W, ACCESS
5DB2  E307     BNC 0x5DC2
5DB4  5181     MOVF _PFNf_ofnserw, W, BANKED
5DB6  5C3D     SUBWF 0x3D, W, ACCESS
5DB8  E350     BNC 0x5E5A
5DBA  0E01     MOVLW 0x1
5DBC  ECDA     CALL 0xEFB4, 0
5DBE  F077     NOP
5DC0  E24C     BC 0x5E5A
431:                       {
432:                           if(DtIN.DIN > DtIN.cDLT)
5DC2  0101     MOVLB 0x1
5DC4  511C     MOVF _DtCSf_hi, W, BANKED
5DC6  5D1F     SUBWF _DtCSf_no_mont, W, BANKED
5DC8  E248     BC 0x5E5A
433:                           {
434:                               if(!pup)
5DCA  0103     MOVLB 0x3
5DCC  5181     MOVF _PFNf_ofnserw, W, BANKED
5DCE  E11D     BNZ 0x5E0A
435:                                   if(ppwm < PMP.MGPROC)
5DD0  503E     MOVF PMP, W, ACCESS
5DD2  5D82     SUBWF M, W, BANKED
5DD4  E21A     BC 0x5E0A
436:                                   {
437:                                       if(((ppwm + _PMPKUP) < PMP.MGPROC))
5DD6  503E     MOVF PMP, W, ACCESS
5DD8  6F77     MOVWF _PFNf_lato, BANKED
5DDA  6B78     CLRF _PFNf_mod_ncw, BANKED
5DDC  5182     MOVF M, W, BANKED
5DDE  6F79     MOVWF _PFNf_newPCO, BANKED
5DE0  6B7A     CLRF _PFNf_newPCW, BANKED
5DE2  2B79     INCF _PFNf_newPCO, F, BANKED
5DE4  0E00     MOVLW 0x0
5DE6  237A     ADDWFC _PFNf_newPCW, F, BANKED
5DE8  5177     MOVF _PFNf_lato, W, BANKED
5DEA  5D79     SUBWF _PFNf_newPCO, W, BANKED
5DEC  517A     MOVF _PFNf_newPCW, W, BANKED
5DEE  0A80     XORLW 0x80
5DF0  6F7B     MOVWF _PFNf_newPFN, BANKED
5DF2  5178     MOVF _PFNf_mod_ncw, W, BANKED
5DF4  0A80     XORLW 0x80
5DF6  597B     SUBWFB _PFNf_newPFN, W, BANKED
5DF8  E205     BC 0x5E04
438:                                       {
439:                                           ppwm += _PMPKUP;
5DFA  2B82     INCF M, F, BANKED
440:                                           pup = 1;
5DFC  0E01     MOVLW 0x1
5DFE  0103     MOVLB 0x3
5E00  6F81     MOVWF _PFNf_ofnserw, BANKED
441:                                       }
5E02  D003     BRA 0x5E0A
442:                                       else ppwm = PMP.MGPROC;
5E04  C03E     MOVFF PMP, ppwm
5E06  F382     NOP
443:                                   }
5E08  D000     BRA 0x5E0A
444:                               if(!pup)
5E0A  0103     MOVLB 0x3
5E0C  5181     MOVF _PFNf_ofnserw, W, BANKED
5E0E  E125     BNZ 0x5E5A
445:                                   if(DtIN.DIN > DtIN.DIN2)
5E10  0101     MOVLB 0x1
5E12  511C     MOVF _DtCSf_hi, W, BANKED
5E14  5D1D     SUBWF _DtCSf_lo, W, BANKED
5E16  E221     BC 0x5E5A
446:                                   {
447:                                       if(ppwm < PMP.MGPROC)
5E18  503E     MOVF PMP, W, ACCESS
5E1A  0103     MOVLB 0x3
5E1C  5D82     SUBWF M, W, BANKED
5E1E  E21D     BC 0x5E5A
448:                                       {
449:                                           if(((ppwm + _PMPKUP) < PMP.MGPROC))
5E20  503E     MOVF PMP, W, ACCESS
5E22  6F77     MOVWF _PFNf_lato, BANKED
5E24  6B78     CLRF _PFNf_mod_ncw, BANKED
5E26  5182     MOVF M, W, BANKED
5E28  6F79     MOVWF _PFNf_newPCO, BANKED
5E2A  6B7A     CLRF _PFNf_newPCW, BANKED
5E2C  2B79     INCF _PFNf_newPCO, F, BANKED
5E2E  0E00     MOVLW 0x0
5E30  237A     ADDWFC _PFNf_newPCW, F, BANKED
5E32  5177     MOVF _PFNf_lato, W, BANKED
5E34  5D79     SUBWF _PFNf_newPCO, W, BANKED
5E36  517A     MOVF _PFNf_newPCW, W, BANKED
5E38  0A80     XORLW 0x80
5E3A  6F7B     MOVWF _PFNf_newPFN, BANKED
5E3C  5178     MOVF _PFNf_mod_ncw, W, BANKED
5E3E  0A80     XORLW 0x80
5E40  597B     SUBWFB _PFNf_newPFN, W, BANKED
5E42  E208     BC 0x5E54
450:                                           {
451:                                               ppwm += _PMPKUP;
5E44  2B82     INCF M, F, BANKED
452:                                               pup = 1;
5E46  0E01     MOVLW 0x1
5E48  0103     MOVLB 0x3
5E4A  6F81     MOVWF _PFNf_ofnserw, BANKED
453:                                           }
454:                                           else ppwm = PMP.MGPROC;
455:                                       }
456:                                   }
457:                           }
458:                           //-------------------------
459:                       }
460:                   }
461:               }
5E4C  D006     BRA 0x5E5A
462:               else
463:               {
464:                   StartRTdS(_RTPMOD);
5E4E  0E08     MOVLW 0x8
5E50  ECA0     CALL 0xE540, 0
5E52  F072     NOP
465:                   ppwm = PMP.MGPROC;
5E54  C03E     MOVFF PMP, ppwm
5E56  F382     NOP
5E58  D000     BRA 0x5E5A
466:               }
467:               return ppwm;
5E5A  0103     MOVLB 0x3
5E5C  5182     MOVF M, W, BANKED
5E5E  0012     RETURN 0
468:           }
5E60  0012     RETURN 0
469:           //--------------------------------------------------------------------------------------
470:           //-----------------------------------------------------------------------
471:           //Modulacja praca pompy w zaleznosci od temperatury IN  (delta uzalezniona od parametru ECO i nastawy PPCO)
472:           
473:           void RglPmp2(void)
474:           {
475:               PMP.MGPROC = DtKNF.mgpm; //gorny prog procentowy predkosci
D610  C0A3     MOVFF _UADtf_RErrREC, PMP
D612  F03E     NOP
476:               PMP.MDPROC = DtKNF.mdpm; //dolny prog procentowy predkosci
D614  C0A2     MOVFF _UADtf_RErrBUF, 0x3F
D616  F03F     NOP
477:           
478:           
479:               if(!Mf_PRACA)
D618  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
D61A  D011     BRA 0xD63E
480:               {
481:                   DtIN.pop = 0;
D61C  0101     MOVLB 0x1
D61E  6B2C     CLRF _DtI2Cf_krok, BANKED
482:                   StartRTS(_RTMPMP);
D620  0E0E     MOVLW 0xE
D622  EC60     CALL 0xE4C0, 0
D624  F072     NOP
483:                   if(_POMPA)
D626  A483     BTFSS PORTD, 2, ACCESS
D628  D003     BRA 0xD630
484:                   {
485:                       PMP.APROC = PMP.MGPROC; //pelny wybieg
D62A  C03E     MOVFF PMP, 0x40
D62C  F040     NOP
486:                   }
D62E  D002     BRA 0xD634
487:                   else
488:                   {
489:                       PMP.APROC = 0; //minimalizuj straty energii
D630  6A40     CLRF 0x40, ACCESS
D632  D000     BRA 0xD634
490:                   }
491:                   WritePWM2(ProcToPmpPwm(PMP.APROC));
D634  5040     MOVF 0x40, W, ACCESS
D636  EC04     CALL 0xDE08, 0
D638  F06F     NOP
D63A  EF6D     GOTO 0xF2DA
D63C  F079     NOP
492:               }
493:               else
494:               {
495:                   if(Mf_MODULUJ && !DtINf_err_IN && !Mf_RPM_CW && RTS(_RTMPMP) > _TPMPBLK) //obieg CO, po rozruchu po ustalonym czasie rozpocznij modulacje pompa
D63E  B807     BTFSC Mf_BLOKUJ_3M, 4, ACCESS
D640  BA05     BTFSC DtKNFf_enknf, 5, ACCESS
D642  D011     BRA 0xD666
D644  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
D646  D00F     BRA 0xD666
D648  0E0E     MOVLW 0xE
D64A  ECA9     CALL 0xEB52, 0
D64C  F075     NOP
D64E  0100     MOVLB 0x0
D650  6FFF     MOVWF key, BANKED
D652  0E0A     MOVLW 0xA
D654  65FF     CPFSGT key, BANKED
D656  D007     BRA 0xD666
496:                   {
497:                       if(rglf_fz)		//dla fazy 1 narost lub spadek obrotow w rgl.c (IncMaxCO())
D658  A815     BTFSS rglf_btcw, 4, ACCESS
D65A  D008     BRA 0xD66C
498:           			{
499:                           PMP.APROC = ModPmp2(PMP.APROC);
D65C  5040     MOVF 0x40, W, ACCESS
D65E  EC9C     CALL 0x5B38, 0
D660  F02D     NOP
D662  6E40     MOVWF 0x40, ACCESS
500:                       }
501:                   }
D664  D003     BRA 0xD66C
502:                   else
503:                   {
504:                       PMP.APROC = PMP.MGPROC;
D666  C03E     MOVFF PMP, 0x40
D668  F040     NOP
D66A  D000     BRA 0xD66C
505:                   }
506:                   WritePWM2(ProcToPmpPwm(PMP.APROC));
D66C  5040     MOVF 0x40, W, ACCESS
D66E  EC04     CALL 0xDE08, 0
D670  F06F     NOP
D672  EF6D     GOTO 0xF2DA
D674  F079     NOP
507:               }
508:           }
D676  0012     RETURN 0
509:           //--------------------------------------------------------------------------------------
510:           //--------------------------------------------------------------------------------------
511:           //--------------------------------------------------------------------------------------
512:           //Funkcja wywolywana w proc regulacji [rgl.c (IncMaxCO())] przy naroscie mocy (FAZA1)
513:           void PmpToUP(void)
514:           {
515:               static unsigned char tm;
516:           
517:               if(DtKNF.rdpm)
DF90  0100     MOVLB 0x0
DF92  51A0     MOVF _UADtf_RData, W, BANKED
DF94  B4D8     BTFSC STATUS, 2, ACCESS
DF96  0012     RETURN 0
518:               {
519:                   tm++;
DF98  0101     MOVLB 0x1
DF9A  2B6C     INCF _PFNf_enKNF, F, BANKED
520:                   if(tm > 30)
DF9C  0E1E     MOVLW 0x1E
DF9E  0101     MOVLB 0x1
DFA0  656C     CPFSGT _PFNf_enKNF, BANKED
DFA2  0C1E     RETLW 0x1E
521:                   {
522:                       tm = 0;
DFA4  0E00     MOVLW 0x0
DFA6  6F6C     MOVWF _PFNf_enKNF, BANKED
523:           			if(!Mf_RPM_CW)
DFA8  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
DFAA  0012     RETURN 0
524:           			{            
525:                           if(PMP.APROC + 1 < PMP.MGPROC) PMP.APROC = PMP.APROC + 1;
DFAC  503E     MOVF PMP, W, ACCESS
DFAE  0100     MOVLB 0x0
DFB0  6FDE     MOVWF __pcstackBANK0, BANKED
DFB2  6BDF     CLRF pco, BANKED
DFB4  5040     MOVF 0x40, W, ACCESS
DFB6  6FE0     MOVWF bdat, BANKED
DFB8  6BE1     CLRF GIE_BIT_VAL, BANKED
DFBA  2BE0     INCF bdat, F, BANKED
DFBC  0E00     MOVLW 0x0
DFBE  23E1     ADDWFC GIE_BIT_VAL, F, BANKED
DFC0  51DE     MOVF __pcstackBANK0, W, BANKED
DFC2  5DE0     SUBWF bdat, W, BANKED
DFC4  51E1     MOVF GIE_BIT_VAL, W, BANKED
DFC6  0A80     XORLW 0x80
DFC8  6FE2     MOVWF divisor, BANKED
DFCA  51DF     MOVF pco, W, BANKED
DFCC  0A80     XORLW 0x80
DFCE  59E2     SUBWFB divisor, W, BANKED
DFD0  B0D8     BTFSC STATUS, 0, ACCESS
DFD2  0012     RETURN 0
DFD4  2840     INCF 0x40, W, ACCESS
DFD6  6E40     MOVWF 0x40, ACCESS
526:                       }
527:                   }
DFD8  0012     RETURN 0
528:               }
529:               //else PMP.APROC = PMP.MGPROC;   
530:           }
DFDA  0012     RETURN 0
531:           //Funkcja wywolywana w proc regulacji przy naroscie mocy (FAZA1)
532:           void PmpToDW(void)
533:           {
534:               static unsigned char tm;
535:           
536:               if(DtKNF.rdpm)
E196  0100     MOVLB 0x0
E198  51A0     MOVF _UADtf_RData, W, BANKED
E19A  B4D8     BTFSC STATUS, 2, ACCESS
E19C  0012     RETURN 0
537:               {
538:                   tm++;
E19E  0101     MOVLB 0x1
E1A0  2B6B     INCF _PFNf_csn, F, BANKED
539:                   if(tm > 0)
E1A2  0101     MOVLB 0x1
E1A4  516B     MOVF _PFNf_csn, W, BANKED
E1A6  B4D8     BTFSC STATUS, 2, ACCESS
E1A8  0012     RETURN 0
540:                   {
541:                       tm = 0;
E1AA  0E00     MOVLW 0x0
E1AC  6F6B     MOVWF _PFNf_csn, BANKED
542:           			if(!Mf_RPM_CW)
E1AE  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
E1B0  0012     RETURN 0
543:           			{            
544:                           if(PMP.APROC - 1 > 50) PMP.APROC = PMP.APROC - 1;
E1B2  0100     MOVLB 0x0
E1B4  69DE     SETF __pcstackBANK0, BANKED
E1B6  69DF     SETF pco, BANKED
E1B8  5040     MOVF 0x40, W, ACCESS
E1BA  6FE0     MOVWF bdat, BANKED
E1BC  6BE1     CLRF GIE_BIT_VAL, BANKED
E1BE  51DE     MOVF __pcstackBANK0, W, BANKED
E1C0  27E0     ADDWF bdat, F, BANKED
E1C2  51DF     MOVF pco, W, BANKED
E1C4  23E1     ADDWFC GIE_BIT_VAL, F, BANKED
E1C6  BFE1     BTFSC GIE_BIT_VAL, 7, BANKED
E1C8  0012     RETURN 0
E1CA  51E1     MOVF GIE_BIT_VAL, W, BANKED
E1CC  E104     BNZ 0xE1D6
E1CE  0E33     MOVLW 0x33
E1D0  5DE0     SUBWF bdat, W, BANKED
E1D2  A0D8     BTFSS STATUS, 0, ACCESS
E1D4  0012     RETURN 0
E1D6  0440     DECF 0x40, W, ACCESS
E1D8  6E40     MOVWF 0x40, ACCESS
545:                       }
546:                   }
E1DA  0012     RETURN 0
547:               }
548:               //else PMP.APROC = PMP.MGPROC;
549:           }
E1DC  0012     RETURN 0
550:           //--------------------------------------------------------------------------------------
551:           //--------------------------------------------------------------------------------------
552:           //--------------------------------------------------------------------------------------
553:           //Modulacja praca pompy
554:           
555:           void RglPmp(void)
556:           {
557:               if(DtKNF.rdpm) //zdecyduj ze wzgledu na rodzaj pompy
E634  0100     MOVLB 0x0
E636  51A0     MOVF _UADtf_RData, W, BANKED
E638  E007     BZ 0xE648
558:               {
559:                   if(!DtKNF.teco)
E63A  51A4     MOVF _UADtf_TData, W, BANKED
E63C  E102     BNZ 0xE642
560:                   {
561:                       RglPmp1(); //moduluj tradycyjnym algorytmem (delta = DtKNF.dtpm)
E63E  EF5B     GOTO 0xD2B6
E640  F069     NOP
562:                   }
563:                   else
564:                   {
565:                       RglPmp2(); //moduluj algorytmem ECO
E642  EC08     CALL 0xD610, 0
E644  F06B     NOP
566:                   }
567:               }
E646  0012     RETURN 0
568:               else //minimalizuj straty energii/zapobiegnij postojowi w przypadku pomylki konfiguracyjnej
569:               {
570:                   if(!Mf_PRACA)
E648  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
E64A  D008     BRA 0xE65C
571:                   {
572:                       StartRTS(_RTMPMP);
E64C  0E0E     MOVLW 0xE
E64E  EC60     CALL 0xE4C0, 0
E650  F072     NOP
573:                       if(_POMPA)
E652  B483     BTFSC PORTD, 2, ACCESS
E654  D003     BRA 0xE65C
574:                       {
575:                           PMP.APROC = 15; //wybieg z predkoscia bezpieczenstwa
576:                       }
577:                       else
578:                       {
579:                           PMP.APROC = 0; //minimalizuj straty energii
E656  0E00     MOVLW 0x0
E658  D002     BRA 0xE65E
580:                       }
581:                   }
E65A  D003     BRA 0xE662
582:                   else
583:                   {
584:                       PMP.APROC = 15; //wybieg z predkoscia bezpieczenstwa
E65C  0E0F     MOVLW 0xF
E65E  6E40     MOVWF 0x40, ACCESS
E660  D000     BRA 0xE662
585:                   }
586:                   WritePWM2(ProcToPmpPwm(PMP.APROC));
E662  5040     MOVF 0x40, W, ACCESS
E664  EC04     CALL 0xDE08, 0
E666  F06F     NOP
E668  EF6D     GOTO 0xF2DA
E66A  F079     NOP
587:               }
588:           }
E66C  0012     RETURN 0
589:           //--------------------------------------------------------------------------------------
590:           //--------------------------------------------------------------------------------------
591:           //--------------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/pomiar.c  --------------------------------
1:             /*pomiar.c*/
2:             //Procedury pomiarowe (oparte na przetworniku AC) UNISTER zmodyfikowany GRZ01
3:             // (!) Bazuje na funkcjach z pliku: ac.c, rtimer.c /RTdS(2)/
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"				//parametry globalne
7:             #include "pomiar.h"				//parametry lokalne
8:             #include "konfig2.h"
9:             #include "main.tp.h"
10:            #include "pwm.h"
11:            #include "smgs_rs9b.tp.h"			
12:            
13:            volatile DataCO DtCO;
14:            volatile DataIN DtIN;
15:            volatile DataCW DtCW;
16:            volatile DataZW DtZW;
17:            volatile DataCSN DtCS;
18:            
19:            extern tpMAIN M;
20:            extern DataPFN PFN;
21:            extern DtKONF DtKNF;
22:            extern DtPWM PWM;
23:            
24:            volatile static unsigned char PmrtimFlt1, PmrtimFlt2;
25:            volatile static unsigned int PmrtimFlt3;
26:            volatile unsigned char wff[12];
27:            
28:            #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
29:            unsigned char mypwm = _MG2_MOD;
30:            #endif
31:            /*---------------------------------------------------------------------------------*/
32:            //Inicjalizacja DtCO, DtCW, DtCS, PFN
33:            
34:            void InitDataPmr(void)
35:            {
36:                DtCOf_err_CO = 0;
E66E  9E01     BCF DtCOf_err_CO, 7, ACCESS
37:                DtCOf_su_CO = 0;
E670  9E02     BCF DtCOf_su_CO, 7, ACCESS
38:                DtCOf_ad_CO = 0;
E672  9601     BCF DtCOf_err_CO, 3, ACCESS
39:                DtCOf_su_SRW_CO = 0;
E674  9203     BCF DtCOf_su_SRW_CO, 1, ACCESS
40:                DtCOf_ad_SRW_CO = 0;
E676  9A01     BCF DtCOf_err_CO, 5, ACCESS
41:                DtCOf_cold_CO = 0;
E678  9C01     BCF DtCOf_err_CO, 6, ACCESS
42:                DtCOf_hot_CO = 0;
E67A  9002     BCF DtCOf_su_CO, 0, ACCESS
43:                DtCOf_on_DZ_CO = 0;
E67C  9602     BCF DtCOf_su_CO, 3, ACCESS
44:                DtCOf_su_DZ_CO = 0;
E67E  9003     BCF DtCOf_su_SRW_CO, 0, ACCESS
45:                DtCOf_ad_DZ_CO = 0;
E680  9801     BCF DtCOf_err_CO, 4, ACCESS
46:                DtCOf_ptwp_CO = 0;
E682  9802     BCF DtCOf_su_CO, 4, ACCESS
47:                DtCOf_pz_CO = 0;
E684  9A02     BCF DtCOf_su_CO, 5, ACCESS
48:                DtCO.indCO = 0;
E686  0100     MOVLB 0x0
E688  6BD7     CLRF 0xD7, BANKED
49:            
50:                DtCWf_err_CW = 0;
E68A  9804     BCF DtCWf_err_CW, 4, ACCESS
51:                DtCWf_su_CW = 0;
E68C  9005     BCF DtKNFf_enknf, 0, ACCESS
52:                DtCWf_ad_CW = 0;
E68E  9204     BCF DtCWf_err_CW, 1, ACCESS
53:                DtCWf_on_DZ_CW = 0;
E690  9E04     BCF DtCWf_err_CW, 7, ACCESS
54:                DtCWf_su_DZ_CW = 0;
E692  9205     BCF DtKNFf_enknf, 1, ACCESS
55:                DtCWf_ad_DZ_CW = 0;
E694  9404     BCF DtCWf_err_CW, 2, ACCESS
56:                DtCW.indCW = 0;
E696  0E00     MOVLW 0x0
E698  0100     MOVLB 0x0
E69A  6BB2     CLRF 0xB2, BANKED
57:            
58:                DtCSf_hi = 0;
E69C  9803     BCF DtCOf_su_SRW_CO, 4, ACCESS
59:                DtCSf_lo = 0;
E69E  9A03     BCF DtCOf_su_SRW_CO, 5, ACCESS
60:                DtCSf_no = 0;
E6A0  9C03     BCF DtCOf_su_SRW_CO, 6, ACCESS
61:                DtCSf_error = 0;
E6A2  9603     BCF DtCOf_su_SRW_CO, 3, ACCESS
62:                DtCSf_work = 1; //przed pomiarem domyslne cisnienie robocze
E6A4  8004     BSF DtCWf_err_CW, 0, ACCESS
63:            }
E6A6  0012     RETURN 0
64:            //-------------------------------------------------------------------------------
65:            //Timer na potrzeby filtracji (umiescic w przerwaniu od zegara TMR1)
66:            
67:            void IncPmrTimer(void)
68:            {
69:                if(PmrtimFlt1 < 0xff) PmrtimFlt1++;
ED0A  0101     MOVLB 0x1
ED0C  2976     INCF _PFNf_fnserw, W, BANKED
ED0E  E002     BZ 0xED14
ED10  2B76     INCF _PFNf_fnserw, F, BANKED
ED12  D000     BRA 0xED14
70:                if(PmrtimFlt2 < 0xff) PmrtimFlt2++;
ED14  0101     MOVLB 0x1
ED16  2977     INCF _PFNf_lato, W, BANKED
ED18  E002     BZ 0xED1E
ED1A  2B77     INCF _PFNf_lato, F, BANKED
ED1C  D000     BRA 0xED1E
71:                if(PmrtimFlt3 < 0xffff) PmrtimFlt3++;
ED1E  0101     MOVLB 0x1
ED20  2948     INCF 0x48, W, BANKED
ED22  E103     BNZ 0xED2A
ED24  2949     INCF 0x49, W, BANKED
ED26  B4D8     BTFSC STATUS, 2, ACCESS
ED28  0012     RETURN 0
ED2A  0101     MOVLB 0x1
ED2C  4B48     INFSNZ 0x48, F, BANKED
ED2E  2B49     INCF 0x49, F, BANKED
ED30  0012     RETURN 0
72:            }
ED32  0012     RETURN 0
73:            //-------------------------------------------------------------------------------
74:            //Zegar 1 odcinkow czasowych
75:            
76:            void StartTim1(void)
77:            {
78:                PmrtimFlt1 = 0;
F3EC  0E00     MOVLW 0x0
F3EE  0101     MOVLB 0x1
F3F0  6B76     CLRF _PFNf_fnserw, BANKED
79:            }
F3F2  0012     RETURN 0
80:            
81:            bit PmrTim1(unsigned char tm)
F10E  0100     MOVLB 0x0
F110  6FDE     MOVWF __pcstackBANK0, BANKED
82:            {
83:                if(PmrtimFlt1 < tm) return 0;
F112  0100     MOVLB 0x0
F114  51DE     MOVF __pcstackBANK0, W, BANKED
F116  0101     MOVLB 0x1
F118  5D76     SUBWF _PFNf_fnserw, W, BANKED
F11A  E202     BC 0xF120
F11C  90D8     BCF STATUS, 0, ACCESS
F11E  0012     RETURN 0
84:                return 1;
F120  80D8     BSF STATUS, 0, ACCESS
F122  0012     RETURN 0
85:            }
F124  0012     RETURN 0
86:            //-------------------------------------------------------------------------------
87:            //Zegar 2 odcinkow czasowych
88:            
89:            void StartTim2(void)
90:            {
91:                PmrtimFlt2 = 0;
F3E4  0E00     MOVLW 0x0
F3E6  0101     MOVLB 0x1
F3E8  6B77     CLRF _PFNf_lato, BANKED
92:            }
F3EA  0012     RETURN 0
93:            
94:            bit PmrTim2(unsigned char tm)
F0F6  0100     MOVLB 0x0
F0F8  6FDE     MOVWF __pcstackBANK0, BANKED
95:            {
96:                if(PmrtimFlt2 < tm) return 0;
F0FA  0100     MOVLB 0x0
F0FC  51DE     MOVF __pcstackBANK0, W, BANKED
F0FE  0101     MOVLB 0x1
F100  5D77     SUBWF _PFNf_lato, W, BANKED
F102  E202     BC 0xF108
F104  90D8     BCF STATUS, 0, ACCESS
F106  0012     RETURN 0
97:                return 1;
F108  80D8     BSF STATUS, 0, ACCESS
F10A  0012     RETURN 0
98:            }
F10C  0012     RETURN 0
99:            //-------------------------------------------------------------------------------
100:           //Zegar 3 odcinkow czasowych
101:           
102:           void StartTim3(void)
103:           {
104:               PmrtimFlt3 = 0;
105:           }
106:           
107:           bit PmrTim3(unsigned int tm)
108:           {
109:               if(PmrtimFlt3 < tm) return 0;
110:               return 1;
111:           }
112:           /*---------------------------------------------------------------------------------*/
113:           //Filtracja wartosci temperatur na cele wizualizacji.
114:           
115:           void GoldenEye(void)
116:           {
117:               signed char dt;
118:               signed char pop;
119:               //----------
120:               //wskaz CO
121:               dt = DtCO.PPCO - DtCO.CO;
2F34  0100     MOVLB 0x0
2F36  51CF     MOVF DtCO, W, BANKED
2F38  0800     SUBLW 0x0
2F3A  25D1     ADDWF 0xD1, W, BANKED
2F3C  6FEC     MOVWF dt, BANKED
122:               if((DtCO.CO >= (DtCO.PPCO + _DM_GECO)) || (DtCO.CO <= (DtCO.PPCO - _DM_GECO))) DtCO.SCO = DtCO.CO;
2F3E  51D1     MOVF 0xD1, W, BANKED
2F40  6FE4     MOVWF k, BANKED
2F42  6BE5     CLRF k, BANKED
2F44  0E0B     MOVLW 0xB
2F46  27E4     ADDWF k, F, BANKED
2F48  0E00     MOVLW 0x0
2F4A  23E5     ADDWFC k, F, BANKED
2F4C  51CF     MOVF DtCO, W, BANKED
2F4E  6FE6     MOVWF counter, BANKED
2F50  6BE7     CLRF sign, BANKED
2F52  51E4     MOVF k, W, BANKED
2F54  5DE6     SUBWF counter, W, BANKED
2F56  51E7     MOVF sign, W, BANKED
2F58  0A80     XORLW 0x80
2F5A  6FE8     MOVWF quotient, BANKED
2F5C  51E5     MOVF k, W, BANKED
2F5E  0A80     XORLW 0x80
2F60  59E8     SUBWFB quotient, W, BANKED
2F62  E216     BC 0x2F90
2F64  51CF     MOVF DtCO, W, BANKED
2F66  6FE4     MOVWF k, BANKED
2F68  6BE5     CLRF k, BANKED
2F6A  0EF5     MOVLW 0xF5
2F6C  6FE6     MOVWF counter, BANKED
2F6E  69E7     SETF sign, BANKED
2F70  51D1     MOVF 0xD1, W, BANKED
2F72  6FE8     MOVWF quotient, BANKED
2F74  6BE9     CLRF p, BANKED
2F76  51E6     MOVF counter, W, BANKED
2F78  27E8     ADDWF quotient, F, BANKED
2F7A  51E7     MOVF sign, W, BANKED
2F7C  23E9     ADDWFC p, F, BANKED
2F7E  51E4     MOVF k, W, BANKED
2F80  5DE8     SUBWF quotient, W, BANKED
2F82  51E9     MOVF p, W, BANKED
2F84  0A80     XORLW 0x80
2F86  6FEA     MOVWF tim, BANKED
2F88  51E5     MOVF k, W, BANKED
2F8A  0A80     XORLW 0x80
2F8C  59EA     SUBWFB tim, W, BANKED
2F8E  E303     BNC 0x2F96
2F90  C0CF     MOVFF DtCO, 0xD8
2F92  F0D8     NOP
2F94  D078     BRA 0x3086
123:               else
124:               {
125:                   if(dt >= 0)
2F96  0100     MOVLB 0x0
2F98  BFEC     BTFSC dt, 7, BANKED
2F9A  D020     BRA 0x2FDC
126:                   {
127:                       if(dt < _BNCO) pop = dt;
2F9C  51EC     MOVF dt, W, BANKED
2F9E  0A80     XORLW 0x80
2FA0  0F7F     ADDLW 0x7F
2FA2  E203     BC 0x2FAA
2FA4  C0EC     MOVFF dt, pop
2FA6  F0EB     NOP
2FA8  D016     BRA 0x2FD6
128:                       else
129:                           if((dt >= _BNCO) && (dt <= (_DM_GECO - _BNCO))) pop = _BNCO;
2FAA  0100     MOVLB 0x0
2FAC  51EC     MOVF dt, W, BANKED
2FAE  0A80     XORLW 0x80
2FB0  0F7F     ADDLW 0x7F
2FB2  E306     BNC 0x2FC0
2FB4  51EC     MOVF dt, W, BANKED
2FB6  0A80     XORLW 0x80
2FB8  0F75     ADDLW 0x75
2FBA  E202     BC 0x2FC0
2FBC  0E01     MOVLW 0x1
2FBE  D008     BRA 0x2FD0
130:                       else
131:                           if(dt > (_DM_GECO - _BNCO)) pop = _DM_GECO - dt;
2FC0  0100     MOVLB 0x0
2FC2  51EC     MOVF dt, W, BANKED
2FC4  0A80     XORLW 0x80
2FC6  0F75     ADDLW 0x75
2FC8  E306     BNC 0x2FD6
2FCA  51EC     MOVF dt, W, BANKED
2FCC  0800     SUBLW 0x0
2FCE  0F0B     ADDLW 0xB
2FD0  0100     MOVLB 0x0
2FD2  6FEB     MOVWF pop, BANKED
2FD4  D000     BRA 0x2FD6
132:                       DtCO.SCO = DtCO.CO + pop;
2FD6  0100     MOVLB 0x0
2FD8  51EB     MOVF pop, W, BANKED
2FDA  D051     BRA 0x307E
133:                   }
134:                   else    //********* proc poprawiona dla gornego marginesu wylaczenia=10 (a nie 5)
135:                   {
136:                       if(-1 * dt < _BNCO) pop = _BNCO + dt;
2FDC  0100     MOVLB 0x0
2FDE  51EC     MOVF dt, W, BANKED
2FE0  6FDE     MOVWF __pcstackBANK0, BANKED
2FE2  6BDF     CLRF pco, BANKED
2FE4  BFDE     BTFSC __pcstackBANK0, 7, BANKED
2FE6  07DF     DECF pco, F, BANKED
2FE8  6BE1     CLRF GIE_BIT_VAL, BANKED
2FEA  0E01     MOVLW 0x1
2FEC  6FE0     MOVWF bdat, BANKED
2FEE  EC5B     CALL 0xECB6, 0
2FF0  F076     NOP
2FF2  0100     MOVLB 0x0
2FF4  1FDE     COMF __pcstackBANK0, F, BANKED
2FF6  1FDF     COMF pco, F, BANKED
2FF8  4BDE     INFSNZ __pcstackBANK0, F, BANKED
2FFA  2BDF     INCF pco, F, BANKED
2FFC  BFDF     BTFSC pco, 7, BANKED
2FFE  D005     BRA 0x300A
3000  51DF     MOVF pco, W, BANKED
3002  E106     BNZ 0x3010
3004  05DE     DECF __pcstackBANK0, W, BANKED
3006  B0D8     BTFSC STATUS, 0, ACCESS
3008  D003     BRA 0x3010
300A  0100     MOVLB 0x0
300C  29EC     INCF dt, W, BANKED
300E  D031     BRA 0x3072
137:                       else
138:                           if((-1 * dt >= _BNCO) && (-1 * dt <= (_DM_GECO - _BNCO))) pop = _BNCO;
3010  0100     MOVLB 0x0
3012  51EC     MOVF dt, W, BANKED
3014  6FDE     MOVWF __pcstackBANK0, BANKED
3016  6BDF     CLRF pco, BANKED
3018  BFDE     BTFSC __pcstackBANK0, 7, BANKED
301A  07DF     DECF pco, F, BANKED
301C  6BE1     CLRF GIE_BIT_VAL, BANKED
301E  0E01     MOVLW 0x1
3020  6FE0     MOVWF bdat, BANKED
3022  EC5B     CALL 0xECB6, 0
3024  F076     NOP
3026  0100     MOVLB 0x0
3028  1FDE     COMF __pcstackBANK0, F, BANKED
302A  1FDF     COMF pco, F, BANKED
302C  4BDE     INFSNZ __pcstackBANK0, F, BANKED
302E  2BDF     INCF pco, F, BANKED
3030  BFDF     BTFSC pco, 7, BANKED
3032  D01E     BRA 0x3070
3034  51DF     MOVF pco, W, BANKED
3036  E102     BNZ 0x303C
3038  05DE     DECF __pcstackBANK0, W, BANKED
303A  E31A     BNC 0x3070
303C  0100     MOVLB 0x0
303E  51EC     MOVF dt, W, BANKED
3040  6FDE     MOVWF __pcstackBANK0, BANKED
3042  6BDF     CLRF pco, BANKED
3044  BFDE     BTFSC __pcstackBANK0, 7, BANKED
3046  07DF     DECF pco, F, BANKED
3048  6BE1     CLRF GIE_BIT_VAL, BANKED
304A  0E01     MOVLW 0x1
304C  6FE0     MOVWF bdat, BANKED
304E  EC5B     CALL 0xECB6, 0
3050  F076     NOP
3052  0100     MOVLB 0x0
3054  1FDE     COMF __pcstackBANK0, F, BANKED
3056  1FDF     COMF pco, F, BANKED
3058  4BDE     INFSNZ __pcstackBANK0, F, BANKED
305A  2BDF     INCF pco, F, BANKED
305C  BFDF     BTFSC pco, 7, BANKED
305E  D006     BRA 0x306C
3060  51DF     MOVF pco, W, BANKED
3062  E106     BNZ 0x3070
3064  0E0B     MOVLW 0xB
3066  5DDE     SUBWF __pcstackBANK0, W, BANKED
3068  B0D8     BTFSC STATUS, 0, ACCESS
306A  D002     BRA 0x3070
306C  0E01     MOVLW 0x1
306E  D001     BRA 0x3072
139:                       else
140:                           //if(-1 * dt > (_DM_GECO - _BNCO)) pop = _DM_GECO + dt;
141:                           pop=0;
3070  0E00     MOVLW 0x0
3072  0100     MOVLB 0x0
3074  6FEB     MOVWF pop, BANKED
3076  D000     BRA 0x3078
142:                       DtCO.SCO = DtCO.CO - pop;
3078  0100     MOVLB 0x0
307A  51EB     MOVF pop, W, BANKED
307C  0800     SUBLW 0x0
307E  0100     MOVLB 0x0
3080  25CF     ADDWF DtCO, W, BANKED
3082  6FD8     MOVWF 0xD8, BANKED
143:                   }
3084  D000     BRA 0x3086
144:               }
145:               PFN.CO = DtCO.SCO;
3086  C0D8     MOVFF 0xD8, PFN
3088  F1DF     NOP
146:               //----------
147:               //wskaz CW
148:               if(DtKNF.tpkt != _UNICO) //kociol inny niz UniCO?
308A  0100     MOVLB 0x0
308C  519E     MOVF _PWMf_ENPWM2, W, BANKED
308E  E101     BNZ 0x3092
3090  D183     BRA 0x3398
149:               {
150:                   if(DtKNF.tpkt == _BITERM)
3092  059E     DECF _PWMf_ENPWM2, W, BANKED
3094  E001     BZ 0x3098
3096  D0BE     BRA 0x3214
151:                   {
152:                       dt = DtCW.PPCW - DtCW.CW;
3098  51AA     MOVF DtCW, W, BANKED
309A  0800     SUBLW 0x0
309C  25AC     ADDWF _rglf_fz, W, BANKED
309E  6FEC     MOVWF dt, BANKED
153:                       if((DtCW.CW >= (DtCW.PPCW + _DM_GECW2)) || (DtCW.CW <= (DtCW.PPCW - _DM_GECW2))) DtCW.SCW = DtCW.CW;
30A0  51AC     MOVF _rglf_fz, W, BANKED
30A2  6FE4     MOVWF k, BANKED
30A4  6BE5     CLRF k, BANKED
30A6  0E0B     MOVLW 0xB
30A8  27E4     ADDWF k, F, BANKED
30AA  0E00     MOVLW 0x0
30AC  23E5     ADDWFC k, F, BANKED
30AE  51AA     MOVF DtCW, W, BANKED
30B0  6FE6     MOVWF counter, BANKED
30B2  6BE7     CLRF sign, BANKED
30B4  51E4     MOVF k, W, BANKED
30B6  5DE6     SUBWF counter, W, BANKED
30B8  51E7     MOVF sign, W, BANKED
30BA  0A80     XORLW 0x80
30BC  6FE8     MOVWF quotient, BANKED
30BE  51E5     MOVF k, W, BANKED
30C0  0A80     XORLW 0x80
30C2  59E8     SUBWFB quotient, W, BANKED
30C4  E301     BNC 0x30C8
30C6  D168     BRA 0x3398
30C8  51AA     MOVF DtCW, W, BANKED
30CA  6FE4     MOVWF k, BANKED
30CC  6BE5     CLRF k, BANKED
30CE  0EF5     MOVLW 0xF5
30D0  6FE6     MOVWF counter, BANKED
30D2  69E7     SETF sign, BANKED
30D4  51AC     MOVF _rglf_fz, W, BANKED
30D6  6FE8     MOVWF quotient, BANKED
30D8  6BE9     CLRF p, BANKED
30DA  51E6     MOVF counter, W, BANKED
30DC  27E8     ADDWF quotient, F, BANKED
30DE  51E7     MOVF sign, W, BANKED
30E0  23E9     ADDWFC p, F, BANKED
30E2  51E4     MOVF k, W, BANKED
30E4  5DE8     SUBWF quotient, W, BANKED
30E6  51E9     MOVF p, W, BANKED
30E8  0A80     XORLW 0x80
30EA  6FEA     MOVWF tim, BANKED
30EC  51E5     MOVF k, W, BANKED
30EE  0A80     XORLW 0x80
30F0  59EA     SUBWFB tim, W, BANKED
30F2  E301     BNC 0x30F6
30F4  D151     BRA 0x3398
154:                       else
155:                       {
156:                           if(dt >= 0)
30F6  0100     MOVLB 0x0
30F8  BFEC     BTFSC dt, 7, BANKED
30FA  D01D     BRA 0x3136
157:                           {
158:                               if(dt < _BNCW2) pop = dt;
30FC  51EC     MOVF dt, W, BANKED
30FE  0A80     XORLW 0x80
3100  0F7D     ADDLW 0x7D
3102  E201     BC 0x3106
3104  D0BE     BRA 0x3282
159:                               else
160:                                   if((dt >= _BNCW2) && (dt <= (_DM_GECW2 - _BNCW2))) pop = _BNCW2;
3106  0100     MOVLB 0x0
3108  51EC     MOVF dt, W, BANKED
310A  0A80     XORLW 0x80
310C  0F7D     ADDLW 0x7D
310E  E306     BNC 0x311C
3110  51EC     MOVF dt, W, BANKED
3112  0A80     XORLW 0x80
3114  0F77     ADDLW 0x77
3116  E202     BC 0x311C
3118  0E03     MOVLW 0x3
311A  D0CA     BRA 0x32B0
161:                               else
162:                                   if(dt > (_DM_GECW2 - _BNCW2)) pop = _DM_GECW2 - dt;
311C  0100     MOVLB 0x0
311E  51EC     MOVF dt, W, BANKED
3120  0A80     XORLW 0x80
3122  0F77     ADDLW 0x77
3124  E305     BNC 0x3130
3126  51EC     MOVF dt, W, BANKED
3128  0800     SUBLW 0x0
312A  0F0B     ADDLW 0xB
312C  D0C1     BRA 0x32B0
312E  D000     BRA 0x3130
163:                               DtCW.SCW = DtCW.CW + pop;
3130  0100     MOVLB 0x0
3132  51EB     MOVF pop, W, BANKED
3134  D12D     BRA 0x3390
164:                           }
165:                           else
166:                           {
167:                               if((-1 * dt) < _BNCW2) pop = (-1 * dt);
3136  0100     MOVLB 0x0
3138  51EC     MOVF dt, W, BANKED
313A  6FDE     MOVWF __pcstackBANK0, BANKED
313C  6BDF     CLRF pco, BANKED
313E  BFDE     BTFSC __pcstackBANK0, 7, BANKED
3140  07DF     DECF pco, F, BANKED
3142  6BE1     CLRF GIE_BIT_VAL, BANKED
3144  0E01     MOVLW 0x1
3146  6FE0     MOVWF bdat, BANKED
3148  EC5B     CALL 0xECB6, 0
314A  F076     NOP
314C  0100     MOVLB 0x0
314E  1FDE     COMF __pcstackBANK0, F, BANKED
3150  1FDF     COMF pco, F, BANKED
3152  4BDE     INFSNZ __pcstackBANK0, F, BANKED
3154  2BDF     INCF pco, F, BANKED
3156  BFDF     BTFSC pco, 7, BANKED
3158  D006     BRA 0x3166
315A  51DF     MOVF pco, W, BANKED
315C  E10A     BNZ 0x3172
315E  0E03     MOVLW 0x3
3160  5DDE     SUBWF __pcstackBANK0, W, BANKED
3162  B0D8     BTFSC STATUS, 0, ACCESS
3164  D006     BRA 0x3172
3166  0100     MOVLB 0x0
3168  51EC     MOVF dt, W, BANKED
316A  0D01     MULLW 0x1
316C  50F3     MOVF PROD, W, ACCESS
316E  0800     SUBLW 0x0
3170  D04C     BRA 0x320A
168:                               else
169:                                   if(((-1 * dt) >= _BNCW2) && ((-1 * dt) <= (_DM_GECW2 - _BNCW2))) pop = _BNCW2;
3172  0100     MOVLB 0x0
3174  51EC     MOVF dt, W, BANKED
3176  6FDE     MOVWF __pcstackBANK0, BANKED
3178  6BDF     CLRF pco, BANKED
317A  BFDE     BTFSC __pcstackBANK0, 7, BANKED
317C  07DF     DECF pco, F, BANKED
317E  6BE1     CLRF GIE_BIT_VAL, BANKED
3180  0E01     MOVLW 0x1
3182  6FE0     MOVWF bdat, BANKED
3184  EC5B     CALL 0xECB6, 0
3186  F076     NOP
3188  0100     MOVLB 0x0
318A  1FDE     COMF __pcstackBANK0, F, BANKED
318C  1FDF     COMF pco, F, BANKED
318E  4BDE     INFSNZ __pcstackBANK0, F, BANKED
3190  2BDF     INCF pco, F, BANKED
3192  BFDF     BTFSC pco, 7, BANKED
3194  D01F     BRA 0x31D4
3196  51DF     MOVF pco, W, BANKED
3198  E103     BNZ 0x31A0
319A  0E03     MOVLW 0x3
319C  5DDE     SUBWF __pcstackBANK0, W, BANKED
319E  E31A     BNC 0x31D4
31A0  0100     MOVLB 0x0
31A2  51EC     MOVF dt, W, BANKED
31A4  6FDE     MOVWF __pcstackBANK0, BANKED
31A6  6BDF     CLRF pco, BANKED
31A8  BFDE     BTFSC __pcstackBANK0, 7, BANKED
31AA  07DF     DECF pco, F, BANKED
31AC  6BE1     CLRF GIE_BIT_VAL, BANKED
31AE  0E01     MOVLW 0x1
31B0  6FE0     MOVWF bdat, BANKED
31B2  EC5B     CALL 0xECB6, 0
31B4  F076     NOP
31B6  0100     MOVLB 0x0
31B8  1FDE     COMF __pcstackBANK0, F, BANKED
31BA  1FDF     COMF pco, F, BANKED
31BC  4BDE     INFSNZ __pcstackBANK0, F, BANKED
31BE  2BDF     INCF pco, F, BANKED
31C0  BFDF     BTFSC pco, 7, BANKED
31C2  D006     BRA 0x31D0
31C4  51DF     MOVF pco, W, BANKED
31C6  E106     BNZ 0x31D4
31C8  0E09     MOVLW 0x9
31CA  5DDE     SUBWF __pcstackBANK0, W, BANKED
31CC  B0D8     BTFSC STATUS, 0, ACCESS
31CE  D002     BRA 0x31D4
31D0  0E03     MOVLW 0x3
31D2  D01B     BRA 0x320A
170:                               else
171:                                   if((-1 * dt)>(_DM_GECW2 - _BNCW2)) pop = _DM_GECW2 + dt;
31D4  0100     MOVLB 0x0
31D6  51EC     MOVF dt, W, BANKED
31D8  6FDE     MOVWF __pcstackBANK0, BANKED
31DA  6BDF     CLRF pco, BANKED
31DC  BFDE     BTFSC __pcstackBANK0, 7, BANKED
31DE  07DF     DECF pco, F, BANKED
31E0  6BE1     CLRF GIE_BIT_VAL, BANKED
31E2  0E01     MOVLW 0x1
31E4  6FE0     MOVWF bdat, BANKED
31E6  EC5B     CALL 0xECB6, 0
31E8  F076     NOP
31EA  0100     MOVLB 0x0
31EC  1FDE     COMF __pcstackBANK0, F, BANKED
31EE  1FDF     COMF pco, F, BANKED
31F0  4BDE     INFSNZ __pcstackBANK0, F, BANKED
31F2  2BDF     INCF pco, F, BANKED
31F4  BFDF     BTFSC pco, 7, BANKED
31F6  D0C9     BRA 0x338A
31F8  51DF     MOVF pco, W, BANKED
31FA  E104     BNZ 0x3204
31FC  0E09     MOVLW 0x9
31FE  5DDE     SUBWF __pcstackBANK0, W, BANKED
3200  E201     BC 0x3204
3202  D0C3     BRA 0x338A
3204  0100     MOVLB 0x0
3206  51EC     MOVF dt, W, BANKED
3208  0F0B     ADDLW 0xB
320A  0100     MOVLB 0x0
320C  6FEB     MOVWF pop, BANKED
320E  D0BD     BRA 0x338A
172:                               DtCW.SCW = DtCW.CW - pop;
3210  D0BC     BRA 0x338A
173:                           }
174:                       }
175:                   }
3212  D0C4     BRA 0x339C
176:                   else
177:                   {
178:                       dt = DtCW.PPCW - DtCW.CW;
3214  0100     MOVLB 0x0
3216  51AA     MOVF DtCW, W, BANKED
3218  0800     SUBLW 0x0
321A  25AC     ADDWF _rglf_fz, W, BANKED
321C  6FEC     MOVWF dt, BANKED
179:                       if((DtCW.CW >= (DtCW.PPCW + _DM_GECW)) || (DtCW.CW <= (DtCW.PPCW - _DM_GECW))) DtCW.SCW = DtCW.CW;
321E  51AC     MOVF _rglf_fz, W, BANKED
3220  6FE4     MOVWF k, BANKED
3222  6BE5     CLRF k, BANKED
3224  0E08     MOVLW 0x8
3226  27E4     ADDWF k, F, BANKED
3228  0E00     MOVLW 0x0
322A  23E5     ADDWFC k, F, BANKED
322C  51AA     MOVF DtCW, W, BANKED
322E  6FE6     MOVWF counter, BANKED
3230  6BE7     CLRF sign, BANKED
3232  51E4     MOVF k, W, BANKED
3234  5DE6     SUBWF counter, W, BANKED
3236  51E7     MOVF sign, W, BANKED
3238  0A80     XORLW 0x80
323A  6FE8     MOVWF quotient, BANKED
323C  51E5     MOVF k, W, BANKED
323E  0A80     XORLW 0x80
3240  59E8     SUBWFB quotient, W, BANKED
3242  E301     BNC 0x3246
3244  D0A9     BRA 0x3398
3246  51AA     MOVF DtCW, W, BANKED
3248  6FE4     MOVWF k, BANKED
324A  6BE5     CLRF k, BANKED
324C  0EF8     MOVLW 0xF8
324E  6FE6     MOVWF counter, BANKED
3250  69E7     SETF sign, BANKED
3252  51AC     MOVF _rglf_fz, W, BANKED
3254  6FE8     MOVWF quotient, BANKED
3256  6BE9     CLRF p, BANKED
3258  51E6     MOVF counter, W, BANKED
325A  27E8     ADDWF quotient, F, BANKED
325C  51E7     MOVF sign, W, BANKED
325E  23E9     ADDWFC p, F, BANKED
3260  51E4     MOVF k, W, BANKED
3262  5DE8     SUBWF quotient, W, BANKED
3264  51E9     MOVF p, W, BANKED
3266  0A80     XORLW 0x80
3268  6FEA     MOVWF tim, BANKED
326A  51E5     MOVF k, W, BANKED
326C  0A80     XORLW 0x80
326E  59EA     SUBWFB tim, W, BANKED
3270  E301     BNC 0x3274
3272  D092     BRA 0x3398
180:                       else
181:                       {
182:                           if(dt >= 0)
3274  0100     MOVLB 0x0
3276  BFEC     BTFSC dt, 7, BANKED
3278  D01F     BRA 0x32B8
183:                           {
184:                               if(dt < _BNCW) pop = dt;
327A  51EC     MOVF dt, W, BANKED
327C  0A80     XORLW 0x80
327E  0F7E     ADDLW 0x7E
3280  E203     BC 0x3288
3282  C0EC     MOVFF dt, pop
3284  F0EB     NOP
3286  D754     BRA 0x3130
185:                               else
186:                                   if((dt >= _BNCW) && (dt <= (_DM_GECW - _BNCW))) pop = _BNCW;
3288  0100     MOVLB 0x0
328A  51EC     MOVF dt, W, BANKED
328C  0A80     XORLW 0x80
328E  0F7E     ADDLW 0x7E
3290  E306     BNC 0x329E
3292  51EC     MOVF dt, W, BANKED
3294  0A80     XORLW 0x80
3296  0F79     ADDLW 0x79
3298  E202     BC 0x329E
329A  0E02     MOVLW 0x2
329C  D009     BRA 0x32B0
187:                               else
188:                                   if(dt > (_DM_GECW - _BNCW)) pop = _DM_GECW - dt;
329E  0100     MOVLB 0x0
32A0  51EC     MOVF dt, W, BANKED
32A2  0A80     XORLW 0x80
32A4  0F79     ADDLW 0x79
32A6  E201     BC 0x32AA
32A8  D743     BRA 0x3130
32AA  51EC     MOVF dt, W, BANKED
32AC  0800     SUBLW 0x0
32AE  0F08     ADDLW 0x8
32B0  0100     MOVLB 0x0
32B2  6FEB     MOVWF pop, BANKED
32B4  D73D     BRA 0x3130
189:                               DtCW.SCW = DtCW.CW + pop;
32B6  D73C     BRA 0x3130
190:                           }
191:                           else
192:                           {
193:                               if(-1 * dt < _BNCW) pop = _BNCW + dt;
32B8  0100     MOVLB 0x0
32BA  51EC     MOVF dt, W, BANKED
32BC  6FDE     MOVWF __pcstackBANK0, BANKED
32BE  6BDF     CLRF pco, BANKED
32C0  BFDE     BTFSC __pcstackBANK0, 7, BANKED
32C2  07DF     DECF pco, F, BANKED
32C4  6BE1     CLRF GIE_BIT_VAL, BANKED
32C6  0E01     MOVLW 0x1
32C8  6FE0     MOVWF bdat, BANKED
32CA  EC5B     CALL 0xECB6, 0
32CC  F076     NOP
32CE  0100     MOVLB 0x0
32D0  1FDE     COMF __pcstackBANK0, F, BANKED
32D2  1FDF     COMF pco, F, BANKED
32D4  4BDE     INFSNZ __pcstackBANK0, F, BANKED
32D6  2BDF     INCF pco, F, BANKED
32D8  BFDF     BTFSC pco, 7, BANKED
32DA  D006     BRA 0x32E8
32DC  51DF     MOVF pco, W, BANKED
32DE  E108     BNZ 0x32F0
32E0  0E02     MOVLW 0x2
32E2  5DDE     SUBWF __pcstackBANK0, W, BANKED
32E4  B0D8     BTFSC STATUS, 0, ACCESS
32E6  D004     BRA 0x32F0
32E8  0100     MOVLB 0x0
32EA  51EC     MOVF dt, W, BANKED
32EC  0F02     ADDLW 0x2
32EE  D78D     BRA 0x320A
194:                               else
195:                                   if((-1 * dt >= _BNCW) && (-1 * dt <= (_DM_GECW - _BNCW))) pop = _BNCW;
32F0  0100     MOVLB 0x0
32F2  51EC     MOVF dt, W, BANKED
32F4  6FDE     MOVWF __pcstackBANK0, BANKED
32F6  6BDF     CLRF pco, BANKED
32F8  BFDE     BTFSC __pcstackBANK0, 7, BANKED
32FA  07DF     DECF pco, F, BANKED
32FC  6BE1     CLRF GIE_BIT_VAL, BANKED
32FE  0E01     MOVLW 0x1
3300  6FE0     MOVWF bdat, BANKED
3302  EC5B     CALL 0xECB6, 0
3304  F076     NOP
3306  0100     MOVLB 0x0
3308  1FDE     COMF __pcstackBANK0, F, BANKED
330A  1FDF     COMF pco, F, BANKED
330C  4BDE     INFSNZ __pcstackBANK0, F, BANKED
330E  2BDF     INCF pco, F, BANKED
3310  BFDF     BTFSC pco, 7, BANKED
3312  D01F     BRA 0x3352
3314  51DF     MOVF pco, W, BANKED
3316  E103     BNZ 0x331E
3318  0E02     MOVLW 0x2
331A  5DDE     SUBWF __pcstackBANK0, W, BANKED
331C  E31A     BNC 0x3352
331E  0100     MOVLB 0x0
3320  51EC     MOVF dt, W, BANKED
3322  6FDE     MOVWF __pcstackBANK0, BANKED
3324  6BDF     CLRF pco, BANKED
3326  BFDE     BTFSC __pcstackBANK0, 7, BANKED
3328  07DF     DECF pco, F, BANKED
332A  6BE1     CLRF GIE_BIT_VAL, BANKED
332C  0E01     MOVLW 0x1
332E  6FE0     MOVWF bdat, BANKED
3330  EC5B     CALL 0xECB6, 0
3332  F076     NOP
3334  0100     MOVLB 0x0
3336  1FDE     COMF __pcstackBANK0, F, BANKED
3338  1FDF     COMF pco, F, BANKED
333A  4BDE     INFSNZ __pcstackBANK0, F, BANKED
333C  2BDF     INCF pco, F, BANKED
333E  BFDF     BTFSC pco, 7, BANKED
3340  D006     BRA 0x334E
3342  51DF     MOVF pco, W, BANKED
3344  E106     BNZ 0x3352
3346  0E07     MOVLW 0x7
3348  5DDE     SUBWF __pcstackBANK0, W, BANKED
334A  B0D8     BTFSC STATUS, 0, ACCESS
334C  D002     BRA 0x3352
334E  0E02     MOVLW 0x2
3350  D75C     BRA 0x320A
196:                               else
197:                                   if(-1 * dt > (_DM_GECW - _BNCW)) pop = _DM_GECW + dt;
3352  0100     MOVLB 0x0
3354  51EC     MOVF dt, W, BANKED
3356  6FDE     MOVWF __pcstackBANK0, BANKED
3358  6BDF     CLRF pco, BANKED
335A  BFDE     BTFSC __pcstackBANK0, 7, BANKED
335C  07DF     DECF pco, F, BANKED
335E  6BE1     CLRF GIE_BIT_VAL, BANKED
3360  0E01     MOVLW 0x1
3362  6FE0     MOVWF bdat, BANKED
3364  EC5B     CALL 0xECB6, 0
3366  F076     NOP
3368  0100     MOVLB 0x0
336A  1FDE     COMF __pcstackBANK0, F, BANKED
336C  1FDF     COMF pco, F, BANKED
336E  4BDE     INFSNZ __pcstackBANK0, F, BANKED
3370  2BDF     INCF pco, F, BANKED
3372  BFDF     BTFSC pco, 7, BANKED
3374  D00A     BRA 0x338A
3376  51DF     MOVF pco, W, BANKED
3378  E103     BNZ 0x3380
337A  0E07     MOVLW 0x7
337C  5DDE     SUBWF __pcstackBANK0, W, BANKED
337E  E305     BNC 0x338A
3380  0100     MOVLB 0x0
3382  51EC     MOVF dt, W, BANKED
3384  0F08     ADDLW 0x8
3386  D741     BRA 0x320A
3388  D000     BRA 0x338A
198:                               DtCW.SCW = DtCW.CW - pop;
338A  0100     MOVLB 0x0
338C  51EB     MOVF pop, W, BANKED
338E  0800     SUBLW 0x0
3390  0100     MOVLB 0x0
3392  25AA     ADDWF DtCW, W, BANKED
3394  6FB3     MOVWF 0xB3, BANKED
199:                           }
200:                       }
201:                   }
202:               }
3396  D002     BRA 0x339C
203:               else DtCW.SCW = DtCW.CW; //kociol zasobnikowy - brak filtracji wskazu temp. CW
3398  C0AA     MOVFF DtCW, 0xB3
339A  F0B3     NOP
204:               PFN.CW = DtCW.SCW;
339C  C0B3     MOVFF 0xB3, 0x1E0
339E  F1E0     NOP
205:           }
33A0  0012     RETURN 0
206:           /*---------------------------------------------------------------------------------*/
207:           //Filtr dla danych wejsciowych modulatora.
208:           
209:           void PredkoscZmianCW(void)
210:           {
211:               static unsigned char ffcw, indff;
212:               unsigned char i, w;
213:           
214:               if(!Mf_PRACA)
B4D2  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
B4D4  D004     BRA 0xB4DE
215:               {
216:                   ffcw = 0;
B4D6  0101     MOVLB 0x1
B4D8  6B70     CLRF _PFNf_errIN, BANKED
217:                   indff = 0;
B4DA  6B71     CLRF _PFNf_fL3, BANKED
218:               }
B4DC  D051     BRA 0xB580
219:               else
220:               {
221:                   if(!indff)
B4DE  0101     MOVLB 0x1
B4E0  5171     MOVF _PFNf_fL3, W, BANKED
B4E2  E115     BNZ 0xB50E
222:                   {
223:                       for(i = 0; i < 10; i++) wff[i] = 0;
B4E4  0100     MOVLB 0x0
B4E6  6BE1     CLRF GIE_BIT_VAL, BANKED
B4E8  0E09     MOVLW 0x9
B4EA  0100     MOVLB 0x0
B4EC  65E1     CPFSGT GIE_BIT_VAL, BANKED
B4EE  D001     BRA 0xB4F2
B4F0  D00E     BRA 0xB50E
B4F2  0100     MOVLB 0x0
B4F4  51E1     MOVF GIE_BIT_VAL, W, BANKED
B4F6  0D01     MULLW 0x1
B4F8  0E00     MOVLW 0x0
B4FA  24F3     ADDWF PROD, W, ACCESS
B4FC  6ED9     MOVWF FSR2, ACCESS
B4FE  0E03     MOVLW 0x3
B500  20F4     ADDWFC PRODH, W, ACCESS
B502  6EDA     MOVWF FSR2H, ACCESS
B504  6ADF     CLRF INDF2, ACCESS
B506  0100     MOVLB 0x0
B508  2BE1     INCF GIE_BIT_VAL, F, BANKED
B50A  D7EE     BRA 0xB4E8
B50C  D000     BRA 0xB50E
224:                   }
225:                   indff++;
B50E  0101     MOVLB 0x1
B510  2B71     INCF _PFNf_fL3, F, BANKED
226:                   if(indff >= 9)
B512  0E08     MOVLW 0x8
B514  0101     MOVLB 0x1
B516  6571     CPFSGT _PFNf_fL3, BANKED
B518  D024     BRA 0xB562
227:                   {
228:                       indff = 9;
B51A  0E09     MOVLW 0x9
B51C  6F71     MOVWF _PFNf_fL3, BANKED
229:                       for(i = 0; i < 9; i++) wff[i] = wff[i + 1]; //FIFO
B51E  0100     MOVLB 0x0
B520  6BE1     CLRF GIE_BIT_VAL, BANKED
B522  0E08     MOVLW 0x8
B524  0100     MOVLB 0x0
B526  65E1     CPFSGT GIE_BIT_VAL, BANKED
B528  D001     BRA 0xB52C
B52A  D01B     BRA 0xB562
B52C  0100     MOVLB 0x0
B52E  51E1     MOVF GIE_BIT_VAL, W, BANKED
B530  6FDE     MOVWF __pcstackBANK0, BANKED
B532  6BDF     CLRF pco, BANKED
B534  2BDE     INCF __pcstackBANK0, F, BANKED
B536  0E00     MOVLW 0x0
B538  23DF     ADDWFC pco, F, BANKED
B53A  0E00     MOVLW 0x0
B53C  25DE     ADDWF __pcstackBANK0, W, BANKED
B53E  6ED9     MOVWF FSR2, ACCESS
B540  0E03     MOVLW 0x3
B542  21DF     ADDWFC pco, W, BANKED
B544  6EDA     MOVWF FSR2H, ACCESS
B546  51E1     MOVF GIE_BIT_VAL, W, BANKED
B548  0D01     MULLW 0x1
B54A  0E00     MOVLW 0x0
B54C  24F3     ADDWF PROD, W, ACCESS
B54E  6EE1     MOVWF FSR1, ACCESS
B550  0E03     MOVLW 0x3
B552  20F4     ADDWFC PRODH, W, ACCESS
B554  6EE2     MOVWF FSR1H, ACCESS
B556  CFDF     MOVFF INDF2, INDF1
B558  FFE7     NOP
B55A  0100     MOVLB 0x0
B55C  2BE1     INCF GIE_BIT_VAL, F, BANKED
B55E  D7E1     BRA 0xB522
B560  D000     BRA 0xB562
230:                   }
231:                   wff[indff] = DtCW.CW - ffcw; //przyrost/spadek
B562  0101     MOVLB 0x1
B564  5171     MOVF _PFNf_fL3, W, BANKED
B566  0D01     MULLW 0x1
B568  0E00     MOVLW 0x0
B56A  24F3     ADDWF PROD, W, ACCESS
B56C  6ED9     MOVWF FSR2, ACCESS
B56E  0E03     MOVLW 0x3
B570  20F4     ADDWFC PRODH, W, ACCESS
B572  6EDA     MOVWF FSR2H, ACCESS
B574  5170     MOVF _PFNf_errIN, W, BANKED
B576  0800     SUBLW 0x0
B578  0100     MOVLB 0x0
B57A  25AA     ADDWF DtCW, W, BANKED
B57C  6EDF     MOVWF INDF2, ACCESS
B57E  D000     BRA 0xB580
232:               }
233:               ffcw = DtCW.CW;
B580  C0AA     MOVFF DtCW, ffcw
B582  F170     NOP
234:               w = 0;
B584  0100     MOVLB 0x0
B586  6BE0     CLRF bdat, BANKED
235:               for(i = 0; i < 10; i++) w += wff[i];
B588  0100     MOVLB 0x0
B58A  6BE1     CLRF GIE_BIT_VAL, BANKED
B58C  D00E     BRA 0xB5AA
B58E  D011     BRA 0xB5B2
B590  0100     MOVLB 0x0
B592  51E1     MOVF GIE_BIT_VAL, W, BANKED
B594  0D01     MULLW 0x1
B596  0E00     MOVLW 0x0
B598  24F3     ADDWF PROD, W, ACCESS
B59A  6ED9     MOVWF FSR2, ACCESS
B59C  0E03     MOVLW 0x3
B59E  20F4     ADDWFC PRODH, W, ACCESS
B5A0  6EDA     MOVWF FSR2H, ACCESS
B5A2  50DF     MOVF INDF2, W, ACCESS
B5A4  27E0     ADDWF bdat, F, BANKED
B5A6  0100     MOVLB 0x0
B5A8  2BE1     INCF GIE_BIT_VAL, F, BANKED
B5AA  0E09     MOVLW 0x9
B5AC  0100     MOVLB 0x0
B5AE  65E1     CPFSGT GIE_BIT_VAL, BANKED
B5B0  D7EF     BRA 0xB590
236:               DtCW.ddDCW = w;
B5B2  C0E0     MOVFF bdat, 0xB1
B5B4  F0B1     NOP
237:           }
B5B6  0012     RETURN 0
238:           /*---------------------------------------------------------------------------------*/
239:           //Filtr dla danych wejsciowych modulatora.
240:           
241:           void FltParMod(void)
242:           {
243:               static unsigned char indtm, fco, fcw;
244:               unsigned char wr;
245:           
246:               //----------
247:               //wykonywane co 0.1 sek.
248:               //CO
249:               if(DtCO.CO > fco) wr = DtCO.CO - fco;
B5B8  0100     MOVLB 0x0
B5BA  51CF     MOVF DtCO, W, BANKED
B5BC  0101     MOVLB 0x1
B5BE  5D4A     SUBWF 0x4A, W, BANKED
B5C0  E205     BC 0xB5CC
B5C2  514A     MOVF 0x4A, W, BANKED
B5C4  0800     SUBLW 0x0
B5C6  0100     MOVLB 0x0
B5C8  25CF     ADDWF DtCO, W, BANKED
B5CA  D005     BRA 0xB5D6
250:               else wr = fco - DtCO.CO;
B5CC  0100     MOVLB 0x0
B5CE  51CF     MOVF DtCO, W, BANKED
B5D0  0800     SUBLW 0x0
B5D2  0101     MOVLB 0x1
B5D4  254A     ADDWF 0x4A, W, BANKED
B5D6  0100     MOVLB 0x0
B5D8  6FE2     MOVWF divisor, BANKED
B5DA  D000     BRA 0xB5DC
251:               if(wr) DtCO.indCO++;
B5DC  0100     MOVLB 0x0
B5DE  51E2     MOVF divisor, W, BANKED
B5E0  E002     BZ 0xB5E6
B5E2  2BD7     INCF 0xD7, F, BANKED
B5E4  D000     BRA 0xB5E6
252:               if(wr >= 2) DtCO.indCO = 10;
B5E6  0E01     MOVLW 0x1
B5E8  0100     MOVLB 0x0
B5EA  65E2     CPFSGT divisor, BANKED
B5EC  D003     BRA 0xB5F4
B5EE  0E0A     MOVLW 0xA
B5F0  6FD7     MOVWF 0xD7, BANKED
B5F2  D000     BRA 0xB5F4
253:               //CW
254:               if(DtCW.CW > fcw) wr = DtCW.CW - fcw;
B5F4  0100     MOVLB 0x0
B5F6  51AA     MOVF DtCW, W, BANKED
B5F8  0101     MOVLB 0x1
B5FA  5D4B     SUBWF 0x4B, W, BANKED
B5FC  E205     BC 0xB608
B5FE  514B     MOVF 0x4B, W, BANKED
B600  0800     SUBLW 0x0
B602  0100     MOVLB 0x0
B604  25AA     ADDWF DtCW, W, BANKED
B606  D005     BRA 0xB612
255:               else wr = fcw - DtCW.CW;
B608  0100     MOVLB 0x0
B60A  51AA     MOVF DtCW, W, BANKED
B60C  0800     SUBLW 0x0
B60E  0101     MOVLB 0x1
B610  254B     ADDWF 0x4B, W, BANKED
B612  0100     MOVLB 0x0
B614  6FE2     MOVWF divisor, BANKED
B616  D000     BRA 0xB618
256:               if(wr) DtCW.indCW++;
B618  0100     MOVLB 0x0
B61A  51E2     MOVF divisor, W, BANKED
B61C  E002     BZ 0xB622
B61E  2BB2     INCF 0xB2, F, BANKED
B620  D000     BRA 0xB622
257:               if(wr >= 2) DtCW.indCW = 10;
B622  0E01     MOVLW 0x1
B624  0100     MOVLB 0x0
B626  65E2     CPFSGT divisor, BANKED
B628  D003     BRA 0xB630
B62A  0E0A     MOVLW 0xA
B62C  6FB2     MOVWF 0xB2, BANKED
B62E  D000     BRA 0xB630
258:               PredkoscZmianCW();
B630  EC69     CALL 0xB4D2, 0
B632  F05A     NOP
259:               //----------
260:               //wykonywane co 1 sek.
261:               indtm++;
B634  0101     MOVLB 0x1
B636  2B4C     INCF 0x4C, F, BANKED
262:               if(indtm > 9)
B638  0E09     MOVLW 0x9
B63A  0101     MOVLB 0x1
B63C  654C     CPFSGT 0x4C, BANKED
B63E  0C09     RETLW 0x9
263:               {
264:                   indtm = 0;
B640  0E00     MOVLW 0x0
B642  6F4C     MOVWF 0x4C, BANKED
265:           
266:                   DtZW.SZW = DtZW.ZW; //wartosc temp zewnwtrznej (aktualizacja co 1 sek.)
B644  C146     MOVFF 0x146, 0x147
B646  F147     NOP
267:           
268:                   //szybkosc i kierunek zmian temp CO
269:                   if(DtCO.indCO <= 7) DtCO.dDCO = 0; //temp = const
B648  0E08     MOVLW 0x8
B64A  0100     MOVLB 0x0
B64C  61D7     CPFSLT 0xD7, BANKED
B64E  D003     BRA 0xB656
B650  0E00     MOVLW 0x0
B652  6FD6     MOVWF 0xD6, BANKED
B654  D009     BRA 0xB668
270:                   else
271:                   {
272:                       DtCO.dDCO = DtCO.CO - fco;
B656  0101     MOVLB 0x1
B658  514A     MOVF 0x4A, W, BANKED
B65A  0800     SUBLW 0x0
B65C  0100     MOVLB 0x0
B65E  25CF     ADDWF DtCO, W, BANKED
B660  6FD6     MOVWF 0xD6, BANKED
273:                       fco = DtCO.CO;
B662  C0CF     MOVFF DtCO, fco
B664  F14A     NOP
B666  D000     BRA 0xB668
274:                   }
275:                   DtCO.indCO = 0;
B668  0E00     MOVLW 0x0
B66A  0100     MOVLB 0x0
B66C  6FD7     MOVWF 0xD7, BANKED
276:                   //szybkosc i kierunek zmian temp CW
277:                   if(DtCW.indCW <= 7)
B66E  0E08     MOVLW 0x8
B670  0100     MOVLB 0x0
B672  61B2     CPFSLT 0xB2, BANKED
B674  D004     BRA 0xB67E
278:                   {
279:                       DtCW.dDCW = 0; //temp = const
B676  0E00     MOVLW 0x0
B678  6FB0     MOVWF 0xB0, BANKED
280:                       DtCWf_fpCW = 1;
B67A  8A04     BSF DtCWf_err_CW, 5, ACCESS
281:                   }
B67C  D00A     BRA 0xB692
282:                   else
283:                   {
284:                       DtCW.dDCW = DtCW.CW - fcw;
B67E  0101     MOVLB 0x1
B680  514B     MOVF 0x4B, W, BANKED
B682  0800     SUBLW 0x0
B684  0100     MOVLB 0x0
B686  25AA     ADDWF DtCW, W, BANKED
B688  6FB0     MOVWF 0xB0, BANKED
285:                       DtCWf_fpCW = 1;
B68A  8A04     BSF DtCWf_err_CW, 5, ACCESS
286:                       fcw = DtCW.CW;
B68C  C0AA     MOVFF DtCW, fcw
B68E  F14B     NOP
B690  D000     BRA 0xB692
287:                   }
288:                   DtCW.indCW = 0;
B692  0E00     MOVLW 0x0
B694  0100     MOVLB 0x0
B696  6FB2     MOVWF 0xB2, BANKED
B698  0C00     RETLW 0x0
289:               }
290:           }
B69A  0012     RETURN 0
291:           /*---------------------------------------------------------------------------------*/
292:           //Filtracja wartosci (nowa wartosc odswiezana jest co 0.5 sek)
293:           //(umiescic w petli glownej programu po procedurach pomiaru CO,CW,PCO,PCW)
294:           
295:           void FiltrPomiarowyCOCW(void)
296:           {
297:               //----------
298:               //Filtr GoldenEye
299:               if(PmrTim1(_ITFGE))
C7AA  0E14     MOVLW 0x14
C7AC  EC87     CALL 0xF10E, 0
C7AE  F078     NOP
C7B0  E305     BNC 0xC7BC
300:               {
301:                   StartTim1();
C7B2  ECF6     CALL 0xF3EC, 0
C7B4  F079     NOP
302:                   GoldenEye();
C7B6  EC9A     CALL 0x2F34, 0
C7B8  F017     NOP
C7BA  D000     BRA 0xC7BC
303:               }
304:               //----------
305:               //Filtr dla danych wejsciowych modulatora.
306:               DtCO.DCO = (DtCO.PPCO - _BNCO) - DtCO.CO; //wielkosc bledu CO
C7BC  0100     MOVLB 0x0
C7BE  51CF     MOVF DtCO, W, BANKED
C7C0  0800     SUBLW 0x0
C7C2  25D1     ADDWF 0xD1, W, BANKED
C7C4  6FED     MOVWF min, BANKED
C7C6  05ED     DECF min, W, BANKED
C7C8  6FD5     MOVWF 0xD5, BANKED
307:           
308:               DtCW.DCW = (DtCW.PPCW - (_BNCW - 1)) - DtCW.CW; //wielkosc bledu CW
C7CA  0100     MOVLB 0x0
C7CC  51AA     MOVF DtCW, W, BANKED
C7CE  0800     SUBLW 0x0
C7D0  25AC     ADDWF _rglf_fz, W, BANKED
C7D2  6FED     MOVWF min, BANKED
C7D4  05ED     DECF min, W, BANKED
C7D6  6FAF     MOVWF _rglf_nmod, BANKED
309:           
310:               if(!DtINf_err_IN)
C7D8  BA05     BTFSC DtKNFf_enknf, 5, ACCESS
C7DA  D01C     BRA 0xC814
311:               {
312:                   //delta wzgledem temp. wyj. CO
313:                   if(DtCO.CO > DtIN.IN) DtIN.DIN = DtCO.CO - DtIN.IN;
C7DC  0100     MOVLB 0x0
C7DE  51CF     MOVF DtCO, W, BANKED
C7E0  0101     MOVLB 0x1
C7E2  5D1B     SUBWF _DtCSf_error, W, BANKED
C7E4  E205     BC 0xC7F0
C7E6  511B     MOVF _DtCSf_error, W, BANKED
C7E8  0800     SUBLW 0x0
C7EA  0100     MOVLB 0x0
C7EC  25CF     ADDWF DtCO, W, BANKED
C7EE  D001     BRA 0xC7F2
314:                   else DtIN.DIN = 0;
C7F0  0E00     MOVLW 0x0
C7F2  0101     MOVLB 0x1
C7F4  6F1C     MOVWF _DtCSf_hi, BANKED
C7F6  D000     BRA 0xC7F8
315:                   //delta wzgledem nastawy CO
316:                   if((DtCO.PPCO - (_BNCO - 1)) > DtIN.IN) DtIN.DIN2 = (DtCO.PPCO - (_BNCO - 1)) - DtIN.IN;
C7F8  0100     MOVLB 0x0
C7FA  51D1     MOVF 0xD1, W, BANKED
C7FC  0101     MOVLB 0x1
C7FE  5D1B     SUBWF _DtCSf_error, W, BANKED
C800  E205     BC 0xC80C
C802  511B     MOVF _DtCSf_error, W, BANKED
C804  0800     SUBLW 0x0
C806  0100     MOVLB 0x0
C808  25D1     ADDWF 0xD1, W, BANKED
C80A  D001     BRA 0xC80E
317:                   else DtIN.DIN2 = 0;
C80C  0E00     MOVLW 0x0
C80E  0101     MOVLB 0x1
C810  6F1D     MOVWF _DtCSf_lo, BANKED
C812  D000     BRA 0xC814
318:               }
319:           
320:               if(PmrTim2(_ITFTM))
C814  0E0A     MOVLW 0xA
C816  EC7B     CALL 0xF0F6, 0
C818  F078     NOP
C81A  E305     BNC 0xC826
321:               {
322:                   StartTim2();
C81C  ECF2     CALL 0xF3E4, 0
C81E  F079     NOP
323:                   FltParMod();
C820  ECDC     CALL 0xB5B8, 0
C822  F05A     NOP
C824  D000     BRA 0xC826
324:               }
325:               if(DtCO.dDCO >= _MAX_DXCO) DtCOf_ldDCO = 1; //b.szybki narost temperatury?
C826  0100     MOVLB 0x0
C828  51D6     MOVF 0xD6, W, BANKED
C82A  0A80     XORLW 0x80
C82C  0F7A     ADDLW 0x7A
C82E  E302     BNC 0xC834
C830  8202     BSF DtCOf_su_CO, 1, ACCESS
C832  0012     RETURN 0
326:               else DtCOf_ldDCO = 0;
C834  9202     BCF DtCOf_su_CO, 1, ACCESS
C836  0012     RETURN 0
327:           }
C838  0012     RETURN 0
328:           /*---------------------------------------------------------------------------------*/
329:           //Pomiar wartosci CO i ustawienie odpowiednich flag stanu
330:           
331:           void PomiarCO(void)
332:           {
333:               DtCO.AC_CO = ReadAC(_CHN_CO);
3806  0E00     MOVLW 0x0
3808  EC33     CALL 0xD466, 0
380A  F06A     NOP
380C  0100     MOVLB 0x0
380E  6FD9     MOVWF 0xD9, BANKED
334:               DtCO.CO = ReadTabNTC(DtCO.AC_CO);
3810  51D9     MOVF 0xD9, W, BANKED
3812  EC21     CALL 0xD242, 0
3814  F069     NOP
3816  0100     MOVLB 0x0
3818  6FCF     MOVWF DtCO, BANKED
335:           
336:               if(DtCO.AC_CO <= _NTC_MIN || DtCO.AC_CO >= _NTC_MAX) //stwierdzenie awarii czujnika temp. CO
381A  0E28     MOVLW 0x28
381C  0100     MOVLB 0x0
381E  65D9     CPFSGT 0xD9, BANKED
3820  D003     BRA 0x3828
3822  0EF4     MOVLW 0xF4
3824  65D9     CPFSGT 0xD9, BANKED
3826  D00E     BRA 0x3844
337:               {
338:                   DtCOf_err_CO = 1;
3828  8E01     BSF DtCOf_err_CO, 7, ACCESS
339:                   DtCOf_su_CO = 0;
382A  9E02     BCF DtCOf_su_CO, 7, ACCESS
340:                   DtCOf_ad_CO = 0;
382C  9601     BCF DtCOf_err_CO, 3, ACCESS
341:                   DtCOf_cold_CO = 0;
382E  9C01     BCF DtCOf_err_CO, 6, ACCESS
342:                   DtCOf_hot_CO = 0;
3830  9002     BCF DtCOf_su_CO, 0, ACCESS
343:                   DtCOf_on_DZ_CO = 0;
3832  9602     BCF DtCOf_su_CO, 3, ACCESS
344:                   DtCOf_su_DZ_CO = 0;
3834  9003     BCF DtCOf_su_SRW_CO, 0, ACCESS
345:                   DtCOf_ad_DZ_CO = 0;
3836  9801     BCF DtCOf_err_CO, 4, ACCESS
346:                   DtCOf_ptwp_CO = 0;
3838  9802     BCF DtCOf_su_CO, 4, ACCESS
347:                   DtCOf_pz_CO = 0;
383A  9A02     BCF DtCOf_su_CO, 5, ACCESS
348:                   DtCOf_su_SRW_CO = 0;
383C  9203     BCF DtCOf_su_SRW_CO, 1, ACCESS
349:                   DtCOf_ad_SRW_CO = 0;
383E  9A01     BCF DtCOf_err_CO, 5, ACCESS
350:                   return;
3840  0012     RETURN 0
351:               }
3842  D1C1     BRA 0x3BC6
352:               else DtCOf_err_CO = 0;
3844  9E01     BCF DtCOf_err_CO, 7, ACCESS
353:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
3846  D1BF     BRA 0x3BC6
3BC6  0100     MOVLB 0x0
3BC8  519E     MOVF _PWMf_ENPWM2, W, BANKED
3BCA  E101     BNZ 0x3BCE
3BCC  D726     BRA 0x3A1A
3BCE  0A01     XORLW 0x1
3BD0  E101     BNZ 0x3BD4
3BD2  D63B     BRA 0x384A
3BD4  0A03     XORLW 0x3
3BD6  E101     BNZ 0x3BDA
3BD8  D638     BRA 0x384A
3BDA  0A01     XORLW 0x1
3BDC  E101     BNZ 0x3BE0
3BDE  D6AD     BRA 0x393A
3BE0  D787     BRA 0x3AF0
354:               {
355:                   case _BITERM: //bitermiczny (miniterm)
3848  D000     BRA 0x384A
356:                   case _BITERM2: //bitermiczny (maxiterm)
357:                   {
358:                       //if((DtCO.CO - DtCO.PPCO) >= F1_AD_CO) DtCOf_ad_CO = 1;
359:                       //else DtCOf_ad_CO = 0;
360:                       if(DtCO.PPCO>(_MAX_PCO-5))	//nastawa > 80?
384A  0E50     MOVLW 0x50
384C  0100     MOVLB 0x0
384E  65D1     CPFSGT 0xD1, BANKED
3850  D022     BRA 0x3896
361:                       {
362:                               if(DtCO.PPCO<=_MAX_PCO)	//nastawa <= _MAX_PCO?
3852  0E56     MOVLW 0x56
3854  61D1     CPFSLT 0xD1, BANKED
3856  D006     BRA 0x3864
363:                               {
364:                                       if((DtCO.CO-_MAX_PCO)>=F1_AD_CO) DtCOf_ad_CO=1;
3858  0EAB     MOVLW 0xAB
385A  6FE4     MOVWF k, BANKED
385C  69E5     SETF k, BANKED
385E  D00A     BRA 0x3874
3860  D030     BRA 0x38C2
365:                                       else DtCOf_ad_CO=0;
366:                               }
3862  D033     BRA 0x38CA
367:                               else
368:                               {
369:                                       if((DtCO.CO-DtCO.PPCO)>=F1_AD_CO) DtCOf_ad_CO=1;
3864  0100     MOVLB 0x0
3866  51D1     MOVF 0xD1, W, BANKED
3868  6FE4     MOVWF k, BANKED
386A  6BE5     CLRF k, BANKED
386C  1FE4     COMF k, F, BANKED
386E  1FE5     COMF k, F, BANKED
3870  4BE4     INFSNZ k, F, BANKED
3872  2BE5     INCF k, F, BANKED
3874  0100     MOVLB 0x0
3876  51CF     MOVF DtCO, W, BANKED
3878  6FE6     MOVWF counter, BANKED
387A  6BE7     CLRF sign, BANKED
387C  51E4     MOVF k, W, BANKED
387E  27E6     ADDWF counter, F, BANKED
3880  51E5     MOVF k, W, BANKED
3882  23E7     ADDWFC sign, F, BANKED
3884  BFE7     BTFSC sign, 7, BANKED
3886  D01F     BRA 0x38C6
3888  51E7     MOVF sign, W, BANKED
388A  E11B     BNZ 0x38C2
388C  0E05     MOVLW 0x5
388E  5DE6     SUBWF counter, W, BANKED
3890  E31A     BNC 0x38C6
3892  D017     BRA 0x38C2
370:                                       else DtCOf_ad_CO=0;
371:                               }
372:                       }
3894  D01A     BRA 0x38CA
373:                       else	//nastawa <= 80?
374:                       {
375:                               if((DtCO.CO-DtCO.PPCO)>=F1_AD_CO2) DtCOf_ad_CO=1;
3896  0100     MOVLB 0x0
3898  51D1     MOVF 0xD1, W, BANKED
389A  6FE4     MOVWF k, BANKED
389C  6BE5     CLRF k, BANKED
389E  1FE4     COMF k, F, BANKED
38A0  1FE5     COMF k, F, BANKED
38A2  4BE4     INFSNZ k, F, BANKED
38A4  2BE5     INCF k, F, BANKED
38A6  51CF     MOVF DtCO, W, BANKED
38A8  6FE6     MOVWF counter, BANKED
38AA  6BE7     CLRF sign, BANKED
38AC  51E4     MOVF k, W, BANKED
38AE  27E6     ADDWF counter, F, BANKED
38B0  51E5     MOVF k, W, BANKED
38B2  23E7     ADDWFC sign, F, BANKED
38B4  BFE7     BTFSC sign, 7, BANKED
38B6  D007     BRA 0x38C6
38B8  51E7     MOVF sign, W, BANKED
38BA  E103     BNZ 0x38C2
38BC  0E0A     MOVLW 0xA
38BE  5DE6     SUBWF counter, W, BANKED
38C0  E302     BNC 0x38C6
38C2  8601     BSF DtCOf_err_CO, 3, ACCESS
38C4  D002     BRA 0x38CA
376:                               else DtCOf_ad_CO=0;
38C6  9601     BCF DtCOf_err_CO, 3, ACCESS
38C8  D000     BRA 0x38CA
377:                       }
378:                       if((DtCO.PPCO - DtCO.CO) >= F1_SU_CO) DtCOf_su_CO = 1;
38CA  0100     MOVLB 0x0
38CC  51CF     MOVF DtCO, W, BANKED
38CE  6FE4     MOVWF k, BANKED
38D0  6BE5     CLRF k, BANKED
38D2  1FE4     COMF k, F, BANKED
38D4  1FE5     COMF k, F, BANKED
38D6  4BE4     INFSNZ k, F, BANKED
38D8  2BE5     INCF k, F, BANKED
38DA  51D1     MOVF 0xD1, W, BANKED
38DC  6FE6     MOVWF counter, BANKED
38DE  6BE7     CLRF sign, BANKED
38E0  51E4     MOVF k, W, BANKED
38E2  27E6     ADDWF counter, F, BANKED
38E4  51E5     MOVF k, W, BANKED
38E6  23E7     ADDWFC sign, F, BANKED
38E8  BFE7     BTFSC sign, 7, BANKED
38EA  D007     BRA 0x38FA
38EC  51E7     MOVF sign, W, BANKED
38EE  E103     BNZ 0x38F6
38F0  0E05     MOVLW 0x5
38F2  5DE6     SUBWF counter, W, BANKED
38F4  E302     BNC 0x38FA
38F6  8E02     BSF DtCOf_su_CO, 7, ACCESS
38F8  D002     BRA 0x38FE
379:                       else DtCOf_su_CO = 0;
38FA  9E02     BCF DtCOf_su_CO, 7, ACCESS
38FC  D000     BRA 0x38FE
380:                       if(DtCO.CO <= F1_PTWP_CO) DtCOf_ptwp_CO = 1;
38FE  0E33     MOVLW 0x33
3900  0100     MOVLB 0x0
3902  61CF     CPFSLT DtCO, BANKED
3904  D002     BRA 0x390A
3906  8802     BSF DtCOf_su_CO, 4, ACCESS
3908  D000     BRA 0x390A
381:                       if(DtCO.CO > F1_PTWP_CO + 1) DtCOf_ptwp_CO = 0;
390A  0E33     MOVLW 0x33
390C  0100     MOVLB 0x0
390E  65CF     CPFSGT DtCO, BANKED
3910  D002     BRA 0x3916
3912  9802     BCF DtCOf_su_CO, 4, ACCESS
3914  D000     BRA 0x3916
382:                       if(DtCO.CO <= F1_PZ_CO) DtCOf_pz_CO = 1;
3916  0E53     MOVLW 0x53
3918  0100     MOVLB 0x0
391A  61CF     CPFSLT DtCO, BANKED
391C  D002     BRA 0x3922
391E  8A02     BSF DtCOf_su_CO, 5, ACCESS
3920  D000     BRA 0x3922
383:                       if(DtCO.CO > F1_PW_CO) DtCOf_pz_CO = 0;
3922  0E58     MOVLW 0x58
3924  D06B     BRA 0x39FC
384:                       if(DtCO.CO <= F1_CLD_CO) DtCOf_cold_CO = 1;
3926  0E08     MOVLW 0x8
3928  0100     MOVLB 0x0
392A  61CF     CPFSLT DtCO, BANKED
392C  D06D     BRA 0x3A08
392E  8C01     BSF DtCOf_err_CO, 6, ACCESS
3930  D06B     BRA 0x3A08
385:                       if(DtCO.CO > F1_CLD_CO + 1) DtCOf_cold_CO = 0;
3932  D06A     BRA 0x3A08
386:                       if(DtCO.CO >= F1_HOT_CO) DtCOf_hot_CO = 1;
3934  D0D5     BRA 0x3AE0
387:                       if(DtCO.CO < F1_HOT_CO - 1) DtCOf_hot_CO = 0;
3936  D141     BRA 0x3BBA
388:                       break;
3938  D154     BRA 0x3BE2
389:                   }
390:                   case _MONOHB:
391:                   {
392:                       //if((DtCO.CO - DtCO.PPCO) >= F2_AD_CO) DtCOf_ad_CO = 1;
393:                       //else DtCOf_ad_CO = 0;
394:                       if(DtCO.PPCO>(_MAX_PCO-5))	//nastawa > 80?
393A  0E50     MOVLW 0x50
393C  0100     MOVLB 0x0
393E  65D1     CPFSGT 0xD1, BANKED
3940  D022     BRA 0x3986
395:                       {
396:                               if(DtCO.PPCO<=_MAX_PCO)	//nastawa <= _MAX_PCO?
3942  0E56     MOVLW 0x56
3944  61D1     CPFSLT 0xD1, BANKED
3946  D006     BRA 0x3954
397:                               {
398:                                       if((DtCO.CO-_MAX_PCO)>=F2_AD_CO) DtCOf_ad_CO=1;
3948  0EAB     MOVLW 0xAB
394A  6FE4     MOVWF k, BANKED
394C  69E5     SETF k, BANKED
394E  D00A     BRA 0x3964
3950  D030     BRA 0x39B2
399:                                       else DtCOf_ad_CO=0;
400:                               }
3952  D033     BRA 0x39BA
401:                               else
402:                               {
403:                                       if((DtCO.CO-DtCO.PPCO)>=F2_AD_CO) DtCOf_ad_CO=1;
3954  0100     MOVLB 0x0
3956  51D1     MOVF 0xD1, W, BANKED
3958  6FE4     MOVWF k, BANKED
395A  6BE5     CLRF k, BANKED
395C  1FE4     COMF k, F, BANKED
395E  1FE5     COMF k, F, BANKED
3960  4BE4     INFSNZ k, F, BANKED
3962  2BE5     INCF k, F, BANKED
3964  0100     MOVLB 0x0
3966  51CF     MOVF DtCO, W, BANKED
3968  6FE6     MOVWF counter, BANKED
396A  6BE7     CLRF sign, BANKED
396C  51E4     MOVF k, W, BANKED
396E  27E6     ADDWF counter, F, BANKED
3970  51E5     MOVF k, W, BANKED
3972  23E7     ADDWFC sign, F, BANKED
3974  BFE7     BTFSC sign, 7, BANKED
3976  D01F     BRA 0x39B6
3978  51E7     MOVF sign, W, BANKED
397A  E11B     BNZ 0x39B2
397C  0E05     MOVLW 0x5
397E  5DE6     SUBWF counter, W, BANKED
3980  E31A     BNC 0x39B6
3982  D017     BRA 0x39B2
404:                                       else DtCOf_ad_CO=0;
405:                               }
406:                       }
3984  D01A     BRA 0x39BA
407:                       else	//nastawa <= 80?
408:                       {
409:                               if((DtCO.CO-DtCO.PPCO)>=F2_AD_CO2) DtCOf_ad_CO=1;
3986  0100     MOVLB 0x0
3988  51D1     MOVF 0xD1, W, BANKED
398A  6FE4     MOVWF k, BANKED
398C  6BE5     CLRF k, BANKED
398E  1FE4     COMF k, F, BANKED
3990  1FE5     COMF k, F, BANKED
3992  4BE4     INFSNZ k, F, BANKED
3994  2BE5     INCF k, F, BANKED
3996  51CF     MOVF DtCO, W, BANKED
3998  6FE6     MOVWF counter, BANKED
399A  6BE7     CLRF sign, BANKED
399C  51E4     MOVF k, W, BANKED
399E  27E6     ADDWF counter, F, BANKED
39A0  51E5     MOVF k, W, BANKED
39A2  23E7     ADDWFC sign, F, BANKED
39A4  BFE7     BTFSC sign, 7, BANKED
39A6  D007     BRA 0x39B6
39A8  51E7     MOVF sign, W, BANKED
39AA  E103     BNZ 0x39B2
39AC  0E0A     MOVLW 0xA
39AE  5DE6     SUBWF counter, W, BANKED
39B0  E302     BNC 0x39B6
39B2  8601     BSF DtCOf_err_CO, 3, ACCESS
39B4  D002     BRA 0x39BA
410:                               else DtCOf_ad_CO=0;
39B6  9601     BCF DtCOf_err_CO, 3, ACCESS
39B8  D000     BRA 0x39BA
411:                       }
412:                       if((DtCO.PPCO - DtCO.CO) >= F2_SU_CO) DtCOf_su_CO = 1;
39BA  0100     MOVLB 0x0
39BC  51CF     MOVF DtCO, W, BANKED
39BE  6FE4     MOVWF k, BANKED
39C0  6BE5     CLRF k, BANKED
39C2  1FE4     COMF k, F, BANKED
39C4  1FE5     COMF k, F, BANKED
39C6  4BE4     INFSNZ k, F, BANKED
39C8  2BE5     INCF k, F, BANKED
39CA  51D1     MOVF 0xD1, W, BANKED
39CC  6FE6     MOVWF counter, BANKED
39CE  6BE7     CLRF sign, BANKED
39D0  51E4     MOVF k, W, BANKED
39D2  27E6     ADDWF counter, F, BANKED
39D4  51E5     MOVF k, W, BANKED
39D6  23E7     ADDWFC sign, F, BANKED
39D8  BFE7     BTFSC sign, 7, BANKED
39DA  D0E1     BRA 0x3B9E
39DC  51E7     MOVF sign, W, BANKED
39DE  E173     BNZ 0x3AC6
39E0  0E05     MOVLW 0x5
39E2  5DE6     SUBWF counter, W, BANKED
39E4  B0D8     BTFSC STATUS, 0, ACCESS
39E6  D06F     BRA 0x3AC6
413:                       else DtCOf_su_CO = 0;
39E8  D0DA     BRA 0x3B9E
414:                       if(DtCO.CO <= F2_PTWP_CO) DtCOf_ptwp_CO = 1;
39EA  0E58     MOVLW 0x58
39EC  0100     MOVLB 0x0
39EE  61CF     CPFSLT DtCO, BANKED
39F0  D0D9     BRA 0x3BA4
39F2  8802     BSF DtCOf_su_CO, 4, ACCESS
39F4  D0D7     BRA 0x3BA4
415:                       if(DtCO.CO > F2_PTWP_CO + 1) DtCOf_ptwp_CO = 0;
39F6  D0D6     BRA 0x3BA4
416:                       if(DtCO.CO <= F2_PZ_CO) DtCOf_pz_CO = 1;
39F8  D06A     BRA 0x3ACE
417:                       if(DtCO.CO > F2_PW_CO) DtCOf_pz_CO = 0;
39FA  0E5B     MOVLW 0x5B
39FC  0100     MOVLB 0x0
39FE  65CF     CPFSGT DtCO, BANKED
3A00  D792     BRA 0x3926
3A02  9A02     BCF DtCOf_su_CO, 5, ACCESS
3A04  D790     BRA 0x3926
418:                       if(DtCO.CO <= F2_CLD_CO) DtCOf_cold_CO = 1;
3A06  D78F     BRA 0x3926
419:                       if(DtCO.CO > F2_CLD_CO + 1) DtCOf_cold_CO = 0;
3A08  0E08     MOVLW 0x8
3A0A  0100     MOVLB 0x0
3A0C  65CF     CPFSGT DtCO, BANKED
3A0E  D068     BRA 0x3AE0
3A10  9C01     BCF DtCOf_err_CO, 6, ACCESS
3A12  D066     BRA 0x3AE0
420:                       if(DtCO.CO >= F2_HOT_CO) DtCOf_hot_CO = 1;
3A14  D065     BRA 0x3AE0
421:                       if(DtCO.CO < F2_HOT_CO - 1) DtCOf_hot_CO = 0;
3A16  D0D1     BRA 0x3BBA
422:                       break;
3A18  D0E4     BRA 0x3BE2
423:                   }
424:                   case _UNICO: //kociol unico
425:                   {
426:                       //if((DtCO.CO - DtCO.PPCO) >= F3_AD_CO) DtCOf_ad_CO = 1;
427:                       //else DtCOf_ad_CO = 0;
428:                       if(DtCO.PPCO>(_MAX_PCO-5))	//nastawa > 80?
3A1A  0E50     MOVLW 0x50
3A1C  0100     MOVLB 0x0
3A1E  65D1     CPFSGT 0xD1, BANKED
3A20  D022     BRA 0x3A66
429:                       {
430:                               if(DtCO.PPCO<=_MAX_PCO)	//nastawa <= _MAX_PCO?
3A22  0E56     MOVLW 0x56
3A24  61D1     CPFSLT 0xD1, BANKED
3A26  D006     BRA 0x3A34
431:                               {
432:                                       if((DtCO.CO-_MAX_PCO)>=F3_AD_CO) DtCOf_ad_CO=1;
3A28  0EAB     MOVLW 0xAB
3A2A  6FE4     MOVWF k, BANKED
3A2C  69E5     SETF k, BANKED
3A2E  D00A     BRA 0x3A44
3A30  D030     BRA 0x3A92
433:                                       else DtCOf_ad_CO=0;
434:                               }
3A32  D033     BRA 0x3A9A
435:                               else
436:                               {
437:                                       if((DtCO.CO-DtCO.PPCO)>=F3_AD_CO) DtCOf_ad_CO=1;
3A34  0100     MOVLB 0x0
3A36  51D1     MOVF 0xD1, W, BANKED
3A38  6FE4     MOVWF k, BANKED
3A3A  6BE5     CLRF k, BANKED
3A3C  1FE4     COMF k, F, BANKED
3A3E  1FE5     COMF k, F, BANKED
3A40  4BE4     INFSNZ k, F, BANKED
3A42  2BE5     INCF k, F, BANKED
3A44  0100     MOVLB 0x0
3A46  51CF     MOVF DtCO, W, BANKED
3A48  6FE6     MOVWF counter, BANKED
3A4A  6BE7     CLRF sign, BANKED
3A4C  51E4     MOVF k, W, BANKED
3A4E  27E6     ADDWF counter, F, BANKED
3A50  51E5     MOVF k, W, BANKED
3A52  23E7     ADDWFC sign, F, BANKED
3A54  BFE7     BTFSC sign, 7, BANKED
3A56  D01F     BRA 0x3A96
3A58  51E7     MOVF sign, W, BANKED
3A5A  E11B     BNZ 0x3A92
3A5C  0E05     MOVLW 0x5
3A5E  5DE6     SUBWF counter, W, BANKED
3A60  E31A     BNC 0x3A96
3A62  D017     BRA 0x3A92
438:                                       else DtCOf_ad_CO=0;
439:                               }
440:                       }
3A64  D01A     BRA 0x3A9A
441:                       else	//nastawa <= 80?
442:                       {
443:                               if((DtCO.CO-DtCO.PPCO)>=F3_AD_CO2) DtCOf_ad_CO=1;
3A66  0100     MOVLB 0x0
3A68  51D1     MOVF 0xD1, W, BANKED
3A6A  6FE4     MOVWF k, BANKED
3A6C  6BE5     CLRF k, BANKED
3A6E  1FE4     COMF k, F, BANKED
3A70  1FE5     COMF k, F, BANKED
3A72  4BE4     INFSNZ k, F, BANKED
3A74  2BE5     INCF k, F, BANKED
3A76  51CF     MOVF DtCO, W, BANKED
3A78  6FE6     MOVWF counter, BANKED
3A7A  6BE7     CLRF sign, BANKED
3A7C  51E4     MOVF k, W, BANKED
3A7E  27E6     ADDWF counter, F, BANKED
3A80  51E5     MOVF k, W, BANKED
3A82  23E7     ADDWFC sign, F, BANKED
3A84  BFE7     BTFSC sign, 7, BANKED
3A86  D007     BRA 0x3A96
3A88  51E7     MOVF sign, W, BANKED
3A8A  E103     BNZ 0x3A92
3A8C  0E0A     MOVLW 0xA
3A8E  5DE6     SUBWF counter, W, BANKED
3A90  E302     BNC 0x3A96
3A92  8601     BSF DtCOf_err_CO, 3, ACCESS
3A94  D002     BRA 0x3A9A
444:                               else DtCOf_ad_CO=0;
3A96  9601     BCF DtCOf_err_CO, 3, ACCESS
3A98  D000     BRA 0x3A9A
445:                       }  
446:                       if((DtCO.PPCO - DtCO.CO) >= F3_SU_CO) DtCOf_su_CO = 1;
3A9A  0100     MOVLB 0x0
3A9C  51CF     MOVF DtCO, W, BANKED
3A9E  6FE4     MOVWF k, BANKED
3AA0  6BE5     CLRF k, BANKED
3AA2  1FE4     COMF k, F, BANKED
3AA4  1FE5     COMF k, F, BANKED
3AA6  4BE4     INFSNZ k, F, BANKED
3AA8  2BE5     INCF k, F, BANKED
3AAA  51D1     MOVF 0xD1, W, BANKED
3AAC  6FE6     MOVWF counter, BANKED
3AAE  6BE7     CLRF sign, BANKED
3AB0  51E4     MOVF k, W, BANKED
3AB2  27E6     ADDWF counter, F, BANKED
3AB4  51E5     MOVF k, W, BANKED
3AB6  23E7     ADDWFC sign, F, BANKED
3AB8  BFE7     BTFSC sign, 7, BANKED
3ABA  D071     BRA 0x3B9E
3ABC  51E7     MOVF sign, W, BANKED
3ABE  E103     BNZ 0x3AC6
3AC0  0E05     MOVLW 0x5
3AC2  5DE6     SUBWF counter, W, BANKED
3AC4  E36C     BNC 0x3B9E
3AC6  8E02     BSF DtCOf_su_CO, 7, ACCESS
3AC8  D790     BRA 0x39EA
447:                       else DtCOf_su_CO = 0;
448:                       if(DtCO.CO <= F3_PTWP_CO) DtCOf_ptwp_CO = 1;
3ACA  D78F     BRA 0x39EA
449:                       if(DtCO.CO > F3_PTWP_CO + 1) DtCOf_ptwp_CO = 0;
3ACC  D06B     BRA 0x3BA4
450:                       if(DtCO.CO <= F3_PZ_CO) DtCOf_pz_CO = 1;
3ACE  0E58     MOVLW 0x58
3AD0  0100     MOVLB 0x0
3AD2  61CF     CPFSLT DtCO, BANKED
3AD4  D792     BRA 0x39FA
3AD6  8A02     BSF DtCOf_su_CO, 5, ACCESS
3AD8  D790     BRA 0x39FA
451:                       if(DtCO.CO > F3_PW_CO) DtCOf_pz_CO = 0;
3ADA  D78F     BRA 0x39FA
452:                       if(DtCO.CO <= F3_CLD_CO) DtCOf_cold_CO = 1;
3ADC  D724     BRA 0x3926
453:                       if(DtCO.CO > F3_CLD_CO + 1) DtCOf_cold_CO = 0;
3ADE  D794     BRA 0x3A08
454:                       if(DtCO.CO >= F3_HOT_CO) DtCOf_hot_CO = 1;
3AE0  0E57     MOVLW 0x57
3AE2  0100     MOVLB 0x0
3AE4  65CF     CPFSGT DtCO, BANKED
3AE6  D069     BRA 0x3BBA
3AE8  8002     BSF DtCOf_su_CO, 0, ACCESS
3AEA  D067     BRA 0x3BBA
455:                       if(DtCO.CO < F3_HOT_CO - 1) DtCOf_hot_CO = 0;
3AEC  D066     BRA 0x3BBA
456:                       break;
3AEE  D079     BRA 0x3BE2
457:                   }
458:                   default: //domyslny monotermiczny
459:                   {
460:                       //if((DtCO.CO - DtCO.PPCO) >= F2_AD_CO) DtCOf_ad_CO = 1;
461:                       //else DtCOf_ad_CO = 0;
462:                       if(DtCO.PPCO>(_MAX_PCO-5))	//nastawa > 80?
3AF0  0E50     MOVLW 0x50
3AF2  0100     MOVLB 0x0
3AF4  65D1     CPFSGT 0xD1, BANKED
3AF6  D022     BRA 0x3B3C
463:                       {
464:                               if(DtCO.PPCO<=_MAX_PCO)	//nastawa <= _MAX_PCO?
3AF8  0E56     MOVLW 0x56
3AFA  61D1     CPFSLT 0xD1, BANKED
3AFC  D006     BRA 0x3B0A
465:                               {
466:                                       if((DtCO.CO-_MAX_PCO)>=F2_AD_CO) DtCOf_ad_CO=1;
3AFE  0EAB     MOVLW 0xAB
3B00  6FE4     MOVWF k, BANKED
3B02  69E5     SETF k, BANKED
3B04  D00A     BRA 0x3B1A
3B06  D030     BRA 0x3B68
467:                                       else DtCOf_ad_CO=0;
468:                               }
3B08  D033     BRA 0x3B70
469:                               else
470:                               {
471:                                       if((DtCO.CO-DtCO.PPCO)>=F2_AD_CO) DtCOf_ad_CO=1;
3B0A  0100     MOVLB 0x0
3B0C  51D1     MOVF 0xD1, W, BANKED
3B0E  6FE4     MOVWF k, BANKED
3B10  6BE5     CLRF k, BANKED
3B12  1FE4     COMF k, F, BANKED
3B14  1FE5     COMF k, F, BANKED
3B16  4BE4     INFSNZ k, F, BANKED
3B18  2BE5     INCF k, F, BANKED
3B1A  0100     MOVLB 0x0
3B1C  51CF     MOVF DtCO, W, BANKED
3B1E  6FE6     MOVWF counter, BANKED
3B20  6BE7     CLRF sign, BANKED
3B22  51E4     MOVF k, W, BANKED
3B24  27E6     ADDWF counter, F, BANKED
3B26  51E5     MOVF k, W, BANKED
3B28  23E7     ADDWFC sign, F, BANKED
3B2A  BFE7     BTFSC sign, 7, BANKED
3B2C  D01F     BRA 0x3B6C
3B2E  51E7     MOVF sign, W, BANKED
3B30  E11B     BNZ 0x3B68
3B32  0E05     MOVLW 0x5
3B34  5DE6     SUBWF counter, W, BANKED
3B36  E31A     BNC 0x3B6C
3B38  D017     BRA 0x3B68
472:                                       else DtCOf_ad_CO=0;
473:                               }
474:                       }
3B3A  D01A     BRA 0x3B70
475:                       else	//nastawa <= 80?
476:                       {
477:                               if((DtCO.CO-DtCO.PPCO)>=F2_AD_CO2) DtCOf_ad_CO=1;
3B3C  0100     MOVLB 0x0
3B3E  51D1     MOVF 0xD1, W, BANKED
3B40  6FE4     MOVWF k, BANKED
3B42  6BE5     CLRF k, BANKED
3B44  1FE4     COMF k, F, BANKED
3B46  1FE5     COMF k, F, BANKED
3B48  4BE4     INFSNZ k, F, BANKED
3B4A  2BE5     INCF k, F, BANKED
3B4C  51CF     MOVF DtCO, W, BANKED
3B4E  6FE6     MOVWF counter, BANKED
3B50  6BE7     CLRF sign, BANKED
3B52  51E4     MOVF k, W, BANKED
3B54  27E6     ADDWF counter, F, BANKED
3B56  51E5     MOVF k, W, BANKED
3B58  23E7     ADDWFC sign, F, BANKED
3B5A  BFE7     BTFSC sign, 7, BANKED
3B5C  D007     BRA 0x3B6C
3B5E  51E7     MOVF sign, W, BANKED
3B60  E103     BNZ 0x3B68
3B62  0E0A     MOVLW 0xA
3B64  5DE6     SUBWF counter, W, BANKED
3B66  E302     BNC 0x3B6C
3B68  8601     BSF DtCOf_err_CO, 3, ACCESS
3B6A  D002     BRA 0x3B70
478:                               else DtCOf_ad_CO=0;
3B6C  9601     BCF DtCOf_err_CO, 3, ACCESS
3B6E  D000     BRA 0x3B70
479:                       } 
480:                       if((DtCO.PPCO - DtCO.CO) >= F2_SU_CO) DtCOf_su_CO = 1;
3B70  0100     MOVLB 0x0
3B72  51CF     MOVF DtCO, W, BANKED
3B74  6FE4     MOVWF k, BANKED
3B76  6BE5     CLRF k, BANKED
3B78  1FE4     COMF k, F, BANKED
3B7A  1FE5     COMF k, F, BANKED
3B7C  4BE4     INFSNZ k, F, BANKED
3B7E  2BE5     INCF k, F, BANKED
3B80  51D1     MOVF 0xD1, W, BANKED
3B82  6FE6     MOVWF counter, BANKED
3B84  6BE7     CLRF sign, BANKED
3B86  51E4     MOVF k, W, BANKED
3B88  27E6     ADDWF counter, F, BANKED
3B8A  51E5     MOVF k, W, BANKED
3B8C  23E7     ADDWFC sign, F, BANKED
3B8E  BFE7     BTFSC sign, 7, BANKED
3B90  D006     BRA 0x3B9E
3B92  51E7     MOVF sign, W, BANKED
3B94  E198     BNZ 0x3AC6
3B96  0E05     MOVLW 0x5
3B98  5DE6     SUBWF counter, W, BANKED
3B9A  B0D8     BTFSC STATUS, 0, ACCESS
3B9C  D794     BRA 0x3AC6
481:                       else DtCOf_su_CO = 0;
3B9E  9E02     BCF DtCOf_su_CO, 7, ACCESS
3BA0  D724     BRA 0x39EA
482:                       if(DtCO.CO <= F2_PTWP_CO) DtCOf_ptwp_CO = 1;
3BA2  D723     BRA 0x39EA
483:                       if(DtCO.CO > F2_PTWP_CO + 1) DtCOf_ptwp_CO = 0;
3BA4  0E58     MOVLW 0x58
3BA6  0100     MOVLB 0x0
3BA8  65CF     CPFSGT DtCO, BANKED
3BAA  D791     BRA 0x3ACE
3BAC  9802     BCF DtCOf_su_CO, 4, ACCESS
3BAE  D78F     BRA 0x3ACE
484:                       if(DtCO.CO <= F2_PZ_CO) DtCOf_pz_CO = 1;
3BB0  D78E     BRA 0x3ACE
485:                       if(DtCO.CO > F2_PW_CO) DtCOf_pz_CO = 0;
3BB2  D723     BRA 0x39FA
486:                       if(DtCO.CO <= F2_CLD_CO) DtCOf_cold_CO = 1;
3BB4  D6B8     BRA 0x3926
487:                       if(DtCO.CO > F2_CLD_CO + 1) DtCOf_cold_CO = 0;
3BB6  D728     BRA 0x3A08
488:                       if(DtCO.CO >= F2_HOT_CO) DtCOf_hot_CO = 1;
3BB8  D793     BRA 0x3AE0
489:                       if(DtCO.CO < F2_HOT_CO - 1) DtCOf_hot_CO = 0;
3BBA  0E57     MOVLW 0x57
3BBC  0100     MOVLB 0x0
3BBE  61CF     CPFSLT DtCO, BANKED
3BC0  D010     BRA 0x3BE2
3BC2  9002     BCF DtCOf_su_CO, 0, ACCESS
490:                       break;
491:                   }
492:               }
3BC4  D00E     BRA 0x3BE2
493:           
494:               if(DtCO.CO <= _ON_DZ_CO)
3BE2  0E09     MOVLW 0x9
3BE4  0100     MOVLB 0x0
3BE6  61CF     CPFSLT DtCO, BANKED
3BE8  D003     BRA 0x3BF0
495:               {
496:                   DtCOf_su_DZ_CO = 1;
3BEA  8003     BSF DtCOf_su_SRW_CO, 0, ACCESS
497:                   DtCOf_on_DZ_CO = 1;
3BEC  8602     BSF DtCOf_su_CO, 3, ACCESS
498:               }
3BEE  D002     BRA 0x3BF4
499:               else DtCOf_su_DZ_CO = 0;
3BF0  9003     BCF DtCOf_su_SRW_CO, 0, ACCESS
3BF2  D000     BRA 0x3BF4
500:               if(DtCO.CO >= _OFF_DZ_CO)
3BF4  0E13     MOVLW 0x13
3BF6  0100     MOVLB 0x0
3BF8  65CF     CPFSGT DtCO, BANKED
3BFA  D003     BRA 0x3C02
501:               {
502:                   DtCOf_ad_DZ_CO = 1;
3BFC  8801     BSF DtCOf_err_CO, 4, ACCESS
503:                   DtCOf_on_DZ_CO = 0;
3BFE  9602     BCF DtCOf_su_CO, 3, ACCESS
504:               }
3C00  D002     BRA 0x3C06
505:               else DtCOf_ad_DZ_CO = 0;
3C02  9801     BCF DtCOf_err_CO, 4, ACCESS
3C04  D000     BRA 0x3C06
506:           
507:               if(!DtKNF.opdg)
3C06  0100     MOVLB 0x0
3C08  51A7     MOVF _rglf_btco, W, BANKED
3C0A  E10F     BNZ 0x3C2A
508:               {
509:                   if(DtCO.CO <= _ON_SRW_CO) DtCOf_su_SRW_CO = 1;
3C0C  0E4F     MOVLW 0x4F
3C0E  61CF     CPFSLT DtCO, BANKED
3C10  D002     BRA 0x3C16
3C12  8203     BSF DtCOf_su_SRW_CO, 1, ACCESS
3C14  D002     BRA 0x3C1A
510:                   else DtCOf_su_SRW_CO = 0;
3C16  9203     BCF DtCOf_su_SRW_CO, 1, ACCESS
3C18  D000     BRA 0x3C1A
511:                   if(DtCO.CO > _OFF_SRW_CO) DtCOf_ad_SRW_CO = 1;
3C1A  0E58     MOVLW 0x58
3C1C  0100     MOVLB 0x0
3C1E  65CF     CPFSGT DtCO, BANKED
3C20  D002     BRA 0x3C26
3C22  8A01     BSF DtCOf_err_CO, 5, ACCESS
3C24  0C58     RETLW 0x58
512:                   else DtCOf_ad_SRW_CO = 0;
3C26  9A01     BCF DtCOf_err_CO, 5, ACCESS
513:               }
3C28  0012     RETURN 0
514:               else //ogrzewanie podlogowe
515:               {
516:                   if(DtCO.CO <= _ONP_SRW_CO) DtCOf_su_SRW_CO = 1;
3C2A  0E31     MOVLW 0x31
3C2C  0100     MOVLB 0x0
3C2E  61CF     CPFSLT DtCO, BANKED
3C30  D002     BRA 0x3C36
3C32  8203     BSF DtCOf_su_SRW_CO, 1, ACCESS
3C34  D002     BRA 0x3C3A
517:                   else DtCOf_su_SRW_CO = 0;
3C36  9203     BCF DtCOf_su_SRW_CO, 1, ACCESS
3C38  D000     BRA 0x3C3A
518:                   if(DtCO.CO > _OFFP_SRW_CO) DtCOf_ad_SRW_CO = 1;
3C3A  0E3A     MOVLW 0x3A
3C3C  0100     MOVLB 0x0
3C3E  65CF     CPFSGT DtCO, BANKED
3C40  D002     BRA 0x3C46
3C42  8A01     BSF DtCOf_err_CO, 5, ACCESS
3C44  0C3A     RETLW 0x3A
519:                   else DtCOf_ad_SRW_CO = 0;
3C46  9A01     BCF DtCOf_err_CO, 5, ACCESS
3C48  0012     RETURN 0
520:               }
521:           }
3C4A  0012     RETURN 0
522:           /*---------------------------------------------------------------------------------*/
523:           /*---------------------------------------------------------------------------------*/
524:           //Pomiar wartosci temperatury na wlocie i ustawienie odpowiednich flag stanu
525:           
526:           void PomiarIN(void)
527:           {
528:               //	signed char delta;
529:           
530:               DtIN.AC_IN = ReadAC(_CHN_IN);
EA36  0E04     MOVLW 0x4
EA38  EC33     CALL 0xD466, 0
EA3A  F06A     NOP
EA3C  0101     MOVLB 0x1
EA3E  6F1A     MOVWF _DtCOf_zroPCO, BANKED
531:               DtIN.IN = ReadTabNTC(DtIN.AC_IN);
EA40  511A     MOVF _DtCOf_zroPCO, W, BANKED
EA42  EC21     CALL 0xD242, 0
EA44  F069     NOP
EA46  0101     MOVLB 0x1
EA48  6F1B     MOVWF _DtCSf_error, BANKED
532:               PFN.IN = DtIN.IN;
EA4A  C11B     MOVFF 0x11B, 0x1E2
EA4C  F1E2     NOP
533:               if(DtIN.AC_IN <= _NTC_MIN || DtIN.AC_IN >= _NTC_MAX) //stwierdzenie awarii czujnika temp. IN
EA4E  0E28     MOVLW 0x28
EA50  0101     MOVLB 0x1
EA52  651A     CPFSGT _DtCOf_zroPCO, BANKED
EA54  D003     BRA 0xEA5C
EA56  0EF4     MOVLW 0xF4
EA58  651A     CPFSGT _DtCOf_zroPCO, BANKED
EA5A  D002     BRA 0xEA60
534:               {
535:                   DtINf_err_IN = 1;
EA5C  8A05     BSF DtKNFf_enknf, 5, ACCESS
536:                   return;
537:               }
EA5E  0012     RETURN 0
538:               else DtINf_err_IN = 0;
EA60  9A05     BCF DtKNFf_enknf, 5, ACCESS
EA62  0012     RETURN 0
539:           }
EA64  0012     RETURN 0
540:           /*---------------------------------------------------------------------------------*/
541:           //Pomiar wartosci CW i ustawienie odpowiednich flag stanu
542:           
543:           void PomiarCW(void)
544:           {
545:               DtCW.AC_CW = ReadAC(_CHN_CW);
A7EA  0E01     MOVLW 0x1
A7EC  EC33     CALL 0xD466, 0
A7EE  F06A     NOP
A7F0  0100     MOVLB 0x0
A7F2  6FB4     MOVWF 0xB4, BANKED
546:               DtCW.CW = ReadTabNTC(DtCW.AC_CW);
A7F4  51B4     MOVF 0xB4, W, BANKED
A7F6  EC21     CALL 0xD242, 0
A7F8  F069     NOP
A7FA  0100     MOVLB 0x0
A7FC  6FAA     MOVWF DtCW, BANKED
547:           
548:               if(DtCW.AC_CW <= _NTC_MIN || DtCW.AC_CW >= _NTC_MAX) //stwierdzenie awarii czujnika temp. CO
A7FE  0E28     MOVLW 0x28
A800  0100     MOVLB 0x0
A802  65B4     CPFSGT 0xB4, BANKED
A804  D003     BRA 0xA80C
A806  0EF4     MOVLW 0xF4
A808  65B4     CPFSGT 0xB4, BANKED
A80A  D00A     BRA 0xA820
549:               {
550:                   DtCWf_err_CW = 1;
A80C  8804     BSF DtCWf_err_CW, 4, ACCESS
551:                   DtCWf_su_CW = 0;
A80E  9005     BCF DtKNFf_enknf, 0, ACCESS
552:                   DtCWf_ad_CW = 0;
A810  9204     BCF DtCWf_err_CW, 1, ACCESS
553:                   DtCWf_cold_CW = 0;
A812  9604     BCF DtCWf_err_CW, 3, ACCESS
554:                   DtCWf_on_DZ_CW = 0;
A814  9E04     BCF DtCWf_err_CW, 7, ACCESS
555:                   DtCWf_su_DZ_CW = 0;
A816  9205     BCF DtKNFf_enknf, 1, ACCESS
556:                   DtCWf_ad_DZ_CW = 0;
A818  9404     BCF DtCWf_err_CW, 2, ACCESS
557:                   DtCWf_wpz_CW = 0;
A81A  9405     BCF DtKNFf_enknf, 2, ACCESS
558:                   return;
A81C  0012     RETURN 0
559:               }
A81E  D06C     BRA 0xA8F8
560:               else DtCWf_err_CW = 0;
A820  9804     BCF DtCWf_err_CW, 4, ACCESS
561:               
562:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
A822  D06A     BRA 0xA8F8
A8F8  0100     MOVLB 0x0
A8FA  519E     MOVF _PWMf_ENPWM2, W, BANKED
A8FC  E0B0     BZ 0xA85E
A8FE  0A01     XORLW 0x1
A900  E092     BZ 0xA826
A902  0A03     XORLW 0x3
A904  E090     BZ 0xA826
A906  0A01     XORLW 0x1
A908  D7A0     BRA 0xA84A
563:               {
564:                   case _BITERM: //bitermiczny (miniterm)
A824  D000     BRA 0xA826
565:                   case _BITERM2: //bitermiczny (maxiterm)
566:                   {
567:                       /*if(DtCW.CW>F1_OFF_CW) DtCWf_ad_CW=1;
568:                       else DtCWf_ad_CW=0;
569:                       if(DtCW.CW<=F1_OFF_CW-F1_MR_OFF_CW) DtCWf_su_CW=1;
570:                       else DtCWf_su_CW=0;*/
571:                       if(DtCW.PCW < 55) //dwa bezwzgledne progi wylaczenia
A826  0E37     MOVLW 0x37
A828  0100     MOVLB 0x0
A82A  61AB     CPFSLT _rglf_fast_up, BANKED
A82C  D003     BRA 0xA834
A82E  D00D     BRA 0xA84A
572:                       {
573:                           if(DtCW.CW > F1_OFF_CW) DtCWf_ad_CW = 1;
574:                           else DtCWf_ad_CW = 0;
575:                           if(DtCW.CW <= F1_OFF_CW - F1_MR_OFF_CW) DtCWf_su_CW = 1;
A830  D05B     BRA 0xA8E8
576:                           else DtCWf_su_CW = 0;
577:                       }
A832  D06B     BRA 0xA90A
578:                       else
579:                       {
580:                           if(DtCW.CW > F1_OFF2_CW) DtCWf_ad_CW = 1;
A834  0E46     MOVLW 0x46
A836  0100     MOVLB 0x0
A838  65AA     CPFSGT DtCW, BANKED
A83A  D002     BRA 0xA840
A83C  8204     BSF DtCWf_err_CW, 1, ACCESS
A83E  D002     BRA 0xA844
581:                           else DtCWf_ad_CW = 0;
A840  9204     BCF DtCWf_err_CW, 1, ACCESS
A842  D000     BRA 0xA844
582:                           if(DtCW.CW <= F1_OFF2_CW - F1_MR_OFF_CW) DtCWf_su_CW = 1;
A844  0E45     MOVLW 0x45
A846  D051     BRA 0xA8EA
583:                           else DtCWf_su_CW = 0;
584:                       }
585:           
586:                       break;
A848  D060     BRA 0xA90A
587:                   }
588:                   case _MONOHB:
589:                   {
590:                       if(DtCW.CW > F2_OFF_CW) DtCWf_ad_CW = 1;
A84A  0E41     MOVLW 0x41
A84C  0100     MOVLB 0x0
A84E  65AA     CPFSGT DtCW, BANKED
A850  D002     BRA 0xA856
A852  8204     BSF DtCWf_err_CW, 1, ACCESS
A854  D049     BRA 0xA8E8
591:                       else DtCWf_ad_CW = 0;
A856  9204     BCF DtCWf_err_CW, 1, ACCESS
A858  D047     BRA 0xA8E8
592:                       if(DtCW.CW <= F2_OFF_CW - F2_MR_OFF_CW) DtCWf_su_CW = 1;
A85A  D046     BRA 0xA8E8
593:                       else DtCWf_su_CW = 0;
594:                       break;
A85C  D056     BRA 0xA90A
595:                   }
596:                   case _UNICO: //kociol unico
597:                   {
598:                       if((DtCW.CW - DtCW.PPCW) >= F3_AD_CW) DtCWf_ad_CW = 1;
A85E  0100     MOVLB 0x0
A860  51AC     MOVF _rglf_fz, W, BANKED
A862  6FE4     MOVWF k, BANKED
A864  6BE5     CLRF k, BANKED
A866  1FE4     COMF k, F, BANKED
A868  1FE5     COMF k, F, BANKED
A86A  4BE4     INFSNZ k, F, BANKED
A86C  2BE5     INCF k, F, BANKED
A86E  51AA     MOVF DtCW, W, BANKED
A870  6FE6     MOVWF counter, BANKED
A872  6BE7     CLRF sign, BANKED
A874  51E4     MOVF k, W, BANKED
A876  27E6     ADDWF counter, F, BANKED
A878  51E5     MOVF k, W, BANKED
A87A  23E7     ADDWFC sign, F, BANKED
A87C  BFE7     BTFSC sign, 7, BANKED
A87E  D006     BRA 0xA88C
A880  51E7     MOVF sign, W, BANKED
A882  E102     BNZ 0xA888
A884  05E6     DECF counter, W, BANKED
A886  E302     BNC 0xA88C
A888  8204     BSF DtCWf_err_CW, 1, ACCESS
A88A  D002     BRA 0xA890
599:                       else DtCWf_ad_CW = 0;
A88C  9204     BCF DtCWf_err_CW, 1, ACCESS
A88E  D000     BRA 0xA890
600:                       if((DtCW.PPCW - DtCW.CW) >= F3_SU_CW) DtCWf_su_CW = 1;
A890  0100     MOVLB 0x0
A892  51AA     MOVF DtCW, W, BANKED
A894  6FE4     MOVWF k, BANKED
A896  6BE5     CLRF k, BANKED
A898  1FE4     COMF k, F, BANKED
A89A  1FE5     COMF k, F, BANKED
A89C  4BE4     INFSNZ k, F, BANKED
A89E  2BE5     INCF k, F, BANKED
A8A0  51AC     MOVF _rglf_fz, W, BANKED
A8A2  6FE6     MOVWF counter, BANKED
A8A4  6BE7     CLRF sign, BANKED
A8A6  51E4     MOVF k, W, BANKED
A8A8  27E6     ADDWF counter, F, BANKED
A8AA  51E5     MOVF k, W, BANKED
A8AC  23E7     ADDWFC sign, F, BANKED
A8AE  BFE7     BTFSC sign, 7, BANKED
A8B0  D007     BRA 0xA8C0
A8B2  51E7     MOVF sign, W, BANKED
A8B4  E103     BNZ 0xA8BC
A8B6  0E05     MOVLW 0x5
A8B8  5DE6     SUBWF counter, W, BANKED
A8BA  E302     BNC 0xA8C0
A8BC  8005     BSF DtKNFf_enknf, 0, ACCESS
A8BE  D002     BRA 0xA8C4
601:                       else DtCWf_su_CW = 0;
A8C0  9005     BCF DtKNFf_enknf, 0, ACCESS
A8C2  D000     BRA 0xA8C4
602:                       if(RdPrt(S_WCW)) //aktywne pobudzenie z timera zasobnika?
A8C4  0E0B     MOVLW 0xB
A8C6  ECFD     CALL 0xE7FA, 0
A8C8  F073     NOP
A8CA  E30B     BNC 0xA8E2
603:                       {
604:                           if(DtCWf_su_CW) DtCWf_wpz_CW = 1;
A8CC  A005     BTFSS DtKNFf_enknf, 0, ACCESS
A8CE  D002     BRA 0xA8D4
A8D0  8405     BSF DtKNFf_enknf, 2, ACCESS
A8D2  D003     BRA 0xA8DA
605:                           else if(!Mf_PRACA) DtCWf_wpz_CW = 0;
A8D4  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
A8D6  9405     BCF DtKNFf_enknf, 2, ACCESS
A8D8  D000     BRA 0xA8DA
606:                           if(DtCWf_ad_CW) DtCWf_wpz_CW = 0;
A8DA  A204     BTFSS DtCWf_err_CW, 1, ACCESS
A8DC  D016     BRA 0xA90A
A8DE  9405     BCF DtKNFf_enknf, 2, ACCESS
607:                       }
A8E0  D014     BRA 0xA90A
608:                       else DtCWf_wpz_CW = 0;
A8E2  9405     BCF DtKNFf_enknf, 2, ACCESS
609:                       break;
A8E4  D012     BRA 0xA90A
610:                   }
611:                   default: //domyslny monotermiczny
612:                   {
613:                       if(DtCW.CW > F2_OFF_CW) DtCWf_ad_CW = 1;
A8E6  D7B1     BRA 0xA84A
614:                       else DtCWf_ad_CW = 0;
615:                       if(DtCW.CW <= F2_OFF_CW - F2_MR_OFF_CW) DtCWf_su_CW = 1;
A8E8  0E40     MOVLW 0x40
A8EA  0100     MOVLB 0x0
A8EC  61AA     CPFSLT DtCW, BANKED
A8EE  D002     BRA 0xA8F4
A8F0  8005     BSF DtKNFf_enknf, 0, ACCESS
A8F2  D00B     BRA 0xA90A
616:                       else DtCWf_su_CW = 0;
A8F4  9005     BCF DtKNFf_enknf, 0, ACCESS
617:                       break;
618:                   }
619:               }
A8F6  D009     BRA 0xA90A
620:               if(DtCW.CW <= _ON_DZ_CW)
A90A  0E06     MOVLW 0x6
A90C  0100     MOVLB 0x0
A90E  61AA     CPFSLT DtCW, BANKED
A910  D003     BRA 0xA918
621:               {
622:                   DtCWf_su_DZ_CW = 1;
A912  8205     BSF DtKNFf_enknf, 1, ACCESS
623:                   DtCWf_on_DZ_CW = 1;
A914  8E04     BSF DtCWf_err_CW, 7, ACCESS
624:               }
A916  D002     BRA 0xA91C
625:               else DtCWf_su_DZ_CW = 0;
A918  9205     BCF DtKNFf_enknf, 1, ACCESS
A91A  D000     BRA 0xA91C
626:               if(DtCW.CW >= _OFF_DZ_CW)
A91C  0E09     MOVLW 0x9
A91E  0100     MOVLB 0x0
A920  65AA     CPFSGT DtCW, BANKED
A922  D003     BRA 0xA92A
627:               {
628:                   DtCWf_ad_DZ_CW = 1;
A924  8404     BSF DtCWf_err_CW, 2, ACCESS
629:                   DtCWf_on_DZ_CW = 0;
A926  9E04     BCF DtCWf_err_CW, 7, ACCESS
630:               }
A928  D002     BRA 0xA92E
631:               else DtCWf_ad_DZ_CW = 0;
A92A  9404     BCF DtCWf_err_CW, 2, ACCESS
A92C  D000     BRA 0xA92E
632:               if(DtCW.CW <= _CLD_CW) DtCWf_cold_CW = 1;
A92E  0E06     MOVLW 0x6
A930  0100     MOVLB 0x0
A932  61AA     CPFSLT DtCW, BANKED
A934  D002     BRA 0xA93A
A936  8604     BSF DtCWf_err_CW, 3, ACCESS
A938  D000     BRA 0xA93A
633:               if(DtCW.CW > _CLD_CW + 1) DtCWf_cold_CW = 0;
A93A  0E06     MOVLW 0x6
A93C  0100     MOVLB 0x0
A93E  65AA     CPFSGT DtCW, BANKED
A940  0C06     RETLW 0x6
A942  9604     BCF DtCWf_err_CW, 3, ACCESS
A944  0C06     RETLW 0x6
634:           }
A946  0012     RETURN 0
635:           /*---------------------------------------------------------------------------------*/
636:           //Pomiar wartosci temperatury zewnetrznej i ustawienie odpowiednich flag stanu
637:           
638:           void PomiarZW(void)
639:           {
640:               DtZW.AC_ZW = ReadAC(_CHN_ZW);
EC36  0E02     MOVLW 0x2
EC38  EC33     CALL 0xD466, 0
EC3A  F06A     NOP
EC3C  0101     MOVLB 0x1
EC3E  6F45     MOVWF 0x45, BANKED
641:               DtZW.ZW = ReadTabZNTC(DtZW.AC_ZW);
EC40  5145     MOVF 0x45, W, BANKED
EC42  ECC3     CALL 0xCD86, 0
EC44  F066     NOP
EC46  0101     MOVLB 0x1
EC48  6F46     MOVWF 0x46, BANKED
642:               if(DtZW.AC_ZW <= _ZNTC_MIN || DtZW.AC_ZW >= _ZNTC_MAX) DtZWf_on_ZW = 0; //stwierdzenie awarii czujnika temp. CO
EC4A  0E0F     MOVLW 0xF
EC4C  0101     MOVLB 0x1
EC4E  6545     CPFSGT 0x45, BANKED
EC50  D003     BRA 0xEC58
EC52  0EEF     MOVLW 0xEF
EC54  6545     CPFSGT 0x45, BANKED
EC56  D002     BRA 0xEC5C
EC58  9406     BCF DtKNFf_wymCO, 2, ACCESS
EC5A  0012     RETURN 0
643:               else DtZWf_on_ZW = 1;
EC5C  8406     BSF DtKNFf_wymCO, 2, ACCESS
EC5E  0012     RETURN 0
644:           }
EC60  0012     RETURN 0
645:           /*---------------------------------------------------------------------------------*/
646:           //Formatowanie nastawy CO
647:           
648:           void SetModPCO(void)
649:           {
650:               if(Mf_AKTYWNE_KNF)
C544  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
C546  D008     BRA 0xC558
651:               {
652:                   if(!DtKNF.opdg) DtCO.PPCO = _KNF_PCO; //aktywna konfiguracja
C548  0100     MOVLB 0x0
C54A  51A7     MOVF _rglf_btco, W, BANKED
C54C  E102     BNZ 0xC552
C54E  0E55     MOVLW 0x55
C550  D00D     BRA 0xC56C
653:                   else DtCO.PPCO = _MAX_PDCO; //dla ogrzewania podlogowego
C552  0E37     MOVLW 0x37
C554  D00B     BRA 0xC56C
654:               }
C556  D029     BRA 0xC5AA
655:               else
656:               if(Mf_pob_CW||Mf_pob_AL||Mf_pob_DzCW) //pobudzenie CW?
C558  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
C55A  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
C55C  D014     BRA 0xC586
C55E  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
C560  D012     BRA 0xC586
C562  D01B     BRA 0xC59A
657:               {
658:                   switch(DtKNF.tpkt) //dla danego rodzaju kotla
C564  D010     BRA 0xC586
C586  0100     MOVLB 0x0
C588  519E     MOVF _PWMf_ENPWM2, W, BANKED
C58A  E0F3     BZ 0xC572
C58C  0A01     XORLW 0x1
C58E  E0DF     BZ 0xC54E
C590  0A03     XORLW 0x3
C592  E0DD     BZ 0xC54E
C594  0A01     XORLW 0x1
C596  D7F4     BRA 0xC580
659:                   {
660:                       case _BITERM: //bitermiczny (miniterm)
C566  D7F3     BRA 0xC54E
661:                       case _BITERM2: //bitermiczny (maxiterm)
662:                       {
663:                           DtCO.PPCO = F1_PPCO;
C568  D7F2     BRA 0xC54E
664:                           break;
665:                       }
666:                       case _MONOHB:
667:                       {
668:                           DtCO.PPCO = F2_PPCO;
C56A  D00A     BRA 0xC580
C56C  0100     MOVLB 0x0
C56E  6FD1     MOVWF 0xD1, BANKED
669:                           break;
C570  D01C     BRA 0xC5AA
670:                       }
671:                       case _UNICO: //kociol unico
672:                       {
673:           				if(Mf_pob_CW||Mf_pob_AL)
C572  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
C574  D005     BRA 0xC580
C576  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
674:           				{
675:           					DtCO.PPCO=F3_PPCO;
C578  D003     BRA 0xC580
676:           				}
677:           				else
678:           				{
679:           					DtCO.PPCO=F3_PW_CO;
C57A  0E5B     MOVLW 0x5B
C57C  D7F7     BRA 0xC56C
680:           				}                
681:                           break;
C57E  D015     BRA 0xC5AA
682:                       }
683:                       default: //domyslny monotermiczny
684:                       {
685:                           DtCO.PPCO = F2_PPCO;
C580  0E59     MOVLW 0x59
C582  D7F4     BRA 0xC56C
686:                           break;
687:                       }
688:                   }
C584  D012     BRA 0xC5AA
689:               }
C598  D008     BRA 0xC5AA
690:               else
691:               if(Mf_AKTYWNE_PGD) DtCO.PPCO = DtCO.PGDPCO; //aktywna funkcja pogodowa
C59A  AA06     BTFSS DtKNFf_wymCO, 5, ACCESS
C59C  D003     BRA 0xC5A4
C59E  C0D4     MOVFF 0xD4, 0xD1
C5A0  F0D1     NOP
C5A2  D003     BRA 0xC5AA
692:               else
693:               {
694:                   DtCO.PPCO = DtCO.PCO;
C5A4  C0D0     MOVFF 0xD0, 0xD1
C5A6  F0D1     NOP
695:               }
C5A8  D000     BRA 0xC5AA
696:               
697:               if(!DtKNF.opdg)
C5AA  0100     MOVLB 0x0
C5AC  51A7     MOVF _rglf_btco, W, BANKED
C5AE  E105     BNZ 0xC5BA
698:               {
699:                   if(!Mf_pob_SRW) PFN.PPCO = DtCO.PPCO;
C5B0  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
C5B2  D005     BRA 0xC5BE
700:                   else 
701:                   {
702:                       DtCO.PPCO = _OFF_SRW_CO;
C5B4  0E58     MOVLW 0x58
C5B6  D007     BRA 0xC5C6
703:                       PFN.PPCO = _OFF_SRW_CO;
704:                   }
705:               }
C5B8  D00B     BRA 0xC5D0
706:               else //dla aktywnego ogrzewania podlogowego
707:               {
708:                   if(!Mf_pob_SRW) PFN.PPCO = DtCO.PPCO;
C5BA  BA0B     BTFSC Mf_pob_KCO, 5, ACCESS
C5BC  D003     BRA 0xC5C4
C5BE  C0D1     MOVFF 0xD1, 0x1E3
C5C0  F1E3     NOP
C5C2  D006     BRA 0xC5D0
709:                   else 
710:                   {
711:                       DtCO.PPCO = _OFFP_SRW_CO;
C5C4  0E3A     MOVLW 0x3A
C5C6  0100     MOVLB 0x0
C5C8  6FD1     MOVWF 0xD1, BANKED
712:                       PFN.PPCO = _OFFP_SRW_CO;
C5CA  0101     MOVLB 0x1
C5CC  6FE3     MOVWF a, BANKED
713:                   }
C5CE  D000     BRA 0xC5D0
714:               }
715:               if(Mf_pob_DzCO)
C5D0  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
C5D2  0012     RETURN 0
716:               {
717:                   DtCO.PPCO = _OFF_DZ_CO;
C5D4  0E14     MOVLW 0x14
C5D6  0100     MOVLB 0x0
C5D8  6FD1     MOVWF 0xD1, BANKED
718:                   PFN.PPCO = _OFF_DZ_CO;
C5DA  0101     MOVLB 0x1
C5DC  6FE3     MOVWF a, BANKED
C5DE  0C14     RETLW 0x14
719:               }
720:           }
C5E0  0012     RETURN 0
721:           /*---------------------------------------------------------------------------------*/
722:           //Oblicza modyfikator mocy maksymalnej dla grzania obiegu CO
723:           //przy aktywnym regulatorze pogodowym
724:           //gdzie:
725:           //kt - nastawa PCO w zakresie 0...100%
726:           //wspolczynnik krzywej grzania:
727:           //WSP=0,0662*kt-0,0369
728:           //a wartosc modyfikatora mocy maksymalnej [0...100%]:
729:           //dla Tzw<25C PGD=WSP*(Tzw-25)
730:           //dla Tzw>=25 PGD=0
731:           /*void SetWspPGD(void)
732:           {
733:                   signed long m;
734:                   if(Mf_AKTYWNE_PGD)		//aktywny regulator pogodowy?
735:                   {
736:                           if(DtCO.PCO)		//kt>0?
737:                           {
738:                                   if(DtZW.SZW<25)	//Tzw<25?
739:                                   {
740:                                           m=-66*DtCO.PCO-37;
741:                                           m*=(DtZW.SZW-25);
742:                                           m/=1000;
743:                                           if(m>100) PWM.PGD=100;
744:                                           else
745:                                           if(m<0) PWM.PGD=0;
746:                                           else PWM.PGD=m;
747:                                   }
748:                                   else PWM.PGD=0;
749:                           }
750:                           else PWM.PGD=0;
751:                   }else PWM.PGD=100;
752:           }*/
753:           /*---------------------------------------------------------------------------------*/
754:           //Dla ogrzewania pogodowego:
755:           //PPCO=_MIN_PCO+(_MAX_PCO-_MIN_PCO)*((25-Tzew)/(25-10))*kt/99
756:           
757:           unsigned char GetPGD_PCO(void)
758:           {
759:               unsigned char p;
760:               signed long m;
761:           
762:               if(!DtKNF.opdg) //ogrzewanie tradycyjne
6DD2  0100     MOVLB 0x0
6DD4  51A7     MOVF _rglf_btco, W, BANKED
6DD6  E001     BZ 0x6DDA
6DD8  D0BB     BRA 0x6F50
763:               {
764:                   if(DtCO.PCO) //kt>0?
6DDA  51D0     MOVF 0xD0, W, BANKED
6DDC  E101     BNZ 0x6DE0
6DDE  D0B6     BRA 0x6F4C
765:                   {
766:                       if(DtZW.SZW < 25) //Tzw<25?
6DE0  0101     MOVLB 0x1
6DE2  5147     MOVF 0x47, W, BANKED
6DE4  0A80     XORLW 0x80
6DE6  0F67     ADDLW 0x67
6DE8  E301     BNC 0x6DEC
6DEA  D0AE     BRA 0x6F48
767:                       {
768:                           m = (25 - DtZW.SZW) * DtCO.PCO;
6DEC  C147     MOVFF 0x147, dt
6DEE  F0EC     NOP
6DF0  0100     MOVLB 0x0
6DF2  6BED     CLRF min, BANKED
6DF4  BFEC     BTFSC dt, 7, BANKED
6DF6  07ED     DECF min, F, BANKED
6DF8  1FEC     COMF dt, F, BANKED
6DFA  1FED     COMF min, F, BANKED
6DFC  4BEC     INFSNZ dt, F, BANKED
6DFE  2BED     INCF min, F, BANKED
6E00  0E19     MOVLW 0x19
6E02  25EC     ADDWF dt, W, BANKED
6E04  6FDE     MOVWF __pcstackBANK0, BANKED
6E06  0E00     MOVLW 0x0
6E08  21ED     ADDWFC min, W, BANKED
6E0A  6FDF     MOVWF pco, BANKED
6E0C  C0D0     MOVFF 0xD0, bdat
6E0E  F0E0     NOP
6E10  6BE1     CLRF GIE_BIT_VAL, BANKED
6E12  EC5B     CALL 0xECB6, 0
6E14  F076     NOP
6E16  C0DE     MOVFF __pcstackBANK0, m
6E18  F0F1     NOP
6E1A  C0DF     MOVFF pco, tid
6E1C  F0F2     NOP
6E1E  0100     MOVLB 0x0
6E20  0E00     MOVLW 0x0
6E22  BFF2     BTFSC tid, 7, BANKED
6E24  0EFF     MOVLW 0xFF
6E26  6FF3     MOVWF min, BANKED
6E28  6FF4     MOVWF pco, BANKED
769:                           m *= (_MAX_PCO - _MIN_PCO);
6E2A  C0F1     MOVFF m, __pcstackBANK0
6E2C  F0DE     NOP
6E2E  C0F2     MOVFF tid, pco
6E30  F0DF     NOP
6E32  C0F3     MOVFF min, bdat
6E34  F0E0     NOP
6E36  C0F4     MOVFF pco, GIE_BIT_VAL
6E38  F0E1     NOP
6E3A  0E2D     MOVLW 0x2D
6E3C  0100     MOVLB 0x0
6E3E  6FE2     MOVWF divisor, BANKED
6E40  6BE3     CLRF a, BANKED
6E42  6BE4     CLRF k, BANKED
6E44  6BE5     CLRF k, BANKED
6E46  EC2F     CALL 0xDA5E, 0
6E48  F06D     NOP
6E4A  C0DE     MOVFF __pcstackBANK0, m
6E4C  F0F1     NOP
6E4E  C0DF     MOVFF pco, tid
6E50  F0F2     NOP
6E52  C0E0     MOVFF bdat, min
6E54  F0F3     NOP
6E56  C0E1     MOVFF GIE_BIT_VAL, pco
6E58  F0F4     NOP
770:                           m *= 100;
6E5A  C0F1     MOVFF m, __pcstackBANK0
6E5C  F0DE     NOP
6E5E  C0F2     MOVFF tid, pco
6E60  F0DF     NOP
6E62  C0F3     MOVFF min, bdat
6E64  F0E0     NOP
6E66  C0F4     MOVFF pco, GIE_BIT_VAL
6E68  F0E1     NOP
6E6A  0E64     MOVLW 0x64
6E6C  0100     MOVLB 0x0
6E6E  6FE2     MOVWF divisor, BANKED
6E70  6BE3     CLRF a, BANKED
6E72  6BE4     CLRF k, BANKED
6E74  6BE5     CLRF k, BANKED
6E76  EC2F     CALL 0xDA5E, 0
6E78  F06D     NOP
6E7A  C0DE     MOVFF __pcstackBANK0, m
6E7C  F0F1     NOP
6E7E  C0DF     MOVFF pco, tid
6E80  F0F2     NOP
6E82  C0E0     MOVFF bdat, min
6E84  F0F3     NOP
6E86  C0E1     MOVFF GIE_BIT_VAL, pco
6E88  F0F4     NOP
771:                           m /= 1485; //(25-10)*99
6E8A  C0F1     MOVFF m, __pcstackBANK0
6E8C  F0DE     NOP
6E8E  C0F2     MOVFF tid, pco
6E90  F0DF     NOP
6E92  C0F3     MOVFF min, bdat
6E94  F0E0     NOP
6E96  C0F4     MOVFF pco, GIE_BIT_VAL
6E98  F0E1     NOP
6E9A  0ECD     MOVLW 0xCD
6E9C  0100     MOVLB 0x0
6E9E  6FE2     MOVWF divisor, BANKED
6EA0  0E05     MOVLW 0x5
6EA2  6FE3     MOVWF a, BANKED
6EA4  6BE4     CLRF k, BANKED
6EA6  6BE5     CLRF k, BANKED
6EA8  ECF3     CALL 0xB3E6, 0
6EAA  F059     NOP
6EAC  C0DE     MOVFF __pcstackBANK0, m
6EAE  F0F1     NOP
6EB0  C0DF     MOVFF pco, tid
6EB2  F0F2     NOP
6EB4  C0E0     MOVFF bdat, min
6EB6  F0F3     NOP
6EB8  C0E1     MOVFF GIE_BIT_VAL, pco
6EBA  F0F4     NOP
772:                           if((_MIN_PCO + m / 100) > _MAX_PCO) return _MAX_PCO;
6EBC  C0F1     MOVFF m, __pcstackBANK0
6EBE  F0DE     NOP
6EC0  C0F2     MOVFF tid, pco
6EC2  F0DF     NOP
6EC4  C0F3     MOVFF min, bdat
6EC6  F0E0     NOP
6EC8  C0F4     MOVFF pco, GIE_BIT_VAL
6ECA  F0E1     NOP
6ECC  0E64     MOVLW 0x64
6ECE  0100     MOVLB 0x0
6ED0  6FE2     MOVWF divisor, BANKED
6ED2  6BE3     CLRF a, BANKED
6ED4  6BE4     CLRF k, BANKED
6ED6  6BE5     CLRF k, BANKED
6ED8  ECF3     CALL 0xB3E6, 0
6EDA  F059     NOP
6EDC  0E28     MOVLW 0x28
6EDE  0100     MOVLB 0x0
6EE0  25DE     ADDWF __pcstackBANK0, W, BANKED
6EE2  6FEC     MOVWF dt, BANKED
6EE4  0E00     MOVLW 0x0
6EE6  21DF     ADDWFC pco, W, BANKED
6EE8  6FED     MOVWF min, BANKED
6EEA  0E00     MOVLW 0x0
6EEC  21E0     ADDWFC bdat, W, BANKED
6EEE  6FEE     MOVWF dt, BANKED
6EF0  0E00     MOVLW 0x0
6EF2  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
6EF4  6FEF     MOVWF 0xEF, BANKED
6EF6  BFEF     BTFSC 0xEF, 7, BANKED
6EF8  D00A     BRA 0x6F0E
6EFA  51EF     MOVF 0xEF, W, BANKED
6EFC  11EE     IORWF dt, W, BANKED
6EFE  11ED     IORWF min, W, BANKED
6F00  E103     BNZ 0x6F08
6F02  0E56     MOVLW 0x56
6F04  5DEC     SUBWF dt, W, BANKED
6F06  E303     BNC 0x6F0E
6F08  0E55     MOVLW 0x55
6F0A  0012     RETURN 0
6F0C  D015     BRA 0x6F38
773:                           else p = _MIN_PCO + m / 100;
6F0E  C0F1     MOVFF m, __pcstackBANK0
6F10  F0DE     NOP
6F12  C0F2     MOVFF tid, pco
6F14  F0DF     NOP
6F16  C0F3     MOVFF min, bdat
6F18  F0E0     NOP
6F1A  C0F4     MOVFF pco, GIE_BIT_VAL
6F1C  F0E1     NOP
6F1E  0E64     MOVLW 0x64
6F20  0100     MOVLB 0x0
6F22  6FE2     MOVWF divisor, BANKED
6F24  6BE3     CLRF a, BANKED
6F26  6BE4     CLRF k, BANKED
6F28  6BE5     CLRF k, BANKED
6F2A  ECF3     CALL 0xB3E6, 0
6F2C  F059     NOP
6F2E  0100     MOVLB 0x0
6F30  51DE     MOVF __pcstackBANK0, W, BANKED
6F32  0F28     ADDLW 0x28
6F34  6FF0     MOVWF p, BANKED
6F36  D000     BRA 0x6F38
774:                           if(p < _MIN_PCO) return _MIN_PCO;
6F38  0E28     MOVLW 0x28
6F3A  0100     MOVLB 0x0
6F3C  61F0     CPFSLT p, BANKED
6F3E  D001     BRA 0x6F42
6F40  0012     RETURN 0
775:                           return p;
6F42  0100     MOVLB 0x0
6F44  51F0     MOVF p, W, BANKED
776:                       }
6F46  0012     RETURN 0
777:                       else return _MIN_PCO;
6F48  0E28     MOVLW 0x28
778:                   }
6F4A  0012     RETURN 0
779:                   else return _MIN_PCO;
6F4C  0E28     MOVLW 0x28
780:               }
6F4E  0012     RETURN 0
781:               else //ogrzewanie podlogowe
782:               {
783:                   if(DtCO.PCO) //kt>0?
6F50  0100     MOVLB 0x0
6F52  51D0     MOVF 0xD0, W, BANKED
6F54  E101     BNZ 0x6F58
6F56  D0B6     BRA 0x70C4
784:                   {
785:                       if(DtZW.SZW < 25) //Tzw<25?
6F58  0101     MOVLB 0x1
6F5A  5147     MOVF 0x47, W, BANKED
6F5C  0A80     XORLW 0x80
6F5E  0F67     ADDLW 0x67
6F60  E301     BNC 0x6F64
6F62  D0AE     BRA 0x70C0
786:                       {
787:                           m = (25 - DtZW.SZW) * DtCO.PCO;
6F64  C147     MOVFF 0x147, dt
6F66  F0EC     NOP
6F68  0100     MOVLB 0x0
6F6A  6BED     CLRF min, BANKED
6F6C  BFEC     BTFSC dt, 7, BANKED
6F6E  07ED     DECF min, F, BANKED
6F70  1FEC     COMF dt, F, BANKED
6F72  1FED     COMF min, F, BANKED
6F74  4BEC     INFSNZ dt, F, BANKED
6F76  2BED     INCF min, F, BANKED
6F78  0E19     MOVLW 0x19
6F7A  25EC     ADDWF dt, W, BANKED
6F7C  6FDE     MOVWF __pcstackBANK0, BANKED
6F7E  0E00     MOVLW 0x0
6F80  21ED     ADDWFC min, W, BANKED
6F82  6FDF     MOVWF pco, BANKED
6F84  C0D0     MOVFF 0xD0, bdat
6F86  F0E0     NOP
6F88  6BE1     CLRF GIE_BIT_VAL, BANKED
6F8A  EC5B     CALL 0xECB6, 0
6F8C  F076     NOP
6F8E  C0DE     MOVFF __pcstackBANK0, m
6F90  F0F1     NOP
6F92  C0DF     MOVFF pco, tid
6F94  F0F2     NOP
6F96  0100     MOVLB 0x0
6F98  0E00     MOVLW 0x0
6F9A  BFF2     BTFSC tid, 7, BANKED
6F9C  0EFF     MOVLW 0xFF
6F9E  6FF3     MOVWF min, BANKED
6FA0  6FF4     MOVWF pco, BANKED
788:                           m *= (_MAX_PDCO - _MIN_PDCO);
6FA2  C0F1     MOVFF m, __pcstackBANK0
6FA4  F0DE     NOP
6FA6  C0F2     MOVFF tid, pco
6FA8  F0DF     NOP
6FAA  C0F3     MOVFF min, bdat
6FAC  F0E0     NOP
6FAE  C0F4     MOVFF pco, GIE_BIT_VAL
6FB0  F0E1     NOP
6FB2  0E14     MOVLW 0x14
6FB4  0100     MOVLB 0x0
6FB6  6FE2     MOVWF divisor, BANKED
6FB8  6BE3     CLRF a, BANKED
6FBA  6BE4     CLRF k, BANKED
6FBC  6BE5     CLRF k, BANKED
6FBE  EC2F     CALL 0xDA5E, 0
6FC0  F06D     NOP
6FC2  C0DE     MOVFF __pcstackBANK0, m
6FC4  F0F1     NOP
6FC6  C0DF     MOVFF pco, tid
6FC8  F0F2     NOP
6FCA  C0E0     MOVFF bdat, min
6FCC  F0F3     NOP
6FCE  C0E1     MOVFF GIE_BIT_VAL, pco
6FD0  F0F4     NOP
789:                           m *= 100;
6FD2  C0F1     MOVFF m, __pcstackBANK0
6FD4  F0DE     NOP
6FD6  C0F2     MOVFF tid, pco
6FD8  F0DF     NOP
6FDA  C0F3     MOVFF min, bdat
6FDC  F0E0     NOP
6FDE  C0F4     MOVFF pco, GIE_BIT_VAL
6FE0  F0E1     NOP
6FE2  0E64     MOVLW 0x64
6FE4  0100     MOVLB 0x0
6FE6  6FE2     MOVWF divisor, BANKED
6FE8  6BE3     CLRF a, BANKED
6FEA  6BE4     CLRF k, BANKED
6FEC  6BE5     CLRF k, BANKED
6FEE  EC2F     CALL 0xDA5E, 0
6FF0  F06D     NOP
6FF2  C0DE     MOVFF __pcstackBANK0, m
6FF4  F0F1     NOP
6FF6  C0DF     MOVFF pco, tid
6FF8  F0F2     NOP
6FFA  C0E0     MOVFF bdat, min
6FFC  F0F3     NOP
6FFE  C0E1     MOVFF GIE_BIT_VAL, pco
7000  F0F4     NOP
790:                           m /= 1485; //(25-10)*99
7002  C0F1     MOVFF m, __pcstackBANK0
7004  F0DE     NOP
7006  C0F2     MOVFF tid, pco
7008  F0DF     NOP
700A  C0F3     MOVFF min, bdat
700C  F0E0     NOP
700E  C0F4     MOVFF pco, GIE_BIT_VAL
7010  F0E1     NOP
7012  0ECD     MOVLW 0xCD
7014  0100     MOVLB 0x0
7016  6FE2     MOVWF divisor, BANKED
7018  0E05     MOVLW 0x5
701A  6FE3     MOVWF a, BANKED
701C  6BE4     CLRF k, BANKED
701E  6BE5     CLRF k, BANKED
7020  ECF3     CALL 0xB3E6, 0
7022  F059     NOP
7024  C0DE     MOVFF __pcstackBANK0, m
7026  F0F1     NOP
7028  C0DF     MOVFF pco, tid
702A  F0F2     NOP
702C  C0E0     MOVFF bdat, min
702E  F0F3     NOP
7030  C0E1     MOVFF GIE_BIT_VAL, pco
7032  F0F4     NOP
791:                           if((_MIN_PDCO + m / 100) > _MAX_PDCO) return _MAX_PDCO;
7034  C0F1     MOVFF m, __pcstackBANK0
7036  F0DE     NOP
7038  C0F2     MOVFF tid, pco
703A  F0DF     NOP
703C  C0F3     MOVFF min, bdat
703E  F0E0     NOP
7040  C0F4     MOVFF pco, GIE_BIT_VAL
7042  F0E1     NOP
7044  0E64     MOVLW 0x64
7046  0100     MOVLB 0x0
7048  6FE2     MOVWF divisor, BANKED
704A  6BE3     CLRF a, BANKED
704C  6BE4     CLRF k, BANKED
704E  6BE5     CLRF k, BANKED
7050  ECF3     CALL 0xB3E6, 0
7052  F059     NOP
7054  0E23     MOVLW 0x23
7056  0100     MOVLB 0x0
7058  25DE     ADDWF __pcstackBANK0, W, BANKED
705A  6FEC     MOVWF dt, BANKED
705C  0E00     MOVLW 0x0
705E  21DF     ADDWFC pco, W, BANKED
7060  6FED     MOVWF min, BANKED
7062  0E00     MOVLW 0x0
7064  21E0     ADDWFC bdat, W, BANKED
7066  6FEE     MOVWF dt, BANKED
7068  0E00     MOVLW 0x0
706A  21E1     ADDWFC GIE_BIT_VAL, W, BANKED
706C  6FEF     MOVWF 0xEF, BANKED
706E  BFEF     BTFSC 0xEF, 7, BANKED
7070  D00A     BRA 0x7086
7072  51EF     MOVF 0xEF, W, BANKED
7074  11EE     IORWF dt, W, BANKED
7076  11ED     IORWF min, W, BANKED
7078  E103     BNZ 0x7080
707A  0E38     MOVLW 0x38
707C  5DEC     SUBWF dt, W, BANKED
707E  E303     BNC 0x7086
7080  0E37     MOVLW 0x37
7082  0012     RETURN 0
7084  D015     BRA 0x70B0
792:                           else p = _MIN_PDCO + m / 100;
7086  C0F1     MOVFF m, __pcstackBANK0
7088  F0DE     NOP
708A  C0F2     MOVFF tid, pco
708C  F0DF     NOP
708E  C0F3     MOVFF min, bdat
7090  F0E0     NOP
7092  C0F4     MOVFF pco, GIE_BIT_VAL
7094  F0E1     NOP
7096  0E64     MOVLW 0x64
7098  0100     MOVLB 0x0
709A  6FE2     MOVWF divisor, BANKED
709C  6BE3     CLRF a, BANKED
709E  6BE4     CLRF k, BANKED
70A0  6BE5     CLRF k, BANKED
70A2  ECF3     CALL 0xB3E6, 0
70A4  F059     NOP
70A6  0100     MOVLB 0x0
70A8  51DE     MOVF __pcstackBANK0, W, BANKED
70AA  0F23     ADDLW 0x23
70AC  6FF0     MOVWF p, BANKED
70AE  D000     BRA 0x70B0
793:                           if(p < _MIN_PDCO) return _MIN_PDCO;
70B0  0E23     MOVLW 0x23
70B2  0100     MOVLB 0x0
70B4  61F0     CPFSLT p, BANKED
70B6  D001     BRA 0x70BA
70B8  0012     RETURN 0
794:                           return p;
70BA  0100     MOVLB 0x0
70BC  51F0     MOVF p, W, BANKED
795:                       }
70BE  0012     RETURN 0
796:                       else return _MIN_PDCO;
70C0  0E23     MOVLW 0x23
797:                   }
70C2  0012     RETURN 0
798:                   else return _MIN_PDCO;
70C4  0E23     MOVLW 0x23
70C6  0012     RETURN 0
799:               }
800:           }
70C8  0012     RETURN 0
801:           /*---------------------------------------------------------------------------------*/
802:           //Zapis nastawy PCW po ustalonym czasie do EEPROM
803:           
804:           void WritePCO(void)
805:           {
806:               if(DtCOf_newPCO && RTdS(_RTPCO) >= _TWRTPCO)
EECE  A402     BTFSS DtCOf_su_CO, 2, ACCESS
EED0  0012     RETURN 0
EED2  0E05     MOVLW 0x5
EED4  ECD7     CALL 0xEBAE, 0
EED6  F075     NOP
EED8  0100     MOVLB 0x0
EEDA  6FE2     MOVWF divisor, BANKED
EEDC  0E09     MOVLW 0x9
EEDE  65E2     CPFSGT divisor, BANKED
EEE0  0C09     RETLW 0x9
807:               {
808:                   DtCOf_newPCO = 0;
EEE2  9402     BCF DtCOf_su_CO, 2, ACCESS
809:                   StartRTdS(_RTPCO);
EEE4  0E05     MOVLW 0x5
EEE6  ECA0     CALL 0xE540, 0
EEE8  F072     NOP
810:                   WriteEEPCO();
EEEA  EFB4     GOTO 0xF168
EEEC  F078     NOP
811:               }
812:           }
EEEE  0012     RETURN 0
813:           /*---------------------------------------------------------------------------------*/
814:           //Nastawa PCO
815:           
816:           void PomiarPCO(void)
817:           {
818:               static unsigned char pnst;
819:               //unsigned char dac,dz,nst;
820:           
821:               if(!Mf_AKTYWNE_PGD)
C714  BA06     BTFSC DtKNFf_wymCO, 5, ACCESS
C716  D00D     BRA 0xC732
822:               {
823:                   if(!DtKNF.opdg)
C718  0100     MOVLB 0x0
C71A  51A7     MOVF _rglf_btco, W, BANKED
C71C  E104     BNZ 0xC726
824:                   {
825:                       DtCO.minPCO = _MIN_PCO;
C71E  0E28     MOVLW 0x28
C720  6FD2     MOVWF 0xD2, BANKED
826:                       DtCO.maxPCO = _MAX_PCO;
C722  0E55     MOVLW 0x55
C724  D009     BRA 0xC738
827:                   }
828:                   else
829:                   {
830:                       DtCO.minPCO = _MIN_PDCO;
C726  0E23     MOVLW 0x23
C728  0100     MOVLB 0x0
C72A  6FD2     MOVWF 0xD2, BANKED
831:                       DtCO.maxPCO = _MAX_PDCO;
C72C  0E37     MOVLW 0x37
C72E  D004     BRA 0xC738
832:                   }
833:               }
C730  D006     BRA 0xC73E
834:               else
835:               {
836:                   DtCO.minPCO = _MIN_PGD;
C732  0100     MOVLB 0x0
C734  6BD2     CLRF 0xD2, BANKED
837:                   DtCO.maxPCO = _MAX_PGD;
C736  0E63     MOVLW 0x63
C738  0100     MOVLB 0x0
C73A  6FD3     MOVWF 0xD3, BANKED
C73C  D000     BRA 0xC73E
838:               }
839:               pnst = PFN.PCO;
C73E  C1EF     MOVFF 0x1EF, pnst
C740  F16D     NOP
840:               if(pnst < DtCO.minPCO) pnst = DtCO.minPCO; //nastawa w dozwolonym zakresie?
C742  0100     MOVLB 0x0
C744  51D2     MOVF 0xD2, W, BANKED
C746  0101     MOVLB 0x1
C748  5D6D     SUBWF _PFNf_errCO, W, BANKED
C74A  E203     BC 0xC752
C74C  C0D2     MOVFF 0xD2, pnst
C74E  F16D     NOP
C750  D000     BRA 0xC752
841:               if(pnst > DtCO.maxPCO) pnst = DtCO.maxPCO; //nastawa w dozwolonym zakresie?
C752  0101     MOVLB 0x1
C754  516D     MOVF _PFNf_errCO, W, BANKED
C756  0100     MOVLB 0x0
C758  5DD3     SUBWF 0xD3, W, BANKED
C75A  E203     BC 0xC762
C75C  C0D3     MOVFF 0xD3, pnst
C75E  F16D     NOP
C760  D000     BRA 0xC762
842:               if(DtCO.PCO != pnst) //nowa wartosc nastawy?
C762  0101     MOVLB 0x1
C764  516D     MOVF _PFNf_errCO, W, BANKED
C766  0100     MOVLB 0x0
C768  19D0     XORWF 0xD0, W, BANKED
C76A  E006     BZ 0xC778
843:               {
844:                   DtCO.PCO = pnst;
C76C  C16D     MOVFF pnst, 0xD0
C76E  F0D0     NOP
845:                   DtCOf_newPCO = 1;
C770  8402     BSF DtCOf_su_CO, 2, ACCESS
846:                   StartRTdS(_RTPCO);
C772  0E05     MOVLW 0x5
C774  ECA0     CALL 0xE540, 0
C776  F072     NOP
847:               }
848:               WritePCO(); //zapisz nastawe do pamieci
C778  EC67     CALL 0xEECE, 0
C77A  F077     NOP
849:               if(Mf_AKTYWNE_PGD) DtCO.PGDPCO = GetPGD_PCO();
C77C  AA06     BTFSS DtKNFf_wymCO, 5, ACCESS
C77E  D005     BRA 0xC78A
C780  ECE9     CALL 0x6DD2, 0
C782  F036     NOP
C784  0100     MOVLB 0x0
C786  6FD4     MOVWF 0xD4, BANKED
C788  D000     BRA 0xC78A
850:               SetModPCO();
C78A  ECA2     CALL 0xC544, 0
C78C  F062     NOP
851:               DtCO.DAD_CO = ReturnACfromNTC(DtCO.PPCO - _BNCO);
C78E  0100     MOVLB 0x0
C790  05D1     DECF 0xD1, W, BANKED
C792  EC7A     CALL 0xDEF4, 0
C794  F06F     NOP
C796  0100     MOVLB 0x0
C798  6FDB     MOVWF 0xDB, BANKED
852:               DtCO.MAD_CO = ReturnACfromNTC(DtCO.PPCO - _BNCO - _MR_MADCO);
C79A  0100     MOVLB 0x0
C79C  51D1     MOVF 0xD1, W, BANKED
C79E  0FF9     ADDLW 0xF9
C7A0  EC7A     CALL 0xDEF4, 0
C7A2  F06F     NOP
C7A4  0100     MOVLB 0x0
C7A6  6FDA     MOVWF 0xDA, BANKED
853:           }
C7A8  0012     RETURN 0
854:           /*---------------------------------------------------------------------------------*/
855:           /*---------------------------------------------------------------------------------*/
856:           //Zapis nastawy PCW po ustalonym czasie do EEPROM
857:           
858:           void WritePCW(void)
859:           {
860:               if(DtCWf_newPCW && RTdS(_RTPCW) >= _TWRTPCW)
EEAC  AC04     BTFSS DtCWf_err_CW, 6, ACCESS
EEAE  0012     RETURN 0
EEB0  0E06     MOVLW 0x6
EEB2  ECD7     CALL 0xEBAE, 0
EEB4  F075     NOP
EEB6  0100     MOVLB 0x0
EEB8  6FE2     MOVWF divisor, BANKED
EEBA  0E09     MOVLW 0x9
EEBC  65E2     CPFSGT divisor, BANKED
EEBE  0C09     RETLW 0x9
861:               {
862:                   DtCWf_newPCW = 0;
EEC0  9C04     BCF DtCWf_err_CW, 6, ACCESS
863:                   StartRTdS(_RTPCW);
EEC2  0E06     MOVLW 0x6
EEC4  ECA0     CALL 0xE540, 0
EEC6  F072     NOP
864:                   WriteEEPCW();
EEC8  EFA9     GOTO 0xF152
EECA  F078     NOP
865:               }
866:           }
EECC  0012     RETURN 0
867:           /*---------------------------------------------------------------------------------*/
868:           //Formatowanie nastawy CW
869:           
870:           void SetModPCW(void)
871:           {
872:               if(Mf_AKTYWNE_KNF) DtCW.PPCW = _KNF_PCW; //aktywna konfiguracja?
EA04  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
EA06  D002     BRA 0xEA0C
EA08  0E3C     MOVLW 0x3C
EA0A  D006     BRA 0xEA18
873:               else
874:               if((DtKNF.tpkt == _UNICO) && Mf_pob_AL) DtCW.PPCW = _AL_PCW; //aktywna f. AntyLegionella
EA0C  0100     MOVLB 0x0
EA0E  519E     MOVF _PWMf_ENPWM2, W, BANKED
EA10  B4D8     BTFSC STATUS, 2, ACCESS
EA12  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
EA14  D004     BRA 0xEA1E
EA16  0E46     MOVLW 0x46
EA18  0100     MOVLB 0x0
EA1A  6FAC     MOVWF _rglf_fz, BANKED
EA1C  D003     BRA 0xEA24
875:               else DtCW.PPCW = DtCW.PCW;
EA1E  C0AB     MOVFF _rglf_fast_up, _rglf_fz
EA20  F0AC     NOP
EA22  D000     BRA 0xEA24
876:           
877:               if(Mf_pob_DzCW) 
EA24  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
EA26  D004     BRA 0xEA30
878:               {
879:                   DtCW.PPCW = _OFF_DZ_CW;
EA28  0E0A     MOVLW 0xA
EA2A  0100     MOVLB 0x0
EA2C  6FAC     MOVWF _rglf_fz, BANKED
EA2E  D000     BRA 0xEA30
880:               }
881:               PFN.PPCW = DtCW.PPCW;
EA30  C0AC     MOVFF _rglf_fz, 0x1E4
EA32  F1E4     NOP
882:           }
EA34  0012     RETURN 0
883:           /*---------------------------------------------------------------------------------*/
884:           //Nastawa PCW
885:           
886:           void PomiarPCW(void)
887:           {
888:               static unsigned char pnst;
889:               //	unsigned char dac,dz,nst;
890:           
891:               //----------
892:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
C8CA  D00E     BRA 0xC8E8
C8E8  0100     MOVLB 0x0
C8EA  519E     MOVF _PWMf_ENPWM2, W, BANKED
C8EC  E0F1     BZ 0xC8D0
C8EE  0A01     XORLW 0x1
C8F0  E0F4     BZ 0xC8DA
C8F2  0A03     XORLW 0x3
C8F4  E0F2     BZ 0xC8DA
C8F6  0A01     XORLW 0x1
C8F8  D7F0     BRA 0xC8DA
893:               {
894:                   case _BITERM: //bitermiczny (miniterm)
C8CC  D006     BRA 0xC8DA
895:                   case _BITERM2: //bitermiczny (maxiterm)
896:                   {
897:                       DtCW.minPCW = F1_MIN_PCW;
898:                       DtCW.maxPCW = F1_MAX_PCW;
899:                       break;
900:                   }
901:                   case _MONOHB:
902:                   {
903:                       DtCW.minPCW = F2_MIN_PCW;
C8CE  D005     BRA 0xC8DA
904:                       DtCW.maxPCW = F2_MAX_PCW;
905:                       break;
906:                   }
907:                   case _UNICO: //kociol unico
908:                   {
909:                       DtCW.minPCW = F3_MIN_PCW;
C8D0  0E23     MOVLW 0x23
C8D2  0100     MOVLB 0x0
C8D4  6FAD     MOVWF _rglf_inv_mod, BANKED
910:                       DtCW.maxPCW = F3_MAX_PCW;
C8D6  0E41     MOVLW 0x41
C8D8  D004     BRA 0xC8E2
911:                       break;
912:                   }
913:                   default: //domyslny monotermiczny
914:                   {
915:                       DtCW.minPCW = F2_MIN_PCW;
C8DA  0E1E     MOVLW 0x1E
C8DC  0100     MOVLB 0x0
C8DE  6FAD     MOVWF _rglf_inv_mod, BANKED
916:                       DtCW.maxPCW = F2_MAX_PCW;
C8E0  0E3C     MOVLW 0x3C
C8E2  0100     MOVLB 0x0
C8E4  6FAE     MOVWF _rglf_med_up, BANKED
917:                       break;
918:                   }
919:               }
C8E6  D009     BRA 0xC8FA
920:               pnst = PFN.PCW;
C8FA  C1F1     MOVFF 0x1F1, pnst
C8FC  F16E     NOP
921:               if(pnst < DtCW.minPCW) pnst = DtCW.minPCW; //nastawa w dozwolonym zakresie?
C8FE  0100     MOVLB 0x0
C900  51AD     MOVF _rglf_inv_mod, W, BANKED
C902  0101     MOVLB 0x1
C904  5D6E     SUBWF _PFNf_errCS, W, BANKED
C906  E203     BC 0xC90E
C908  C0AD     MOVFF _rglf_inv_mod, pnst
C90A  F16E     NOP
C90C  D000     BRA 0xC90E
922:               if(pnst > DtCW.maxPCW) pnst = DtCW.maxPCW; //nastawa w dozwolonym zakresie?
C90E  0101     MOVLB 0x1
C910  516E     MOVF _PFNf_errCS, W, BANKED
C912  0100     MOVLB 0x0
C914  5DAE     SUBWF _rglf_med_up, W, BANKED
C916  E203     BC 0xC91E
C918  C0AE     MOVFF _rglf_med_up, pnst
C91A  F16E     NOP
C91C  D000     BRA 0xC91E
923:               if(DtCW.PCW != pnst) //nowa wartosc nastawy?
C91E  0101     MOVLB 0x1
C920  516E     MOVF _PFNf_errCS, W, BANKED
C922  0100     MOVLB 0x0
C924  19AB     XORWF _rglf_fast_up, W, BANKED
C926  E006     BZ 0xC934
924:               {
925:                   DtCW.PCW = pnst;
C928  C16E     MOVFF pnst, _rglf_fast_up
C92A  F0AB     NOP
926:                   DtCWf_newPCW = 1;
C92C  8C04     BSF DtCWf_err_CW, 6, ACCESS
927:                   StartRTdS(_RTPCW);
C92E  0E06     MOVLW 0x6
C930  ECA0     CALL 0xE540, 0
C932  F072     NOP
928:               }
929:               WritePCW(); //zapisz nastawe do pamieci
C934  EC56     CALL 0xEEAC, 0
C936  F077     NOP
930:               SetModPCW();
C938  EC02     CALL 0xEA04, 0
C93A  F075     NOP
931:               DtCW.DAD_CW = ReturnACfromNTC(DtCW.PPCW - (_BNCW - 1));
C93C  0100     MOVLB 0x0
C93E  05AC     DECF _rglf_fz, W, BANKED
C940  EC7A     CALL 0xDEF4, 0
C942  F06F     NOP
C944  0100     MOVLB 0x0
C946  6FB6     MOVWF 0xB6, BANKED
932:               DtCW.MAD_CW = ReturnACfromNTC(DtCW.PPCW - (_BNCW - 1) - _MR_MADCW);
C948  0100     MOVLB 0x0
C94A  51AC     MOVF _rglf_fz, W, BANKED
C94C  0FF6     ADDLW 0xF6
C94E  EC7A     CALL 0xDEF4, 0
C950  F06F     NOP
C952  0100     MOVLB 0x0
C954  6FB5     MOVWF 0xB5, BANKED
933:           }
C956  0012     RETURN 0
934:           
935:           
936:           
937:           /*---------------------------------------------------------------------------------*/
938:           //Zapis nastawy ECO po ustalonym czasie do EEPROM
939:           /*
940:           void WriteECO(void)
941:           {
942:                   if(DtINf_newECO&&RTdS(_RTECO)>=_TWRTECO)
943:                   {
944:                           DtINf_newECO=0;
945:                           StartRTdS(_RTECO);
946:                           WriteEEECO();
947:                   }
948:           }*/
949:           /*---------------------------------------------------------------------------------*/
950:           /*---------------------------------------------------------------------------------*/
951:           //Nastawa ECO
952:           /*void PomiarECO(void)
953:           {
954:                   static unsigned char peco;
955:           
956:                   if(!GetBit2(RSDT1.inSTAT0,_INITDTA)&&MGSD._CON)
957:                   {
958:                           peco=10-RSDT1.inECO;
959:                           if(peco<N_MIN_ECO) peco=N_MIN_ECO;	//nastawa w dozwolonym zakresie?
960:                           if(peco>N_MAX_ECO) peco=N_MAX_ECO;	//nastawa w dozwolonym zakresie?	//nastawa w dozwolonym zakresie?
961:                           if(DtIN.Eco!=peco)	//nowa wartosc nastawy?
962:                           {
963:                                   DtIN.Eco=peco;
964:                                   DtINf_newECO=1;
965:                                   StartRTdS(_RTECO);
966:                           }
967:                           WriteECO();		//zapisz nastawe do pamieci
968:                   }
969:                   else
970:                   {
971:                           DtIN.Eco=ReadEEECO();
972:                           if(peco<N_MIN_ECO) peco=N_MIN_ECO;	//nastawa w dozwolonym zakresie?
973:                           if(peco>N_MAX_ECO) peco=N_MAX_ECO;	//nastawa w dozwolonym zakresie?
974:                   }
975:                   if(Mf_AKTYWNE_PGD) 	DtIN.PPEco=_PGDECO;
976:                   else DtIN.PPEco=DtIN.Eco;
977:                   RSDT1.outECO=10-DtIN.PPEco;
978:           }*/
979:           /*---------------------------------------------------------------------------------*/
980:           /*---------------------------------------------------------------------------------*/
981:           //Zapis pozycji PFN po ustalonym czasie do EEPROM
982:           
983:           void WritePFN(void)
984:           {
985:               if(PFNf_newPFN && RTdS(_RTPFN) >= _TWRTPFN)
EE8A  A60F     BTFSS PFNf_off, 3, ACCESS
EE8C  0012     RETURN 0
EE8E  0E07     MOVLW 0x7
EE90  ECD7     CALL 0xEBAE, 0
EE92  F075     NOP
EE94  0100     MOVLB 0x0
EE96  6FE2     MOVWF divisor, BANKED
EE98  0E09     MOVLW 0x9
EE9A  65E2     CPFSGT divisor, BANKED
EE9C  0C09     RETLW 0x9
986:               {
987:                   PFNf_newPFN = 0;
EE9E  960F     BCF PFNf_off, 3, ACCESS
988:                   StartRTdS(_RTPFN);
EEA0  0E07     MOVLW 0x7
EEA2  ECA0     CALL 0xE540, 0
EEA4  F072     NOP
989:                   WriteEEPFN();
EEA6  EF9E     GOTO 0xF13C
EEA8  F078     NOP
990:               }
991:           }
EEAA  0012     RETURN 0
992:           /*---------------------------------------------------------------------------------*/
993:           //Nastawa przelacznika funkcyjnego
994:           
995:           void PomiarPFN(void)
996:           {
997:               static unsigned char pnst;
998:           
999:               if(PFNf_off) //pozycja off
E26A  AE0F     BTFSS PFNf_off, 7, ACCESS
E26C  D002     BRA 0xE272
1000:              {
1001:                  PFN.poz = _PFOFF;
E26E  0E01     MOVLW 0x1
E270  D00A     BRA 0xE286
1002:              }
1003:              else
1004:                  if(PFNf_zima && !PFNf_off) //pozycja zima
E272  B613     BTFSC PFNf_zima, 3, ACCESS
E274  BE0F     BTFSC PFNf_off, 7, ACCESS
E276  D001     BRA 0xE27A
E278  D005     BRA 0xE284
1005:              {
1006:                  PFN.poz = _PFZMA;
1007:              }
1008:              else
1009:                  if(PFNf_lato && !PFNf_off) //pozycja lato
E27A  BE0E     BTFSC PFNf_lato, 7, ACCESS
E27C  BE0F     BTFSC PFNf_off, 7, ACCESS
E27E  D002     BRA 0xE284
1010:              {
1011:                  PFN.poz = _PFLTO;
E280  0E02     MOVLW 0x2
E282  D001     BRA 0xE286
1012:              }
1013:              else
1014:              {
1015:                  PFN.poz = _PFZMA;
E284  0E03     MOVLW 0x3
E286  0101     MOVLB 0x1
E288  6FF3     MOVWF min, BANKED
1016:              }
E28A  D000     BRA 0xE28C
1017:              pnst = ReadEEPFN();
E28C  ECBA     CALL 0xF374, 0
E28E  F079     NOP
E290  0101     MOVLB 0x1
E292  6F6F     MOVWF _PFNf_errCW, BANKED
1018:              if(PFN.poz != pnst) //nowa wartosc pozycji PFN?
E294  0101     MOVLB 0x1
E296  516F     MOVF _PFNf_errCW, W, BANKED
E298  19F3     XORWF min, W, BANKED
E29A  E007     BZ 0xE2AA
1019:              {
1020:                  if(!PFNf_newPFN) StartRTdS(_RTPFN);
E29C  B60F     BTFSC PFNf_off, 3, ACCESS
E29E  D004     BRA 0xE2A8
E2A0  0E07     MOVLW 0x7
E2A2  ECA0     CALL 0xE540, 0
E2A4  F072     NOP
E2A6  D000     BRA 0xE2A8
1021:                  PFNf_newPFN = 1;
E2A8  860F     BSF PFNf_off, 3, ACCESS
1022:              }
1023:              WritePFN(); //zapisz nastawe do pamieci
E2AA  EC45     CALL 0xEE8A, 0
E2AC  F077     NOP
1024:          }
E2AE  0012     RETURN 0
1025:          /*---------------------------------------------------------------------------------*/
1026:          //Pomiar wartosci cisnienia
1027:          
1028:          void PomiarCS(void)
1029:          {
1030:              static unsigned char pcs;
1031:              unsigned char dac, cs;
1032:              dac = ReadAC(_CHN_CS);
8310  0E03     MOVLW 0x3
8312  EC33     CALL 0xD466, 0
8314  F06A     NOP
8316  0100     MOVLB 0x0
8318  6FF0     MOVWF p, BANKED
1033:          
1034:              if((!DtKNF.tpcs && (dac < _CS_MIN || dac > _CS_MAX)) || (DtKNF.tpcs && (dac < _CS5_MIN || dac > _CS5_MAX))) //awaria czujnika?
831A  0100     MOVLB 0x0
831C  51A8     MOVF _rglf_btcw, W, BANKED
831E  E107     BNZ 0x832E
8320  0E0F     MOVLW 0xF
8322  65F0     CPFSGT p, BANKED
8324  D00E     BRA 0x8342
8326  0EEC     MOVLW 0xEC
8328  61F0     CPFSLT p, BANKED
832A  D00B     BRA 0x8342
832C  D000     BRA 0x832E
832E  0100     MOVLB 0x0
8330  51A8     MOVF _rglf_btcw, W, BANKED
8332  E01B     BZ 0x836A
8334  0E0F     MOVLW 0xF
8336  65F0     CPFSGT p, BANKED
8338  D004     BRA 0x8342
833A  0EEB     MOVLW 0xEB
833C  65F0     CPFSGT p, BANKED
833E  D015     BRA 0x836A
8340  D000     BRA 0x8342
1035:              {
1036:                  if(DtKNF.robg == _OTWARTY) //UniCo z ukladem otwartym?
8342  0100     MOVLB 0x0
8344  51A6     MOVF _mux, W, BANKED
8346  E10A     BNZ 0x835C
1037:                  {
1038:                      DtCSf_error = 0;
8348  9603     BCF DtCOf_su_SRW_CO, 3, ACCESS
1039:                      DtCSf_no = 0;
834A  9C03     BCF DtCOf_su_SRW_CO, 6, ACCESS
1040:                      DtCSf_lo = 0;
834C  9A03     BCF DtCOf_su_SRW_CO, 5, ACCESS
1041:                      DtCSf_hi = 0;
834E  9803     BCF DtCOf_su_SRW_CO, 4, ACCESS
1042:                      DtCSf_work = 1;
8350  8004     BSF DtCWf_err_CW, 0, ACCESS
1043:                      DtCSf_no_mont = 1; //czujnik cisnienia nie zam. w ukladzie
8352  8E03     BSF DtCOf_su_SRW_CO, 7, ACCESS
1044:                      DtCS.CS = 0;
8354  0E00     MOVLW 0x0
8356  0100     MOVLB 0x0
8358  6FCB     MOVWF DtCS, BANKED
1045:                  }
835A  0C00     RETLW 0x0
1046:                  else
1047:                  {
1048:                      DtCSf_error = 1;
835C  8603     BSF DtCOf_su_SRW_CO, 3, ACCESS
1049:                      DtCSf_no = 0;
835E  9C03     BCF DtCOf_su_SRW_CO, 6, ACCESS
1050:                      DtCSf_lo = 0;
8360  9A03     BCF DtCOf_su_SRW_CO, 5, ACCESS
1051:                      DtCSf_hi = 0;
8362  9803     BCF DtCOf_su_SRW_CO, 4, ACCESS
1052:                      DtCSf_work = 0;
8364  9004     BCF DtCWf_err_CW, 0, ACCESS
1053:                      DtCSf_no_mont = 0; //czujnik cisnienia zam. w ukladzie
8366  9E03     BCF DtCOf_su_SRW_CO, 7, ACCESS
1054:                  }
1055:              }
8368  0012     RETURN 0
1056:              else
1057:              {
1058:                  DtCSf_error = 0;
836A  9603     BCF DtCOf_su_SRW_CO, 3, ACCESS
1059:                  DtCSf_no_mont = 0; //czujnik cisnienia zam. w ukladzie
836C  9E03     BCF DtCOf_su_SRW_CO, 7, ACCESS
1060:                  if(!DtKNF.tpcs) //czujnki 18V?
836E  0100     MOVLB 0x0
8370  51A8     MOVF _rglf_btcw, W, BANKED
8372  E159     BNZ 0x8426
1061:                  {
1062:                      if(dac < _CS_0) dac = _CS_0;
8374  0E1E     MOVLW 0x1E
8376  61F0     CPFSLT p, BANKED
8378  D002     BRA 0x837E
837A  6FF0     MOVWF p, BANKED
837C  D000     BRA 0x837E
1063:                      if(dac > _CS_4) dac = _CS_4;
837E  0ED2     MOVLW 0xD2
8380  0100     MOVLB 0x0
8382  65F0     CPFSGT p, BANKED
8384  D002     BRA 0x838A
8386  6FF0     MOVWF p, BANKED
8388  D000     BRA 0x838A
1064:                      cs = ((dac - _CS_0)*10) / (((_CS_4 - _CS_0)*10) / _NWCS);
838A  0EE2     MOVLW 0xE2
838C  0100     MOVLB 0x0
838E  25F0     ADDWF p, W, BANKED
8390  6FDE     MOVWF __pcstackBANK0, BANKED
8392  6BDF     CLRF pco, BANKED
8394  0EFF     MOVLW 0xFF
8396  23DF     ADDWFC pco, F, BANKED
8398  6BE1     CLRF GIE_BIT_VAL, BANKED
839A  0E0A     MOVLW 0xA
839C  6FE0     MOVWF bdat, BANKED
839E  EC5B     CALL 0xECB6, 0
83A0  F076     NOP
83A2  C0DE     MOVFF __pcstackBANK0, k
83A4  F0E4     NOP
83A6  C0DF     MOVFF pco, k
83A8  F0E5     NOP
83AA  0100     MOVLB 0x0
83AC  6BE7     CLRF sign, BANKED
83AE  0E2D     MOVLW 0x2D
83B0  6FE6     MOVWF counter, BANKED
83B2  EC09     CALL 0xC212, 0
83B4  F061     NOP
83B6  0100     MOVLB 0x0
83B8  51E4     MOVF k, W, BANKED
83BA  6FF1     MOVWF m, BANKED
1065:                      if(cs < _NWCS)
83BC  0E28     MOVLW 0x28
83BE  0100     MOVLB 0x0
83C0  61F1     CPFSLT m, BANKED
83C2  D084     BRA 0x84CC
1066:                          if((cs - pcs > 0) && (cs - pcs) < 2) cs = pcs; //filtr wskazu cisnienia
83C4  51C8     MOVF pcs, W, BANKED
83C6  6FEC     MOVWF dt, BANKED
83C8  6BED     CLRF min, BANKED
83CA  1FEC     COMF dt, F, BANKED
83CC  1FED     COMF min, F, BANKED
83CE  4BEC     INFSNZ dt, F, BANKED
83D0  2BED     INCF min, F, BANKED
83D2  51F1     MOVF m, W, BANKED
83D4  6FEE     MOVWF dt, BANKED
83D6  6BEF     CLRF 0xEF, BANKED
83D8  51EC     MOVF dt, W, BANKED
83DA  27EE     ADDWF dt, F, BANKED
83DC  51ED     MOVF min, W, BANKED
83DE  23EF     ADDWFC 0xEF, F, BANKED
83E0  BFEF     BTFSC 0xEF, 7, BANKED
83E2  D074     BRA 0x84CC
83E4  51EF     MOVF 0xEF, W, BANKED
83E6  E102     BNZ 0x83EC
83E8  05EE     DECF dt, W, BANKED
83EA  E370     BNC 0x84CC
83EC  0100     MOVLB 0x0
83EE  51C8     MOVF pcs, W, BANKED
83F0  6FEC     MOVWF dt, BANKED
83F2  6BED     CLRF min, BANKED
83F4  1FEC     COMF dt, F, BANKED
83F6  1FED     COMF min, F, BANKED
83F8  4BEC     INFSNZ dt, F, BANKED
83FA  2BED     INCF min, F, BANKED
83FC  51F1     MOVF m, W, BANKED
83FE  6FEE     MOVWF dt, BANKED
8400  6BEF     CLRF 0xEF, BANKED
8402  51EC     MOVF dt, W, BANKED
8404  27EE     ADDWF dt, F, BANKED
8406  51ED     MOVF min, W, BANKED
8408  23EF     ADDWFC 0xEF, F, BANKED
840A  BFEF     BTFSC 0xEF, 7, BANKED
840C  D007     BRA 0x841C
840E  51EF     MOVF 0xEF, W, BANKED
8410  E15D     BNZ 0x84CC
8412  0E02     MOVLW 0x2
8414  0100     MOVLB 0x0
8416  5DEE     SUBWF dt, W, BANKED
8418  B0D8     BTFSC STATUS, 0, ACCESS
841A  D058     BRA 0x84CC
841C  C0C8     MOVFF pcs, m
841E  F0F1     NOP
8420  D055     BRA 0x84CC
1067:                      if(cs > _NWCS) cs = _NWCS;
8422  D054     BRA 0x84CC
1068:                  }
8424  D059     BRA 0x84D8
1069:                  else //czujnik 5V
1070:                  {
1071:                      if(dac < _CS5_0) dac = _CS5_0;
8426  0E23     MOVLW 0x23
8428  0100     MOVLB 0x0
842A  61F0     CPFSLT p, BANKED
842C  D002     BRA 0x8432
842E  6FF0     MOVWF p, BANKED
8430  D000     BRA 0x8432
1072:                      if(dac > _CS5_4) dac = _CS5_4;
8432  0EBE     MOVLW 0xBE
8434  0100     MOVLB 0x0
8436  65F0     CPFSGT p, BANKED
8438  D002     BRA 0x843E
843A  6FF0     MOVWF p, BANKED
843C  D000     BRA 0x843E
1073:                      cs = ((dac - _CS5_0)*10) / (((_CS5_4 - _CS5_0)*10) / _NWCS5);
843E  0EDD     MOVLW 0xDD
8440  0100     MOVLB 0x0
8442  25F0     ADDWF p, W, BANKED
8444  6FDE     MOVWF __pcstackBANK0, BANKED
8446  6BDF     CLRF pco, BANKED
8448  0EFF     MOVLW 0xFF
844A  23DF     ADDWFC pco, F, BANKED
844C  6BE1     CLRF GIE_BIT_VAL, BANKED
844E  0E0A     MOVLW 0xA
8450  6FE0     MOVWF bdat, BANKED
8452  EC5B     CALL 0xECB6, 0
8454  F076     NOP
8456  C0DE     MOVFF __pcstackBANK0, k
8458  F0E4     NOP
845A  C0DF     MOVFF pco, k
845C  F0E5     NOP
845E  0100     MOVLB 0x0
8460  6BE7     CLRF sign, BANKED
8462  0E26     MOVLW 0x26
8464  6FE6     MOVWF counter, BANKED
8466  EC09     CALL 0xC212, 0
8468  F061     NOP
846A  0100     MOVLB 0x0
846C  51E4     MOVF k, W, BANKED
846E  6FF1     MOVWF m, BANKED
1074:                      if(cs < _NWCS5)
8470  0E28     MOVLW 0x28
8472  0100     MOVLB 0x0
8474  61F1     CPFSLT m, BANKED
8476  D02A     BRA 0x84CC
1075:                          if((cs - pcs > 0) && (cs - pcs) < 2) cs = pcs; //filtr wskazu cisnienia
8478  51C8     MOVF pcs, W, BANKED
847A  6FEC     MOVWF dt, BANKED
847C  6BED     CLRF min, BANKED
847E  1FEC     COMF dt, F, BANKED
8480  1FED     COMF min, F, BANKED
8482  4BEC     INFSNZ dt, F, BANKED
8484  2BED     INCF min, F, BANKED
8486  51F1     MOVF m, W, BANKED
8488  6FEE     MOVWF dt, BANKED
848A  6BEF     CLRF 0xEF, BANKED
848C  51EC     MOVF dt, W, BANKED
848E  27EE     ADDWF dt, F, BANKED
8490  51ED     MOVF min, W, BANKED
8492  23EF     ADDWFC 0xEF, F, BANKED
8494  BFEF     BTFSC 0xEF, 7, BANKED
8496  D01A     BRA 0x84CC
8498  51EF     MOVF 0xEF, W, BANKED
849A  E102     BNZ 0x84A0
849C  05EE     DECF dt, W, BANKED
849E  E316     BNC 0x84CC
84A0  0100     MOVLB 0x0
84A2  51C8     MOVF pcs, W, BANKED
84A4  6FEC     MOVWF dt, BANKED
84A6  6BED     CLRF min, BANKED
84A8  1FEC     COMF dt, F, BANKED
84AA  1FED     COMF min, F, BANKED
84AC  4BEC     INFSNZ dt, F, BANKED
84AE  2BED     INCF min, F, BANKED
84B0  51F1     MOVF m, W, BANKED
84B2  6FEE     MOVWF dt, BANKED
84B4  6BEF     CLRF 0xEF, BANKED
84B6  51EC     MOVF dt, W, BANKED
84B8  27EE     ADDWF dt, F, BANKED
84BA  51ED     MOVF min, W, BANKED
84BC  23EF     ADDWFC 0xEF, F, BANKED
84BE  BFEF     BTFSC 0xEF, 7, BANKED
84C0  D002     BRA 0x84C6
84C2  D7A5     BRA 0x840E
84C4  D003     BRA 0x84CC
84C6  C0C8     MOVFF pcs, m
84C8  F0F1     NOP
84CA  D000     BRA 0x84CC
1076:                      if(cs > _NWCS5) cs = _NWCS5;
84CC  0E28     MOVLW 0x28
84CE  0100     MOVLB 0x0
84D0  65F1     CPFSGT m, BANKED
84D2  D002     BRA 0x84D8
84D4  6FF1     MOVWF m, BANKED
84D6  D000     BRA 0x84D8
1077:                  }
1078:                  pcs = cs;
84D8  C0F1     MOVFF m, pcs
84DA  F0C8     NOP
1079:                  DtCS.CS = cs;
84DC  C0F1     MOVFF m, DtCS
84DE  F0CB     NOP
1080:                  PFN.CS = DtCS.CS;
84E0  C0CB     MOVFF DtCS, 0x1E1
84E2  F1E1     NOP
1081:                  if(DtKNF.robg == _OTWARTY) //UniCo z ukladem otwartym?
84E4  0100     MOVLB 0x0
84E6  51A6     MOVF _mux, W, BANKED
84E8  E109     BNZ 0x84FC
1082:                  {
1083:                      //wylaczona detekcja niskiego cisnienia
1084:                      DtCSf_no = 0;
84EA  9C03     BCF DtCOf_su_SRW_CO, 6, ACCESS
1085:                      DtCSf_lo = 0;
84EC  9A03     BCF DtCOf_su_SRW_CO, 5, ACCESS
1086:                      if(DtCS.CS <= _ON2_WRK_CSN) DtCSf_work = 1;
84EE  0E1C     MOVLW 0x1C
84F0  0100     MOVLB 0x0
84F2  61CB     CPFSLT DtCS, BANKED
84F4  D021     BRA 0x8538
84F6  D01A     BRA 0x852C
1087:                      else
1088:                          if(DtCS.CS >= _OFF2_WRK_CSN) DtCSf_work = 0;
84F8  D01F     BRA 0x8538
1089:                  }
84FA  D024     BRA 0x8544
1090:                  else
1091:                  {
1092:                      //aktywna detekcja niskiego cisnienia
1093:                      if(DtCS.CS < _NO_CSN) DtCSf_no = 1; //brak wody w ukladzie?
84FC  0E03     MOVLW 0x3
84FE  0100     MOVLB 0x0
8500  61CB     CPFSLT DtCS, BANKED
8502  D002     BRA 0x8508
8504  8C03     BSF DtCOf_su_SRW_CO, 6, ACCESS
8506  D001     BRA 0x850A
1094:                      else DtCSf_no = 0;
8508  9C03     BCF DtCOf_su_SRW_CO, 6, ACCESS
1095:                      if(!DtCSf_no && DtCS.CS < _LO_CSN) DtCSf_lo = 1; //niskie cisnienie w ukladzie?
850A  BC03     BTFSC DtCOf_su_SRW_CO, 6, ACCESS
850C  D006     BRA 0x851A
850E  0E05     MOVLW 0x5
8510  0100     MOVLB 0x0
8512  61CB     CPFSLT DtCS, BANKED
8514  D002     BRA 0x851A
8516  8A03     BSF DtCOf_su_SRW_CO, 5, ACCESS
8518  D002     BRA 0x851E
1096:                      else DtCSf_lo = 0;
851A  9A03     BCF DtCOf_su_SRW_CO, 5, ACCESS
851C  D000     BRA 0x851E
1097:                      if((DtCS.CS >= _ON1_WRK_CSN) && (DtCS.CS <= _ON2_WRK_CSN)) DtCSf_work = 1;
851E  0E05     MOVLW 0x5
8520  0100     MOVLB 0x0
8522  65CB     CPFSGT DtCS, BANKED
8524  D005     BRA 0x8530
8526  0E1C     MOVLW 0x1C
8528  61CB     CPFSLT DtCS, BANKED
852A  D002     BRA 0x8530
852C  8004     BSF DtCWf_err_CW, 0, ACCESS
852E  D00A     BRA 0x8544
1098:                      else
1099:                          if((DtCS.CS <= _OFF1_WRK_CSN) || (DtCS.CS >= _OFF2_WRK_CSN)) DtCSf_work = 0;
8530  0E04     MOVLW 0x4
8532  0100     MOVLB 0x0
8534  65CB     CPFSGT DtCS, BANKED
8536  D004     BRA 0x8540
8538  0E1C     MOVLW 0x1C
853A  0100     MOVLB 0x0
853C  65CB     CPFSGT DtCS, BANKED
853E  D002     BRA 0x8544
8540  9004     BCF DtCWf_err_CW, 0, ACCESS
1100:                  }
8542  D000     BRA 0x8544
1101:                  if(DtCS.CS >= _ON_HI_CSN) DtCSf_hi = 1; //zbyt wysokie cisnienie?
8544  0E1C     MOVLW 0x1C
8546  0100     MOVLB 0x0
8548  65CB     CPFSGT DtCS, BANKED
854A  D002     BRA 0x8550
854C  8803     BSF DtCOf_su_SRW_CO, 4, ACCESS
854E  0C1C     RETLW 0x1C
1102:                  else DtCSf_hi = 0;
8550  9803     BCF DtCOf_su_SRW_CO, 4, ACCESS
8552  0012     RETURN 0
1103:              }
1104:          }
8554  0012     RETURN 0
1105:          /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/osc.c  -----------------------------------
1:             /*osc.c*/
2:             /*Konfiguracja wewnetrznego oscylatora*/
3:             //wersja takze dla procesorow serii K
4:             #include <pic18.h>
5:             #include "global.h"			//parametry globalne
6:             
7:             #if defined(_18F46K20) 
8:             
9:             void InitOsc(void)
10:            {
11:                IRCF2 = 1; //wewnetrzny oscylator ustawiony na 8MHz (K20)
F366  8CD3     BSF OSCCON, 6, ACCESS
12:                IRCF1 = 1;
F368  8AD3     BSF OSCCON, 5, ACCESS
13:                IRCF0 = 0;
F36A  98D3     BCF OSCCON, 4, ACCESS
14:                SCS1 = 0; //Primary clock (determined by CONFIG1H[FOSC<3:0>]).
F36C  92D3     BCF OSCCON, 1, ACCESS
15:                SCS0 = 0;
F36E  90D3     BCF OSCCON, 0, ACCESS
16:                /*	//USTAWIANY W MAIN.H JAKO RCIO
17:                        FOSC3=1;	//Internal oscillator block, port function on RA6 and RA7
18:                        FOSC2=0;
19:                        FOSC1=0;
20:                        FOSC0=0;
21:                 */
22:            #if _PLL!=0
23:                PLLEN = 1; //zalacz petle PLLx4
F370  8C9B     BSF OSCTUNE, 6, ACCESS
24:            #else
25:                PLLEN = 0; //wylacz petle PLLx4
26:            #endif
27:            }
F372  0012     RETURN 0
28:            #else
29:            
30:            void InitOsc(void)
31:            {
32:                IRCF0 = 1; //wewnetrzny oscylator ustawiony na 8MHz
33:                IRCF1 = 1;
34:                IRCF2 = 1;
35:            #if _PLL!=0
36:                PLLEN = 1; //zalacz petle x4
37:            #else
38:                PLLEN = 0; //wylacz petle x4
39:            #endif
40:            }
41:            #endif
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/main.c  ----------------------------------
1:             /*main.c*/
2:             /*Oprogramowanie rodziny sterownikow T02 (na bazie p?ytki UNI-02) z interfejsem LED*/
3:             /*dodana funkcja modulacja pwm obrotow pompy, pomiar temp wlotowej 08.03.2013*/
4:             /*	14.04.2015
5:              poprawki:
6:                     brak autowylaczenia funkcji serwisowej
7:                     brak autowylaczenia f.antylegionella w trybie manual (kotly UNICO)
8:                     poprawiona wizualizacja wybranego trybu pracy na I2C
9:              nowe:
10:            	temp CO dla kotlow monoterm. zmienione na 89C
11:            	wprowadzone podbicie mocy minimalnej po procedurze startowej
12:            	maksymalny czas trwania funkcji serwisowej zmieniony na 60 min
13:                    i2c pokazuje rzeczywista docelowa temp PPCO i PPCW
14:                    powiekszona histereza przy grzaniu CO (+10)
15:                    poprawiona proc GoldenEye dla wiekszej histerezy wylaczenia przy grzaniu CO
16:            */
17:            #include <pic18.h>
18:            #include <htc.h>
19:            #include <stdio.h>
20:            #include <string.h>
21:            #include "global.h"			//parametry globalne
22:            #include "main.h"			//parametry lokalne
23:            #include "wsw.h"
24:            #include "print.h"
25:            #include "eeprom.h"
26:            #include "pwm.h"
27:            #include "czcw.tp.h"
28:            #include "pomiar.h"
29:            
30:            #include "keypad.h"
31:            #include "konfig2.h"
32:            #include "pompa.tp.h"
33:            #include "rgl.h"
34:            
35:            //tpRSDTA1 RSDT1;
36:            volatile tpMAIN M;
37:            volatile DataPFN PFN;
38:            unsigned char zps, zmn;  
39:            
40:            extern DtPMP PMP; //pompa.c
41:            extern DtPWM PWM; //pwm.c
42:            extern DataPrCW PrCW; //czcw.c
43:            extern DataCO DtCO; //pomiar.c
44:            extern DataCW DtCW;
45:            extern DataZW DtZW;
46:            //extern DataPFN PFN;
47:            extern DataCSN DtCS;
48:            extern DataIN DtIN;
49:            extern DtKONF DtKNF;
50:            
51:            
52:            extern DtRgl rgl;
53:            volatile unsigned char x,xj;
54:            extern StPin sp;
55:            //extern unsigned char xxy, zzz, vvv;
56:            #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
57:            extern unsigned char mypwm;
58:            #endif
59:            
60:            void main(void)
61:            {
62:                //------------------
63:                //------------------
64:                InitOsc();
8E3C  ECB3     CALL 0xF366, 0
8E3E  F079     NOP
65:                InitGlobal();
8E40  ECEE     CALL 0xF3DC, 0
8E42  F079     NOP
66:                InitTimer1();
8E44  EC00     CALL 0xE400, 0
8E46  F072     NOP
67:                InitPort();
8E48  ECEA     CALL 0xEDD4, 0
8E4A  F076     NOP
68:                InitAC();
8E4C  ECAE     CALL 0xED5C, 0
8E4E  F076     NOP
69:                InitWsw();
8E50  EC97     CALL 0xB92E, 0
8E52  F05C     NOP
70:                InitPWM();
8E54  EC19     CALL 0xE832, 0
8E56  F074     NOP
71:                InitI2C();
8E58  EC46     CALL 0xEC8C, 0
8E5A  F076     NOP
72:                InitUart();
8E5C  ECE1     CALL 0xE7C2, 0
8E5E  F073     NOP
73:                InitDataPmr();
8E60  EC37     CALL 0xE66E, 0
8E62  F073     NOP
74:                ClearData();
8E64  EC1D     CALL 0xC83A, 0
8E66  F064     NOP
75:            
76:                //------------------
77:                //------------------
78:                if(!POR || !BOR) //zalaczono zasilanie?
8E68  A2D0     BTFSS RCON, 1, ACCESS
8E6A  D002     BRA 0x8E70
8E6C  B0D0     BTFSC RCON, 0, ACCESS
8E6E  D008     BRA 0x8E80
79:                {
80:                    Mf_PW_START = 1; //znacznik rozruchu sterownika po wlaczeniu zasilania
8E70  8E07     BSF Mf_BLOKUJ_3M, 7, ACCESS
81:                    TestScr(); //wysterowanie wszystkich segmentow wyswietlacza
8E72  ECFD     CALL 0xE5FA, 0
8E74  F072     NOP
82:                    PwrOnDelay(); //zwloka na wypadek stanow nieustalonych
8E76  ECB2     CALL 0xDB64, 0
8E78  F06D     NOP
83:                    EndTestScr(); //wyjdz z trybu wysterowania wszystkich segmentow wyswietlacza
8E7A  EC54     CALL 0xE6A8, 0
8E7C  F073     NOP
84:                }
8E7E  D008     BRA 0x8E90
85:                else
86:                {
87:                    Mf_RS_START = 1; //znacznik rozruchu sterownika po resecie
8E80  8408     BSF Mf_ROZRUCH, 2, ACCESS
88:                    ClsScr(); //wygas wyswietlacz
8E82  EC0C     CALL 0xF418, 0
8E84  F07A     NOP
89:                    PwrOnDelay(); //zwloka na wypadek stanow nieustalonych
8E86  ECB2     CALL 0xDB64, 0
8E88  F06D     NOP
90:                    EndClsScr(); //zapal wyswietlacz
8E8A  ECDC     CALL 0xF3B8, 0
8E8C  F079     NOP
8E8E  D000     BRA 0x8E90
91:                }
92:                //Odczytaj parametry zapisane w pamieci EEPROM
93:                RdEEParam();
8E90  EC36     CALL 0xA66C, 0
8E92  F053     NOP
94:            
95:                //Stan po zalaczeniu zasilania - warunek wejscia do trybu konfiguracji
96:                if(!POR || !BOR) //zalaczono zasilanie?
8E94  A2D0     BTFSS RCON, 1, ACCESS
8E96  D002     BRA 0x8E9C
8E98  B0D0     BTFSC RCON, 0, ACCESS
8E9A  D005     BRA 0x8EA6
97:                {
98:                    POR = 1;
8E9C  82D0     BSF RCON, 1, ACCESS
99:                    BOR = 1;
8E9E  80D0     BSF RCON, 0, ACCESS
100:                   EnKonf(); //aktywacja oczekiwania na wejscie do konfiguracji
8EA0  ECC9     CALL 0xF192, 0
8EA2  F078     NOP
8EA4  D000     BRA 0x8EA6
101:               }
102:               //ustaw znacznik aktualnego obiegu
103:               _POMPA = 0;
8EA6  9483     BCF PORTD, 2, ACCESS
104:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
8EA8  D009     BRA 0x8EBC
8EBC  0100     MOVLB 0x0
8EBE  519E     MOVF _PWMf_ENPWM2, W, BANKED
8EC0  E0F7     BZ 0x8EB0
8EC2  0A01     XORLW 0x1
8EC4  E0F2     BZ 0x8EAA
8EC6  0A03     XORLW 0x3
8EC8  E0F0     BZ 0x8EAA
8ECA  0A01     XORLW 0x1
8ECC  D7F1     BRA 0x8EB0
105:               {
106:                   case _BITERM: //bitermiczny (miniterm)
107:                   case _BITERM2: //bitermiczny (maxiterm)
108:                   {
109:                       Mf_RPM_CW = !_POMPA;
8EAA  B483     BTFSC PORTD, 2, ACCESS
8EAC  D005     BRA 0x8EB8
8EAE  D002     BRA 0x8EB4
110:                       break;
111:                   }
112:                   case _UNICO:
113:                   case _MONOHB:
114:                   {
115:                       Mf_RPM_CW = !_KCO_CW;
116:                       break;
117:                   }
118:                   default: //domyslny monotermiczny
119:                   {
120:                       Mf_RPM_CW = !_KCO_CW;
8EB0  B283     BTFSC PORTD, 1, ACCESS
8EB2  D002     BRA 0x8EB8
8EB4  8208     BSF Mf_ROZRUCH, 1, ACCESS
8EB6  D00B     BRA 0x8ECE
8EB8  9208     BCF Mf_ROZRUCH, 1, ACCESS
121:                       break;
122:                   }
123:               }
8EBA  D009     BRA 0x8ECE
124:           
125:               //Sprawd? czy nastapilo wylaczenie awaryjne z blokada
126:               if(M.ERR_BTY = eeprom_read(_ADRERR)) //uruchomienie po wylaczeniu awaryjnym?
8ECE  0100     MOVLB 0x0
8ED0  6BDF     CLRF pco, BANKED
8ED2  0EC0     MOVLW 0xC0
8ED4  6FDE     MOVWF __pcstackBANK0, BANKED
8ED6  EC2E     CALL 0xF05C, 0
8ED8  F078     NOP
8EDA  0100     MOVLB 0x0
8EDC  6F87     MOVWF _PFNf_pgd, BANKED
8EDE  5187     MOVF _PFNf_pgd, W, BANKED
8EE0  E01B     BZ 0x8F18
127:               {
128:                   if(DtKNF.robg == _OTWARTY) //obieg otwarty?
8EE2  51A6     MOVF _mux, W, BANKED
8EE4  E109     BNZ 0x8EF8
129:                   {
130:                       if(M.ERR_BTY == 5) //dozwolony kod bledu?
8EE6  0E05     MOVLW 0x5
8EE8  1987     XORWF _PFNf_pgd, W, BANKED
8EEA  E106     BNZ 0x8EF8
131:                       {
132:                           SetErr(M.ERR_BTY);//PrintErr(M.ERR_BTY, 1); //wyswietl kod bledu
8EEC  5187     MOVF _PFNf_pgd, W, BANKED
8EEE  ECC7     CALL 0xF38E, 0
8EF0  F079     NOP
133:                           ErrPTG(); //przejdz do petli wylaczenia awaryjnego
8EF2  ECCC     CALL 0x8798, 0
8EF4  F043     NOP
134:                       }
8EF6  D000     BRA 0x8EF8
135:                   }
136:                   if((M.ERR_BTY >= 1) && (M.ERR_BTY <= 3)) //dozwolony kod bledu?
8EF8  0100     MOVLB 0x0
8EFA  5187     MOVF _PFNf_pgd, W, BANKED
8EFC  E009     BZ 0x8F10
8EFE  0E04     MOVLW 0x4
8F00  6187     CPFSLT _PFNf_pgd, BANKED
8F02  D006     BRA 0x8F10
137:                   {
138:                       SetErr(M.ERR_BTY);//PrintErr(M.ERR_BTY, 1); //wyswietl kod bledu
8F04  5187     MOVF _PFNf_pgd, W, BANKED
8F06  ECC7     CALL 0xF38E, 0
8F08  F079     NOP
139:                       ErrPTG(); //przejdz do petli wylaczenia awaryjnego
8F0A  ECCC     CALL 0x8798, 0
8F0C  F043     NOP
140:                   }
8F0E  D004     BRA 0x8F18
141:                   else M.ERR_BTY = 0;
8F10  0E00     MOVLW 0x0
8F12  0100     MOVLB 0x0
8F14  6F87     MOVWF _PFNf_pgd, BANKED
8F16  D000     BRA 0x8F18
142:               }
143:           
144:               //Pomiar wartosci nastaw dla unikniecia migajacej nastawy po zal. zasilania
145:               PomiarCO(); //wartosc temperatury CO
8F18  EC03     CALL 0x3806, 0
8F1A  F01C     NOP
146:               PomiarCW(); //wartosc temperatury CW
8F1C  ECF5     CALL 0xA7EA, 0
8F1E  F053     NOP
147:               PomiarZW(); //temperatura z czujnika zewnetrznego
8F20  EC1B     CALL 0xEC36, 0
8F22  F076     NOP
148:               PomiarCS(); //wartosc cisnienia w instalacji CO
8F24  EC88     CALL 0x8310, 0
8F26  F041     NOP
149:               PomiarPCO(); //wartosc nastawy CO
8F28  EC8A     CALL 0xC714, 0
8F2A  F063     NOP
150:               PomiarPCW(); //wartosc nastawy CW
8F2C  EC65     CALL 0xC8CA, 0
8F2E  F064     NOP
151:               PomiarPFN(); //stan przelacznika funkcji
8F30  EC35     CALL 0xE26A, 0
8F32  F071     NOP
152:               PomiarIN(); //wartosc temperatury na powrocie
8F34  EC1B     CALL 0xEA36, 0
8F36  F075     NOP
153:               DtCOf_newPCO = 0; //deaktywacja wyswietlania nastawy CO
8F38  9402     BCF DtCOf_su_CO, 2, ACCESS
154:               DtCWf_newPCW = 0; //deaktywacja wyswietlania nastawy CW
8F3A  9C04     BCF DtCWf_err_CW, 6, ACCESS
155:               RefInterfaceData(); //aktualizacja danych na potrzeby interfejsu uzytkownika
8F3C  EC47     CALL 0xB08E, 0
8F3E  F058     NOP
156:               //deaktywacja pobudzen
157:               _VNT = 0; //wentylator na stale wylaczony
8F40  9683     BCF PORTD, 3, ACCESS
158:               _GRZEJ = 0;
8F42  9083     BCF PORTD, 0, ACCESS
159:           
160:               //decyzja czy kociol jest typu TURBO
161:               Mf_TURBO = !RdPrt(S_CIG_NC) || RdPrt(S_CIG_NO);
8F44  0E02     MOVLW 0x2
8F46  ECFD     CALL 0xE7FA, 0
8F48  F073     NOP
8F4A  E306     BNC 0x8F58
8F4C  0E03     MOVLW 0x3
8F4E  ECFD     CALL 0xE7FA, 0
8F50  F073     NOP
8F52  E202     BC 0x8F58
8F54  940A     BCF Mf_pob_AL, 2, ACCESS
8F56  D002     BRA 0x8F5C
8F58  840A     BSF Mf_pob_AL, 2, ACCESS
8F5A  D000     BRA 0x8F5C
162:               RestartFltPrt();
8F5C  EC87     CALL 0xDB0E, 0
8F5E  F06D     NOP
163:               StartRTS(_RTSTR); //start timera rozruchu sterownika
8F60  0E08     MOVLW 0x8
8F62  EC60     CALL 0xE4C0, 0
8F64  F072     NOP
164:               //------------------
165:               //------------------
166:               //------------------
167:               DtCW.PCW = 65;
8F66  0E41     MOVLW 0x41
8F68  0100     MOVLB 0x0
8F6A  6FAB     MOVWF _rglf_fast_up, BANKED
168:               DtCO.PCO = 85;
8F6C  0E55     MOVLW 0x55
8F6E  0100     MOVLB 0x0
8F70  6FD0     MOVWF 0xD0, BANKED
169:               //------------------
170:               //------------------
171:               WritePWM2(0);
8F72  0E00     MOVLW 0x0
8F74  EC6D     CALL 0xF2DA, 0
8F76  F079     NOP
172:               while(1) //petla glowna programu
905C  D78D     BRA 0x8F78
173:               {
174:                   CLRWDT();
8F78  0004     CLRWDT
175:                   PFNf_opgprg = 1;
8F7A  8A10     BSF PFNf_ofnserw, 5, ACCESS
176:                   PFNf_opgres = 0;
8F7C  9C10     BCF PFNf_ofnserw, 6, ACCESS
177:           
178:                   //BitSet2(&RSDT1.outSTAT0,_PGPRG,1);		//znacznik petli programu
179:                   //BitSet2(&RSDT1.outSTAT0,_PGRES,0);
180:                   Mf_PRACA = Mf_ROZRUCH || _GRZEJ;
8F7E  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
8F80  B083     BTFSC PORTD, 0, ACCESS
8F82  D002     BRA 0x8F88
8F84  9C07     BCF Mf_BLOKUJ_3M, 6, ACCESS
8F86  D002     BRA 0x8F8C
8F88  8C07     BSF Mf_BLOKUJ_3M, 6, ACCESS
8F8A  D000     BRA 0x8F8C
181:           
182:                   //----------------
183:                   RefInterfaceData(); //aktualizacja danych na potrzeby interfejsu uzytkownika
8F8C  EC47     CALL 0xB08E, 0
8F8E  F058     NOP
184:                   TrybPracy();
8F90  ECC1     CALL 0x2382, 0
8F92  F011     NOP
185:                   RefInterfaceData(); //aktualizacja danych na potrzeby interfejsu uzytkownika
8F94  EC47     CALL 0xB08E, 0
8F96  F058     NOP
186:                   MKonfiguracja();		//sterowanie znacznikiem mozliwosci wejscia do proc. konfiguracji
8F98  ECCB     CALL 0x2996, 0
8F9A  F014     NOP
187:                   //----------------
188:                   PomiarPCO(); //wartosc nastawy CO
8F9C  EC8A     CALL 0xC714, 0
8F9E  F063     NOP
189:                   PomiarPCW(); //wartosc nastawy CW
8FA0  EC65     CALL 0xC8CA, 0
8FA2  F064     NOP
190:                   PomiarPFN(); //stan przelacznika funkcji
8FA4  EC35     CALL 0xE26A, 0
8FA6  F071     NOP
191:                   PomiarCO(); //wartosc temperatury CO
8FA8  EC03     CALL 0x3806, 0
8FAA  F01C     NOP
192:                   PomiarCW(); //wartosc temperatury CW
8FAC  ECF5     CALL 0xA7EA, 0
8FAE  F053     NOP
193:                   PomiarZW(); //temperatura z czujnika zewnetrznego
8FB0  EC1B     CALL 0xEC36, 0
8FB2  F076     NOP
194:                   FiltrPomiarowyCOCW(); //filtr danych opisujacych stan temperatur
8FB4  ECD5     CALL 0xC7AA, 0
8FB6  F063     NOP
195:                   PomiarCS(); //wartosc cisnienia w instalacji CO
8FB8  EC88     CALL 0x8310, 0
8FBA  F041     NOP
196:                   PomiarIN(); //wartosc temperatury na powrocie
8FBC  EC1B     CALL 0xEA36, 0
8FBE  F075     NOP
197:                   //----------------
198:                   DecWSW(); //wyswietlane parametry pracy
8FC0  EC46     CALL 0x488C, 0
8FC2  F024     NOP
199:                   DecERR(); //stany awaryjne, wyswietlane kody awaryjne
8FC4  EC31     CALL 0x5E62, 0
8FC6  F02F     NOP
200:                   DecSTR(); //dodatkowe decyzje sterowania
8FC8  ECEF     CALL 0x57DE, 0
8FCA  F02B     NOP
201:                   DecRozruch(); //decyzja o zapaleniu palnika
8FCC  EC44     CALL 0x9288, 0
8FCE  F049     NOP
202:                   DecWylacz(); //decyzja o wygaszeniu palnika
8FD0  ECDD     CALL 0x67BA, 0
8FD2  F033     NOP
203:                   FunkcjaSerwisowa(); //decyzja o realizacji funkcji serwisowej
8FD4  EC9E     CALL 0xD53C, 0
8FD6  F06A     NOP
204:                   DecyzjaAntyLeg(); //decyzja o realizacji funkcji ANTYLEGIONELLA
8FD8  ECDA     CALL 0xB1B4, 0
8FDA  F058     NOP
205:                   KolejkaPobudzen(); //aktywacja pobudzen wg priorytetu
8FDC  EC84     CALL 0xAD08, 0
8FDE  F056     NOP
206:           
207:                   //----------------
208:                   RglPmp(); //dla pompy PWM reguluj predkosc obrotowa
8FE0  EC1A     CALL 0xE634, 0
8FE2  F073     NOP
209:                   if(Mf_ZMKCOCW) ZmienKCOKCW(); //zmiana kierunku obrotu pompy
8FE4  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8FE6  ECA4     CALL 0xA948, 0
8FE8  F054     NOP
8FEA  D000     BRA 0x8FEC
210:                   if(Mf_WYLACZ) Wylacz(); //kontrola wybiegu pompy
8FEC  B80A     BTFSC Mf_pob_AL, 4, ACCESS
8FEE  EC51     CALL 0x64A2, 0
8FF0  F032     NOP
8FF2  D000     BRA 0x8FF4
211:                   if(Mf_ROZRUCH) Rozruch(); //rozruch kotla
8FF4  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
8FF6  ECD5     CALL 0x73AA, 0
8FF8  F039     NOP
8FFA  D000     BRA 0x8FFC
212:                   if(Mf_VWYBIEG) VWybieg(); //wybieg wentylatora
8FFC  B60A     BTFSC Mf_pob_AL, 3, ACCESS
8FFE  EC7C     CALL 0xCEF8, 0
9000  F067     NOP
213:                   ReloadPlomien(); //decyzja o wyzerowaniu licznika prob przy braku plomienia
9002  EC9A     CALL 0xED34, 0
9004  F076     NOP
214:                   if(Mf_RUSZ_PLOMIEN) RuszPlomien(); //awaryjna procedura przy braku plomienia
9006  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
9008  EC3F     CALL 0xCE7E, 0
900A  F067     NOP
215:                   ReloadCiag(); //zerowanie licznika ponowien prob ciagu
900C  ECDC     CALL 0xDDB8, 0
900E  F06E     NOP
216:                   if(Mf_RUSZ_CIAG) RuszCiag(); //awaryjna procedura przy braku ciagu
9010  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
9012  ECCB     CALL 0xA196, 0
9014  F050     NOP
9016  D000     BRA 0x9018
217:                   Proba48(); //zegar 48h
9018  ECE9     CALL 0xE9D2, 0
901A  F074     NOP
218:                   if(Mf_RUSZ_48) Rusz48(); //wybieg pompy co 48h
901C  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
901E  EC6C     CALL 0xB2D8, 0
9020  F059     NOP
219:                   Proba48Z3(); //zegar 48h dla Z3Dr
9022  ECEE     CALL 0xDFDC, 0
9024  F06F     NOP
220:                   if(Mf_RUSZ_48Z3) Rusz48Z3(); //wybieg pompy co 48h w obiegu WU
9026  BA08     BTFSC Mf_ROZRUCH, 5, ACCESS
9028  ECA1     CALL 0xD942, 0
902A  F06C     NOP
902C  D000     BRA 0x902E
221:                   if(Mf_BLOKUJ_3M) BlokadaL3(); //blokada 3 minuty
902E  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
9030  ECA4     CALL 0xD748, 0
9032  F06B     NOP
9034  D000     BRA 0x9036
222:                   if(Mf_BLOKUJ_15S)
9036  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
223:                   {
224:                       if(!Mf_PRACA) Blokada15S(); //blokada 15 sekund
9038  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
903A  D003     BRA 0x9042
903C  ECD2     CALL 0xD9A4, 0
903E  F06C     NOP
9040  D000     BRA 0x9042
225:                   }
226:                   if(Mf_MODULUJ) Moduluj(); //algorytm modulacji
9042  B807     BTFSC Mf_BLOKUJ_3M, 4, ACCESS
9044  ECC4     CALL 0x6188, 0
9046  F030     NOP
9048  D000     BRA 0x904A
227:                   if(DtKNF.robg == _OTWARTY) //uklad z obiegiem otwartym?
904A  0100     MOVLB 0x0
904C  51A6     MOVF _mux, W, BANKED
904E  E194     BNZ 0x8F78
228:                   {
229:                       DetekcjaPrzeplywuWG(); //kontrola nieprawidlowosci przeplywu wody grzewczej
9050  ECF1     CALL 0xC5E2, 0
9052  F062     NOP
230:                       if(Mf_RUSZ_POMPE) OczekujNaPrzeplywWG(); //oczekiwanie na powrot czujnika do prawidlowej pozycji
9054  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
9056  D790     BRA 0x8F78
9058  EC33     CALL 0xD066, 0
905A  F068     NOP
231:                   }
232:               }
233:           }
905E  EF70     GOTO 0xE0
234:           //------------------
235:           //------------------
236:           //------------------
237:           //Wyzerowanie podstawowych danych sterujacych
238:           
239:           void ClearData(void)
240:           {
241:               DtKNFf_enknf = 0;
C83A  9E05     BCF DtKNFf_enknf, 7, ACCESS
242:               Mf_pob_KCO = 0;
C83C  960B     BCF Mf_pob_KCO, 3, ACCESS
243:               Mf_pob_KCW = 0;
C83E  980B     BCF Mf_pob_KCO, 4, ACCESS
244:               Mf_pob_AL = 0;
C840  9C0A     BCF Mf_pob_AL, 6, ACCESS
245:               Mf_pob_SRW = 0;
C842  9A0B     BCF Mf_pob_KCO, 5, ACCESS
246:               Mf_pob_CO = 0;
C844  9E0A     BCF Mf_pob_AL, 7, ACCESS
247:               Mf_pob_CW = 0;
C846  900B     BCF Mf_pob_KCO, 0, ACCESS
248:               Mf_pob_DzCO = 0;
C848  920B     BCF Mf_pob_KCO, 1, ACCESS
249:               Mf_pob_DzCW = 0;
C84A  940B     BCF Mf_pob_KCO, 2, ACCESS
250:           
251:               Mf_WYLACZ = 0;
C84C  980A     BCF Mf_pob_AL, 4, ACCESS
252:               Mf_ZMKCOCW = 0;
C84E  9A0A     BCF Mf_pob_AL, 5, ACCESS
253:               Mf_ROZRUCH = 0;
C850  9008     BCF Mf_ROZRUCH, 0, ACCESS
254:               Mf_RUSZ_48 = 0;
C852  9808     BCF Mf_ROZRUCH, 4, ACCESS
255:               Mf_RUSZ_48Z3 = 0;
C854  9A08     BCF Mf_ROZRUCH, 5, ACCESS
256:               Mf_RUSZ_PWR = 0;
C856  9E09     BCF Mf_RUSZ_PWR, 7, ACCESS
257:               Mf_VWYBIEG = 0;
C858  960A     BCF Mf_pob_AL, 3, ACCESS
258:               Mf_MODULUJ = 0;
C85A  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
259:               Mf_RUSZ_CIAG = 0;
C85C  9C08     BCF Mf_ROZRUCH, 6, ACCESS
260:               Mf_RUSZ_PLOMIEN = 0;
C85E  9A09     BCF Mf_RUSZ_PWR, 5, ACCESS
261:               Mf_RUSZ_RPLM = 0;
C860  900A     BCF Mf_pob_AL, 0, ACCESS
262:               Mf_RUSZ_POMPE = 0;
C862  9C09     BCF Mf_RUSZ_PWR, 6, ACCESS
263:               Mf_BLOKUJ_3M = 0;
C864  9007     BCF Mf_BLOKUJ_3M, 0, ACCESS
264:               Mf_BLOKUJ_15S = 0;
C866  9E06     BCF DtKNFf_wymCO, 7, ACCESS
265:               Mf_MODULUJ = 0;
C868  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
266:           
267:               Mf_AKTYWNE_AL = 0;
C86A  9606     BCF DtKNFf_wymCO, 3, ACCESS
268:               Mf_AKTYWNE_SRW = 0;
C86C  9C06     BCF DtKNFf_wymCO, 6, ACCESS
269:               Mf_AKTYWNE_PGD = 0;
C86E  9A06     BCF DtKNFf_wymCO, 5, ACCESS
270:               Mf_AKTYWNE_KNF = 0;
C870  9806     BCF DtKNFf_wymCO, 4, ACCESS
271:               Mf_RUSZ_NTC_CO = 0;
C872  9409     BCF Mf_RUSZ_PWR, 2, ACCESS
272:               Mf_RUSZ_NTC_CW = 0;
C874  9609     BCF Mf_RUSZ_PWR, 3, ACCESS
273:               Mf_RUSZ_STB = 0;
C876  920A     BCF Mf_pob_AL, 1, ACCESS
274:               Mf_RUSZ_MOD = 0;
C878  9009     BCF Mf_RUSZ_PWR, 0, ACCESS
275:               Mf_RUSZ_CISN = 0;
C87A  9E08     BCF Mf_ROZRUCH, 7, ACCESS
276:               Mf_RUSZ_NCISN = 0;
C87C  9209     BCF Mf_RUSZ_PWR, 1, ACCESS
277:           
278:               Mf_PW_START = 0;
C87E  9E07     BCF Mf_BLOKUJ_3M, 7, ACCESS
279:               Mf_RS_START = 0;
C880  9408     BCF Mf_ROZRUCH, 2, ACCESS
280:               Mf_TURBO = 0;
C882  940A     BCF Mf_pob_AL, 2, ACCESS
281:               Mf_PRACA = 0;
C884  9C07     BCF Mf_BLOKUJ_3M, 6, ACCESS
282:               Mf_OST_PL = 0;
C886  9A07     BCF Mf_BLOKUJ_3M, 5, ACCESS
283:               Mf_RUN_MNMOD = 0;
C888  9608     BCF Mf_ROZRUCH, 3, ACCESS
284:               Mf_KCW_PMP = 0;
C88A  9607     BCF Mf_BLOKUJ_3M, 3, ACCESS
285:               Mf_DE_VNT = 0;
C88C  9407     BCF Mf_BLOKUJ_3M, 2, ACCESS
286:               Mf_DE_PMP = 0;
C88E  9207     BCF Mf_BLOKUJ_3M, 1, ACCESS
287:               Mf_RPM_CW = 0;
C890  9208     BCF Mf_ROZRUCH, 1, ACCESS
288:               Mf_RUSZ_NTC_IN = 0;
C892  9809     BCF Mf_RUSZ_PWR, 4, ACCESS
289:           
290:               M.ERR_BTY = 0;
C894  0E00     MOVLW 0x0
C896  0100     MOVLB 0x0
C898  6B87     CLRF _PFNf_pgd, BANKED
291:               M.ROZ = 0;
C89A  6B88     CLRF _PFNf_plmCO, BANKED
292:               M.R48 = 0;
C89C  6B89     CLRF _PFNf_plmCW, BANKED
293:               M.R48Z3 = 0;
C89E  6B8A     CLRF _PFNf_pmpPWM, BANKED
294:               M.BL3 = 0;
C8A0  6B8B     CLRF _PFNf_prn_cs, BANKED
295:               M.BL15 = 0;
C8A2  6B8C     CLRF _PFNf_prn_in, BANKED
296:               M.WYL = 0;
C8A4  6B8D     CLRF _PFNf_prn_res, BANKED
297:               M.RPR = 0;
C8A6  6B8E     CLRF _PFNf_prnaleg, BANKED
298:               M.RPL = 0;
C8A8  6B8F     CLRF _PFNf_prnserw, BANKED
299:               M.RCI = 0;
C8AA  6B90     CLRF _PFNf_res, BANKED
300:               M.MNM = 0;
C8AC  6B91     CLRF _PFNf_set_aleg, BANKED
301:               M.ZKP = 0;
C8AE  6B92     CLRF _PFNf_set_fnserw, BANKED
302:               M.VWB = 0;
C8B0  6B93     CLRF _PFNf_set_nco, BANKED
303:               M.SRV = 0;
C8B2  6B94     CLRF _PFNf_set_ncw, BANKED
304:               M.KRS = 0;
C8B4  6B95     CLRF _PFNf_str_nco, BANKED
305:               M.HVZ = 0;
C8B6  6B96     CLRF _PFNf_str_ncw, BANKED
306:               M.LICZNIK_PL = 0;
C8B8  6B82     CLRF M, BANKED
307:               M.LICZNIK_CIG = 0;
C8BA  6B83     CLRF _PFNf_ofzima, BANKED
308:               M.LICZNIK_CIG2 = 0;
C8BC  6B84     CLRF _PFNf_opKNF, BANKED
309:               M.LICZNIK_CIG3 = 0;
C8BE  6B85     CLRF _PFNf_opgprg, BANKED
310:               M.DPR = 0;
C8C0  6B97     CLRF _PFNf_tdzCO, BANKED
311:           
312:               _VNT = 0;
C8C2  9683     BCF PORTD, 3, ACCESS
313:               _GRZEJ = 0;
C8C4  9083     BCF PORTD, 0, ACCESS
314:               _POMPA = 0;
C8C6  9483     BCF PORTD, 2, ACCESS
315:           }
C8C8  0012     RETURN 0
316:           //------------------
317:           
318:           void RestartFltPrt(void)
319:           {
320:               SetPrt(S_ON_PMP, 0);
DB0E  0E00     MOVLW 0x0
DB10  0100     MOVLB 0x0
DB12  6FDE     MOVWF __pcstackBANK0, BANKED
DB14  0E0D     MOVLW 0xD
DB16  EC01     CALL 0xDA02, 0
DB18  F06D     NOP
321:               SetPrt(S_ON_PMP_CW, 0);
DB1A  0E00     MOVLW 0x0
DB1C  0100     MOVLB 0x0
DB1E  6FDE     MOVWF __pcstackBANK0, BANKED
DB20  0E11     MOVLW 0x11
DB22  EC01     CALL 0xDA02, 0
DB24  F06D     NOP
322:               SetPrt(S_DZ_CO, 0);
DB26  0E00     MOVLW 0x0
DB28  0100     MOVLB 0x0
DB2A  6FDE     MOVWF __pcstackBANK0, BANKED
DB2C  0E09     MOVLW 0x9
DB2E  EC01     CALL 0xDA02, 0
DB30  F06D     NOP
323:               SetPrt(S_DZ_CW, 0);
DB32  0E00     MOVLW 0x0
DB34  0100     MOVLB 0x0
DB36  6FDE     MOVWF __pcstackBANK0, BANKED
DB38  0E0A     MOVLW 0xA
DB3A  EC01     CALL 0xDA02, 0
DB3C  F06D     NOP
324:               SetPrt(S_RT, 0);
DB3E  0E00     MOVLW 0x0
DB40  0100     MOVLB 0x0
DB42  6FDE     MOVWF __pcstackBANK0, BANKED
DB44  0E0C     MOVLW 0xC
DB46  EC01     CALL 0xDA02, 0
DB48  F06D     NOP
325:               SetPrt(S_WCW, 0);
DB4A  0E00     MOVLW 0x0
DB4C  0100     MOVLB 0x0
DB4E  6FDE     MOVWF __pcstackBANK0, BANKED
DB50  0E0B     MOVLW 0xB
DB52  EC01     CALL 0xDA02, 0
DB54  F06D     NOP
326:               SetPrt(S_HVZ, 0);
DB56  0E00     MOVLW 0x0
DB58  0100     MOVLB 0x0
DB5A  6FDE     MOVWF __pcstackBANK0, BANKED
DB5C  0E07     MOVLW 0x7
DB5E  EC01     CALL 0xDA02, 0
DB60  F06D     NOP
327:           }
DB62  0012     RETURN 0
328:           //------------------
329:           //------------------
330:           
331:           unsigned char KodSterownika(void)
332:           {
333:               //Kod sterownika
334:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
335:               {
336:                   case _UNICO: //unico - monotermiczny
337:                       if(!Mf_TURBO) return 0x10;
338:                       else return 0x11;
339:                   case _BITERM: //bitermiczny (miniterm)
340:                       if(!Mf_TURBO) return 0x12;
341:                       else return 0x13;
342:                   case _BITERM2: //bitermiczny (maksiterm)
343:                       if(!Mf_TURBO) return 0x14;
344:                       else return 0x15;
345:                   case _MONOHB: //monotermiczny z hydroblokiem
346:                       if(!Mf_TURBO) return 0x16;
347:                       else return 0x17;
348:                   default: //domyslny monotermiczny z hydroblokiem
349:                       if(!Mf_TURBO) return 0x18;
350:                       else return 0x19;
351:               }
352:           }
353:           
354:           
355:           //------------------
356:           //------------------
357:           //Aktualizacja danych do wysylki
358:           
359:           void RefInterfaceData(void)
360:           {
361:               PFNf_EnAleg = (DtKNF.tpkt == _UNICO);
B08E  0100     MOVLB 0x0
B090  519E     MOVF _PWMf_ENPWM2, W, BANKED
B092  E102     BNZ 0xB098
B094  800C     BSF PFNf_b_set_nco, 0, ACCESS
B096  D001     BRA 0xB09A
B098  900C     BCF PFNf_b_set_nco, 0, ACCESS
362:               PFNf_plmCO = Mf_PRACA && !Mf_RPM_CW && RdPrt(S_PLM);
B09A  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
B09C  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
B09E  D006     BRA 0xB0AC
B0A0  0E05     MOVLW 0x5
B0A2  ECFD     CALL 0xE7FA, 0
B0A4  F073     NOP
B0A6  E302     BNC 0xB0AC
B0A8  8011     BSF PFNf_prn_res, 0, ACCESS
B0AA  D001     BRA 0xB0AE
B0AC  9011     BCF PFNf_prn_res, 0, ACCESS
363:               PFNf_plmCW = Mf_PRACA && Mf_RPM_CW && RdPrt(S_PLM);
B0AE  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
B0B0  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
B0B2  D006     BRA 0xB0C0
B0B4  0E05     MOVLW 0x5
B0B6  ECFD     CALL 0xE7FA, 0
B0B8  F073     NOP
B0BA  E302     BNC 0xB0C0
B0BC  8211     BSF PFNf_prn_res, 1, ACCESS
B0BE  D001     BRA 0xB0C2
B0C0  9211     BCF PFNf_prn_res, 1, ACCESS
364:               //PFNf_ofnserw = Mf_AKTYWNE_SRW;
365:               //PFNf_oaleg = Mf_AKTYWNE_AL;
366:               PFNf_opKNF = Mf_AKTYWNE_KNF;
B0C2  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
B0C4  D002     BRA 0xB0CA
B0C6  8810     BSF PFNf_ofnserw, 4, ACCESS
B0C8  D001     BRA 0xB0CC
B0CA  9810     BCF PFNf_ofnserw, 4, ACCESS
367:           
368:               PFNf_tdzCO = PFNf_plmCO && Mf_pob_DzCO;
B0CC  B011     BTFSC PFNf_prn_res, 0, ACCESS
B0CE  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
B0D0  D002     BRA 0xB0D6
B0D2  8E12     BSF PFNf_str_nco, 7, ACCESS
B0D4  D001     BRA 0xB0D8
B0D6  9E12     BCF PFNf_str_nco, 7, ACCESS
369:               PFNf_tdzCW = PFNf_plmCW && Mf_pob_DzCW;
B0D8  B211     BTFSC PFNf_prn_res, 1, ACCESS
B0DA  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
B0DC  D002     BRA 0xB0E2
B0DE  8013     BSF PFNf_zima, 0, ACCESS
B0E0  D001     BRA 0xB0E4
B0E2  9013     BCF PFNf_zima, 0, ACCESS
370:           
371:           
372:               PFNf_pgd = Mf_AKTYWNE_PGD;
B0E4  AA06     BTFSS DtKNFf_wymCO, 5, ACCESS
B0E6  D002     BRA 0xB0EC
B0E8  8E10     BSF PFNf_ofnserw, 7, ACCESS
B0EA  D001     BRA 0xB0EE
B0EC  9E10     BCF PFNf_ofnserw, 7, ACCESS
373:               PFNf_obgCO = Mf_PRACA && !Mf_RPM_CW;
B0EE  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
B0F0  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
B0F2  D002     BRA 0xB0F8
B0F4  8A0F     BSF PFNf_off, 5, ACCESS
B0F6  D001     BRA 0xB0FA
B0F8  9A0F     BCF PFNf_off, 5, ACCESS
374:               PFNf_obgCW = Mf_PRACA && Mf_RPM_CW;
B0FA  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
B0FC  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
B0FE  D002     BRA 0xB104
B100  8C0F     BSF PFNf_off, 6, ACCESS
B102  D001     BRA 0xB106
B104  9C0F     BCF PFNf_off, 6, ACCESS
375:           
376:               PFNf_errCS = DtCSf_error;
B106  A603     BTFSS DtCOf_su_SRW_CO, 3, ACCESS
B108  D002     BRA 0xB10E
B10A  8C0D     BSF PFNf_b_str_nco, 6, ACCESS
B10C  D001     BRA 0xB110
B10E  9C0D     BCF PFNf_b_str_nco, 6, ACCESS
377:               PFNf_errCO = DtCOf_err_CO;
B110  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
B112  D002     BRA 0xB118
B114  8A0D     BSF PFNf_b_str_nco, 5, ACCESS
B116  D001     BRA 0xB11A
B118  9A0D     BCF PFNf_b_str_nco, 5, ACCESS
378:               PFNf_errCW = DtCWf_err_CW;
B11A  A804     BTFSS DtCWf_err_CW, 4, ACCESS
B11C  D002     BRA 0xB122
B11E  8E0D     BSF PFNf_b_str_nco, 7, ACCESS
B120  D001     BRA 0xB124
B122  9E0D     BCF PFNf_b_str_nco, 7, ACCESS
379:               PFNf_fnoCS = DtCSf_no_mont;
B124  AE03     BTFSS DtCOf_su_SRW_CO, 7, ACCESS
B126  D002     BRA 0xB12C
B128  880E     BSF PFNf_lato, 4, ACCESS
B12A  D001     BRA 0xB12E
B12C  980E     BCF PFNf_lato, 4, ACCESS
380:           
381:               PFNf_ofzima = PFNf_zima;
B12E  A613     BTFSS PFNf_zima, 3, ACCESS
B130  D002     BRA 0xB136
B132  8610     BSF PFNf_ofnserw, 3, ACCESS
B134  D001     BRA 0xB138
B136  9610     BCF PFNf_ofnserw, 3, ACCESS
382:               PFNf_oflato = PFNf_lato;
B138  AE0E     BTFSS PFNf_lato, 7, ACCESS
B13A  D002     BRA 0xB140
B13C  8010     BSF PFNf_ofnserw, 0, ACCESS
B13E  D001     BRA 0xB142
B140  9010     BCF PFNf_ofnserw, 0, ACCESS
383:               PFNf_ofoff = PFNf_off;
B142  AE0F     BTFSS PFNf_off, 7, ACCESS
B144  D002     BRA 0xB14A
B146  8410     BSF PFNf_ofnserw, 2, ACCESS
B148  D001     BRA 0xB14C
B14A  9410     BCF PFNf_ofnserw, 2, ACCESS
384:           
385:               PFNf_errIN = DtINf_err_IN;
B14C  AA05     BTFSS DtKNFf_enknf, 5, ACCESS
B14E  D002     BRA 0xB154
B150  800E     BSF PFNf_lato, 0, ACCESS
B152  D001     BRA 0xB156
B154  900E     BCF PFNf_lato, 0, ACCESS
386:               PFNf_pmpPWM = (DtKNF.rdpm != 0) ? 1 : 0;
B156  0100     MOVLB 0x0
B158  51A0     MOVF _UADtf_RData, W, BANKED
B15A  E002     BZ 0xB160
B15C  8411     BSF PFNf_prn_res, 2, ACCESS
B15E  D001     BRA 0xB162
B160  9411     BCF PFNf_prn_res, 2, ACCESS
387:               PFNf_trbECO = (DtKNF.teco != 0) ? 1 : 0;
B162  0100     MOVLB 0x0
B164  51A4     MOVF _UADtf_TData, W, BANKED
B166  E002     BZ 0xB16C
B168  8413     BSF PFNf_zima, 2, ACCESS
B16A  D001     BRA 0xB16E
B16C  9413     BCF PFNf_zima, 2, ACCESS
388:           
389:               PFNf_oaleg=PFNf_aleg&&Mf_AKTYWNE_AL;
B16E  B60C     BTFSC PFNf_b_set_nco, 3, ACCESS
B170  A606     BTFSS DtKNFf_wymCO, 3, ACCESS
B172  D002     BRA 0xB178
B174  880F     BSF PFNf_off, 4, ACCESS
B176  D001     BRA 0xB17A
B178  980F     BCF PFNf_off, 4, ACCESS
390:               PFNf_ofnserw=PFNf_fnserw&&Mf_AKTYWNE_SRW;
B17A  BC0E     BTFSC PFNf_lato, 6, ACCESS
B17C  AC06     BTFSS DtKNFf_wymCO, 6, ACCESS
B17E  D002     BRA 0xB184
B180  8210     BSF PFNf_ofnserw, 1, ACCESS
B182  D001     BRA 0xB186
B184  9210     BCF PFNf_ofnserw, 1, ACCESS
391:                
392:               if(!PFNf_set_fnserw && !PFNf_ofnserw) PFNf_prnserw=0;
B186  A412     BTFSS PFNf_str_nco, 2, ACCESS
B188  B210     BTFSC PFNf_ofnserw, 1, ACCESS
B18A  D002     BRA 0xB190
B18C  9E11     BCF PFNf_prn_res, 7, ACCESS
B18E  D006     BRA 0xB19C
393:               else if(PFNf_set_fnserw || PFNf_ofnserw) PFNf_prnserw=1;
B190  B412     BTFSC PFNf_str_nco, 2, ACCESS
B192  D002     BRA 0xB198
B194  A210     BTFSS PFNf_ofnserw, 1, ACCESS
B196  D002     BRA 0xB19C
B198  8E11     BSF PFNf_prn_res, 7, ACCESS
B19A  D000     BRA 0xB19C
394:           
395:               if(!PFNf_set_aleg && !PFNf_oaleg) PFNf_prnaleg=0;
B19C  A212     BTFSS PFNf_str_nco, 1, ACCESS
B19E  B80F     BTFSC PFNf_off, 4, ACCESS
B1A0  D002     BRA 0xB1A6
B1A2  9C11     BCF PFNf_prn_res, 6, ACCESS
B1A4  0012     RETURN 0
396:               else if(PFNf_set_aleg || PFNf_oaleg) PFNf_prnaleg=1;
B1A6  B212     BTFSC PFNf_str_nco, 1, ACCESS
B1A8  D002     BRA 0xB1AE
B1AA  A80F     BTFSS PFNf_off, 4, ACCESS
B1AC  0012     RETURN 0
B1AE  8C11     BSF PFNf_prn_res, 6, ACCESS
B1B0  0012     RETURN 0
397:           }
B1B2  0012     RETURN 0
398:           //------------------
399:           //------------------
400:           //Wybor aktywnego pobudzenia ze wzgledu na miejsce w kolejce priorytetow i pozycje przelacznika funkcyjnego
401:           
402:           void KolejkaPobudzen(void)
403:           {
404:               unsigned char wr = 0;
AD08  0E00     MOVLW 0x0
AD0A  0100     MOVLB 0x0
AD0C  6FE2     MOVWF divisor, BANKED
405:           
406:               //grzanie w proc. konfiguracji
407:               if(Mf_AKTYWNE_KNF)
AD0E  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
AD10  D01C     BRA 0xAD4A
408:               {
409:                   Mf_pob_SRW = 0; //zerowanie pobudzen o nizszym priorytecie
AD12  9A0B     BCF Mf_pob_KCO, 5, ACCESS
410:                   Mf_pob_AL = 0;
AD14  9C0A     BCF Mf_pob_AL, 6, ACCESS
411:                   Mf_pob_CO = 0;
AD16  9E0A     BCF Mf_pob_AL, 7, ACCESS
412:                   Mf_pob_CW = 0;
AD18  900B     BCF Mf_pob_KCO, 0, ACCESS
413:                   Mf_pob_DzCO = 0;
AD1A  920B     BCF Mf_pob_KCO, 1, ACCESS
414:                   Mf_pob_DzCW = 0;
AD1C  940B     BCF Mf_pob_KCO, 2, ACCESS
415:                   if((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA))
AD1E  0E02     MOVLW 0x2
AD20  0101     MOVLB 0x1
AD22  19F3     XORWF min, W, BANKED
AD24  E003     BZ 0xAD2C
AD26  0E03     MOVLW 0x3
AD28  19F3     XORWF min, W, BANKED
AD2A  E10C     BNZ 0xAD44
416:                   {
417:                       if(DtKNFf_wymCW) Mf_pob_KCW = 1; //aktywacja pobudzenia
AD2C  A206     BTFSS DtKNFf_wymCO, 1, ACCESS
AD2E  D002     BRA 0xAD34
AD30  880B     BSF Mf_pob_KCO, 4, ACCESS
AD32  D001     BRA 0xAD36
418:                       else Mf_pob_KCW = 0;
AD34  980B     BCF Mf_pob_KCO, 4, ACCESS
419:                       if(DtKNFf_wymCO)
AD36  A006     BTFSS DtKNFf_wymCO, 0, ACCESS
AD38  D003     BRA 0xAD40
420:                       {
421:                           Mf_pob_KCO = 1; //aktywacja pobudzenia
AD3A  860B     BSF Mf_pob_KCO, 3, ACCESS
422:                           Mf_BLOKUJ_15S = 0;
AD3C  9E06     BCF DtKNFf_wymCO, 7, ACCESS
423:                       }
AD3E  0012     RETURN 0
424:                       else Mf_pob_KCO = 0;
AD40  960B     BCF Mf_pob_KCO, 3, ACCESS
425:                   }
AD42  0012     RETURN 0
426:                   else
427:                   {
428:                       Mf_pob_KCW = 0;
AD44  980B     BCF Mf_pob_KCO, 4, ACCESS
429:                       Mf_pob_KCO = 0;
AD46  960B     BCF Mf_pob_KCO, 3, ACCESS
430:                   }
431:               }
AD48  0012     RETURN 0
432:               else
433:               {
434:                   //grzanie w proc. serwisowej
435:                   Mf_pob_KCW = 0;
AD4A  980B     BCF Mf_pob_KCO, 4, ACCESS
436:                   Mf_pob_KCO = 0;
AD4C  960B     BCF Mf_pob_KCO, 3, ACCESS
437:                   if(Mf_AKTYWNE_SRW && (PFN.poz == _PFZMA))
AD4E  AC06     BTFSS DtKNFf_wymCO, 6, ACCESS
AD50  D00C     BRA 0xAD6A
AD52  0E03     MOVLW 0x3
AD54  0101     MOVLB 0x1
AD56  19F3     XORWF min, W, BANKED
AD58  E108     BNZ 0xAD6A
438:                   {
439:                       Mf_pob_SRW = 1; //aktywacja pobudzenia
AD5A  8A0B     BSF Mf_pob_KCO, 5, ACCESS
440:                       Mf_pob_AL = 0;
AD5C  9C0A     BCF Mf_pob_AL, 6, ACCESS
441:                       Mf_pob_CW = 0; //zerowanie pobudzen o nizszym priorytecie
AD5E  900B     BCF Mf_pob_KCO, 0, ACCESS
442:                       Mf_pob_CO = 0;
AD60  9E0A     BCF Mf_pob_AL, 7, ACCESS
443:                       Mf_pob_DzCO = 0;
AD62  920B     BCF Mf_pob_KCO, 1, ACCESS
444:                       Mf_pob_DzCW = 0;
AD64  940B     BCF Mf_pob_KCO, 2, ACCESS
445:                       Mf_BLOKUJ_15S = 0;
AD66  9E06     BCF DtKNFf_wymCO, 7, ACCESS
446:                   }
AD68  0012     RETURN 0
447:                   else
448:                   {
449:                       //grzanie w funkcji ANTYLEGIONELLA
450:                       Mf_pob_SRW = 0;
AD6A  9A0B     BCF Mf_pob_KCO, 5, ACCESS
451:                       if(Mf_AKTYWNE_AL)
AD6C  A606     BTFSS DtKNFf_wymCO, 3, ACCESS
AD6E  D00E     BRA 0xAD8C
452:                       {
453:                           if(_AL_PCW > DtCW.CW) Mf_pob_AL = 1; //zalacz wymuszenie grzania
AD70  0E46     MOVLW 0x46
AD72  0100     MOVLB 0x0
AD74  61AA     CPFSLT DtCW, BANKED
AD76  D002     BRA 0xAD7C
AD78  8C0A     BSF Mf_pob_AL, 6, ACCESS
AD7A  D003     BRA 0xAD82
454:                           else
455:                           {
456:                               PFNf_aleg=0;        //usun znacznik konsoli
AD7C  960C     BCF PFNf_b_set_nco, 3, ACCESS
457:                               Mf_pob_AL = 0;      //wylacz wymuszenie grzania
AD7E  9C0A     BCF Mf_pob_AL, 6, ACCESS
458:                               Mf_AKTYWNE_AL = 0;  //deaktywuj funkcje ANTYLEGIONELLA
AD80  9606     BCF DtKNFf_wymCO, 3, ACCESS
459:                           }
460:                           Mf_pob_CW = 0; //zerowanie pobudzen o nizszym priorytecie
AD82  900B     BCF Mf_pob_KCO, 0, ACCESS
461:                           Mf_pob_CO = 0;
AD84  9E0A     BCF Mf_pob_AL, 7, ACCESS
462:                           Mf_pob_DzCO = 0;
AD86  920B     BCF Mf_pob_KCO, 1, ACCESS
463:                           Mf_pob_DzCW = 0;
AD88  940B     BCF Mf_pob_KCO, 2, ACCESS
464:                       }
AD8A  0012     RETURN 0
465:                       else
466:                       {
467:                           //grzanie od pobudzenia CW
468:                           Mf_pob_AL = 0;
AD8C  9C0A     BCF Mf_pob_AL, 6, ACCESS
469:                           if(DtKNF.tpkt != _UNICO) wr = RdPrt(S_WCW) && ((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA));
AD8E  0100     MOVLB 0x0
AD90  519E     MOVF _PWMf_ENPWM2, W, BANKED
AD92  E013     BZ 0xADBA
AD94  6BE0     CLRF bdat, BANKED
AD96  0E0B     MOVLW 0xB
AD98  ECFD     CALL 0xE7FA, 0
AD9A  F073     NOP
AD9C  E30B     BNC 0xADB4
AD9E  0E02     MOVLW 0x2
ADA0  0101     MOVLB 0x1
ADA2  19F3     XORWF min, W, BANKED
ADA4  E003     BZ 0xADAC
ADA6  0E03     MOVLW 0x3
ADA8  19F3     XORWF min, W, BANKED
ADAA  E104     BNZ 0xADB4
ADAC  0E01     MOVLW 0x1
ADAE  0100     MOVLB 0x0
ADB0  6FE0     MOVWF bdat, BANKED
ADB2  D000     BRA 0xADB4
ADB4  C0E0     MOVFF bdat, divisor
ADB6  F0E2     NOP
ADB8  D013     BRA 0xADE0
470:                           else wr = DtCWf_wpz_CW && DtCOf_pz_CO && ((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)); //DtCWf_wpz_CW uzaleznione jest od stanu RdPrt(S_WCW)
ADBA  0E00     MOVLW 0x0
ADBC  0100     MOVLB 0x0
ADBE  6FE1     MOVWF GIE_BIT_VAL, BANKED
ADC0  B405     BTFSC DtKNFf_enknf, 2, ACCESS
ADC2  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
ADC4  D00B     BRA 0xADDC
ADC6  0E02     MOVLW 0x2
ADC8  0101     MOVLB 0x1
ADCA  19F3     XORWF min, W, BANKED
ADCC  E003     BZ 0xADD4
ADCE  0E03     MOVLW 0x3
ADD0  19F3     XORWF min, W, BANKED
ADD2  E104     BNZ 0xADDC
ADD4  0E01     MOVLW 0x1
ADD6  0100     MOVLB 0x0
ADD8  6FE1     MOVWF GIE_BIT_VAL, BANKED
ADDA  D000     BRA 0xADDC
ADDC  C0E1     MOVFF GIE_BIT_VAL, divisor
ADDE  F0E2     NOP
471:                           if(wr != 0)
ADE0  0100     MOVLB 0x0
ADE2  51E2     MOVF divisor, W, BANKED
ADE4  E005     BZ 0xADF0
472:                           {
473:                               Mf_pob_CW = 1; //aktywacja pobudzenia
ADE6  800B     BSF Mf_pob_KCO, 0, ACCESS
474:                               Mf_pob_CO = 0; //zerowanie pobudzen o nizszym priorytecie
ADE8  9E0A     BCF Mf_pob_AL, 7, ACCESS
475:                               Mf_pob_DzCO = 0;
ADEA  920B     BCF Mf_pob_KCO, 1, ACCESS
476:                               Mf_pob_DzCW = 0;
ADEC  940B     BCF Mf_pob_KCO, 2, ACCESS
477:                           }
ADEE  0012     RETURN 0
478:                           else
479:                           {
480:                               //grzanie od pobudzenia RT
481:                               Mf_pob_CW = 0;
ADF0  900B     BCF Mf_pob_KCO, 0, ACCESS
482:                               if(RdPrt(S_RT) && (PFN.poz == _PFZMA))
ADF2  0E0C     MOVLW 0xC
ADF4  ECFD     CALL 0xE7FA, 0
ADF6  F073     NOP
ADF8  E308     BNC 0xAE0A
ADFA  0E03     MOVLW 0x3
ADFC  0101     MOVLB 0x1
ADFE  19F3     XORWF min, W, BANKED
AE00  E104     BNZ 0xAE0A
483:                               {
484:                                   Mf_pob_CO = 1; //aktywacja pobudzenia
AE02  8E0A     BSF Mf_pob_AL, 7, ACCESS
485:                                   Mf_pob_DzCO = 0; //zerowanie pobudzen o nizszym priorytecie
AE04  920B     BCF Mf_pob_KCO, 1, ACCESS
486:                                   Mf_pob_DzCW = 0;
AE06  940B     BCF Mf_pob_KCO, 2, ACCESS
487:                               }
AE08  0012     RETURN 0
488:                               else
489:                               {
490:                                   //grzanie od pobudzenia temp. dyz. CO
491:                                   Mf_pob_CO = 0;
AE0A  9E0A     BCF Mf_pob_AL, 7, ACCESS
492:                                   if(RdPrt(S_DZ_CO))
AE0C  0E09     MOVLW 0x9
AE0E  ECFD     CALL 0xE7FA, 0
AE10  F073     NOP
AE12  E303     BNC 0xAE1A
493:                                   {
494:                                       Mf_pob_DzCO = 1; //aktywacja pobudzenia
AE14  820B     BSF Mf_pob_KCO, 1, ACCESS
495:                                       Mf_pob_DzCW = 0; //zerowanie pobudzen o nizszym priorytecie
AE16  940B     BCF Mf_pob_KCO, 2, ACCESS
496:                                   }
AE18  0012     RETURN 0
497:                                   else
498:                                   {
499:                                       Mf_pob_DzCO = 0;
AE1A  920B     BCF Mf_pob_KCO, 1, ACCESS
500:                                       if(DtKNF.tpkt == _UNICO) //opcja tylko dla kotla z zasobnikiem
AE1C  0100     MOVLB 0x0
AE1E  519E     MOVF _PWMf_ENPWM2, W, BANKED
AE20  E108     BNZ 0xAE32
501:                                       {
502:                                           //grzanie od pobudzenia temp. dyz. CW
503:                                           if(RdPrt(S_DZ_CW)) Mf_pob_DzCW = 1; //aktywacja pobudzenia
AE22  0E0A     MOVLW 0xA
AE24  ECFD     CALL 0xE7FA, 0
AE26  F073     NOP
AE28  E302     BNC 0xAE2E
AE2A  840B     BSF Mf_pob_KCO, 2, ACCESS
AE2C  0012     RETURN 0
504:                                           else Mf_pob_DzCW = 0;
AE2E  940B     BCF Mf_pob_KCO, 2, ACCESS
505:                                       }
AE30  0012     RETURN 0
506:                                       else Mf_pob_DzCW = 0;
AE32  940B     BCF Mf_pob_KCO, 2, ACCESS
507:                                   }
508:                               }
509:                           }
510:                       }
511:                   }
AE34  0012     RETURN 0
512:               }
513:           }
AE36  0012     RETURN 0
514:           //------------------
515:           //------------------
516:           //Decyzja o realizacji funkcji ANTYLEGIONELLA
517:           
518:           void DecyzjaAntyLeg(void)
519:           {
520:               //static unsigned char kanl;
521:           #if _SRVANL==1										//aktywny tryb kontrolny antylegionella?
522:               if(DtKNF.tpkt == _UNICO) //obowiazuje tylko dla kotlow z obsluga zasobnika
523:               {
524:                   //--------
525:                   //Warunki przerwania realizacji funkcji ANTYLEGIONELLA
526:                   if(Mf_AKTYWNE_AL)
527:                   {
528:                       if(DtKNF.aleg)
529:                       {
530:                           //StartRTG(_RTANL);						//zatrzymanie zegara ponawiania funkcji ANTYLEGIONELLA
531:                           StartRTM(_SRVRTANL);
532:                           M.LICZNIK_ANL = 0;
533:                       }
534:                       if(Mf_AKTYWNE_KNF || Mf_AKTYWNE_SRW)
535:                       {
536:                           PFNf_aleg=0;
537:                           Mf_AKTYWNE_AL = 0;
538:                           return;
539:                       }
540:                       //niedozwolona pozycja przelacznika funkcyjnego
541:                       if(!((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)))
542:                       {
543:                           PFNf_aleg=0;
544:                           Mf_AKTYWNE_AL = 0;
545:                           return;
546:                       }
547:                       //maksymalny dozwolony czas aktywnosci funkcji ANTYLEGIONELLA
548:                       if(RTM(_RTMAL) >= _SRVTEXTAL)
549:                       {
550:                           PFNf_aleg=0;                
551:                           Mf_AKTYWNE_AL = 0;
552:                           return;
553:                       }
554:                       //deaktywowano procedure (np nacisnieto przycisk RESET)
555:                       if(!PFNf_aleg)//PFNf_res)
556:                       {
557:                           Mf_AKTYWNE_AL = 0;
558:                           return;
559:                       }
560:                   }
561:                   //--------
562:                   //Warunki aktywacji funkcji ANTYLEGIONELLA
563:                   if(!Mf_AKTYWNE_AL) //mozliwa realizacja funkcji ANTYLEGIONELLA?
564:                   {
565:                       if(Mf_AKTYWNE_KNF || Mf_AKTYWNE_SRW) //realizowana funkcja serwisowa lub konfiguracyjna?
566:                       {
567:                           return;
568:                       }
569:                       //-------
570:                       //zegar ponawiania funkcji ANTYLEGIONELLA
571:                       if(DtKNF.aleg)
572:                       {
573:                           //if(RTG(_RTANL)>=1)							//timer godzinowy wyzwalania funkcji ANTYLEGIONELLA
574:                           if(RTM(_SRVRTANL) >= 1) //timer godzinowy wyzwalania funkcji ANTYLEGIONELLA
575:                           {
576:                               //StartRTG(_RTANL);
577:                               StartRTM(_SRVRTANL);
578:                               M.LICZNIK_ANL++;
579:                               if(M.LICZNIK_ANL >= _NGODZIN_SRVAL) //licznik godzin do wyzwolenia funkcji ANTYLEGIONELLA
580:                               {
581:                                   M.LICZNIK_ANL = 0;
582:                                   if((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)) {Mf_AKTYWNE_AL = 1;PFNf_aleg=1;} //aktywacja funkcji ANTYLEGIONELLA po czasie odliczonym przez timer.
583:                                   StartRTM(_RTMAL); //start timera maksymalnego dozwolonego czasu aktywnosci funkcji ANTYLEGIONELLA
584:                                   eeprom_write(_ADRRTA, 0);
585:                                   return;
586:                               }
587:                               else
588:                               {
589:                                   eeprom_write(_ADRRTA, M.LICZNIK_ANL);
590:                               }
591:                           }
592:                       }
593:                       //-------
594:                       if(!((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA))) //niedozwolona pozycja przelacznika funkcyjnego?
595:                       {
596:                           return;
597:                       }
598:                       //--------
599:                       //wymuszenie grzania AL z konsoli
600:                       if(PFNf_aleg)// && !PFNf_oaleg) //aktywowano recznie funkcje ANTYLEGIONELLA?
601:                       {
602:                           M.LICZNIK_ANL = 0;
603:                           Mf_AKTYWNE_AL = 1; //aktywacja funkcji ANTYLEGIONELLA
604:                           StartRTM(_RTMAL); //start timera maksymalnego dozwolonego czasu aktywnosci funkcji ANTYLEGIONELLA
605:                           eeprom_write(_ADRRTA, 0);
606:                       }           
607:                   }
608:                   else
609:                   {
610:                       //StartRTG(_RTANL);						//zatrzymanie zegara (funkcja ANTYLEGIONELLA nieaktywna)
611:                       StartRTM(_SRVRTANL);
612:                       M.LICZNIK_ANL = 0;
613:                   }
614:               }
615:               else {Mf_AKTYWNE_AL = 0;PFNf_aleg=0;}
616:           #else
617:               if(DtKNF.tpkt == _UNICO) //obowiazuje tylko dla kotlow z obsluga zasobnika
B1B4  0100     MOVLB 0x0
B1B6  519E     MOVF _PWMf_ENPWM2, W, BANKED
B1B8  E001     BZ 0xB1BC
B1BA  D08A     BRA 0xB2D0
618:               {
619:                   //--------
620:                   //Warunki przerwania realizacji funkcji ANTYLEGIONELLA
621:                   if(Mf_AKTYWNE_AL)
B1BC  A606     BTFSS DtKNFf_wymCO, 3, ACCESS
B1BE  D029     BRA 0xB212
622:                   {
623:                       if(DtKNF.aleg)
B1C0  51A9     MOVF _rglf_del1s, W, BANKED
B1C2  E007     BZ 0xB1D2
624:                       {
625:                           StartRTG(_RTANL); //zatrzymanie zegara ponawiania funkcji ANTYLEGIONELLA
B1C4  0E01     MOVLW 0x1
B1C6  EC40     CALL 0xE480, 0
B1C8  F072     NOP
626:                           M.LICZNIK_ANL = 0;
B1CA  0E00     MOVLW 0x0
B1CC  0100     MOVLB 0x0
B1CE  6F86     MOVWF _PFNf_opgres, BANKED
B1D0  D000     BRA 0xB1D2
627:                       }
628:                       if(Mf_AKTYWNE_KNF || Mf_AKTYWNE_SRW)
B1D2  B806     BTFSC DtKNFf_wymCO, 4, ACCESS
B1D4  D002     BRA 0xB1DA
B1D6  AC06     BTFSS DtKNFf_wymCO, 6, ACCESS
B1D8  D003     BRA 0xB1E0
629:                       {
630:                           PFNf_aleg=0;
B1DA  960C     BCF PFNf_b_set_nco, 3, ACCESS
631:                           Mf_AKTYWNE_AL = 0;
B1DC  9606     BCF DtKNFf_wymCO, 3, ACCESS
632:                           return;
B1DE  0012     RETURN 0
633:                       }
634:                       //niedozwolona pozycja przelacznika funkcyjnego
635:                       if(!((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)))
B1E0  0E02     MOVLW 0x2
B1E2  0101     MOVLB 0x1
B1E4  19F3     XORWF min, W, BANKED
B1E6  E006     BZ 0xB1F4
B1E8  0E03     MOVLW 0x3
B1EA  19F3     XORWF min, W, BANKED
B1EC  E003     BZ 0xB1F4
636:                       {
637:                           PFNf_aleg=0;
B1EE  960C     BCF PFNf_b_set_nco, 3, ACCESS
638:                           Mf_AKTYWNE_AL = 0;
B1F0  9606     BCF DtKNFf_wymCO, 3, ACCESS
639:                           return;
B1F2  0012     RETURN 0
640:                       }
641:                       //maksymalny dozwolony czas aktywnosci funkcji ANTYLEGIONELLA
642:                       if(RTM(_RTMAL) >= _TEXTAL)
B1F4  0E04     MOVLW 0x4
B1F6  ECC0     CALL 0xEB80, 0
B1F8  F075     NOP
B1FA  0100     MOVLB 0x0
B1FC  6FE2     MOVWF divisor, BANKED
B1FE  0E3B     MOVLW 0x3B
B200  65E2     CPFSGT divisor, BANKED
B202  D003     BRA 0xB20A
643:                       {
644:                           PFNf_aleg=0;
B204  960C     BCF PFNf_b_set_nco, 3, ACCESS
645:                           Mf_AKTYWNE_AL = 0;
B206  9606     BCF DtKNFf_wymCO, 3, ACCESS
646:                           return;
B208  0C3B     RETLW 0x3B
647:                       }
648:                       //deaktywowano procedure (np nacisnieto przycisk RESET)
649:                       if(!PFNf_aleg)
B20A  B60C     BTFSC PFNf_b_set_nco, 3, ACCESS
B20C  D002     BRA 0xB212
650:                       {
651:                           Mf_AKTYWNE_AL = 0;
B20E  9606     BCF DtKNFf_wymCO, 3, ACCESS
652:                           return;
B210  0012     RETURN 0
653:                       }
654:                   }
655:                   //--------
656:                   //Warunki aktywacji funkcji ANTYLEGIONELLA
657:                   if(!Mf_AKTYWNE_AL) //mozliwa realizacja funkcji ANTYLEGIONELLA?
B212  B606     BTFSC DtKNFf_wymCO, 3, ACCESS
B214  D056     BRA 0xB2C2
658:                   {
659:                       if(Mf_AKTYWNE_KNF || Mf_AKTYWNE_SRW) //realizowana funkcja serwisowa lub konfiguracyjna?
B216  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
B218  BC06     BTFSC DtKNFf_wymCO, 6, ACCESS
B21A  0012     RETURN 0
B21C  D001     BRA 0xB220
660:                       {
661:                           return;
B21E  0012     RETURN 0
662:                       }
663:                       //-------
664:                       //zegar ponawiania funkcji ANTYLEGIONELLA
665:                       if(DtKNF.aleg)
B220  0100     MOVLB 0x0
B222  51A9     MOVF _rglf_del1s, W, BANKED
B224  E032     BZ 0xB28A
666:                       {
667:                           if(RTG(_RTANL) >= 1) //timer godzinowy wyzwalania funkcji ANTYLEGIONELLA
B226  0E01     MOVLW 0x1
B228  EC92     CALL 0xEB24, 0
B22A  F075     NOP
B22C  0900     IORLW 0x0
B22E  E02D     BZ 0xB28A
668:                           {
669:                               StartRTG(_RTANL);
B230  0E01     MOVLW 0x1
B232  EC40     CALL 0xE480, 0
B234  F072     NOP
670:                               M.LICZNIK_ANL++;
B236  0100     MOVLB 0x0
B238  2B86     INCF _PFNf_opgres, F, BANKED
671:                               if(M.LICZNIK_ANL >= _NGODZIN_AL) //licznik godzin do wyzwolenia funkcji ANTYLEGIONELLA
B23A  0EA7     MOVLW 0xA7
B23C  0100     MOVLB 0x0
B23E  6586     CPFSGT _PFNf_opgres, BANKED
B240  D019     BRA 0xB274
672:                               {
673:                                   M.LICZNIK_ANL = 0;
B242  6B86     CLRF _PFNf_opgres, BANKED
674:                                   if((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)) {Mf_AKTYWNE_AL = 1;PFNf_aleg=1;} //aktywacja funkcji ANTYLEGIONELLA po czasie odliczonym przez timer.
B244  0E02     MOVLW 0x2
B246  0101     MOVLB 0x1
B248  19F3     XORWF min, W, BANKED
B24A  E003     BZ 0xB252
B24C  0E03     MOVLW 0x3
B24E  19F3     XORWF min, W, BANKED
B250  E103     BNZ 0xB258
B252  8606     BSF DtKNFf_wymCO, 3, ACCESS
B254  860C     BSF PFNf_b_set_nco, 3, ACCESS
B256  D000     BRA 0xB258
675:                                   StartRTM(_RTMAL); //start timera maksymalnego dozwolonego czasu aktywnosci funkcji ANTYLEGIONELLA
B258  0E04     MOVLW 0x4
B25A  EC80     CALL 0xE500, 0
B25C  F072     NOP
676:                                   eeprom_write(_ADRRTA, 0);
B25E  ECFE     CALL 0xF3FC, 0
B260  F079     NOP
B262  0100     MOVLB 0x0
B264  6BDF     CLRF pco, BANKED
B266  0EC7     MOVLW 0xC7
B268  6FDE     MOVWF __pcstackBANK0, BANKED
B26A  6BE0     CLRF bdat, BANKED
B26C  EC58     CALL 0xE2B0, 0
B26E  F071     NOP
677:                                   return;
B270  0012     RETURN 0
678:                               }
B272  D00B     BRA 0xB28A
679:                               else
680:                               {
681:                                   eeprom_write(_ADRRTA, M.LICZNIK_ANL);
B274  ECFE     CALL 0xF3FC, 0
B276  F079     NOP
B278  0100     MOVLB 0x0
B27A  6BDF     CLRF pco, BANKED
B27C  0EC7     MOVLW 0xC7
B27E  6FDE     MOVWF __pcstackBANK0, BANKED
B280  C086     MOVFF _PFNf_opgres, bdat
B282  F0E0     NOP
B284  EC58     CALL 0xE2B0, 0
B286  F071     NOP
682:                               }
B288  D000     BRA 0xB28A
683:                           }
684:                       }
685:                       //-------
686:                       if(!((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA))) //niedozwolona pozycja przelacznika funkcyjnego?
B28A  0E02     MOVLW 0x2
B28C  0101     MOVLB 0x1
B28E  19F3     XORWF min, W, BANKED
B290  E006     BZ 0xB29E
B292  0E03     MOVLW 0x3
B294  19F3     XORWF min, W, BANKED
B296  A4D8     BTFSS STATUS, 2, ACCESS
B298  0012     RETURN 0
B29A  D001     BRA 0xB29E
687:                       {
688:                           return;
B29C  0012     RETURN 0
689:                       }
690:                       //--------
691:                       //wymuszenie grzania AL z konsoli
692:                       if(PFNf_aleg) //aktywowano recznie funkcje ANTYLEGIONELLA?
B29E  A60C     BTFSS PFNf_b_set_nco, 3, ACCESS
B2A0  0012     RETURN 0
693:                       {
694:                           M.LICZNIK_ANL = 0;
B2A2  0100     MOVLB 0x0
B2A4  6B86     CLRF _PFNf_opgres, BANKED
695:                           Mf_AKTYWNE_AL = 1; //aktywacja funkcji ANTYLEGIONELLA
B2A6  8606     BSF DtKNFf_wymCO, 3, ACCESS
696:                           StartRTM(_RTMAL); //start timera maksymalnego dozwolonego czasu aktywnosci funkcji ANTYLEGIONELLA
B2A8  0E04     MOVLW 0x4
B2AA  EC80     CALL 0xE500, 0
B2AC  F072     NOP
697:                           eeprom_write(_ADRRTA, 0);
B2AE  ECFE     CALL 0xF3FC, 0
B2B0  F079     NOP
B2B2  0100     MOVLB 0x0
B2B4  6BDF     CLRF pco, BANKED
B2B6  0EC7     MOVLW 0xC7
B2B8  6FDE     MOVWF __pcstackBANK0, BANKED
B2BA  6BE0     CLRF bdat, BANKED
B2BC  EC58     CALL 0xE2B0, 0
B2BE  F071     NOP
698:                       }
699:                   }
B2C0  0012     RETURN 0
700:                   else
701:                   {
702:                       StartRTG(_RTANL); //zatrzymanie zegara (funkcja ANTYLEGIONELLA nieaktywna)
B2C2  0E01     MOVLW 0x1
B2C4  EC40     CALL 0xE480, 0
B2C6  F072     NOP
703:                       M.LICZNIK_ANL = 0;
B2C8  0E00     MOVLW 0x0
B2CA  0100     MOVLB 0x0
B2CC  6F86     MOVWF _PFNf_opgres, BANKED
704:                   }
705:               }
B2CE  0012     RETURN 0
706:               else {Mf_AKTYWNE_AL = 0;PFNf_aleg=0;}
B2D0  9606     BCF DtKNFf_wymCO, 3, ACCESS
B2D2  960C     BCF PFNf_b_set_nco, 3, ACCESS
B2D4  0012     RETURN 0
707:           #endif
708:           }
B2D6  0012     RETURN 0
709:           //------------------
710:           //------------------
711:           //Regulacja stanu wyswietlacza 
712:           //void NastawaCOCW(unsigned char one);
713:           /*
714:           void DecWSW(void)
715:           {
716:                   //NastawaCOCW(1);
717:                   //PrintHex(PFN.AC);
718:           
719:                   //stan plomienia
720:                   SetDiode(_DPL,RdPrt(S_PLM)&&Mf_PRACA);
721:                   //funkcja serwisowa
722:                   SetDiode(_DKM,Mf_AKTYWNE_SRW);
723:                   //sygnalizacja obiegu
724:                   SetDiode(_DCO,Mf_PRACA&&!Mf_RPM_CW);
725:                   SetDiode(_DCW,Mf_PRACA&&Mf_RPM_CW);
726:           
727:           #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
728:                   if(Mf_pob_SRW&&!Mf_ROZRUCH&&_GRZEJ)
729:                   {
730:                           PrintHex(PWM.BufPWM);
731:                           return;
732:                   }
733:           #endif
734:           
735:                   if(!DtCSf_no_mont)		//czujnik cisnienia zamontowany
736:                   {
737:                           //przelacznik funkcji na pozycji CISNIENIE
738:                           if((PFN.poz==_PFCSN)&&!RdPrt(S_ERR_CSN)) PrintCS(DtCS.CS);
739:                           else EndCS();
740:           
741:                           //przelacznik funkcji na dowolnej pozycji oprocz pozycji CISNIENIE gdy nie jest realizowana funkcja grzania
742:                           if((PFN.poz!=_PFCSN)&&!Mf_PRACA) PrintOFF();
743:                           else
744:                           //przelacznik funkcji na pozycji CISNIENIE gdy jest awaria czujnika cisnienia
745:                           if((PFN.poz==_PFCSN)&&RdPrt(S_ERR_CSN)) PrintOFF();
746:                           else EndOFF();
747:                   }
748:                   else					//czujnik cisnienia nie zamontowany
749:                   {
750:                           //przelacznik funkcji na dowolnej pozycji oprocz pozycji CISNIENIE gdy nie jest realizowana funkcja grzania
751:                           if(!Mf_PRACA) PrintOFF();
752:                           else EndOFF();
753:                   }
754:           
755:                   //nastawa PCO
756:                   if(DtCOf_newPCO)
757:                   {
758:                           if(Mf_AKTYWNE_PGD) PrintNstKt(DtCO.PCO);
759:                           else PrintNstCO(DtCO.PCO);
760:                   }
761:                   else
762:                   //nastawa PCW
763:                   if(DtCWf_newPCW) PrintNstCW(DtCW.PCW);
764:           
765:                   //przelacznik funkcji na pozycji LATO lub ZIMA
766:                   if((PFN.poz==_PFLTO)&&!DtCWf_err_CW) PrintCW(DtCW.SCW);							//pozycja LATO
767:                   else
768:                   if((PFN.poz==_PFZMA)&&!DtCWf_err_CW&&Mf_pob_CW&&Mf_PRACA) PrintCW(DtCW.SCW);	//pozycja ZIMA i wymuszenie CW
769:                   else
770:                   {
771:                           EndCW();
772:                           PrintCO(DtCO.SCO);
773:                   }
774:           
775:                   //temperatura dyzurna
776:                   if(!DtCSf_no_mont)		//czujnik cisnienia zamontowany
777:                   {
778:                           if(PFN.poz!=_PFCSN)			//przelacznik funkcji na pozycji innej niz CISNIENIE
779:                           {
780:                                   if(Mf_pob_DzCO&&Mf_PRACA) PrintTdzCO(DtCO.SCO);
781:                                   else
782:                                   {
783:                                           EndTdzCO();
784:                                           if(Mf_pob_DzCW&&Mf_PRACA) PrintTdzCW(DtCW.SCW);
785:                                           else EndTdzCW();
786:                                   }
787:                           }
788:                           else
789:                           {
790:                                   EndTdzCO();
791:                                   EndTdzCW();
792:                           }
793:                   }
794:                   else					//czujnik cisnienia nie zamontowany
795:                   {
796:                           if(Mf_pob_DzCO&&Mf_PRACA) PrintTdzCO(DtCO.SCO);
797:                           else
798:                           {
799:                                   EndTdzCO();
800:                                   if(Mf_pob_DzCW&&Mf_PRACA) PrintTdzCW(DtCW.SCW);
801:                                   else EndTdzCW();
802:                           }
803:                   }
804:           }
805:            */
806:           //------------------
807:           //------------------
808:           
809:           void NastawaCOCW(void)
810:           {
811:               volatile static unsigned char obg_cw = 0, obg_co = 0, zmn2 = 0, zmn3 = 0, pcw;
812:           
813:               //-----------------
814:               //if(PFNf_fnserw || PFNf_ofnserw || PFNf_set_fnserw || PFNf_aleg || PFNf_oaleg || PFNf_set_aleg) //aktywna funkcja serwisowa lub antylegionella?
815:               if(PFNf_prnserw || PFNf_prnaleg)
89D6  BE11     BTFSC PFNf_prn_res, 7, ACCESS
89D8  D002     BRA 0x89DE
89DA  AC11     BTFSS PFNf_prn_res, 6, ACCESS
89DC  D003     BRA 0x89E4
816:               {
817:                   PFNf_set_ncw = 0;
89DE  9812     BCF PFNf_str_nco, 4, ACCESS
818:                   PFNf_set_nco = 0;
89E0  9612     BCF PFNf_str_nco, 3, ACCESS
819:                   PFNf_str_nco = 0;
89E2  9A12     BCF PFNf_str_nco, 5, ACCESS
820:               }
821:               //-----------------
822:               if(!PFNf_prnserw)
89E4  BE11     BTFSC PFNf_prn_res, 7, ACCESS
89E6  D01C     BRA 0x8A20
823:               {
824:                   if(!PFNf_set_ncw && !obg_cw && PFNf_obgCW) //uruchomienie w obiegu CW?
89E8  B812     BTFSC PFNf_str_nco, 4, ACCESS
89EA  D00B     BRA 0x8A02
89EC  0101     MOVLB 0x1
89EE  5167     MOVF _PFNf_b_set_ncw, W, BANKED
89F0  B4D8     BTFSC STATUS, 2, ACCESS
89F2  AC0F     BTFSS PFNf_off, 6, ACCESS
89F4  D006     BRA 0x8A02
825:                   {
826:                       PFNf_str_ncw = 1;
89F6  8C12     BSF PFNf_str_nco, 6, ACCESS
827:                       PFNf_b_str_ncw = 1;
89F8  820D     BSF PFNf_b_str_nco, 1, ACCESS
828:                       StartRTdS(_RTSTR2);
89FA  0E0B     MOVLW 0xB
89FC  ECA0     CALL 0xE540, 0
89FE  F072     NOP
8A00  D000     BRA 0x8A02
829:                   }
830:                   obg_cw = PFNf_obgCW;
8A02  0E00     MOVLW 0x0
8A04  BC0F     BTFSC PFNf_off, 6, ACCESS
8A06  0E01     MOVLW 0x1
8A08  0101     MOVLB 0x1
8A0A  6F67     MOVWF _PFNf_b_set_ncw, BANKED
831:                   if(PFNf_b_str_ncw)
8A0C  A20D     BTFSS PFNf_b_str_nco, 1, ACCESS
8A0E  D008     BRA 0x8A20
832:                   {
833:                       PFNf_b_str_ncw = 0;
8A10  920D     BCF PFNf_b_str_nco, 1, ACCESS
834:                       EndNst();
8A12  ECFA     CALL 0xF3F4, 0
8A14  F079     NOP
835:                       PrintNstCW(PFN.PPCW);
8A16  0101     MOVLB 0x1
8A18  51E4     MOVF k, W, BANKED
8A1A  ECC7     CALL 0xD38E, 0
8A1C  F069     NOP
836:                   }
8A1E  D000     BRA 0x8A20
837:               }
838:               //-----------------
839:               if(!PFNf_set_nco && !obg_co && PFNf_obgCO) //uruchomienie w obiegu CO?
8A20  B612     BTFSC PFNf_str_nco, 3, ACCESS
8A22  D00B     BRA 0x8A3A
8A24  0101     MOVLB 0x1
8A26  5166     MOVF 0x66, W, BANKED
8A28  B4D8     BTFSC STATUS, 2, ACCESS
8A2A  AA0F     BTFSS PFNf_off, 5, ACCESS
8A2C  D006     BRA 0x8A3A
840:               {
841:                   PFNf_str_nco = 1;
8A2E  8A12     BSF PFNf_str_nco, 5, ACCESS
842:                   PFNf_b_str_nco = 1;
8A30  800D     BSF PFNf_b_str_nco, 0, ACCESS
843:                   StartRTdS(_RTSTR2);
8A32  0E0B     MOVLW 0xB
8A34  ECA0     CALL 0xE540, 0
8A36  F072     NOP
8A38  D000     BRA 0x8A3A
844:               }
845:               obg_co = PFNf_obgCO;
8A3A  0E00     MOVLW 0x0
8A3C  BA0F     BTFSC PFNf_off, 5, ACCESS
8A3E  0E01     MOVLW 0x1
8A40  0101     MOVLB 0x1
8A42  6F66     MOVWF 0x66, BANKED
846:               if(PFNf_b_str_nco)
8A44  A00D     BTFSS PFNf_b_str_nco, 0, ACCESS
8A46  D00F     BRA 0x8A66
847:               {
848:                   PFNf_b_str_nco = 0;
8A48  900D     BCF PFNf_b_str_nco, 0, ACCESS
849:                   EndNst();
8A4A  ECFA     CALL 0xF3F4, 0
8A4C  F079     NOP
850:                   if(PFNf_prnserw)
8A4E  AE11     BTFSS PFNf_prn_res, 7, ACCESS
8A50  D005     BRA 0x8A5C
851:                   {
852:                       PFNf_set_nco = 0;
8A52  9612     BCF PFNf_str_nco, 3, ACCESS
853:                       PFNf_str_nco = 0;
8A54  9A12     BCF PFNf_str_nco, 5, ACCESS
854:                       EndNst();
8A56  ECFA     CALL 0xF3F4, 0
8A58  F079     NOP
855:                   }
8A5A  D005     BRA 0x8A66
856:                   else PrintNstCO(PFN.PPCO);
8A5C  0101     MOVLB 0x1
8A5E  51E3     MOVF a, W, BANKED
8A60  ECFD     CALL 0xD3FA, 0
8A62  F069     NOP
8A64  D000     BRA 0x8A66
857:               }
858:               //-----------------
859:               if(PFNf_set_nco || PFNf_set_ncw || RTdS(_RTSTR2) > _TSTRNST) //uplynal czas podtrzymania nastawy po rozruchu?
8A66  A612     BTFSS PFNf_str_nco, 3, ACCESS
8A68  B812     BTFSC PFNf_str_nco, 4, ACCESS
8A6A  D008     BRA 0x8A7C
8A6C  0E0B     MOVLW 0xB
8A6E  ECD7     CALL 0xEBAE, 0
8A70  F075     NOP
8A72  0102     MOVLB 0x2
8A74  6FFE     MOVWF k, BANKED
8A76  0E1E     MOVLW 0x1E
8A78  65FE     CPFSGT k, BANKED
8A7A  D002     BRA 0x8A80
860:               {
861:                   PFNf_str_nco = 0;
8A7C  9A12     BCF PFNf_str_nco, 5, ACCESS
862:                   PFNf_str_ncw = 0;
8A7E  9C12     BCF PFNf_str_nco, 6, ACCESS
863:               }
864:               //-----------------
865:               if(PFNf_set_ncw) //wybrano nastawe CW?
8A80  A812     BTFSS PFNf_str_nco, 4, ACCESS
8A82  D065     BRA 0x8B4E
866:               {
867:                   pcw = PFN.PCW;
8A84  C1F1     MOVFF 0x1F1, pcw
8A86  F168     NOP
868:                   if(!PFNf_mod_ncw)
8A88  B00F     BTFSC PFNf_off, 0, ACCESS
8A8A  D019     BRA 0x8ABE
869:                   {
870:                       if(!RdPrt(S_KUP)&&!RdPrt(S_KDW)) PFNf_mod_ncw=1;
8A8C  0E18     MOVLW 0x18
8A8E  ECFD     CALL 0xE7FA, 0
8A90  F073     NOP
8A92  E206     BC 0x8AA0
8A94  0E19     MOVLW 0x19
8A96  ECFD     CALL 0xE7FA, 0
8A98  F073     NOP
8A9A  E202     BC 0x8AA0
8A9C  800F     BSF PFNf_off, 0, ACCESS
8A9E  D000     BRA 0x8AA0
871:                       if(RTdS(_RTSET)<5) PrintNstCW(PFN.PCW);
8AA0  0E09     MOVLW 0x9
8AA2  ECD7     CALL 0xEBAE, 0
8AA4  F075     NOP
8AA6  0102     MOVLB 0x2
8AA8  6FFE     MOVWF k, BANKED
8AAA  0E05     MOVLW 0x5
8AAC  61FE     CPFSLT k, BANKED
8AAE  D005     BRA 0x8ABA
8AB0  0101     MOVLB 0x1
8AB2  51F1     MOVF m, W, BANKED
8AB4  ECC7     CALL 0xD38E, 0
8AB6  F069     NOP
8AB8  D002     BRA 0x8ABE
872:                       else PFNf_mod_ncw=1;
8ABA  800F     BSF PFNf_off, 0, ACCESS
8ABC  D000     BRA 0x8ABE
873:                   }
874:                   if(PFNf_mod_ncw) ReadParam(&PFN.PCW, &zmn, &zps, DtCW.minPCW, DtCW.maxPCW, 0, 1);
8ABE  A00F     BTFSS PFNf_off, 0, ACCESS
8AC0  D019     BRA 0x8AF4
8AC2  0EF1     MOVLW 0xF1
8AC4  0103     MOVLB 0x3
8AC6  6F75     MOVWF _PFNf_fns_max, BANKED
8AC8  0E01     MOVLW 0x1
8ACA  6F76     MOVWF _PFNf_fnserw, BANKED
8ACC  0EDD     MOVLW 0xDD
8ACE  6F77     MOVWF _PFNf_lato, BANKED
8AD0  0E00     MOVLW 0x0
8AD2  6F78     MOVWF _PFNf_mod_ncw, BANKED
8AD4  0EFF     MOVLW 0xFF
8AD6  6F79     MOVWF _PFNf_newPCO, BANKED
8AD8  0E01     MOVLW 0x1
8ADA  6F7A     MOVWF _PFNf_newPCW, BANKED
8ADC  C0AD     MOVFF _rglf_inv_mod, min
8ADE  F37B     NOP
8AE0  6B7C     CLRF _PFNf_oaleg, BANKED
8AE2  C0AE     MOVFF _rglf_med_up, max
8AE4  F37D     NOP
8AE6  6B7E     CLRF _PFNf_obgCW, BANKED
8AE8  6B7F     CLRF _PFNf_off, BANKED
8AEA  0E01     MOVLW 0x1
8AEC  6F80     MOVWF _PFNf_oflato, BANKED
8AEE  EC3A     CALL 0x7674, 0
8AF0  F03B     NOP
8AF2  D000     BRA 0x8AF4
875:                   if(!PFNf_b_set_ncw) //nacisnieto przycisk set?
8AF4  BE0C     BTFSC PFNf_b_set_nco, 7, ACCESS
8AF6  D009     BRA 0x8B0A
876:                   {
877:                       PFNf_b_set_ncw = 1;
8AF8  8E0C     BSF PFNf_b_set_nco, 7, ACCESS
878:                       EndNst();
8AFA  ECFA     CALL 0xF3F4, 0
8AFC  F079     NOP
879:                       zmn2 = 1;
8AFE  0E01     MOVLW 0x1
8B00  0101     MOVLB 0x1
8B02  6F69     MOVWF _PFNf_b_str_ncw, BANKED
880:                       pcw = PFN.PCW;
8B04  C1F1     MOVFF 0x1F1, pcw
8B06  F168     NOP
8B08  D000     BRA 0x8B0A
881:                   }
882:                   if(zmn2 || zmn) //nastawa ulegla zmianie?
8B0A  0101     MOVLB 0x1
8B0C  5169     MOVF _PFNf_b_str_ncw, W, BANKED
8B0E  E103     BNZ 0x8B16
8B10  0100     MOVLB 0x0
8B12  51DD     MOVF zmn, W, BANKED
8B14  E01C     BZ 0x8B4E
883:                   {
884:                       PFNf_newPCW = (pcw != PFN.PCW);
8B16  0101     MOVLB 0x1
8B18  5168     MOVF _PFNf_b_str_nco, W, BANKED
8B1A  0102     MOVLB 0x2
8B1C  6FFE     MOVWF k, BANKED
8B1E  6BFF     CLRF key, BANKED
8B20  0101     MOVLB 0x1
8B22  51F1     MOVF m, W, BANKED
8B24  0102     MOVLB 0x2
8B26  19FE     XORWF k, W, BANKED
8B28  E105     BNZ 0x8B34
8B2A  0101     MOVLB 0x1
8B2C  51F2     MOVF tid, W, BANKED
8B2E  0102     MOVLB 0x2
8B30  19FF     XORWF key, W, BANKED
8B32  E002     BZ 0x8B38
8B34  840F     BSF PFNf_off, 2, ACCESS
8B36  D001     BRA 0x8B3A
8B38  940F     BCF PFNf_off, 2, ACCESS
885:                       zmn2 = 0;
8B3A  0101     MOVLB 0x1
8B3C  6B69     CLRF _PFNf_b_str_ncw, BANKED
886:                       StartRTdS(_RTSET);
8B3E  0E09     MOVLW 0x9
8B40  ECA0     CALL 0xE540, 0
8B42  F072     NOP
887:                       PrintNstCW(PFN.PCW);
8B44  0101     MOVLB 0x1
8B46  51F1     MOVF m, W, BANKED
8B48  ECC7     CALL 0xD38E, 0
8B4A  F069     NOP
888:                   }
8B4C  D000     BRA 0x8B4E
889:               }
890:               //-----------------
891:               if(PFNf_set_nco) //wybrano nastawe CO?
8B4E  A612     BTFSS PFNf_str_nco, 3, ACCESS
8B50  D052     BRA 0x8BF6
892:               {
893:                   pcw = PFN.PCO;
8B52  C1EF     MOVFF 0x1EF, pcw
8B54  F168     NOP
894:                   ReadParam(&PFN.PCO, &zmn, &zps, DtCO.minPCO, DtCO.maxPCO, 0, 1);
8B56  0EEF     MOVLW 0xEF
8B58  0103     MOVLB 0x3
8B5A  6F75     MOVWF _PFNf_fns_max, BANKED
8B5C  0E01     MOVLW 0x1
8B5E  6F76     MOVWF _PFNf_fnserw, BANKED
8B60  0EDD     MOVLW 0xDD
8B62  6F77     MOVWF _PFNf_lato, BANKED
8B64  0E00     MOVLW 0x0
8B66  6F78     MOVWF _PFNf_mod_ncw, BANKED
8B68  0EFF     MOVLW 0xFF
8B6A  6F79     MOVWF _PFNf_newPCO, BANKED
8B6C  0E01     MOVLW 0x1
8B6E  6F7A     MOVWF _PFNf_newPCW, BANKED
8B70  C0D2     MOVFF 0xD2, min
8B72  F37B     NOP
8B74  6B7C     CLRF _PFNf_oaleg, BANKED
8B76  C0D3     MOVFF 0xD3, max
8B78  F37D     NOP
8B7A  6B7E     CLRF _PFNf_obgCW, BANKED
8B7C  6B7F     CLRF _PFNf_off, BANKED
8B7E  0E01     MOVLW 0x1
8B80  6F80     MOVWF _PFNf_oflato, BANKED
8B82  EC3A     CALL 0x7674, 0
8B84  F03B     NOP
895:                   if(!PFNf_b_set_nco) //stan po nacisnieciu przycisku set?
8B86  BC0C     BTFSC PFNf_b_set_nco, 6, ACCESS
8B88  D00A     BRA 0x8B9E
896:                   {
897:                       PFNf_b_set_nco = 1;
8B8A  8C0C     BSF PFNf_b_set_nco, 6, ACCESS
898:                       EndNst();
8B8C  ECFA     CALL 0xF3F4, 0
8B8E  F079     NOP
899:                       zmn2 = 1;
8B90  0E01     MOVLW 0x1
8B92  0101     MOVLB 0x1
8B94  6F69     MOVWF _PFNf_b_str_ncw, BANKED
900:                       pcw = PFN.PCO;
8B96  C1EF     MOVFF 0x1EF, pcw
8B98  F168     NOP
901:                       PFNf_newPCO = 0;
8B9A  920F     BCF PFNf_off, 1, ACCESS
8B9C  D000     BRA 0x8B9E
902:                   }
903:                   if(zmn2 || zmn) //nastawa ulegla zmianie?
8B9E  0101     MOVLB 0x1
8BA0  5169     MOVF _PFNf_b_str_ncw, W, BANKED
8BA2  E103     BNZ 0x8BAA
8BA4  0100     MOVLB 0x0
8BA6  51DD     MOVF zmn, W, BANKED
8BA8  E026     BZ 0x8BF6
904:                   {
905:                       if(!PFNf_newPCO) PFNf_newPCO = (pcw != PFN.PCO);
8BAA  B20F     BTFSC PFNf_off, 1, ACCESS
8BAC  D013     BRA 0x8BD4
8BAE  0101     MOVLB 0x1
8BB0  5168     MOVF _PFNf_b_str_nco, W, BANKED
8BB2  0102     MOVLB 0x2
8BB4  6FFE     MOVWF k, BANKED
8BB6  6BFF     CLRF key, BANKED
8BB8  0101     MOVLB 0x1
8BBA  51EF     MOVF 0xEF, W, BANKED
8BBC  0102     MOVLB 0x2
8BBE  19FE     XORWF k, W, BANKED
8BC0  E105     BNZ 0x8BCC
8BC2  0101     MOVLB 0x1
8BC4  51F0     MOVF p, W, BANKED
8BC6  0102     MOVLB 0x2
8BC8  19FF     XORWF key, W, BANKED
8BCA  E002     BZ 0x8BD0
8BCC  820F     BSF PFNf_off, 1, ACCESS
8BCE  D002     BRA 0x8BD4
8BD0  920F     BCF PFNf_off, 1, ACCESS
8BD2  D000     BRA 0x8BD4
906:                       zmn2 = 0;
8BD4  0101     MOVLB 0x1
8BD6  6B69     CLRF _PFNf_b_str_ncw, BANKED
907:                       StartRTdS(_RTSET);
8BD8  0E09     MOVLW 0x9
8BDA  ECA0     CALL 0xE540, 0
8BDC  F072     NOP
908:                       if(Mf_AKTYWNE_PGD) PrintNstKt(PFN.PCO);
8BDE  AA06     BTFSS DtKNFf_wymCO, 5, ACCESS
8BE0  D005     BRA 0x8BEC
8BE2  0101     MOVLB 0x1
8BE4  51EF     MOVF 0xEF, W, BANKED
8BE6  EC91     CALL 0xD322, 0
8BE8  F069     NOP
8BEA  D005     BRA 0x8BF6
909:                       else PrintNstCO(PFN.PCO);
8BEC  0101     MOVLB 0x1
8BEE  51EF     MOVF 0xEF, W, BANKED
8BF0  ECFD     CALL 0xD3FA, 0
8BF2  F069     NOP
910:                   }
8BF4  D000     BRA 0x8BF6
911:               }
912:               //-----------------
913:               if(!PFNf_set_ncw && !PFNf_set_nco) //tryb modyfikacji nastawy jest nieaktywny?
8BF6  A812     BTFSS PFNf_str_nco, 4, ACCESS
8BF8  B612     BTFSC PFNf_str_nco, 3, ACCESS
8BFA  0012     RETURN 0
914:               {
915:                   if(!PFNf_str_ncw && !PFNf_str_nco) EndNst();
8BFC  AC12     BTFSS PFNf_str_nco, 6, ACCESS
8BFE  BA12     BTFSC PFNf_str_nco, 5, ACCESS
8C00  D003     BRA 0x8C08
8C02  ECFA     CALL 0xF3F4, 0
8C04  F079     NOP
8C06  D000     BRA 0x8C08
916:                   PFNf_b_set_ncw = 0;
8C08  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
917:                   PFNf_b_set_nco = 0;
8C0A  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
8C0C  0012     RETURN 0
918:               }
919:           }
8C0E  0012     RETURN 0
920:           
921:           //--------------------------------------------------------------
922:           #define _KRSK 0
923:           
924:           void DecWSW(void)
925:           {
926:               //Komunikat bledu
927:               if(PFNf_ferr || PFNf_fmsg)
488C  B40E     BTFSC PFNf_lato, 2, ACCESS
488E  D002     BRA 0x4894
4890  A60E     BTFSS PFNf_lato, 3, ACCESS
4892  D075     BRA 0x497E
928:               {
929:                   NastawaCOCW();
4894  ECEB     CALL 0x89D6, 0
4896  F044     NOP
930:                   if(PFNf_ferr)
4898  A40E     BTFSS PFNf_lato, 2, ACCESS
489A  D065     BRA 0x4966
931:                   {
932:                       if(!PFNf_KnfDisErr || PFNf_opgres)
489C  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
489E  D002     BRA 0x48A4
48A0  AC10     BTFSS PFNf_ofnserw, 6, ACCESS
48A2  D05E     BRA 0x4960
933:                       {
934:                           if(PFNf_opgres) PrintErr(PFN.KERR, 1); //migajacy kod awaryjny w blokadzie trwalej
48A4  AC10     BTFSS PFNf_ofnserw, 6, ACCESS
48A6  D008     BRA 0x48B8
48A8  0E01     MOVLW 0x1
48AA  0100     MOVLB 0x0
48AC  6FE6     MOVWF counter, BANKED
48AE  0101     MOVLB 0x1
48B0  51E6     MOVF counter, W, BANKED
48B2  EC52     CALL 0xC4A4, 0
48B4  F062     NOP
48B6  D066     BRA 0x4984
935:                           else
936:                           {
937:                               if(PFN.KERR != 7 && PFN.KERR != 9 && PFN.KERR != 0x14) PrintErr(PFN.KERR, 1); //migajacy kod awaryjny w petli glownej
48B8  0E07     MOVLW 0x7
48BA  0101     MOVLB 0x1
48BC  19E6     XORWF counter, W, BANKED
48BE  E00E     BZ 0x48DC
48C0  0E09     MOVLW 0x9
48C2  19E6     XORWF counter, W, BANKED
48C4  E00B     BZ 0x48DC
48C6  0E14     MOVLW 0x14
48C8  19E6     XORWF counter, W, BANKED
48CA  E008     BZ 0x48DC
48CC  0E01     MOVLW 0x1
48CE  0100     MOVLB 0x0
48D0  6FE6     MOVWF counter, BANKED
48D2  0101     MOVLB 0x1
48D4  51E6     MOVF counter, W, BANKED
48D6  EC52     CALL 0xC4A4, 0
48D8  F062     NOP
48DA  D054     BRA 0x4984
938:                               else
939:                               {
940:                                   if(PFN.KERR == 7 || PFN.KERR == 0x14)
48DC  0E07     MOVLW 0x7
48DE  0101     MOVLB 0x1
48E0  19E6     XORWF counter, W, BANKED
48E2  E003     BZ 0x48EA
48E4  0E14     MOVLW 0x14
48E6  19E6     XORWF counter, W, BANKED
48E8  E12D     BNZ 0x4944
941:                                   {
942:                                       if(PFNf_obgCW)
48EA  AC0F     BTFSS PFNf_off, 6, ACCESS
48EC  D015     BRA 0x4918
943:                                       {
944:                                           if(!PFNf_errCW) PrintErrTm(PFN.KERR, PFN.CW, 1, 1);
48EE  BE0D     BTFSC PFNf_b_str_nco, 7, ACCESS
48F0  D00B     BRA 0x4908
48F2  C1E0     MOVFF 0x1E0, counter
48F4  F0E6     NOP
48F6  0E01     MOVLW 0x1
48F8  0100     MOVLB 0x0
48FA  6FE7     MOVWF sign, BANKED
48FC  6FE8     MOVWF quotient, BANKED
48FE  0101     MOVLB 0x1
4900  51E6     MOVF counter, W, BANKED
4902  EC4F     CALL 0xBE9E, 0
4904  F05F     NOP
4906  D03E     BRA 0x4984
945:                                           else PrintErr(PFN.KERR, 1);
4908  0E01     MOVLW 0x1
490A  0100     MOVLB 0x0
490C  6FE6     MOVWF counter, BANKED
490E  0101     MOVLB 0x1
4910  51E6     MOVF counter, W, BANKED
4912  EC52     CALL 0xC4A4, 0
4914  F062     NOP
946:                                       }
4916  D036     BRA 0x4984
947:                                       else
948:                                       {
949:                                           if(!PFNf_errCO) PrintErrTm(PFN.KERR, PFN.CO, 1, 0);
4918  BA0D     BTFSC PFNf_b_str_nco, 5, ACCESS
491A  D00C     BRA 0x4934
491C  C1DF     MOVFF PFN, counter
491E  F0E6     NOP
4920  0E01     MOVLW 0x1
4922  0100     MOVLB 0x0
4924  6FE7     MOVWF sign, BANKED
4926  0E00     MOVLW 0x0
4928  6FE8     MOVWF quotient, BANKED
492A  0101     MOVLB 0x1
492C  51E6     MOVF counter, W, BANKED
492E  EC4F     CALL 0xBE9E, 0
4930  F05F     NOP
4932  D028     BRA 0x4984
950:                                           else PrintErr(PFN.KERR, 1);   
4934  0E01     MOVLW 0x1
4936  0100     MOVLB 0x0
4938  6FE6     MOVWF counter, BANKED
493A  0101     MOVLB 0x1
493C  51E6     MOVF counter, W, BANKED
493E  EC52     CALL 0xC4A4, 0
4940  F062     NOP
951:                                       }
952:                                   }
4942  D020     BRA 0x4984
953:                                   else
954:                                       if(PFN.KERR == 9)
4944  0E09     MOVLW 0x9
4946  0101     MOVLB 0x1
4948  19E6     XORWF counter, W, BANKED
494A  E11C     BNZ 0x4984
955:                                   {
956:                                       PrintErrCs(PFN.KERR, PFN.CS, 1);
494C  C1E1     MOVFF 0x1E1, counter
494E  F0E6     NOP
4950  0E01     MOVLW 0x1
4952  0100     MOVLB 0x0
4954  6FE7     MOVWF sign, BANKED
4956  0101     MOVLB 0x1
4958  51E6     MOVF counter, W, BANKED
495A  EC02     CALL 0xC404, 0
495C  F062     NOP
957:                                   }
958:                               }
959:                           }
960:                       }
495E  D012     BRA 0x4984
961:                       else
962:                       {
963:                           EndErr();
4960  EC43     CALL 0xF286, 0
4962  F079     NOP
964:                       }
965:                   }
4964  D00F     BRA 0x4984
966:                   else
967:                   {
968:                       if(!PFNf_KnfDisErr)
4966  B20C     BTFSC PFNf_b_set_nco, 1, ACCESS
4968  D007     BRA 0x4978
969:                       {
970:                           PrintErr(PFN.KAWR, 0); //staly kod awaryjny
496A  0100     MOVLB 0x0
496C  6BE6     CLRF counter, BANKED
496E  0101     MOVLB 0x1
4970  51E5     MOVF k, W, BANKED
4972  EC52     CALL 0xC4A4, 0
4974  F062     NOP
971:                       }
4976  D006     BRA 0x4984
972:                       else EndErr();
4978  EC43     CALL 0xF286, 0
497A  F079     NOP
973:                   }
974:               }
497C  D003     BRA 0x4984
975:               else
976:               {
977:                   EndErr();
497E  EC43     CALL 0xF286, 0
4980  F079     NOP
4982  D000     BRA 0x4984
978:               }
979:               //Normalna praca urzadzenia
980:               if(!PFNf_opKNF && !PFNf_ferr && !PFNf_fmsg)
4984  A810     BTFSS PFNf_ofnserw, 4, ACCESS
4986  B40E     BTFSC PFNf_lato, 2, ACCESS
4988  D132     BRA 0x4BEE
498A  B60E     BTFSC PFNf_lato, 3, ACCESS
498C  D130     BRA 0x4BEE
981:               {
982:                   if(PFNf_ofoff) //pozycja wylacz
498E  A410     BTFSS PFNf_ofnserw, 2, ACCESS
4990  D034     BRA 0x49FA
983:                   {
984:                       //decyzje o wygaszeniu
985:                       if((PFNf_errCS || PFNf_fnoCS) && !PFNf_tdzCO && !PFNf_tdzCW)
4992  BC0D     BTFSC PFNf_b_str_nco, 6, ACCESS
4994  D002     BRA 0x499A
4996  A80E     BTFSS PFNf_lato, 4, ACCESS
4998  D006     BRA 0x49A6
499A  AE12     BTFSS PFNf_str_nco, 7, ACCESS
499C  B013     BTFSC PFNf_zima, 0, ACCESS
499E  D003     BRA 0x49A6
986:                       {
987:                           PrintOFF(); //dwie kreski
49A0  ECB7     CALL 0xE96E, 0
49A2  F074     NOP
988:                       }
49A4  D124     BRA 0x4BEE
989:                       else
990:                       {
991:                           if(!PFNf_errCS && !PFNf_fnoCS && !PFNf_tdzCO && !PFNf_tdzCW)
49A6  AC0D     BTFSS PFNf_b_str_nco, 6, ACCESS
49A8  B80E     BTFSC PFNf_lato, 4, ACCESS
49AA  D00A     BRA 0x49C0
49AC  AE12     BTFSS PFNf_str_nco, 7, ACCESS
49AE  B013     BTFSC PFNf_zima, 0, ACCESS
49B0  D007     BRA 0x49C0
992:                           {
993:                               EndOFF();
49B2  EC04     CALL 0xF008, 0
49B4  F078     NOP
994:                               PrintCS(PFN.CS); //domyslny wskaz cisnienia
49B6  0101     MOVLB 0x1
49B8  51E1     MOVF GIE_BIT_VAL, W, BANKED
49BA  EC83     CALL 0xE906, 0
49BC  F074     NOP
995:                           }
49BE  D117     BRA 0x4BEE
996:                           else
997:                               if(PFNf_tdzCW && !PFNf_errCW)
49C0  B013     BTFSC PFNf_zima, 0, ACCESS
49C2  BE0D     BTFSC PFNf_b_str_nco, 7, ACCESS
49C4  D009     BRA 0x49D8
998:                           {
999:                               EndOFF();
49C6  EC04     CALL 0xF008, 0
49C8  F078     NOP
1000:                              EndCS();
49CA  EC20     CALL 0xF040, 0
49CC  F078     NOP
1001:                              PrintCW(PFN.CW); //temp. dyzurna CW
49CE  0101     MOVLB 0x1
49D0  51E0     MOVF bdat, W, BANKED
49D2  EC69     CALL 0xE8D2, 0
49D4  F074     NOP
1002:                          }
49D6  D10B     BRA 0x4BEE
1003:                          else
1004:                          {
1005:          
1006:                              if(PFNf_tdzCO && !PFNf_errCO)
49D8  BE12     BTFSC PFNf_str_nco, 7, ACCESS
49DA  BA0D     BTFSC PFNf_b_str_nco, 5, ACCESS
49DC  D00B     BRA 0x49F4
1007:                              {
1008:                                  EndOFF();
49DE  EC04     CALL 0xF008, 0
49E0  F078     NOP
1009:                                  EndCS();
49E2  EC20     CALL 0xF040, 0
49E4  F078     NOP
1010:                                  EndCW();
49E6  EC12     CALL 0xF024, 0
49E8  F078     NOP
1011:                                  PrintCO(PFN.CO); //temp. dyzurna CO
49EA  0101     MOVLB 0x1
49EC  51DF     MOVF pco, W, BANKED
49EE  EC9D     CALL 0xE93A, 0
49F0  F074     NOP
1012:                              }
49F2  D0FD     BRA 0x4BEE
1013:                              else
1014:                              {
1015:                                  PrintOFF();
49F4  ECB7     CALL 0xE96E, 0
49F6  F074     NOP
1016:                              }
1017:                          }
1018:                      }
1019:                  }
49F8  D0FA     BRA 0x4BEE
1020:                  else
1021:                  {
1022:                      //-----------------------------------
1023:                      //tryb LATO
1024:                      if(PFNf_oflato)
49FA  A010     BTFSS PFNf_ofnserw, 0, ACCESS
49FC  D062     BRA 0x4AC2
1025:                      {
1026:                          if(!PFNf_prnaleg)
49FE  BC11     BTFSC PFNf_prn_res, 6, ACCESS
4A00  D059     BRA 0x4AB4
1027:                          //if(!PFNf_aleg && !PFNf_oaleg && !PFNf_set_aleg)
1028:                          {
1029:                              if(PFNf_obgCO || PFNf_tdzCO) //temp. dyzurna CO?
4A02  BA0F     BTFSC PFNf_off, 5, ACCESS
4A04  D002     BRA 0x4A0A
4A06  AE12     BTFSS PFNf_str_nco, 7, ACCESS
4A08  D02B     BRA 0x4A60
1030:                              {
1031:                                  if(PFNf_prn_res)
4A0A  AA11     BTFSS PFNf_prn_res, 5, ACCESS
4A0C  D019     BRA 0x4A40
1032:                                  {
1033:                                      if(PFNf_prn_cs) //czasowy wskaz cisnienia
4A0E  A611     BTFSS PFNf_prn_res, 3, ACCESS
4A10  D007     BRA 0x4A20
1034:                                      {
1035:                                          EndOFF();
4A12  EC04     CALL 0xF008, 0
4A14  F078     NOP
1036:                                          PrintCS(PFN.CS); //wylaczny wskaz CS
4A16  0101     MOVLB 0x1
4A18  51E1     MOVF GIE_BIT_VAL, W, BANKED
4A1A  EC83     CALL 0xE906, 0
4A1C  F074     NOP
1037:                                      }
4A1E  D0E4     BRA 0x4BE8
1038:          							else
1039:          							{
1040:          								if(PFNf_prn_in) 
4A20  A811     BTFSS PFNf_prn_res, 4, ACCESS
4A22  D00B     BRA 0x4A3A
1041:          								{
1042:                                              EndOFF();
4A24  EC04     CALL 0xF008, 0
4A26  F078     NOP
1043:                                              EndCS();
4A28  EC20     CALL 0xF040, 0
4A2A  F078     NOP
1044:                                              EndCW();                                    
4A2C  EC12     CALL 0xF024, 0
4A2E  F078     NOP
1045:          									PrintCO(PFN.IN);							//czasowy wskaz IN
4A30  0101     MOVLB 0x1
4A32  51E2     MOVF divisor, W, BANKED
4A34  EC9D     CALL 0xE93A, 0
4A36  F074     NOP
1046:          								}
4A38  D0D7     BRA 0x4BE8
1047:                                          else EndCS();
4A3A  EC20     CALL 0xF040, 0
4A3C  F078     NOP
1048:          							}                            
1049:                                  }
4A3E  D0D4     BRA 0x4BE8
1050:                                  else
1051:                                  {
1052:                                      if(!PFNf_errCO)
4A40  BA0D     BTFSC PFNf_b_str_nco, 5, ACCESS
4A42  D00B     BRA 0x4A5A
1053:                                      {
1054:                                          EndOFF();
4A44  EC04     CALL 0xF008, 0
4A46  F078     NOP
1055:                                          EndCS();
4A48  EC20     CALL 0xF040, 0
4A4A  F078     NOP
1056:                                          EndCW();
4A4C  EC12     CALL 0xF024, 0
4A4E  F078     NOP
1057:                                          PrintCO(PFN.CO); //wylaczny wskaz temperatury CO
4A50  0101     MOVLB 0x1
4A52  51DF     MOVF pco, W, BANKED
4A54  EC9D     CALL 0xE93A, 0
4A56  F074     NOP
1058:                                      }
4A58  D0C7     BRA 0x4BE8
1059:                                      else
1060:                                      {
1061:                                          PrintOFF();
4A5A  ECB7     CALL 0xE96E, 0
4A5C  F074     NOP
1062:                                      }
1063:                                  }
1064:                              }
4A5E  D0C4     BRA 0x4BE8
1065:                              else //wskaz/praca CW
1066:                              {
1067:                                  if(PFNf_prn_res)
4A60  AA11     BTFSS PFNf_prn_res, 5, ACCESS
4A62  D019     BRA 0x4A96
1068:                                  {
1069:                                      if(PFNf_prn_cs) //czasowy wskaz cisnienia
4A64  A611     BTFSS PFNf_prn_res, 3, ACCESS
4A66  D007     BRA 0x4A76
1070:                                      {
1071:                                          EndOFF();
4A68  EC04     CALL 0xF008, 0
4A6A  F078     NOP
1072:                                          PrintCS(PFN.CS); //wylaczny wskaz temp CW
4A6C  0101     MOVLB 0x1
4A6E  51E1     MOVF GIE_BIT_VAL, W, BANKED
4A70  EC83     CALL 0xE906, 0
4A72  F074     NOP
1073:                                      }
4A74  D0B9     BRA 0x4BE8
1074:          							else
1075:          							{
1076:          								if(PFNf_prn_in) 
4A76  A811     BTFSS PFNf_prn_res, 4, ACCESS
4A78  D00B     BRA 0x4A90
1077:          								{
1078:                                              EndOFF();
4A7A  EC04     CALL 0xF008, 0
4A7C  F078     NOP
1079:                                              EndCS();
4A7E  EC20     CALL 0xF040, 0
4A80  F078     NOP
1080:                                              EndCW(); 
4A82  EC12     CALL 0xF024, 0
4A84  F078     NOP
1081:          									PrintCO(PFN.IN);							//czasowy wskaz IN
4A86  0101     MOVLB 0x1
4A88  51E2     MOVF divisor, W, BANKED
4A8A  EC9D     CALL 0xE93A, 0
4A8C  F074     NOP
1082:          								}
4A8E  D0AC     BRA 0x4BE8
1083:                                          else EndCS();
4A90  EC20     CALL 0xF040, 0
4A92  F078     NOP
1084:          							}                            
1085:                                  }
4A94  D0A9     BRA 0x4BE8
1086:                                  else //tylko wskaz temp. CW przy pobudzeniu
1087:                                  {
1088:                                      if(!PFNf_errCW && PFNf_obgCW)
4A96  AE0D     BTFSS PFNf_b_str_nco, 7, ACCESS
4A98  AC0F     BTFSS PFNf_off, 6, ACCESS
4A9A  D009     BRA 0x4AAE
1089:                                      {
1090:                                          EndOFF();
4A9C  EC04     CALL 0xF008, 0
4A9E  F078     NOP
1091:                                          EndCS();
4AA0  EC20     CALL 0xF040, 0
4AA2  F078     NOP
1092:                                          PrintCW(PFN.CW); //temp. dyzurna CW
4AA4  0101     MOVLB 0x1
4AA6  51E0     MOVF bdat, W, BANKED
4AA8  EC69     CALL 0xE8D2, 0
4AAA  F074     NOP
1093:                                      }
4AAC  D09D     BRA 0x4BE8
1094:                                      else
1095:                                      {
1096:                                          PrintOFF(); //dwie kreski
4AAE  ECB7     CALL 0xE96E, 0
4AB0  F074     NOP
1097:                                      }
1098:                                  }
1099:                              }
1100:                          }
4AB2  D09A     BRA 0x4BE8
1101:                          else
1102:                          {
1103:                                  EndOFF();
4AB4  EC04     CALL 0xF008, 0
4AB6  F078     NOP
1104:                                  EndCS();
4AB8  EC20     CALL 0xF040, 0
4ABA  F078     NOP
1105:                                  PrintAL();
4ABC  ECD0     CALL 0xE9A0, 0
4ABE  F074     NOP
1106:                          }
1107:                      }
4AC0  D093     BRA 0x4BE8
1108:                      else
1109:                      //-----------------------------------
1110:                      //tryb ZIMA
1111:                      if(PFNf_ofzima)
4AC2  A610     BTFSS PFNf_ofnserw, 3, ACCESS
4AC4  D091     BRA 0x4BE8
1112:                      {
1113:                          if(!PFNf_prnserw && !PFNf_prnaleg)
4AC6  AE11     BTFSS PFNf_prn_res, 7, ACCESS
4AC8  BC11     BTFSC PFNf_prn_res, 6, ACCESS
4ACA  D07C     BRA 0x4BC4
1114:                          //if(!PFNf_ofnserw && !PFNf_oaleg && !PFNf_set_fnserw && !PFNf_set_aleg)
1115:                          {
1116:                              if(!PFNf_obgCO && !PFNf_obgCW) //oba obiegi nieaktywne?
4ACC  AA0F     BTFSS PFNf_off, 5, ACCESS
4ACE  BC0F     BTFSC PFNf_off, 6, ACCESS
4AD0  D023     BRA 0x4B18
1117:                              {
1118:                                  if(PFNf_prn_res)
4AD2  AA11     BTFSS PFNf_prn_res, 5, ACCESS
4AD4  D019     BRA 0x4B08
1119:                                  {
1120:                                      if(PFNf_prn_cs)
4AD6  A611     BTFSS PFNf_prn_res, 3, ACCESS
4AD8  D007     BRA 0x4AE8
1121:                                      {
1122:                                          EndOFF();
4ADA  EC04     CALL 0xF008, 0
4ADC  F078     NOP
1123:                                          PrintCS(PFN.CS); //wylaczny wskaz CS
4ADE  0101     MOVLB 0x1
4AE0  51E1     MOVF GIE_BIT_VAL, W, BANKED
4AE2  EC83     CALL 0xE906, 0
4AE4  F074     NOP
1124:                                      }
4AE6  D080     BRA 0x4BE8
1125:          							else
1126:          							{
1127:          								if(PFNf_prn_in) 
4AE8  A811     BTFSS PFNf_prn_res, 4, ACCESS
4AEA  D00B     BRA 0x4B02
1128:          								{
1129:                                              EndOFF();
4AEC  EC04     CALL 0xF008, 0
4AEE  F078     NOP
1130:                                              EndCS();
4AF0  EC20     CALL 0xF040, 0
4AF2  F078     NOP
1131:                                              EndCW(); 
4AF4  EC12     CALL 0xF024, 0
4AF6  F078     NOP
1132:          									PrintCO(PFN.IN);							//czasowy wskaz IN
4AF8  0101     MOVLB 0x1
4AFA  51E2     MOVF divisor, W, BANKED
4AFC  EC9D     CALL 0xE93A, 0
4AFE  F074     NOP
1133:          								}
4B00  D073     BRA 0x4BE8
1134:                                          else EndCS();
4B02  EC20     CALL 0xF040, 0
4B04  F078     NOP
1135:                                      }
1136:                                      //else EndCS();
1137:                                      //else
1138:                                      //if(PFNf_prn_in) PrintIN(PFN.IN);							//wylaczny wskaz IN
1139:                                  }
4B06  D070     BRA 0x4BE8
1140:                                  else
1141:                                  {
1142:                                      if(PFNf_fL3) PrintL3();
4B08  A20E     BTFSS PFNf_lato, 1, ACCESS
4B0A  D003     BRA 0x4B12
4B0C  EC5D     CALL 0xC0BA, 0
4B0E  F060     NOP
4B10  D06B     BRA 0x4BE8
1143:                                      else
1144:                                      {
1145:                                          PrintOFF();
4B12  ECB7     CALL 0xE96E, 0
4B14  F074     NOP
1146:                                      }
1147:                                  }
1148:                              }
4B16  D068     BRA 0x4BE8
1149:                              else //dowolny obieg aktywny
1150:                              {
1151:                                  if(PFNf_obgCO) //aktywny obieg CO?
4B18  AA0F     BTFSS PFNf_off, 5, ACCESS
4B1A  D02B     BRA 0x4B72
1152:                                  {
1153:                                      if(PFNf_prn_res)
4B1C  AA11     BTFSS PFNf_prn_res, 5, ACCESS
4B1E  D019     BRA 0x4B52
1154:                                      {
1155:                                          if(PFNf_prn_cs)
4B20  A611     BTFSS PFNf_prn_res, 3, ACCESS
4B22  D007     BRA 0x4B32
1156:                                          {
1157:                                              EndOFF();
4B24  EC04     CALL 0xF008, 0
4B26  F078     NOP
1158:                                              PrintCS(PFN.CS); //wylaczny wskaz CS
4B28  0101     MOVLB 0x1
4B2A  51E1     MOVF GIE_BIT_VAL, W, BANKED
4B2C  EC83     CALL 0xE906, 0
4B2E  F074     NOP
1159:                                          }
4B30  D05B     BRA 0x4BE8
1160:                                          else
1161:                                          {
1162:                                              if(PFNf_prn_in) 
4B32  A811     BTFSS PFNf_prn_res, 4, ACCESS
4B34  D00B     BRA 0x4B4C
1163:                                              {
1164:                                                  EndOFF();
4B36  EC04     CALL 0xF008, 0
4B38  F078     NOP
1165:                                                  EndCS();
4B3A  EC20     CALL 0xF040, 0
4B3C  F078     NOP
1166:                                                  EndCW(); 
4B3E  EC12     CALL 0xF024, 0
4B40  F078     NOP
1167:                                                  PrintCO(PFN.IN);							//czasowy wskaz IN
4B42  0101     MOVLB 0x1
4B44  51E2     MOVF divisor, W, BANKED
4B46  EC9D     CALL 0xE93A, 0
4B48  F074     NOP
1168:                                              }
4B4A  D04E     BRA 0x4BE8
1169:                                              else EndCS();
4B4C  EC20     CALL 0xF040, 0
4B4E  F078     NOP
1170:                                          }                                
1171:                                          //else EndCS();
1172:                                          //else
1173:                                          //if(PFNf_prn_in) PrintIN(PFN.IN);						//wylaczny wskaz IN
1174:                                      }
4B50  D04B     BRA 0x4BE8
1175:                                      else //wskaz CO
1176:                                      {
1177:                                          if(!PFNf_errCO)
4B52  BA0D     BTFSC PFNf_b_str_nco, 5, ACCESS
4B54  D00B     BRA 0x4B6C
1178:                                          {
1179:                                              EndOFF();
4B56  EC04     CALL 0xF008, 0
4B58  F078     NOP
1180:                                              EndCS();
4B5A  EC20     CALL 0xF040, 0
4B5C  F078     NOP
1181:                                              EndCW();
4B5E  EC12     CALL 0xF024, 0
4B60  F078     NOP
1182:                                              PrintCO(PFN.CO); //wylaczny wskaz temp CO
4B62  0101     MOVLB 0x1
4B64  51DF     MOVF pco, W, BANKED
4B66  EC9D     CALL 0xE93A, 0
4B68  F074     NOP
1183:                                          }
4B6A  D03E     BRA 0x4BE8
1184:                                          else PrintOFF();
4B6C  ECB7     CALL 0xE96E, 0
4B6E  F074     NOP
1185:                                      }
1186:                                  }
4B70  D03B     BRA 0x4BE8
1187:                                  else //aktywny obieg CW
1188:                                  {
1189:                                      if(PFNf_prn_res)
4B72  AA11     BTFSS PFNf_prn_res, 5, ACCESS
4B74  D019     BRA 0x4BA8
1190:                                      {
1191:                                          if(PFNf_prn_cs) //aktywny wskaz cisnienia?
4B76  A611     BTFSS PFNf_prn_res, 3, ACCESS
4B78  D007     BRA 0x4B88
1192:                                          {
1193:                                              EndOFF();
4B7A  EC04     CALL 0xF008, 0
4B7C  F078     NOP
1194:                                              PrintCS(PFN.CS); //dzielony wskaz CS
4B7E  0101     MOVLB 0x1
4B80  51E1     MOVF GIE_BIT_VAL, W, BANKED
4B82  EC83     CALL 0xE906, 0
4B84  F074     NOP
1195:                                          }
4B86  D030     BRA 0x4BE8
1196:                                          else
1197:                                          {
1198:                                              if(PFNf_prn_in) 
4B88  A811     BTFSS PFNf_prn_res, 4, ACCESS
4B8A  D00B     BRA 0x4BA2
1199:                                              {
1200:                                                  EndOFF();
4B8C  EC04     CALL 0xF008, 0
4B8E  F078     NOP
1201:                                                  EndCS();
4B90  EC20     CALL 0xF040, 0
4B92  F078     NOP
1202:                                                  EndCW(); 
4B94  EC12     CALL 0xF024, 0
4B96  F078     NOP
1203:                                                  PrintCO(PFN.IN);							//czasowy wskaz IN
4B98  0101     MOVLB 0x1
4B9A  51E2     MOVF divisor, W, BANKED
4B9C  EC9D     CALL 0xE93A, 0
4B9E  F074     NOP
1204:                                              }
4BA0  D023     BRA 0x4BE8
1205:                                              else EndCS();
4BA2  EC20     CALL 0xF040, 0
4BA4  F078     NOP
1206:                                          }
1207:                                      }
4BA6  D020     BRA 0x4BE8
1208:                                      else //wskaz CW
1209:                                      {
1210:          
1211:                                          if(!PFNf_errCW)
4BA8  BE0D     BTFSC PFNf_b_str_nco, 7, ACCESS
4BAA  D009     BRA 0x4BBE
1212:                                          {
1213:                                              EndOFF();
4BAC  EC04     CALL 0xF008, 0
4BAE  F078     NOP
1214:                                              EndCS();
4BB0  EC20     CALL 0xF040, 0
4BB2  F078     NOP
1215:                                              PrintCW(PFN.CW); //wylaczny wskaz temp CW
4BB4  0101     MOVLB 0x1
4BB6  51E0     MOVF bdat, W, BANKED
4BB8  EC69     CALL 0xE8D2, 0
4BBA  F074     NOP
1216:                                          }
4BBC  D015     BRA 0x4BE8
1217:                                          else PrintOFF();
4BBE  ECB7     CALL 0xE96E, 0
4BC0  F074     NOP
1218:                                      }
1219:                                  }
1220:                              }
1221:                          }
4BC2  D012     BRA 0x4BE8
1222:                          else //aktywna funkcja serwisowa lub antylegionella
1223:                          {
1224:                              if(PFNf_prnserw) //aktywna funkcja serwisowa?
4BC4  AE11     BTFSS PFNf_prn_res, 7, ACCESS
4BC6  D009     BRA 0x4BDA
1225:                              {
1226:                                  EndOFF();
4BC8  EC04     CALL 0xF008, 0
4BCA  F078     NOP
1227:                                  EndCS();
4BCC  EC20     CALL 0xF040, 0
4BCE  F078     NOP
1228:                                  EndCW();
4BD0  EC12     CALL 0xF024, 0
4BD2  F078     NOP
1229:                                  PrintSR();
4BD4  ECDF     CALL 0xE5BE, 0
4BD6  F072     NOP
1230:                              }
4BD8  D007     BRA 0x4BE8
1231:                              else //aktywna funkcja antylegionella
1232:                              {
1233:                                  EndOFF();
4BDA  EC04     CALL 0xF008, 0
4BDC  F078     NOP
1234:                                  EndCS();
4BDE  EC20     CALL 0xF040, 0
4BE0  F078     NOP
1235:                                  PrintAL();
4BE2  ECD0     CALL 0xE9A0, 0
4BE4  F074     NOP
1236:                              }
1237:                          }
1238:                      }
4BE6  D000     BRA 0x4BE8
1239:                      //-----------------------------------
1240:                      //nastawa CO/CW
1241:                      NastawaCOCW();
4BE8  ECEB     CALL 0x89D6, 0
4BEA  F044     NOP
1242:                      //-----------------------------------
1243:                  }
4BEC  D000     BRA 0x4BEE
1244:              }
1245:              if(!PFNf_fL3)
4BEE  A20E     BTFSS PFNf_lato, 1, ACCESS
1246:              {
1247:                  EndL3();
4BF0  ECE1     CALL 0xF3C2, 0
4BF2  F079     NOP
4BF4  D000     BRA 0x4BF6
1248:              }
1249:              if(!PFNf_prnserw) EndSR();
4BF6  AE11     BTFSS PFNf_prn_res, 7, ACCESS
4BF8  EC49     CALL 0xF092, 0
4BFA  F078     NOP
4BFC  D000     BRA 0x4BFE
1250:              if(!PFNf_prnaleg) EndAL();
4BFE  AC11     BTFSS PFNf_prn_res, 6, ACCESS
4C00  EC56     CALL 0xF0AC, 0
4C02  F078     NOP
4C04  D000     BRA 0x4C06
1251:              //stan plomienia
1252:              SetDiode(_DPL, PFNf_plmCW || PFNf_plmCO);
4C06  0E01     MOVLW 0x1
4C08  0103     MOVLB 0x3
4C0A  6F86     MOVWF _PFNf_opgres, BANKED
4C0C  A211     BTFSS PFNf_prn_res, 1, ACCESS
4C0E  B011     BTFSC PFNf_prn_res, 0, ACCESS
4C10  D004     BRA 0x4C1A
4C12  0E00     MOVLW 0x0
4C14  0103     MOVLB 0x3
4C16  6F86     MOVWF _PFNf_opgres, BANKED
4C18  D000     BRA 0x4C1A
4C1A  C386     MOVFF 0x386, pco
4C1C  F0DF     NOP
4C1E  0E01     MOVLW 0x1
4C20  EC3C     CALL 0xF078, 0
4C22  F078     NOP
1253:              //funkcja serwisowa
1254:              SetDiode(_DKM, PFNf_ofnserw || PFNf_oaleg);
4C24  0E01     MOVLW 0x1
4C26  0103     MOVLB 0x3
4C28  6F87     MOVWF _PFNf_pgd, BANKED
4C2A  A210     BTFSS PFNf_ofnserw, 1, ACCESS
4C2C  B80F     BTFSC PFNf_off, 4, ACCESS
4C2E  D004     BRA 0x4C38
4C30  0E00     MOVLW 0x0
4C32  0103     MOVLB 0x3
4C34  6F87     MOVWF _PFNf_pgd, BANKED
4C36  D000     BRA 0x4C38
4C38  C387     MOVFF 0x387, pco
4C3A  F0DF     NOP
4C3C  0E04     MOVLW 0x4
4C3E  EC3C     CALL 0xF078, 0
4C40  F078     NOP
1255:              //sygnalizacja obiegu
1256:              SetDiode(_DCO, PFNf_ofzima && !PFNf_ofoff && !PFNf_opKNF);
4C42  0E00     MOVLW 0x0
4C44  0103     MOVLB 0x3
4C46  6F88     MOVWF _PFNf_plmCO, BANKED
4C48  B610     BTFSC PFNf_ofnserw, 3, ACCESS
4C4A  B410     BTFSC PFNf_ofnserw, 2, ACCESS
4C4C  D006     BRA 0x4C5A
4C4E  B810     BTFSC PFNf_ofnserw, 4, ACCESS
4C50  D004     BRA 0x4C5A
4C52  0E01     MOVLW 0x1
4C54  0103     MOVLB 0x3
4C56  6F88     MOVWF _PFNf_plmCO, BANKED
4C58  D000     BRA 0x4C5A
4C5A  C388     MOVFF 0x388, pco
4C5C  F0DF     NOP
4C5E  0E02     MOVLW 0x2
4C60  EC3C     CALL 0xF078, 0
4C62  F078     NOP
1257:              SetDiode(_DCW, (PFNf_ofzima || PFNf_oflato) && !PFNf_ofoff && !PFNf_opKNF);
4C64  0E00     MOVLW 0x0
4C66  0103     MOVLB 0x3
4C68  6F89     MOVWF _PFNf_plmCW, BANKED
4C6A  B610     BTFSC PFNf_ofnserw, 3, ACCESS
4C6C  D002     BRA 0x4C72
4C6E  A010     BTFSS PFNf_ofnserw, 0, ACCESS
4C70  D007     BRA 0x4C80
4C72  A410     BTFSS PFNf_ofnserw, 2, ACCESS
4C74  B810     BTFSC PFNf_ofnserw, 4, ACCESS
4C76  D004     BRA 0x4C80
4C78  0E01     MOVLW 0x1
4C7A  0103     MOVLB 0x3
4C7C  6F89     MOVWF _PFNf_plmCW, BANKED
4C7E  D000     BRA 0x4C80
4C80  C389     MOVFF 0x389, pco
4C82  F0DF     NOP
4C84  0E08     MOVLW 0x8
4C86  EC3C     CALL 0xF078, 0
4C88  F078     NOP
1258:          }
4C8A  0012     RETURN 0
1259:          
1260:          //------------------
1261:          //------------------
1262:          //Reakcja na wiekszosc stanow awaryjnych
1263:          
1264:          void DecERR(void)
1265:          {
1266:              //unsigned char KnfDisErr = 0;
1267:              unsigned char w;
1268:          
1269:              //Znacznik wylaczajacy wizualizacje kodu bledu podczas pracy w proc. konfiguracji
1270:          
1271:              //KnfDisErr=(Mf_AKTYWNE_KNF&&(DtKNF.KRK==1||(DtKNF.KRK==2&&(DtKNF.PRM==4||DtKNF.PRM==6||DtKNF.PRM==7))))?1:0;
1272:          
1273:              //--------BEZWZGLEDNE WYLACZENIE Z BLOKADA
1274:              //UWAGA: natychmiastowe wyswietlenie kodu awaryjnego
1275:              //zadzialalo STB
1276:              if(!RdPrt(S_STB))
5E62  0E04     MOVLW 0x4
5E64  ECFD     CALL 0xE7FA, 0
5E66  F073     NOP
5E68  E209     BC 0x5E7C
1277:              {
1278:                  M.ERR_BTY = 0x02;
5E6A  0E02     MOVLW 0x2
5E6C  0100     MOVLB 0x0
5E6E  6F87     MOVWF _PFNf_pgd, BANKED
1279:                  //PrintErr(0x02,1);
1280:                  SetErr(0x02);
5E70  0E02     MOVLW 0x2
5E72  ECC7     CALL 0xF38E, 0
5E74  F079     NOP
1281:                  ErrPTG();
5E76  ECCC     CALL 0x8798, 0
5E78  F043     NOP
5E7A  D000     BRA 0x5E7C
1282:              }
1283:              //--------BEZWZGLEDNE WYLACZENIE BEZ BLOKADY
1284:              if(Mf_RUSZ_PLOMIEN)
5E7C  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
5E7E  D010     BRA 0x5EA0
1285:              {
1286:                  M.ERR_BTY = 0; //wyzeruj wszystkie wczesniejsze kody
5E80  0100     MOVLB 0x0
5E82  6B87     CLRF _PFNf_pgd, BANKED
1287:                  //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1288:                  //else PrintErr(0x01,0);
1289:                  if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5E84  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5E86  D003     BRA 0x5E8E
5E88  EC43     CALL 0xF286, 0
5E8A  F079     NOP
5E8C  D019     BRA 0x5EC0
1290:                  else SetMsg(0x01);
5E8E  0E01     MOVLW 0x1
5E90  ECC1     CALL 0xF382, 0
5E92  F079     NOP
5E94  D015     BRA 0x5EC0
1291:                  Mf_RUSZ_NTC_CO = 0;
5E96  D014     BRA 0x5EC0
1292:                  Mf_RUSZ_CISN = 0;
5E98  9E08     BCF Mf_ROZRUCH, 7, ACCESS
1293:                  Mf_RUSZ_NCISN = 0;
5E9A  D014     BRA 0x5EC4
1294:                  Mf_RUSZ_NTC_CW = 0;
5E9C  9609     BCF Mf_RUSZ_PWR, 3, ACCESS
1295:                  Mf_RUSZ_MOD = 0;
5E9E  D052     BRA 0x5F44
1296:              }
1297:              else
1298:                  if(Mf_RUSZ_CIAG)
5EA0  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
5EA2  D012     BRA 0x5EC8
1299:              {
1300:                  M.ERR_BTY = 0; //wyzeruj wszystkie wczesniejsze kody
5EA4  0E00     MOVLW 0x0
5EA6  0100     MOVLB 0x0
5EA8  6F87     MOVWF _PFNf_pgd, BANKED
1301:                  /*if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1302:                  else
1303:                  {
1304:                          if(Mf_prb_CIG)
1305:                          {
1306:                                  PrintErr(0x03,0);
1307:                          }
1308:                  }*/
1309:                  if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5EAA  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5EAC  D003     BRA 0x5EB4
5EAE  EC43     CALL 0xF286, 0
5EB0  F079     NOP
5EB2  D006     BRA 0x5EC0
1310:                  else
1311:                  {
1312:                      if(Mf_prb_CIG) SetMsg(0x03);
5EB4  AC0B     BTFSS Mf_pob_KCO, 6, ACCESS
5EB6  D004     BRA 0x5EC0
5EB8  0E03     MOVLW 0x3
5EBA  ECC1     CALL 0xF382, 0
5EBC  F079     NOP
5EBE  D000     BRA 0x5EC0
1313:                  }
1314:                  Mf_RUSZ_NTC_CO = 0;
5EC0  9409     BCF Mf_RUSZ_PWR, 2, ACCESS
1315:                  Mf_RUSZ_CISN = 0;
5EC2  D7EA     BRA 0x5E98
1316:                  Mf_RUSZ_NCISN = 0;
5EC4  9209     BCF Mf_RUSZ_PWR, 1, ACCESS
1317:                  Mf_RUSZ_NTC_CW = 0;
5EC6  D7EA     BRA 0x5E9C
1318:                  Mf_RUSZ_MOD = 0;
1319:              }
1320:              else
1321:                  //awaria czujnika CO (wersja dla kotla mono i bitermicznego)
1322:                  if((RdPrt(S_ERR_CO) && (DtKNF.tpkt != _BITERM) && (DtKNF.tpkt != _BITERM2)) || (RdPrt(S_ERR_CO) && !Mf_pob_KCW && !Mf_pob_CW && (DtKNF.tpkt == _BITERM || DtKNF.tpkt == _BITERM2)))
5EC8  0E12     MOVLW 0x12
5ECA  ECFD     CALL 0xE7FA, 0
5ECC  F073     NOP
5ECE  E306     BNC 0x5EDC
5ED0  0100     MOVLB 0x0
5ED2  059E     DECF _PWMf_ENPWM2, W, BANKED
5ED4  E003     BZ 0x5EDC
5ED6  0E02     MOVLW 0x2
5ED8  199E     XORWF _PWMf_ENPWM2, W, BANKED
5EDA  E110     BNZ 0x5EFC
5EDC  0E12     MOVLW 0x12
5EDE  ECFD     CALL 0xE7FA, 0
5EE0  F073     NOP
5EE2  B0D8     BTFSC STATUS, 0, ACCESS
5EE4  B80B     BTFSC Mf_pob_KCO, 4, ACCESS
5EE6  D01A     BRA 0x5F1C
5EE8  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
5EEA  D018     BRA 0x5F1C
5EEC  0100     MOVLB 0x0
5EEE  059E     DECF _PWMf_ENPWM2, W, BANKED
5EF0  E005     BZ 0x5EFC
5EF2  0E02     MOVLW 0x2
5EF4  199E     XORWF _PWMf_ENPWM2, W, BANKED
5EF6  E002     BZ 0x5EFC
5EF8  D011     BRA 0x5F1C
5EFA  D000     BRA 0x5EFC
1323:              {
1324:                  M.ERR_BTY = 0x04;
5EFC  0E04     MOVLW 0x4
5EFE  0100     MOVLB 0x0
5F00  6F87     MOVWF _PFNf_pgd, BANKED
1325:                  //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1326:                  //else PrintErr(0x04,1);
1327:                  if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5F02  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5F04  D003     BRA 0x5F0C
5F06  EC43     CALL 0xF286, 0
5F08  F079     NOP
5F0A  D004     BRA 0x5F14
1328:                  else SetErr(0x04);
5F0C  0E04     MOVLW 0x4
5F0E  ECC7     CALL 0xF38E, 0
5F10  F079     NOP
5F12  D000     BRA 0x5F14
1329:                  Mf_RUSZ_NTC_CO = 1;
5F14  8409     BSF Mf_RUSZ_PWR, 2, ACCESS
1330:                  Mf_RUSZ_CISN = 0;
5F16  D7C0     BRA 0x5E98
1331:                  Mf_RUSZ_NCISN = 0;
5F18  9209     BCF Mf_RUSZ_PWR, 1, ACCESS
1332:                  Mf_RUSZ_NTC_CW = 0;
5F1A  D7C0     BRA 0x5E9C
1333:                  Mf_RUSZ_MOD = 0;
1334:              }
1335:              else
1336:              {
1337:                  Mf_RUSZ_NTC_CO = 0;
5F1C  9409     BCF Mf_RUSZ_PWR, 2, ACCESS
1338:                  //brak przeplywu WG
1339:                  if(Mf_RUSZ_POMPE)
5F1E  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
5F20  D013     BRA 0x5F48
1340:                  {
1341:                      M.ERR_BTY = 0;
5F22  0E00     MOVLW 0x0
5F24  0100     MOVLB 0x0
5F26  6F87     MOVWF _PFNf_pgd, BANKED
1342:                      /*if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1343:                      else
1344:                      {
1345:                              if(Mf_prb_PRZ) PrintErr(0x05,0);
1346:                      }*/
1347:                      if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5F28  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5F2A  D003     BRA 0x5F32
5F2C  EC43     CALL 0xF286, 0
5F2E  F079     NOP
5F30  D7B3     BRA 0x5E98
1348:                      else
1349:                      {
1350:                          if(Mf_prb_PRZ) SetMsg(0x05);
5F32  AE0B     BTFSS Mf_pob_KCO, 7, ACCESS
5F34  D7B1     BRA 0x5E98
5F36  0E05     MOVLW 0x5
5F38  ECC1     CALL 0xF382, 0
5F3A  F079     NOP
5F3C  D7AD     BRA 0x5E98
1351:                      }
1352:                      Mf_RUSZ_CISN = 0;
5F3E  D7AC     BRA 0x5E98
1353:                      Mf_RUSZ_NCISN = 0;
5F40  9209     BCF Mf_RUSZ_PWR, 1, ACCESS
1354:                      Mf_RUSZ_NTC_CW = 0;
5F42  D7AC     BRA 0x5E9C
1355:                      Mf_RUSZ_MOD = 0;
5F44  9009     BCF Mf_RUSZ_PWR, 0, ACCESS
1356:                  }
5F46  D0A3     BRA 0x608E
1357:                  else
1358:                  {
1359:                      //awaria obwodu czujnika cisnienia
1360:                      if(RdPrt(S_ERR_CSN))
5F48  0E0E     MOVLW 0xE
5F4A  ECFD     CALL 0xE7FA, 0
5F4C  F073     NOP
5F4E  E310     BNC 0x5F70
1361:                      {
1362:                          M.ERR_BTY = 0x08;
5F50  0E08     MOVLW 0x8
5F52  0100     MOVLB 0x0
5F54  6F87     MOVWF _PFNf_pgd, BANKED
1363:                          //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1364:                          //else PrintErr(0x08,1);
1365:                          if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5F56  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5F58  D003     BRA 0x5F60
5F5A  EC43     CALL 0xF286, 0
5F5C  F079     NOP
5F5E  D004     BRA 0x5F68
1366:                          else SetErr(0x08);
5F60  0E08     MOVLW 0x8
5F62  ECC7     CALL 0xF38E, 0
5F64  F079     NOP
5F66  D000     BRA 0x5F68
1367:                          Mf_RUSZ_NCISN = 1;
5F68  8209     BSF Mf_RUSZ_PWR, 1, ACCESS
1368:                          Mf_RUSZ_CISN = 0;
5F6A  9E08     BCF Mf_ROZRUCH, 7, ACCESS
1369:                          Mf_RUSZ_NTC_CW = 0;
5F6C  D797     BRA 0x5E9C
1370:                          Mf_RUSZ_MOD = 0;
5F6E  D7EA     BRA 0x5F44
1371:                      }
1372:                      else
1373:                      {
1374:                          Mf_RUSZ_NCISN = 0;
5F70  9209     BCF Mf_RUSZ_PWR, 1, ACCESS
1375:                          //zbyt niskie lub zbyt wysokie cisnienie w obiegu CO
1376:                          if(!RdPrt(S_WRK_CSN))
5F72  0E0F     MOVLW 0xF
5F74  ECFD     CALL 0xE7FA, 0
5F76  F073     NOP
5F78  E20F     BC 0x5F98
1377:                          {
1378:          
1379:                              M.ERR_BTY = 0x09;
5F7A  0E09     MOVLW 0x9
5F7C  0100     MOVLB 0x0
5F7E  6F87     MOVWF _PFNf_pgd, BANKED
1380:                              //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1381:                              //else PrintErrCs(0x09,DtCS.CS,1);
1382:                              if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
5F80  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
5F82  D003     BRA 0x5F8A
5F84  EC43     CALL 0xF286, 0
5F86  F079     NOP
5F88  D004     BRA 0x5F92
1383:                              else SetErr(0x09);
5F8A  0E09     MOVLW 0x9
5F8C  ECC7     CALL 0xF38E, 0
5F8E  F079     NOP
5F90  D000     BRA 0x5F92
1384:                              //SetMsg(0x09);
1385:                              Mf_RUSZ_CISN = 1;
5F92  8E08     BSF Mf_ROZRUCH, 7, ACCESS
1386:                              Mf_RUSZ_NTC_CW = 0;
5F94  D783     BRA 0x5E9C
1387:                              Mf_RUSZ_MOD = 0;
5F96  D7D6     BRA 0x5F44
1388:                          }
1389:                          else
1390:                          {
1391:                              Mf_RUSZ_CISN = 0;
5F98  9E08     BCF Mf_ROZRUCH, 7, ACCESS
1392:                              if(DtKNF.tpkt != _UNICO)
5F9A  0100     MOVLB 0x0
5F9C  519E     MOVF _PWMf_ENPWM2, W, BANKED
5F9E  E01B     BZ 0x5FD6
1393:                              {
1394:                                  w = (DtCWf_err_CW && (PFN.poz == _PFLTO)) || ((PFN.poz == _PFZMA) && DtCWf_err_CW && (Mf_pob_CW || Mf_pob_KCW || Mf_pob_AL));
5FA0  0E01     MOVLW 0x1
5FA2  0103     MOVLB 0x3
5FA4  6F8C     MOVWF _PFNf_prn_in, BANKED
5FA6  A804     BTFSS DtCWf_err_CW, 4, ACCESS
5FA8  D004     BRA 0x5FB2
5FAA  0E02     MOVLW 0x2
5FAC  0101     MOVLB 0x1
5FAE  19F3     XORWF min, W, BANKED
5FB0  E00F     BZ 0x5FD0
5FB2  0E03     MOVLW 0x3
5FB4  0101     MOVLB 0x1
5FB6  19F3     XORWF min, W, BANKED
5FB8  B4D8     BTFSC STATUS, 2, ACCESS
5FBA  A804     BTFSS DtCWf_err_CW, 4, ACCESS
5FBC  D005     BRA 0x5FC8
5FBE  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
5FC0  B80B     BTFSC Mf_pob_KCO, 4, ACCESS
5FC2  D006     BRA 0x5FD0
5FC4  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
5FC6  D004     BRA 0x5FD0
5FC8  0E00     MOVLW 0x0
5FCA  0103     MOVLB 0x3
5FCC  6F8C     MOVWF _PFNf_prn_in, BANKED
5FCE  D000     BRA 0x5FD0
5FD0  C38C     MOVFF pmp, w
5FD2  F38B     NOP
1395:                              }
5FD4  D019     BRA 0x6008
1396:                              else
1397:                              {
1398:                                  w = (DtCWf_err_CW && (PFN.poz == _PFLTO)) || ((PFN.poz == _PFZMA) && DtCWf_err_CW && RdPrt(S_WCW));
5FD6  0E01     MOVLW 0x1
5FD8  0103     MOVLB 0x3
5FDA  6F8D     MOVWF _PFNf_prn_res, BANKED
5FDC  A804     BTFSS DtCWf_err_CW, 4, ACCESS
5FDE  D004     BRA 0x5FE8
5FE0  0E02     MOVLW 0x2
5FE2  0101     MOVLB 0x1
5FE4  19F3     XORWF min, W, BANKED
5FE6  E00E     BZ 0x6004
5FE8  0E03     MOVLW 0x3
5FEA  0101     MOVLB 0x1
5FEC  19F3     XORWF min, W, BANKED
5FEE  B4D8     BTFSC STATUS, 2, ACCESS
5FF0  A804     BTFSS DtCWf_err_CW, 4, ACCESS
5FF2  D004     BRA 0x5FFC
5FF4  0E0B     MOVLW 0xB
5FF6  ECFD     CALL 0xE7FA, 0
5FF8  F073     NOP
5FFA  E204     BC 0x6004
5FFC  0E00     MOVLW 0x0
5FFE  0103     MOVLB 0x3
6000  6F8D     MOVWF _PFNf_prn_res, BANKED
6002  D000     BRA 0x6004
6004  C38D     MOVFF prz, w
6006  F38B     NOP
1399:                              }
1400:                              //awaria czujnika CW
1401:                              if(w)
6008  0103     MOVLB 0x3
600A  518B     MOVF _PFNf_prn_cs, W, BANKED
600C  E00E     BZ 0x602A
1402:                              {
1403:                                  M.ERR_BTY = 0x10; //0x10;
600E  0E10     MOVLW 0x10
6010  0100     MOVLB 0x0
6012  6F87     MOVWF _PFNf_pgd, BANKED
1404:                                  //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1405:                                  //else PrintErr(0x0A,1);
1406:                                  if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
6014  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
6016  D003     BRA 0x601E
6018  EC43     CALL 0xF286, 0
601A  F079     NOP
601C  D004     BRA 0x6026
1407:                                  else SetErr(0x10);
601E  0E10     MOVLW 0x10
6020  ECC7     CALL 0xF38E, 0
6022  F079     NOP
6024  D000     BRA 0x6026
1408:                                  Mf_RUSZ_NTC_CW = 1;
6026  8609     BSF Mf_RUSZ_PWR, 3, ACCESS
1409:                                  Mf_RUSZ_MOD = 0;
6028  D78D     BRA 0x5F44
1410:                              }
1411:                              else
1412:                              {
1413:                                  Mf_RUSZ_NTC_CW = 0;
602A  9609     BCF Mf_RUSZ_PWR, 3, ACCESS
1414:                                  //awaria obwodu modulatora
1415:                                  if(!RdPrt(S_MOD_ON))
602C  0E08     MOVLW 0x8
602E  ECFD     CALL 0xE7FA, 0
6030  F073     NOP
6032  E20E     BC 0x6050
1416:                                  {
1417:                                      M.ERR_BTY = 0x07;
6034  0E07     MOVLW 0x7
6036  0100     MOVLB 0x0
6038  6F87     MOVWF _PFNf_pgd, BANKED
1418:                                      //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1419:                                      //else PrintErr(0x07,1);
1420:                                      if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
603A  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
603C  D003     BRA 0x6044
603E  EC43     CALL 0xF286, 0
6040  F079     NOP
6042  D004     BRA 0x604C
1421:                                      else SetErr(0x07);
6044  0E07     MOVLW 0x7
6046  ECC7     CALL 0xF38E, 0
6048  F079     NOP
604A  D000     BRA 0x604C
1422:                                      Mf_RUSZ_MOD = 1;
604C  8009     BSF Mf_RUSZ_PWR, 0, ACCESS
1423:                                  }
604E  D01F     BRA 0x608E
1424:                                  else
1425:                                  {
1426:                                      Mf_RUSZ_MOD = 0;
6050  9009     BCF Mf_RUSZ_PWR, 0, ACCESS
1427:                                      if(DtKNF.rdpm != 0)
6052  0100     MOVLB 0x0
6054  51A0     MOVF _UADtf_RData, W, BANKED
6056  E019     BZ 0x608A
1428:                                      {
1429:                                          if((PFN.poz == _PFZMA) && (Mf_PRACA && !Mf_RPM_CW) && DtINf_err_IN) //pozycja ZIMA, grzanie w obiegu CO
6058  0E03     MOVLW 0x3
605A  0101     MOVLB 0x1
605C  19F3     XORWF min, W, BANKED
605E  B4D8     BTFSC STATUS, 2, ACCESS
6060  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
6062  D011     BRA 0x6086
6064  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
6066  AA05     BTFSS DtKNFf_enknf, 5, ACCESS
6068  D00E     BRA 0x6086
1430:                                          {
1431:                                              M.ERR_BTY = 0x14;
606A  0E14     MOVLW 0x14
606C  0100     MOVLB 0x0
606E  6F87     MOVWF _PFNf_pgd, BANKED
1432:                                              //if(KnfDisErr) EndErr();		//nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
1433:                                              //else PrintErr(0x0E,1);
1434:                                              if(PFNf_KnfDisErr) EndErr(); //nie wyswietlaj kodu bledu przy konfiguracji par. r4 i r6, r7
6070  A20C     BTFSS PFNf_b_set_nco, 1, ACCESS
6072  D003     BRA 0x607A
6074  EC43     CALL 0xF286, 0
6076  F079     NOP
6078  D004     BRA 0x6082
1435:                                              else SetErr(0x14);
607A  0E14     MOVLW 0x14
607C  ECC7     CALL 0xF38E, 0
607E  F079     NOP
6080  D000     BRA 0x6082
1436:                                              Mf_RUSZ_NTC_IN = 1;
6082  8809     BSF Mf_RUSZ_PWR, 4, ACCESS
1437:                                          }
6084  D004     BRA 0x608E
1438:                                          else
1439:                                          {
1440:                                              Mf_RUSZ_NTC_IN = 0;
6086  9809     BCF Mf_RUSZ_PWR, 4, ACCESS
1441:                                          }
1442:                                      }
6088  D002     BRA 0x608E
1443:                                      else
1444:                                      {
1445:                                          Mf_RUSZ_NTC_IN = 0;
608A  9809     BCF Mf_RUSZ_PWR, 4, ACCESS
1446:                                      }
1447:                                  }
1448:                              }
1449:                          }
1450:                      }
1451:                  }
1452:              }
608C  D000     BRA 0x608E
1453:              //--------START PROCEDUR NAPRAWCZYCH - WYLACZENIE Z BLOKADA
1454:              //UWAGA: bez wizualizacji kodu awaryjnego (wyswietlany dopiero po wykonaniu procedury naprawczej)
1455:          
1456:              //brak plomienia (praca kotla)
1457:              if(!Mf_RUSZ_PLOMIEN && !RdPrt(S_PLM) && !Mf_ROZRUCH && _GRZEJ)
608E  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
6090  D029     BRA 0x60E4
6092  0E05     MOVLW 0x5
6094  ECFD     CALL 0xE7FA, 0
6096  F073     NOP
6098  A0D8     BTFSS STATUS, 0, ACCESS
609A  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
609C  D023     BRA 0x60E4
609E  A083     BTFSS PORTD, 0, ACCESS
60A0  D021     BRA 0x60E4
1458:              {
1459:                  if(Mf_TURBO) //sterownik TURBO?
60A2  A40A     BTFSS Mf_pob_AL, 2, ACCESS
60A4  D015     BRA 0x60D0
1460:                  {
1461:                      if(_VNT) //wentylator pracuje?
60A6  A683     BTFSS PORTD, 3, ACCESS
60A8  D00D     BRA 0x60C4
1462:                      {
1463:                          if(RdPrt(S_CIG_NO) && RdPrt(S_STB))
60AA  0E03     MOVLW 0x3
60AC  ECFD     CALL 0xE7FA, 0
60AE  F073     NOP
60B0  E319     BNC 0x60E4
60B2  0E04     MOVLW 0x4
60B4  ECFD     CALL 0xE7FA, 0
60B6  F073     NOP
60B8  E315     BNC 0x60E4
1464:                          {
1465:                              M.RPL = 0;
60BA  0E00     MOVLW 0x0
60BC  0100     MOVLB 0x0
60BE  6F8F     MOVWF _PFNf_prnserw, BANKED
1466:                              Mf_RUSZ_PLOMIEN = 1;
60C0  D005     BRA 0x60CC
1467:                          }
1468:                      }
60C2  D010     BRA 0x60E4
1469:                      else //wentylator nie pracuje
1470:                      {
1471:                          if(RdPrt(S_STB))
60C4  0E04     MOVLW 0x4
60C6  ECFD     CALL 0xE7FA, 0
60C8  F073     NOP
60CA  D7F6     BRA 0x60B8
1472:                          {
1473:                              M.RPL = 0;
1474:                              Mf_RUSZ_PLOMIEN = 1;
60CC  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
1475:                          }
1476:                      }
1477:                  }
60CE  D00A     BRA 0x60E4
1478:                  else //sterownik ATMOSFERYCZNY
1479:                  {
1480:                      if(RdPrt(S_CIG_NC) && RdPrt(S_STB))
60D0  0E02     MOVLW 0x2
60D2  ECFD     CALL 0xE7FA, 0
60D4  F073     NOP
60D6  E306     BNC 0x60E4
60D8  0E04     MOVLW 0x4
60DA  ECFD     CALL 0xE7FA, 0
60DC  F073     NOP
60DE  D7EC     BRA 0x60B8
1481:                      {
1482:                          M.RPL = 0;
1483:                          Mf_RUSZ_PLOMIEN = 1;
60E0  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
1484:                      }
1485:                  }
60E2  D000     BRA 0x60E4
1486:              }
1487:          
1488:              //brak ciagu (praca kotla)
1489:              if(!Mf_TURBO) //kociol atmosferyczny
60E4  B40A     BTFSC Mf_pob_AL, 2, ACCESS
60E6  D011     BRA 0x610A
1490:              {
1491:                  if(!Mf_RUSZ_CIAG && !RdPrt(S_CIG_NC) && RdPrt(S_STB) && Mf_PRACA)
60E8  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
60EA  D03A     BRA 0x6160
60EC  0E02     MOVLW 0x2
60EE  ECFD     CALL 0xE7FA, 0
60F0  F073     NOP
60F2  E236     BC 0x6160
60F4  0E04     MOVLW 0x4
60F6  ECFD     CALL 0xE7FA, 0
60F8  F073     NOP
60FA  B0D8     BTFSC STATUS, 0, ACCESS
60FC  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
60FE  D030     BRA 0x6160
1492:                  {
1493:                      M.RCI = 0;
6100  0E00     MOVLW 0x0
6102  0100     MOVLB 0x0
6104  6F90     MOVWF _PFNf_res, BANKED
1494:                      Mf_RUSZ_CIAG = 1;
6106  8C08     BSF Mf_ROZRUCH, 6, ACCESS
1495:                      /*if(!M.LICZNIK_CIG) StartRTS(_RTRSCI);
1496:                      M.LICZNIK_CIG++;
1497:                      if(M.LICZNIK_CIG>=_NCYKLI_CIG)
1498:                      {
1499:                              M.LICZNIK_CIG=0;
1500:                              M.ERR_BTY=0x03;
1501:                              PrintErr(0x03,1);
1502:                              ErrPTG();
1503:                      }*/
1504:                  }
1505:              }
6108  D02B     BRA 0x6160
1506:              else //kociol turbo (praca wentylatora, pomijana procedura rozruchu)
1507:              {
1508:                  if(!Mf_RUSZ_CIAG && !Mf_ROZRUCH && !Mf_DE_VNT && ((!RdPrt(S_CIG_NO) && _VNT) || (RdPrt(S_CIG_NO) && !_VNT)))
610A  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
610C  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
610E  D028     BRA 0x6160
6110  B407     BTFSC Mf_BLOKUJ_3M, 2, ACCESS
6112  D026     BRA 0x6160
6114  0E03     MOVLW 0x3
6116  ECFD     CALL 0xE7FA, 0
6118  F073     NOP
611A  E202     BC 0x6120
611C  B683     BTFSC PORTD, 3, ACCESS
611E  D006     BRA 0x612C
6120  0E03     MOVLW 0x3
6122  ECFD     CALL 0xE7FA, 0
6124  F073     NOP
6126  B0D8     BTFSC STATUS, 0, ACCESS
6128  B683     BTFSC PORTD, 3, ACCESS
612A  D01A     BRA 0x6160
1509:                  {
1510:                      M.RCI = 0;
612C  0E00     MOVLW 0x0
612E  0100     MOVLB 0x0
6130  6F90     MOVWF _PFNf_res, BANKED
1511:                      Mf_RUSZ_CIAG = 1; //aktywuj procedure awaryjna
6132  8C08     BSF Mf_ROZRUCH, 6, ACCESS
1512:                      if(!M.LICZNIK_CIG) StartRTS(_RTRSCI); //licznik liczby zanikow ciagu na minute
6134  0100     MOVLB 0x0
6136  5183     MOVF _PFNf_ofzima, W, BANKED
6138  E104     BNZ 0x6142
613A  0E09     MOVLW 0x9
613C  EC60     CALL 0xE4C0, 0
613E  F072     NOP
6140  D000     BRA 0x6142
1513:                      M.LICZNIK_CIG++;
6142  0100     MOVLB 0x0
6144  2B83     INCF _PFNf_ofzima, F, BANKED
1514:                      if(M.LICZNIK_CIG >= _NCYKLI_CIG) //przekroczono dozwolona liczbe zanikow ciagu na minute?
6146  0E04     MOVLW 0x4
6148  0100     MOVLB 0x0
614A  6583     CPFSGT _PFNf_ofzima, BANKED
614C  D009     BRA 0x6160
1515:                      {
1516:                          M.LICZNIK_CIG = 0;
614E  6B83     CLRF _PFNf_ofzima, BANKED
1517:                          M.ERR_BTY = 0x03;
6150  0E03     MOVLW 0x3
6152  6F87     MOVWF _PFNf_pgd, BANKED
1518:                          SetErr(0x03);//PrintErr(0x03, 1);
6154  0E03     MOVLW 0x3
6156  ECC7     CALL 0xF38E, 0
6158  F079     NOP
1519:                          ErrPTG();
615A  ECCC     CALL 0x8798, 0
615C  F043     NOP
1520:                      }
1521:                  }
615E  D000     BRA 0x6160
1522:              }
1523:          
1524:          
1525:              //--------REAKCJA NA BRAK SYTUACJI AWARYJNEJ (DOTYCZY WIZUALIZACJI KODU AWARYJNEGO)
1526:          
1527:              //usun kod awaryjny z wyswietlacza
1528:              if(!Mf_RUSZ_PLOMIEN && !Mf_RUSZ_CIAG)
6160  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
6162  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
6164  0012     RETURN 0
1529:                  if(!Mf_RUSZ_NTC_CO && !Mf_RUSZ_NCISN && !Mf_RUSZ_CISN)
6166  A409     BTFSS Mf_RUSZ_PWR, 2, ACCESS
6168  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
616A  0012     RETURN 0
616C  AE08     BTFSS Mf_ROZRUCH, 7, ACCESS
1530:                      if(!Mf_RUSZ_NTC_CW && !Mf_RUSZ_MOD && !Mf_RUSZ_POMPE && !Mf_RUSZ_NTC_IN)
616E  B609     BTFSC Mf_RUSZ_PWR, 3, ACCESS
6170  0012     RETURN 0
6172  A009     BTFSS Mf_RUSZ_PWR, 0, ACCESS
6174  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
6176  0012     RETURN 0
6178  B809     BTFSC Mf_RUSZ_PWR, 4, ACCESS
617A  0012     RETURN 0
1531:                      {
1532:                          M.ERR_BTY = 0x00;
617C  0100     MOVLB 0x0
617E  6B87     CLRF _PFNf_pgd, BANKED
1533:                          EndErr();
6180  EC43     CALL 0xF286, 0
6182  F079     NOP
1534:                      }
1535:          }
6184  0012     RETURN 0
1536:          //------------------
1537:          //------------------
1538:          //Decyzje sterujace
1539:          
1540:          void DecSTR(void)
1541:          {
1542:              //dla wylaczonego modulu zapalacza zweruj zegar pracy nieciaglej
1543:              //if(!_GRZEJ) StartRTG(_RTPNC);
1544:              //jezeli praca trwa >24h wywolaj reset sterownika
1545:              //if(RTG(_RTPNC)>=_TPNC) while(1);
1546:              //wyzerowanie znacznikow rozruchu sterownika po wlaczeniu zasilania lub resecie
1547:              if(RTS(_RTSTR) >= _TSTR)
57DE  0E08     MOVLW 0x8
57E0  ECA9     CALL 0xEB52, 0
57E2  F075     NOP
57E4  0100     MOVLB 0x0
57E6  6FE0     MOVWF bdat, BANKED
57E8  0E02     MOVLW 0x2
57EA  65E0     CPFSGT bdat, BANKED
57EC  D003     BRA 0x57F4
1548:              {
1549:                  Mf_PW_START = 0;
57EE  9E07     BCF Mf_BLOKUJ_3M, 7, ACCESS
1550:                  Mf_RS_START = 0;
57F0  9408     BCF Mf_ROZRUCH, 2, ACCESS
57F2  D000     BRA 0x57F4
1551:              }
1552:              //regulacja pogodowa aktywna?
1553:              Mf_AKTYWNE_PGD = (RdPrt(S_PGD)) ? 1 : 0;
57F4  0E14     MOVLW 0x14
57F6  ECFD     CALL 0xE7FA, 0
57F8  F073     NOP
57FA  B0D8     BTFSC STATUS, 0, ACCESS
57FC  D002     BRA 0x5802
57FE  9A06     BCF DtKNFf_wymCO, 5, ACCESS
5800  D001     BRA 0x5804
5802  8A06     BSF DtKNFf_wymCO, 5, ACCESS
1554:              //reakcja na zbyt szybki narost temperatury
1555:              if(!Mf_ROZRUCH && _GRZEJ && DtCOf_ldDCO) Mf_RUN_MNMOD = 1;
5804  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
5806  A083     BTFSS PORTD, 0, ACCESS
5808  D004     BRA 0x5812
580A  A202     BTFSS DtCOf_su_CO, 1, ACCESS
580C  D002     BRA 0x5812
580E  8608     BSF Mf_ROZRUCH, 3, ACCESS
5810  D001     BRA 0x5814
1556:              else Mf_RUN_MNMOD = 0;
5812  9608     BCF Mf_ROZRUCH, 3, ACCESS
1557:              //--------------
1558:              //wybor obiegu dla pompy (w stanie spoczynku pompa pracuje w obiegu CW)
1559:              if(!Mf_ZMKCOCW)
5814  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
5816  D0B7     BRA 0x5986
1560:              {
1561:                      //wymuszenie dla obiegu CW w trakcie pracy?
1562:                      if(Mf_PRACA && (Mf_pob_KCW || Mf_pob_CW || Mf_pob_DzCW || Mf_pob_AL)) ToObiegCW();
5818  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
581A  D00A     BRA 0x5830
581C  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
581E  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
5820  D004     BRA 0x582A
5822  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
5824  D002     BRA 0x582A
5826  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
5828  D003     BRA 0x5830
582A  EC3E     CALL 0xC67C, 0
582C  F063     NOP
582E  D0AB     BRA 0x5986
1563:                  else
1564:                      //wymuszenie dla obiegu CO w trakcie pracy?
1565:                      if(Mf_PRACA && !Mf_BLOKUJ_15S && (Mf_pob_KCO || Mf_pob_SRW || Mf_pob_CO || Mf_pob_DzCO)) ToObiegCO();
5830  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
5832  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
5834  D00A     BRA 0x584A
5836  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
5838  BA0B     BTFSC Mf_pob_KCO, 5, ACCESS
583A  D004     BRA 0x5844
583C  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
583E  D002     BRA 0x5844
5840  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
5842  D003     BRA 0x584A
5844  EC53     CALL 0xDEA6, 0
5846  F06F     NOP
5848  D09E     BRA 0x5986
1566:                  else
1567:                      //pompa pracuje, pobudzenie CW,temperatura CO poza zakresem
1568:                      if(!Mf_PRACA && Mf_WYLACZ && (DtKNF.tpkt == _MONOHB) && (!DtCOf_err_CO && !DtCOf_ptwp_CO) && Mf_pob_CW) ToObiegCW();
584A  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
584C  A80A     BTFSS Mf_pob_AL, 4, ACCESS
584E  D00C     BRA 0x5868
5850  0E03     MOVLW 0x3
5852  0100     MOVLB 0x0
5854  199E     XORWF _PWMf_ENPWM2, W, BANKED
5856  B4D8     BTFSC STATUS, 2, ACCESS
5858  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
585A  D006     BRA 0x5868
585C  A802     BTFSS DtCOf_su_CO, 4, ACCESS
585E  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
5860  D003     BRA 0x5868
5862  EC3E     CALL 0xC67C, 0
5864  F063     NOP
5866  D08F     BRA 0x5986
1569:                  else
1570:                      if(!Mf_PRACA && Mf_WYLACZ && (DtKNF.tpkt == _UNICO) && (!DtCOf_err_CO && !DtCOf_ptwp_CO) && ((PFN.poz == _PFLTO) || (PFN.poz == _PFZMA)) && DtCWf_wpz_CW) ToObiegCW();
5868  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
586A  A80A     BTFSS Mf_pob_AL, 4, ACCESS
586C  D013     BRA 0x5894
586E  0100     MOVLB 0x0
5870  519E     MOVF _PWMf_ENPWM2, W, BANKED
5872  B4D8     BTFSC STATUS, 2, ACCESS
5874  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
5876  D00E     BRA 0x5894
5878  B802     BTFSC DtCOf_su_CO, 4, ACCESS
587A  D00C     BRA 0x5894
587C  0E02     MOVLW 0x2
587E  0101     MOVLB 0x1
5880  19F3     XORWF min, W, BANKED
5882  E003     BZ 0x588A
5884  0E03     MOVLW 0x3
5886  19F3     XORWF min, W, BANKED
5888  E105     BNZ 0x5894
588A  A405     BTFSS DtKNFf_enknf, 2, ACCESS
588C  D003     BRA 0x5894
588E  EC3E     CALL 0xC67C, 0
5890  F063     NOP
5892  D079     BRA 0x5986
1571:                  else
1572:                      //temperatura CO poza zakresem lub aktywny wybieg 48h?
1573:                      if(!Mf_PRACA && !Mf_BLOKUJ_15S && (RdPrt(S_ON_PMP) || Mf_RUSZ_48))
5894  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5896  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
5898  D036     BRA 0x5906
589A  0E0D     MOVLW 0xD
589C  ECFD     CALL 0xE7FA, 0
589E  F073     NOP
58A0  E202     BC 0x58A6
58A2  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
58A4  D030     BRA 0x5906
1574:                      {
1575:                          if(RdPrt(S_ON_PMP)) //temperatura CO poza zakresem
58A6  0E0D     MOVLW 0xD
58A8  ECFD     CALL 0xE7FA, 0
58AA  F073     NOP
58AC  E324     BNC 0x58F6
1576:                          {
1577:                              if(PFNf_off) ToObiegCO();                   //pozycja OFF
58AE  AE0F     BTFSS PFNf_off, 7, ACCESS
58B0  D003     BRA 0x58B8
58B2  EC53     CALL 0xDEA6, 0
58B4  F06F     NOP
58B6  D067     BRA 0x5986
1578:                              else
1579:                              if(PFNf_oflato)                              //pozycja LATO
58B8  A010     BTFSS PFNf_ofnserw, 0, ACCESS
58BA  D011     BRA 0x58DE
1580:                              {
1581:                                  if((DtKNF.tpkt!=_INWEST)&&(DtKNF.tpkt!=_INWEST2))
58BC  0100     MOVLB 0x0
58BE  059E     DECF _PWMf_ENPWM2, W, BANKED
58C0  E00B     BZ 0x58D8
58C2  0E02     MOVLW 0x2
58C4  199E     XORWF _PWMf_ENPWM2, W, BANKED
58C6  E008     BZ 0x58D8
1582:                                  {
1583:                                      if(DtCOf_cold_CO) ToObiegCO();
58C8  AC01     BTFSS DtCOf_err_CO, 6, ACCESS
58CA  D003     BRA 0x58D2
58CC  EC53     CALL 0xDEA6, 0
58CE  F06F     NOP
58D0  D05A     BRA 0x5986
1584:                                      else ToObiegCW();
58D2  EC3E     CALL 0xC67C, 0
58D4  F063     NOP
1585:                                  }
58D6  D057     BRA 0x5986
1586:                                  else ToObiegCO();                            
58D8  EC53     CALL 0xDEA6, 0
58DA  F06F     NOP
1587:                              }
58DC  D054     BRA 0x5986
1588:                              else                                        //pozycja ZIMA
1589:                              {
1590:                                  if(!Mf_pob_KCW && !Mf_pob_CW && !Mf_pob_DzCW && !Mf_pob_AL) ToObiegCO();                //brak pobudzenia CW
58DE  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
58E0  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
58E2  D006     BRA 0x58F0
58E4  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
58E6  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
58E8  D003     BRA 0x58F0
58EA  EC53     CALL 0xDEA6, 0
58EC  F06F     NOP
58EE  D04B     BRA 0x5986
1591:                                  else ToObiegCW();                                                                       //aktywne pobudzenie CW   
58F0  EC3E     CALL 0xC67C, 0
58F2  F063     NOP
1592:                              }                                       
1593:                          }
58F4  D048     BRA 0x5986
1594:                          else 
1595:                          {
1596:                              if(Mf_RUSZ_48) ToObiegCO();   //aktywny wybieg 48h
58F6  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
58F8  D003     BRA 0x5900
58FA  EC53     CALL 0xDEA6, 0
58FC  F06F     NOP
58FE  D043     BRA 0x5986
1597:                              else ToObiegCW();
5900  EC3E     CALL 0xC67C, 0
5902  F063     NOP
1598:                          }
1599:                      }
5904  D040     BRA 0x5986
1600:                  else
1601:                      //aktywne RT (pozycja zima)i temp. CO wyzsza od warunku zalaczenia kotla?
1602:                      if(!Mf_PRACA && !Mf_BLOKUJ_15S && Mf_pob_CO && !DtCOf_su_CO) ToObiegCO();
5906  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5908  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
590A  D032     BRA 0x5970
590C  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
590E  BE02     BTFSC DtCOf_su_CO, 7, ACCESS
5910  D02F     BRA 0x5970
5912  EC53     CALL 0xDEA6, 0
5914  F06F     NOP
5916  D037     BRA 0x5986
1603:                  else //kociol w spoczynku
1604:                  {
1605:                      switch(DtKNF.tpkt) //dla danego rodzaju kotla
5918  D02B     BRA 0x5970
5970  0100     MOVLB 0x0
5972  519E     MOVF _PWMf_ENPWM2, W, BANKED
5974  E0E6     BZ 0x5942
5976  0A01     XORLW 0x1
5978  E0D0     BZ 0x591A
597A  0A03     XORLW 0x3
597C  E0CE     BZ 0x591A
597E  0A01     XORLW 0x1
5980  E0D4     BZ 0x592A
5982  D7ED     BRA 0x595E
1606:                      {
1607:                          case _BITERM: //bitermiczny (miniterm)
1608:                          case _BITERM2: //bitermiczny (maxiterm)
1609:                          {
1610:                              //nieaktywne warunki wybiegu pompy?
1611:                              if(!Mf_PRACA && !Mf_WYLACZ && !Mf_RUSZ_48) ToObiegCW();
591A  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
591C  B80A     BTFSC Mf_pob_AL, 4, ACCESS
591E  D033     BRA 0x5986
5920  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
5922  D031     BRA 0x5986
5924  EC3E     CALL 0xC67C, 0
5926  F063     NOP
1612:                              break;
5928  D02E     BRA 0x5986
1613:                          }
1614:                          case _MONOHB:
1615:                          {
1616:                              //nieaktywna pompa?
1617:                              if(!Mf_PRACA && !Mf_WYLACZ && !Mf_RUSZ_48 && (!_POMPA || Mf_RUSZ_48Z3)) ToObiegCW();
592A  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
592C  B80A     BTFSC Mf_pob_AL, 4, ACCESS
592E  D02B     BRA 0x5986
5930  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
5932  D029     BRA 0x5986
5934  A483     BTFSS PORTD, 2, ACCESS
5936  D002     BRA 0x593C
5938  AA08     BTFSS Mf_ROZRUCH, 5, ACCESS
593A  D025     BRA 0x5986
593C  EC3E     CALL 0xC67C, 0
593E  F063     NOP
1618:                              break;
5940  D022     BRA 0x5986
1619:                          }
1620:                          case _UNICO:
1621:                          {
1622:                              //b.niska temperatura CW lub nieaktywna pompa?
1623:                              if(!Mf_PRACA && (RdPrt(S_ON_PMP_CW) || (!Mf_WYLACZ && !Mf_RUSZ_48 && !_POMPA))) ToObiegCW();
5942  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
5944  D020     BRA 0x5986
5946  0E11     MOVLW 0x11
5948  ECFD     CALL 0xE7FA, 0
594A  F073     NOP
594C  E205     BC 0x5958
594E  A80A     BTFSS Mf_pob_AL, 4, ACCESS
5950  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
5952  D019     BRA 0x5986
5954  B483     BTFSC PORTD, 2, ACCESS
5956  D017     BRA 0x5986
5958  EC3E     CALL 0xC67C, 0
595A  F063     NOP
1624:                              break;
595C  D014     BRA 0x5986
1625:                          }
1626:                          default: //domyslny monotermiczny
1627:                          {
1628:                              //nieaktywna pompa?
1629:                              if(!Mf_PRACA && !Mf_WYLACZ && !Mf_RUSZ_48 && !_POMPA) ToObiegCW();
595E  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5960  B80A     BTFSC Mf_pob_AL, 4, ACCESS
5962  D011     BRA 0x5986
5964  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
5966  B483     BTFSC PORTD, 2, ACCESS
5968  D00E     BRA 0x5986
596A  EC3E     CALL 0xC67C, 0
596C  F063     NOP
1630:                              break;
1631:                          }
1632:                      }
596E  D00B     BRA 0x5986
1633:                  }
5984  D000     BRA 0x5986
1634:              }
1635:              //--------------
1636:              //decyzja o aktywacji wybiegu pompy
1637:              if(!Mf_ZMKCOCW)
5986  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
5988  D048     BRA 0x5A1A
598A  D051     BRA 0x5A2E
1638:              {
1639:                  switch(DtKNF.tpkt) //dla danego rodzaju kotla
598C  D046     BRA 0x5A1A
5A1A  0100     MOVLB 0x0
5A1C  519E     MOVF _PWMf_ENPWM2, W, BANKED
5A1E  E0D9     BZ 0x59D2
5A20  0A01     XORLW 0x1
5A22  E0B5     BZ 0x598E
5A24  0A03     XORLW 0x3
5A26  E0B3     BZ 0x598E
5A28  0A01     XORLW 0x1
5A2A  E0C6     BZ 0x59B8
5A2C  D7E3     BRA 0x59F4
1640:                  {
1641:                      case _BITERM: //bitermiczny (miniterm)
1642:                      case _BITERM2: //bitermiczny (maxiterm)
1643:                      {
1644:                          if(!Mf_WYLACZ && !Mf_RUSZ_48 && !Mf_PRACA)
598E  A80A     BTFSS Mf_pob_AL, 4, ACCESS
5990  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
5992  D04D     BRA 0x5A2E
5994  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
5996  D04B     BRA 0x5A2E
1645:                          {
1646:                              //temperatura CO/CW poza dozwolonym zakresem
1647:                              if(!Mf_RPM_CW&&RdPrt(S_ON_PMP))
5998  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
599A  D004     BRA 0x59A4
599C  0E0D     MOVLW 0xD
599E  ECFD     CALL 0xE7FA, 0
59A0  F073     NOP
1648:                              {
1649:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
59A2  E208     BC 0x59B4
1650:                              }
1651:                              else
1652:                              //decyzja o zlaczeniu pompy dla RT i temp. CO wyzszej od warunku zalaczenia kotla
1653:                              if(!Mf_RPM_CW&&!PFNf_off && !PFNf_oflato && Mf_pob_CO && !DtCOf_su_CO)
59A4  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
59A6  BE0F     BTFSC PFNf_off, 7, ACCESS
59A8  D042     BRA 0x5A2E
59AA  A010     BTFSS PFNf_ofnserw, 0, ACCESS
59AC  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
59AE  D03F     BRA 0x5A2E
59B0  BE02     BTFSC DtCOf_su_CO, 7, ACCESS
59B2  D03D     BRA 0x5A2E
1654:                              {
1655:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
59B4  880A     BSF Mf_pob_AL, 4, ACCESS
1656:                              }
1657:                          }
1658:                          break;
59B6  D03B     BRA 0x5A2E
1659:                      }
1660:                      case _MONOHB:
1661:                      {
1662:                          if(!_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48 && !Mf_RUSZ_48Z3 && !Mf_PRACA)
59B8  A483     BTFSS PORTD, 2, ACCESS
59BA  B80A     BTFSC Mf_pob_AL, 4, ACCESS
59BC  D038     BRA 0x5A2E
59BE  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
59C0  BA08     BTFSC Mf_ROZRUCH, 5, ACCESS
59C2  D035     BRA 0x5A2E
59C4  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
59C6  D033     BRA 0x5A2E
1663:                          {
1664:                              //temperatura CO/CW poza dozwolonym zakresem
1665:                              if(RdPrt(S_ON_PMP))
59C8  0E0D     MOVLW 0xD
59CA  ECFD     CALL 0xE7FA, 0
59CC  F073     NOP
59CE  D01B     BRA 0x5A06
1666:                              {
1667:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
1668:                                  _POMPA = 1;
1669:                              }
1670:                              else
1671:                                  //decyzja o zlaczeniu pompy dla RT i temp. CO wyzszej od warunku zalaczenia kotla
1672:                                  if(!PFNf_off && !PFNf_oflato  && Mf_pob_CO && !DtCOf_su_CO)
1673:                              {
1674:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
1675:                                  _POMPA = 1;
1676:                              }
1677:                          }
1678:                          break;
59D0  D02E     BRA 0x5A2E
1679:                      }
1680:                      case _UNICO:
1681:                      {
1682:                          if(!_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48 && !Mf_PRACA)
59D2  A483     BTFSS PORTD, 2, ACCESS
59D4  B80A     BTFSC Mf_pob_AL, 4, ACCESS
59D6  D02B     BRA 0x5A2E
59D8  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
59DA  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
59DC  D028     BRA 0x5A2E
1683:                          {
1684:                              //temperatura CO/CW poza dozwolonym zakresem
1685:                              if((RdPrt(S_ON_PMP)) || (Mf_RPM_CW && RdPrt(S_ON_PMP_CW)))
59DE  0E0D     MOVLW 0xD
59E0  ECFD     CALL 0xE7FA, 0
59E2  F073     NOP
59E4  E217     BC 0x5A14
59E6  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
59E8  D00F     BRA 0x5A08
59EA  0E11     MOVLW 0x11
59EC  ECFD     CALL 0xE7FA, 0
59EE  F073     NOP
59F0  D00A     BRA 0x5A06
1686:                              {
1687:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
1688:                                  _POMPA = 1;
1689:                              }
1690:                              else
1691:                                  //decyzja o zlaczeniu pompy dla RT i temp. CO wyzszej od warunku zalaczenia kotla
1692:                                  if(!PFNf_off && !PFNf_oflato && Mf_pob_CO && !DtCOf_su_CO)
1693:                              {
1694:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
1695:                                  _POMPA = 1;
1696:                              }
1697:                          }
1698:                          break;
59F2  D01D     BRA 0x5A2E
1699:                      }
1700:                      default: //domyslny monotermiczny
1701:                      {
1702:                          if(!_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48 && !Mf_PRACA)
59F4  A483     BTFSS PORTD, 2, ACCESS
59F6  B80A     BTFSC Mf_pob_AL, 4, ACCESS
59F8  D01A     BRA 0x5A2E
59FA  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
59FC  BC07     BTFSC Mf_BLOKUJ_3M, 6, ACCESS
59FE  D017     BRA 0x5A2E
1703:                          {
1704:                              //temperatura CO/CW poza dozwolonym zakresem
1705:                              if(RdPrt(S_ON_PMP))
5A00  0E0D     MOVLW 0xD
5A02  ECFD     CALL 0xE7FA, 0
5A04  F073     NOP
1706:                              {
1707:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
5A06  E206     BC 0x5A14
1708:                                  _POMPA = 1;
1709:                              }
1710:                              else
1711:                                  //decyzja o zlaczeniu pompy dla RT i temp. CO wyzszej od warunku zalaczenia kotla
1712:                                  if(!PFNf_off && !PFNf_oflato && Mf_pob_CO && !DtCOf_su_CO)
5A08  AE0F     BTFSS PFNf_off, 7, ACCESS
5A0A  B010     BTFSC PFNf_ofnserw, 0, ACCESS
5A0C  D010     BRA 0x5A2E
5A0E  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
5A10  BE02     BTFSC DtCOf_su_CO, 7, ACCESS
5A12  D00D     BRA 0x5A2E
1713:                              {
1714:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy
5A14  880A     BSF Mf_pob_AL, 4, ACCESS
1715:                                  _POMPA = 1;
5A16  8483     BSF PORTD, 2, ACCESS
1716:                              }
1717:                          }
1718:                          break;
1719:                      }
1720:                  }
5A18  D00A     BRA 0x5A2E
1721:              }
1722:              //--------------
1723:              //Czasowe podbicie mocy minimalnej
1724:              if(Mf_PRACA&&(Mf_pob_CO||Mf_pob_DzCO||Mf_pob_DzCW)&&!Mf_pob_SRW&&!Mf_AKTYWNE_KNF&&!Mf_pob_KCO&&!Mf_pob_KCW&&!Mf_pob_CW&&!Mf_pob_AL)
5A2E  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5A30  D020     BRA 0x5A72
5A32  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
5A34  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
5A36  D002     BRA 0x5A3C
5A38  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
5A3A  D01B     BRA 0x5A72
5A3C  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
5A3E  B806     BTFSC DtKNFf_wymCO, 4, ACCESS
5A40  D018     BRA 0x5A72
5A42  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
5A44  B80B     BTFSC Mf_pob_KCO, 4, ACCESS
5A46  D015     BRA 0x5A72
5A48  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
5A4A  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
5A4C  D012     BRA 0x5A72
1725:              {
1726:                      if((PWM.DKNF_MDMOD<PWM.DV16_MDMOD)&&(RTS(_RTWPWM)<_TWSPWM))
5A4E  0100     MOVLB 0x0
5A50  5169     MOVF _PFNf_b_str_ncw, W, BANKED
5A52  5D68     SUBWF _PFNf_b_str_nco, W, BANKED
5A54  E20B     BC 0x5A6C
5A56  0E0F     MOVLW 0xF
5A58  ECA9     CALL 0xEB52, 0
5A5A  F075     NOP
5A5C  0100     MOVLB 0x0
5A5E  6FE0     MOVWF bdat, BANKED
5A60  0E05     MOVLW 0x5
5A62  61E0     CPFSLT bdat, BANKED
5A64  D003     BRA 0x5A6C
1727:                      {
1728:                              PWM.MDMOD=PWM.DV16_MDMOD;	//czasowa praca z moca minimalna od 25 do 50%
5A66  C069     MOVFF _PFNf_b_str_ncw, _PFNf_b_set_ncw
5A68  F067     NOP
1729:                      }
5A6A  D005     BRA 0x5A76
1730:                      else
1731:                      {
1732:                              PWM.MDMOD=PWM.DKNF_MDMOD;	//praca z domyslna moca minimalna zdefiniowana w konfiguracji
5A6C  C068     MOVFF _PFNf_b_str_nco, _PFNf_b_set_ncw
5A6E  F067     NOP
1733:                      }
1734:              }
5A70  D002     BRA 0x5A76
1735:              else
1736:              {
1737:                      PWM.MDMOD=PWM.DKNF_MDMOD;	//praca z domyslna moca minimalna zdefiniowana w konfiguracji
5A72  C068     MOVFF _PFNf_b_str_nco, _PFNf_b_set_ncw
5A74  F067     NOP
1738:              }
1739:              //--------------
1740:              //aktywacja/deaktywacja bloku modulacji plomieniem dla pobudzen RT i CW
1741:              if(Mf_pob_CO || Mf_pob_CW || Mf_pob_AL)
5A76  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
5A78  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
5A7A  D002     BRA 0x5A80
5A7C  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
5A7E  D00B     BRA 0x5A96
1742:              {
1743:                  if(!Mf_ROZRUCH && _GRZEJ)
5A80  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
5A82  A083     BTFSS PORTD, 0, ACCESS
5A84  D006     BRA 0x5A92
1744:                  {
1745:                      if(!Mf_MODULUJ)
5A86  B807     BTFSC Mf_BLOKUJ_3M, 4, ACCESS
5A88  D007     BRA 0x5A98
1746:                      {
1747:                          Mf_MODULUJ = 1;
5A8A  8807     BSF Mf_BLOKUJ_3M, 4, ACCESS
1748:                          RestartMod();
5A8C  ECD3     CALL 0xF1A6, 0
5A8E  F078     NOP
1749:          
1750:                      }
1751:                  }
5A90  D003     BRA 0x5A98
1752:                  else Mf_MODULUJ = 0;
5A92  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
1753:              }
5A94  D001     BRA 0x5A98
1754:              else Mf_MODULUJ = 0;
5A96  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
1755:              //deaktywacja bloku modulacji plomieniem dla awarii modulatora lub dla szybkiego narostu temp.
1756:              if(!Mf_PRACA || !RdPrt(S_MOD_ON) || Mf_RUN_MNMOD)
5A98  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5A9A  D006     BRA 0x5AA8
5A9C  0E08     MOVLW 0x8
5A9E  ECFD     CALL 0xE7FA, 0
5AA0  F073     NOP
5AA2  E302     BNC 0x5AA8
5AA4  A608     BTFSS Mf_ROZRUCH, 3, ACCESS
5AA6  D010     BRA 0x5AC8
1757:              {
1758:                  Mf_MODULUJ = 0; //wylacz blok modulacji
5AA8  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
1759:                  if(!Mf_PRACA || !RdPrt(S_MOD_ON)) WritePWM(0);
5AAA  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
5AAC  D004     BRA 0x5AB6
5AAE  0E08     MOVLW 0x8
5AB0  ECFD     CALL 0xE7FA, 0
5AB2  F073     NOP
5AB4  E204     BC 0x5ABE
5AB6  0E00     MOVLW 0x0
5AB8  ECDD     CALL 0xF1BA, 0
5ABA  F078     NOP
5ABC  D005     BRA 0x5AC8
1760:                  else WritePWM(PWM.MDMOD); //zbyt szybki narost temp.
5ABE  0100     MOVLB 0x0
5AC0  5167     MOVF _PFNf_b_set_ncw, W, BANKED
5AC2  ECDD     CALL 0xF1BA, 0
5AC4  F078     NOP
5AC6  D000     BRA 0x5AC8
1761:              }
1762:              //wymuszenie konkretnej wartosci wypelnienia dla danego wymuszenia
1763:              if(Mf_pob_KCW && !Mf_ROZRUCH && _GRZEJ) WritePWM(PWM.MMAXCW);
5AC8  B80B     BTFSC Mf_pob_KCO, 4, ACCESS
5ACA  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
5ACC  D007     BRA 0x5ADC
5ACE  A083     BTFSS PORTD, 0, ACCESS
5AD0  D005     BRA 0x5ADC
5AD2  0100     MOVLB 0x0
5AD4  517E     MOVF _PFNf_obgCW, W, BANKED
5AD6  ECDD     CALL 0xF1BA, 0
5AD8  F078     NOP
5ADA  D000     BRA 0x5ADC
1764:              if(Mf_pob_KCO && !Mf_ROZRUCH && _GRZEJ) WritePWM(PWM.MMAXCO);
5ADC  B60B     BTFSC Mf_pob_KCO, 3, ACCESS
5ADE  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
5AE0  D007     BRA 0x5AF0
5AE2  A083     BTFSS PORTD, 0, ACCESS
5AE4  D005     BRA 0x5AF0
5AE6  0100     MOVLB 0x0
5AE8  517D     MOVF _PFNf_obgCO, W, BANKED
5AEA  ECDD     CALL 0xF1BA, 0
5AEC  F078     NOP
5AEE  D000     BRA 0x5AF0
1765:          #if _SRVTRB==1														//aktywny tryb serwisowy kompilacji?
1766:              if(Mf_pob_SRW && !Mf_ROZRUCH && _GRZEJ) WriteOPWM(mypwm);
1767:          #else
1768:              if(Mf_pob_SRW && !Mf_ROZRUCH && _GRZEJ)
5AF0  BA0B     BTFSC Mf_pob_KCO, 5, ACCESS
5AF2  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
5AF4  D00D     BRA 0x5B10
5AF6  A083     BTFSS PORTD, 0, ACCESS
5AF8  D00B     BRA 0x5B10
1769:              {
1770:                  if(PFNf_fns_max) WritePWM(_MG2_MOD); //tryb serwisowy z moca maksymalna?
5AFA  AA0E     BTFSS PFNf_lato, 5, ACCESS
5AFC  D004     BRA 0x5B06
5AFE  0EF0     MOVLW 0xF0
5B00  ECDD     CALL 0xF1BA, 0
5B02  F078     NOP
5B04  D005     BRA 0x5B10
1771:                  else WritePWM(PWM.MDMOD);
5B06  0100     MOVLB 0x0
5B08  5167     MOVF _PFNf_b_set_ncw, W, BANKED
5B0A  ECDD     CALL 0xF1BA, 0
5B0C  F078     NOP
5B0E  D000     BRA 0x5B10
1772:              }
1773:          #endif
1774:              if(Mf_pob_DzCO && !Mf_ROZRUCH && _GRZEJ) WritePWM(PWM.MDMOD);
5B10  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
5B12  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
5B14  D007     BRA 0x5B24
5B16  A083     BTFSS PORTD, 0, ACCESS
5B18  D005     BRA 0x5B24
5B1A  0100     MOVLB 0x0
5B1C  5167     MOVF _PFNf_b_set_ncw, W, BANKED
5B1E  ECDD     CALL 0xF1BA, 0
5B20  F078     NOP
5B22  D000     BRA 0x5B24
1775:              if(Mf_pob_DzCW && !Mf_ROZRUCH && _GRZEJ) WritePWM(PWM.MDMOD);
5B24  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
5B26  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
5B28  0012     RETURN 0
5B2A  A083     BTFSS PORTD, 0, ACCESS
5B2C  0012     RETURN 0
5B2E  0100     MOVLB 0x0
5B30  5167     MOVF _PFNf_b_set_ncw, W, BANKED
5B32  EFDD     GOTO 0xF1BA
5B34  F078     NOP
1776:          }
5B36  0012     RETURN 0
1777:          //zmiana obiegu na CO
1778:          
1779:          void ToObiegCO(void)
1780:          {
1781:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
DEA6  D01B     BRA 0xDEDE
DEDE  0100     MOVLB 0x0
DEE0  519E     MOVF _PWMf_ENPWM2, W, BANKED
DEE2  E0EB     BZ 0xDEBA
DEE4  0A01     XORLW 0x1
DEE6  E0E0     BZ 0xDEA8
DEE8  0A03     XORLW 0x3
DEEA  E0DE     BZ 0xDEA8
DEEC  0A01     XORLW 0x1
DEEE  E0E5     BZ 0xDEBA
DEF0  D7ED     BRA 0xDECC
1782:              {
1783:                  case _BITERM: //bitermiczny (miniterm)
1784:                  case _BITERM2: //bitermiczny (maxiterm)
1785:                  {
1786:                      if(!Mf_ZMKCOCW && !_POMPA) //aktywny obieg CW?
DEA8  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
DEAA  B483     BTFSC PORTD, 2, ACCESS
DEAC  0012     RETURN 0
1787:                      {
1788:                          Mf_RPM_CW = 0; //wyzeruj znacznik obiegu CW
DEAE  9208     BCF Mf_ROZRUCH, 1, ACCESS
1789:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CW na CO
DEB0  8A0A     BSF Mf_pob_AL, 5, ACCESS
1790:                          M.ZKP = 0;
DEB2  0E00     MOVLW 0x0
DEB4  0100     MOVLB 0x0
DEB6  6F92     MOVWF _PFNf_set_fnserw, BANKED
1791:                      }
1792:                      return;
DEB8  0012     RETURN 0
1793:                  }
1794:                  case _UNICO:
1795:                  case _MONOHB:
1796:                  {
1797:                      if(!Mf_ZMKCOCW && !_KCO_CW) //aktywny obieg CW?
DEBA  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
DEBC  B283     BTFSC PORTD, 1, ACCESS
DEBE  0012     RETURN 0
1798:                      {
1799:                          Mf_RPM_CW = 0; //wyzeruj znacznik obiegu CW
DEC0  9208     BCF Mf_ROZRUCH, 1, ACCESS
1800:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CW na CO
DEC2  8A0A     BSF Mf_pob_AL, 5, ACCESS
1801:                          M.ZKP = 0;
DEC4  0E00     MOVLW 0x0
DEC6  0100     MOVLB 0x0
DEC8  6F92     MOVWF _PFNf_set_fnserw, BANKED
1802:                      }
1803:                      return;
DECA  0012     RETURN 0
1804:                  }
1805:                  default: //domyslny monotermiczny
1806:                  {
1807:                      if(!Mf_ZMKCOCW && !_KCO_CW) //aktywny obieg CW?
DECC  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
DECE  B283     BTFSC PORTD, 1, ACCESS
DED0  0012     RETURN 0
1808:                      {
1809:                          Mf_RPM_CW = 0; //wyzeruj znacznik obiegu CW
DED2  9208     BCF Mf_ROZRUCH, 1, ACCESS
1810:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CW na CO
DED4  8A0A     BSF Mf_pob_AL, 5, ACCESS
1811:                          M.ZKP = 0;
DED6  0E00     MOVLW 0x0
DED8  0100     MOVLB 0x0
DEDA  6F92     MOVWF _PFNf_set_fnserw, BANKED
1812:                      }
1813:                      return;
1814:                  }
1815:              }
DEDC  0012     RETURN 0
1816:          }
DEF2  0012     RETURN 0
1817:          //zmiana obiegu na CW
1818:          
1819:          void ToObiegCW(void)
1820:          {
1821:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
C67C  D040     BRA 0xC6FE
C6FE  0100     MOVLB 0x0
C700  519E     MOVF _PWMf_ENPWM2, W, BANKED
C702  E0D1     BZ 0xC6A6
C704  0A01     XORLW 0x1
C706  E0BB     BZ 0xC67E
C708  0A03     XORLW 0x3
C70A  E0B9     BZ 0xC67E
C70C  0A01     XORLW 0x1
C70E  E0CB     BZ 0xC6A6
C710  D7E0     BRA 0xC6D2
1822:              {
1823:                  case _BITERM: //bitermiczny (miniterm)
1824:                  case _BITERM2: //bitermiczny (maxiterm)
1825:                  {
1826:                      if(!Mf_ZMKCOCW && _POMPA) //aktywny obieg CO?
C67E  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
C680  A483     BTFSS PORTD, 2, ACCESS
C682  0012     RETURN 0
1827:                      {
1828:                          Mf_RPM_CW = 1; //ustaw znacznik obiegu CW
C684  8208     BSF Mf_ROZRUCH, 1, ACCESS
1829:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CO na CW
C686  8A0A     BSF Mf_pob_AL, 5, ACCESS
1830:                          M.ZKP = 0;
C688  0E00     MOVLW 0x0
C68A  0100     MOVLB 0x0
C68C  6F92     MOVWF _PFNf_set_fnserw, BANKED
1831:                          if(Mf_pob_KCW || Mf_pob_CW || Mf_pob_DzCW)
C68E  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
C690  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
C692  D002     BRA 0xC698
C694  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
C696  0012     RETURN 0
1832:                          {
1833:                              if(Mf_PRACA)
C698  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
C69A  0012     RETURN 0
1834:                              {
1835:                                  Mf_BLOKUJ_15S = 1; //ustaw flage blokady 15 sek dla grzania CO
C69C  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1836:                                  M.BL15 = 0;
C69E  0E00     MOVLW 0x0
C6A0  0100     MOVLB 0x0
C6A2  6F8C     MOVWF _PFNf_prn_in, BANKED
1837:                              }
1838:                          }
1839:                      }
1840:                      return;
C6A4  0012     RETURN 0
1841:                  }
1842:                  case _UNICO:
1843:                  case _MONOHB:
1844:                  {
1845:                      if(!Mf_ZMKCOCW && _KCO_CW) //aktywny obieg CO?
C6A6  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
C6A8  A283     BTFSS PORTD, 1, ACCESS
C6AA  0012     RETURN 0
1846:                      {
1847:                          Mf_RPM_CW = 1; //ustaw znacznik obiegu CW
C6AC  8208     BSF Mf_ROZRUCH, 1, ACCESS
1848:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CO na CW
C6AE  8A0A     BSF Mf_pob_AL, 5, ACCESS
1849:                          M.ZKP = 0;
C6B0  0E00     MOVLW 0x0
C6B2  0100     MOVLB 0x0
C6B4  6F92     MOVWF _PFNf_set_fnserw, BANKED
1850:                          if(Mf_pob_KCW || Mf_pob_CW || Mf_pob_DzCW || Mf_pob_AL)
C6B6  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
C6B8  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
C6BA  D004     BRA 0xC6C4
C6BC  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
C6BE  D002     BRA 0xC6C4
C6C0  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
C6C2  0012     RETURN 0
1851:                          {
1852:                              if(Mf_PRACA)
C6C4  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
C6C6  0012     RETURN 0
1853:                              {
1854:                                  Mf_BLOKUJ_15S = 1; //ustaw flage blokady 15 sek dla grzania CO
C6C8  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1855:                                  M.BL15 = 0;
C6CA  0E00     MOVLW 0x0
C6CC  0100     MOVLB 0x0
C6CE  6F8C     MOVWF _PFNf_prn_in, BANKED
1856:                              }
1857:                          }
1858:                      }
1859:                      return;
C6D0  0012     RETURN 0
1860:                  }
1861:                  default: //domyslny monotermiczny
1862:                  {
1863:                      if(!Mf_ZMKCOCW && _KCO_CW) //aktywny obieg CO?
C6D2  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
C6D4  A283     BTFSS PORTD, 1, ACCESS
C6D6  0012     RETURN 0
1864:                      {
1865:                          Mf_RPM_CW = 1; //ustaw znacznik obiegu CW
C6D8  8208     BSF Mf_ROZRUCH, 1, ACCESS
1866:                          Mf_ZMKCOCW = 1; //uruchom procedure zmiany obiegu CO na CW
C6DA  8A0A     BSF Mf_pob_AL, 5, ACCESS
1867:                          M.ZKP = 0;
C6DC  0E00     MOVLW 0x0
C6DE  0100     MOVLB 0x0
C6E0  6F92     MOVWF _PFNf_set_fnserw, BANKED
1868:                          if(Mf_pob_KCW || Mf_pob_CW || Mf_pob_DzCW || Mf_pob_AL)
C6E2  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
C6E4  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
C6E6  D004     BRA 0xC6F0
C6E8  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
C6EA  D002     BRA 0xC6F0
C6EC  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
C6EE  0012     RETURN 0
1869:                          {
1870:                              if(Mf_PRACA)
C6F0  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
C6F2  0012     RETURN 0
1871:                              {
1872:                                  Mf_BLOKUJ_15S = 1; //ustaw flage blokady 15 sek dla grzania CO
C6F4  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1873:                                  M.BL15 = 0;
C6F6  0E00     MOVLW 0x0
C6F8  0100     MOVLB 0x0
C6FA  6F8C     MOVWF _PFNf_prn_in, BANKED
1874:                              }
1875:                          }
1876:                      }
1877:                      return;
1878:                  }
1879:              }
C6FC  0012     RETURN 0
1880:          }
C712  0012     RETURN 0
1881:          //Ustaw minimalny wydatek na modulatorze
1882:          
1883:          void SetLoMod(void)
1884:          {
1885:              Mf_MODULUJ = 0; //wylacz blok modulacji
1886:              WritePWM(0);
1887:          }
1888:          //------------------
1889:          //------------------
1890:          //Decyzja o zapaleniu palnika
1891:          
1892:          void DecRozruch(void)
1893:          {
1894:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
9288  D103     BRA 0x9490
9490  0100     MOVLB 0x0
9492  519E     MOVF _PWMf_ENPWM2, W, BANKED
9494  E101     BNZ 0x9498
9496  D746     BRA 0x9324
9498  0A01     XORLW 0x1
949A  E101     BNZ 0x949E
949C  D6F6     BRA 0x928A
949E  0A03     XORLW 0x3
94A0  E101     BNZ 0x94A4
94A2  D6F3     BRA 0x928A
94A4  0A01     XORLW 0x1
94A6  E101     BNZ 0x94AA
94A8  D73D     BRA 0x9324
94AA  D797     BRA 0x93DA
1895:              {
1896:                  case _BITERM: //bitermiczny (miniterm)
1897:                  case _BITERM2: //bitermiczny (maxiterm)
1898:                  {
1899:                      if(!Mf_ROZRUCH && !_GRZEJ)
928A  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
928C  B083     BTFSC PORTD, 0, ACCESS
928E  0012     RETURN 0
1900:                          if(!Mf_ZMKCOCW && !Mf_RUSZ_PWR && !Mf_RUSZ_PLOMIEN && !Mf_RUSZ_CIAG && !Mf_RUSZ_STB && !Mf_RUSZ_NTC_CO && !Mf_RUSZ_NTC_CW)
9290  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
9292  BE09     BTFSC Mf_RUSZ_PWR, 7, ACCESS
9294  0012     RETURN 0
9296  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
9298  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
929A  0012     RETURN 0
929C  A20A     BTFSS Mf_pob_AL, 1, ACCESS
929E  B409     BTFSC Mf_RUSZ_PWR, 2, ACCESS
92A0  0012     RETURN 0
92A2  A609     BTFSS Mf_RUSZ_PWR, 3, ACCESS
1901:                              if(!Mf_RUSZ_POMPE && !Mf_RUSZ_CISN && !Mf_RUSZ_NCISN)
92A4  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
92A6  0012     RETURN 0
92A8  AE08     BTFSS Mf_ROZRUCH, 7, ACCESS
92AA  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
92AC  0012     RETURN 0
1902:                              {
1903:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
92AE  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
92B0  D008     BRA 0x92C2
1904:                                  {
1905:                                      if(DtCWf_su_CW)
92B2  A005     BTFSS DtKNFf_enknf, 0, ACCESS
92B4  0012     RETURN 0
1906:                                      {
1907:                                          Mf_BLOKUJ_15S = 1;
92B6  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1908:                                          M.BL15 = 0;
92B8  0100     MOVLB 0x0
92BA  6B8C     CLRF _PFNf_prn_in, BANKED
1909:                                          SetRozruch();
92BC  EC34     CALL 0xE868, 0
92BE  F074     NOP
1910:                                      }
1911:                                  }
92C0  0012     RETURN 0
1912:                                  else
1913:                                      if(Mf_pob_KCO) //konfiguracja obieg CO
92C2  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
92C4  D005     BRA 0x92D0
1914:                                  {
1915:                                      if(DtCOf_su_CO) SetRozruch();
92C6  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
92C8  0012     RETURN 0
92CA  EC34     CALL 0xE868, 0
92CC  F074     NOP
1916:                                  }
92CE  0012     RETURN 0
1917:                                  else
1918:                                      if(Mf_pob_SRW) //funkcja serwisowa
92D0  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
92D2  D005     BRA 0x92DE
1919:                                  {
1920:                                      if(DtCOf_su_SRW_CO) SetRozruch();
92D4  A203     BTFSS DtCOf_su_SRW_CO, 1, ACCESS
92D6  0012     RETURN 0
92D8  EC34     CALL 0xE868, 0
92DA  F074     NOP
1921:                                  }
92DC  0012     RETURN 0
1922:                                  else
1923:                                      if(Mf_pob_CW) //grzanie obiegu CW
92DE  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
92E0  D008     BRA 0x92F2
1924:                                  {
1925:                                      if(DtCWf_su_CW)
92E2  A005     BTFSS DtKNFf_enknf, 0, ACCESS
92E4  0012     RETURN 0
1926:                                      {
1927:                                          Mf_BLOKUJ_15S = 1;
92E6  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1928:                                          M.BL15 = 0;
92E8  0100     MOVLB 0x0
92EA  6B8C     CLRF _PFNf_prn_in, BANKED
1929:                                          SetRozruch();
92EC  EC34     CALL 0xE868, 0
92EE  F074     NOP
1930:                                      }
1931:                                  }
92F0  0012     RETURN 0
1932:                                  else
1933:                                      if(Mf_pob_CO && DtCOf_su_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //grzanie obiegu CO
92F2  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
92F4  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
92F6  D005     BRA 0x9302
92F8  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
92FA  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
92FC  D002     BRA 0x9302
1934:                                  {
1935:                                      SetRozruch();
92FE  EF34     GOTO 0xE868
9300  F074     NOP
1936:                                  }
1937:                                  else
1938:                                      if(Mf_pob_DzCO && DtCOf_su_DZ_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //temperatura dyzurna w obiegu CO
9302  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
9304  A003     BTFSS DtCOf_su_SRW_CO, 0, ACCESS
9306  D005     BRA 0x9312
9308  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
930A  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
930C  D002     BRA 0x9312
1939:                                  {
1940:                                      SetRozruch();
930E  EF34     GOTO 0xE868
9310  F074     NOP
1941:                                  }
1942:                                  else
1943:                                      if(Mf_pob_DzCW && DtCWf_su_DZ_CW) //temperatura dyzurna w obiegu CW
9312  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
9314  A205     BTFSS DtKNFf_enknf, 1, ACCESS
9316  0012     RETURN 0
1944:                                  {
1945:                                      Mf_BLOKUJ_15S = 1;
9318  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1946:                                      M.BL15 = 0;
931A  0100     MOVLB 0x0
931C  6B8C     CLRF _PFNf_prn_in, BANKED
1947:                                      SetRozruch();
931E  EC34     CALL 0xE868, 0
9320  F074     NOP
1948:                                  }
1949:                              }
1950:                      break;
9322  0012     RETURN 0
1951:                  }
1952:                  case _UNICO:
1953:                  case _MONOHB:
1954:                  {
1955:                      if(!Mf_ROZRUCH && !_GRZEJ)
9324  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
9326  B083     BTFSC PORTD, 0, ACCESS
9328  0012     RETURN 0
1956:                          if(!Mf_ZMKCOCW && !Mf_RUSZ_PWR && !Mf_RUSZ_PLOMIEN && !Mf_RUSZ_CIAG && !Mf_RUSZ_STB && !Mf_RUSZ_NTC_CO && !Mf_RUSZ_NTC_CW)
932A  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
932C  BE09     BTFSC Mf_RUSZ_PWR, 7, ACCESS
932E  0012     RETURN 0
9330  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
9332  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
9334  0012     RETURN 0
9336  A20A     BTFSS Mf_pob_AL, 1, ACCESS
9338  B409     BTFSC Mf_RUSZ_PWR, 2, ACCESS
933A  0012     RETURN 0
933C  A609     BTFSS Mf_RUSZ_PWR, 3, ACCESS
1957:                              if(!Mf_RUSZ_POMPE && !Mf_RUSZ_CISN && !Mf_RUSZ_NCISN)
933E  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
9340  0012     RETURN 0
9342  AE08     BTFSS Mf_ROZRUCH, 7, ACCESS
9344  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
9346  0012     RETURN 0
1958:                              {
1959:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
9348  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
934A  D009     BRA 0x935E
1960:                                  {
1961:                                      if(DtCWf_su_CW && DtCOf_pz_CO)
934C  B005     BTFSC DtKNFf_enknf, 0, ACCESS
934E  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9350  0012     RETURN 0
1962:                                      {
1963:                                          Mf_BLOKUJ_15S = 1;
9352  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1964:                                          M.BL15 = 0;
9354  0100     MOVLB 0x0
9356  6B8C     CLRF _PFNf_prn_in, BANKED
1965:                                          SetRozruch();
9358  EC34     CALL 0xE868, 0
935A  F074     NOP
1966:                                      }
1967:                                  }
935C  0012     RETURN 0
1968:                                  else
1969:                                      if(Mf_pob_KCO) //konfiguracja obieg CO
935E  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
9360  D005     BRA 0x936C
1970:                                  {
1971:                                      if(DtCOf_su_CO) SetRozruch();
9362  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
9364  0012     RETURN 0
9366  EC34     CALL 0xE868, 0
9368  F074     NOP
1972:                                  }
936A  0012     RETURN 0
1973:                                  else
1974:                                      if(Mf_pob_SRW) //funkcja serwisowa
936C  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
936E  D005     BRA 0x937A
1975:                                  {
1976:                                      if(DtCOf_su_SRW_CO) SetRozruch();
9370  A203     BTFSS DtCOf_su_SRW_CO, 1, ACCESS
9372  0012     RETURN 0
9374  EC34     CALL 0xE868, 0
9376  F074     NOP
1977:                                  }
9378  0012     RETURN 0
1978:                                  else
1979:                                      if(Mf_pob_AL)
937A  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
937C  D008     BRA 0x938E
1980:                                  {
1981:                                      if(DtCOf_pz_CO)
937E  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9380  0012     RETURN 0
1982:                                      {
1983:                                          Mf_BLOKUJ_15S = 1;
9382  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1984:                                          M.BL15 = 0;
9384  0100     MOVLB 0x0
9386  6B8C     CLRF _PFNf_prn_in, BANKED
1985:                                          SetRozruch();
9388  EC34     CALL 0xE868, 0
938A  F074     NOP
1986:                                      }
1987:                                  }
938C  0012     RETURN 0
1988:                                  else
1989:                                      if(Mf_pob_CW) //grzanie obiegu CW
938E  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
9390  D009     BRA 0x93A4
1990:                                  {
1991:                                      if(DtCWf_su_CW && DtCOf_pz_CO)
9392  B005     BTFSC DtKNFf_enknf, 0, ACCESS
9394  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9396  0012     RETURN 0
1992:                                      {
1993:                                          Mf_BLOKUJ_15S = 1;
9398  8E06     BSF DtKNFf_wymCO, 7, ACCESS
1994:                                          M.BL15 = 0;
939A  0100     MOVLB 0x0
939C  6B8C     CLRF _PFNf_prn_in, BANKED
1995:                                          SetRozruch();
939E  EC34     CALL 0xE868, 0
93A0  F074     NOP
1996:                                      }
1997:                                  }
93A2  0012     RETURN 0
1998:                                  else
1999:                                      if(Mf_pob_CO && DtCOf_su_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //grzanie obiegu CO
93A4  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
93A6  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
93A8  D005     BRA 0x93B4
93AA  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
93AC  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
93AE  D002     BRA 0x93B4
2000:                                  {
2001:                                      SetRozruch();
93B0  EF34     GOTO 0xE868
93B2  F074     NOP
2002:                                  }
2003:                                  else
2004:                                      if(Mf_pob_DzCO && DtCOf_su_DZ_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //temperatura dyzurna w obiegu CO
93B4  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
93B6  A003     BTFSS DtCOf_su_SRW_CO, 0, ACCESS
93B8  D005     BRA 0x93C4
93BA  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
93BC  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
93BE  D002     BRA 0x93C4
2005:                                  {
2006:                                      SetRozruch();
93C0  EF34     GOTO 0xE868
93C2  F074     NOP
2007:                                  }
2008:                                  else
2009:                                      if(Mf_pob_DzCW && DtCWf_su_DZ_CW && DtCOf_pz_CO) //temperatura dyzurna w obiegu CW
93C4  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
93C6  A205     BTFSS DtKNFf_enknf, 1, ACCESS
93C8  0012     RETURN 0
93CA  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
93CC  0012     RETURN 0
2010:                                  {
2011:                                      Mf_BLOKUJ_15S = 1;
93CE  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2012:                                      M.BL15 = 0;
93D0  0100     MOVLB 0x0
93D2  6B8C     CLRF _PFNf_prn_in, BANKED
2013:                                      SetRozruch();
93D4  EC34     CALL 0xE868, 0
93D6  F074     NOP
2014:                                  }
2015:                              }
2016:                      break;
93D8  0012     RETURN 0
2017:                  }
2018:                  default: //domyslny monotermiczny
2019:                  {
2020:                      if(!Mf_ROZRUCH && !_GRZEJ)
93DA  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
93DC  B083     BTFSC PORTD, 0, ACCESS
93DE  0012     RETURN 0
2021:                          if(!Mf_ZMKCOCW && !Mf_RUSZ_PWR && !Mf_RUSZ_PLOMIEN && !Mf_RUSZ_CIAG && !Mf_RUSZ_STB && !Mf_RUSZ_NTC_CO && !Mf_RUSZ_NTC_CW)
93E0  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
93E2  BE09     BTFSC Mf_RUSZ_PWR, 7, ACCESS
93E4  0012     RETURN 0
93E6  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
93E8  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
93EA  0012     RETURN 0
93EC  A20A     BTFSS Mf_pob_AL, 1, ACCESS
93EE  B409     BTFSC Mf_RUSZ_PWR, 2, ACCESS
93F0  0012     RETURN 0
93F2  A609     BTFSS Mf_RUSZ_PWR, 3, ACCESS
2022:                              if(!Mf_RUSZ_POMPE && !Mf_RUSZ_CISN && !Mf_RUSZ_NCISN)
93F4  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
93F6  0012     RETURN 0
93F8  AE08     BTFSS Mf_ROZRUCH, 7, ACCESS
93FA  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
93FC  0012     RETURN 0
2023:                              {
2024:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
93FE  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
9400  D009     BRA 0x9414
2025:                                  {
2026:                                      if(DtCWf_su_CW && DtCOf_pz_CO)
9402  B005     BTFSC DtKNFf_enknf, 0, ACCESS
9404  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9406  0012     RETURN 0
2027:                                      {
2028:                                          Mf_BLOKUJ_15S = 1;
9408  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2029:                                          M.BL15 = 0;
940A  0100     MOVLB 0x0
940C  6B8C     CLRF _PFNf_prn_in, BANKED
2030:                                          SetRozruch();
940E  EC34     CALL 0xE868, 0
9410  F074     NOP
2031:                                      }
2032:                                  }
9412  0012     RETURN 0
2033:                                  else
2034:                                      if(Mf_pob_KCO) //konfiguracja obieg CO
9414  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
9416  D005     BRA 0x9422
2035:                                  {
2036:                                      if(DtCOf_su_CO) SetRozruch();
9418  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
941A  0012     RETURN 0
941C  EC34     CALL 0xE868, 0
941E  F074     NOP
2037:                                  }
9420  0012     RETURN 0
2038:                                  else
2039:                                      if(Mf_pob_SRW) //funkcja serwisowa
9422  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
9424  D005     BRA 0x9430
2040:                                  {
2041:                                      if(DtCOf_su_SRW_CO) SetRozruch();
9426  A203     BTFSS DtCOf_su_SRW_CO, 1, ACCESS
9428  0012     RETURN 0
942A  EC34     CALL 0xE868, 0
942C  F074     NOP
2042:                                  }
942E  0012     RETURN 0
2043:                                  else
2044:                                      if(Mf_pob_AL)
9430  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
9432  D008     BRA 0x9444
2045:                                  {
2046:                                      if(DtCOf_pz_CO)
9434  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9436  0012     RETURN 0
2047:                                      {
2048:                                          Mf_BLOKUJ_15S = 1;
9438  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2049:                                          M.BL15 = 0;
943A  0100     MOVLB 0x0
943C  6B8C     CLRF _PFNf_prn_in, BANKED
2050:                                          SetRozruch();
943E  EC34     CALL 0xE868, 0
9440  F074     NOP
2051:                                      }
2052:                                  }
9442  0012     RETURN 0
2053:                                  else
2054:                                      if(Mf_pob_CW) //grzanie obiegu CW
9444  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
9446  D009     BRA 0x945A
2055:                                  {
2056:                                      if(DtCWf_su_CW && DtCOf_pz_CO)
9448  B005     BTFSC DtKNFf_enknf, 0, ACCESS
944A  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
944C  0012     RETURN 0
2057:                                      {
2058:                                          Mf_BLOKUJ_15S = 1;
944E  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2059:                                          M.BL15 = 0;
9450  0100     MOVLB 0x0
9452  6B8C     CLRF _PFNf_prn_in, BANKED
2060:                                          SetRozruch();
9454  EC34     CALL 0xE868, 0
9456  F074     NOP
2061:                                      }
2062:                                  }
9458  0012     RETURN 0
2063:                                  else
2064:                                      if(Mf_pob_CO && DtCOf_su_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //grzanie obiegu CO
945A  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
945C  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
945E  D005     BRA 0x946A
9460  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
9462  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
9464  D002     BRA 0x946A
2065:                                  {
2066:                                      SetRozruch();
9466  EF34     GOTO 0xE868
9468  F074     NOP
2067:                                  }
2068:                                  else
2069:                                      if(Mf_pob_DzCO && DtCOf_su_DZ_CO && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S) //temperatura dyzurna w obiegu CO
946A  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
946C  A003     BTFSS DtCOf_su_SRW_CO, 0, ACCESS
946E  D005     BRA 0x947A
9470  A007     BTFSS Mf_BLOKUJ_3M, 0, ACCESS
9472  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
9474  D002     BRA 0x947A
2070:                                  {
2071:                                      SetRozruch();
9476  EF34     GOTO 0xE868
9478  F074     NOP
2072:                                  }
2073:                                  else
2074:                                      if(Mf_pob_DzCW && DtCWf_su_DZ_CW && DtCOf_pz_CO) //temperatura dyzurna w obiegu CW
947A  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
947C  A205     BTFSS DtKNFf_enknf, 1, ACCESS
947E  0012     RETURN 0
9480  AA02     BTFSS DtCOf_su_CO, 5, ACCESS
9482  0012     RETURN 0
2075:                                  {
2076:                                      Mf_BLOKUJ_15S = 1;
9484  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2077:                                      M.BL15 = 0;
9486  0100     MOVLB 0x0
9488  6B8C     CLRF _PFNf_prn_in, BANKED
2078:                                      SetRozruch();
948A  EC34     CALL 0xE868, 0
948C  F074     NOP
2079:                                  }
2080:                              }
2081:                      break;
2082:                  }
2083:              }
948E  0012     RETURN 0
2084:          }
94AC  0012     RETURN 0
2085:          //Uruchomienie procedury rozruchu
2086:          
2087:          void SetRozruch(void)
2088:          {
2089:              Mf_BLOKUJ_3M = 0; //usun blokade L3
E868  9007     BCF Mf_BLOKUJ_3M, 0, ACCESS
2090:              M.BL3 = 0;
E86A  0100     MOVLB 0x0
E86C  6B8B     CLRF _PFNf_prn_cs, BANKED
2091:              EndL3();
E86E  ECE1     CALL 0xF3C2, 0
E870  F079     NOP
2092:              Mf_RUSZ_48 = 0;
E872  9808     BCF Mf_ROZRUCH, 4, ACCESS
2093:              M.R48 = 0;
E874  0100     MOVLB 0x0
E876  6B89     CLRF _PFNf_plmCW, BANKED
2094:              Mf_RUSZ_48Z3 = 0;
E878  9A08     BCF Mf_ROZRUCH, 5, ACCESS
2095:              M.R48Z3 = 0;
E87A  0100     MOVLB 0x0
E87C  6B8A     CLRF _PFNf_pmpPWM, BANKED
2096:              Mf_VWYBIEG = 0;
E87E  960A     BCF Mf_pob_AL, 3, ACCESS
2097:              Mf_DE_VNT = 0;
E880  9407     BCF Mf_BLOKUJ_3M, 2, ACCESS
2098:              M.VWB = 0;
E882  0100     MOVLB 0x0
E884  6B93     CLRF _PFNf_set_nco, BANKED
2099:              //-----
2100:              Mf_KCW_PMP = 0;
E886  9607     BCF Mf_BLOKUJ_3M, 3, ACCESS
2101:              M.WYL = 0;
E888  0100     MOVLB 0x0
E88A  6B8D     CLRF _PFNf_prn_res, BANKED
2102:              M.RPR = 0;
E88C  0100     MOVLB 0x0
E88E  6B8E     CLRF _PFNf_prnaleg, BANKED
2103:              Mf_WYLACZ = 0;
E890  980A     BCF Mf_pob_AL, 4, ACCESS
2104:              Mf_RUSZ_POMPE = 0;
E892  9C09     BCF Mf_RUSZ_PWR, 6, ACCESS
2105:              Mf_ROZRUCH = 1;
E894  8008     BSF Mf_ROZRUCH, 0, ACCESS
2106:              M.ROZ = 0;
E896  0E00     MOVLW 0x0
E898  0100     MOVLB 0x0
E89A  6B88     CLRF _PFNf_plmCO, BANKED
2107:              //	x=0;
2108:          }
E89C  0012     RETURN 0
2109:          //------------------
2110:          //------------------
2111:          //Decyzja o wygaszeniu palnika
2112:          
2113:          void DecWylacz(void)
2114:          {
2115:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
67BA  D177     BRA 0x6AAA
6AAA  0100     MOVLB 0x0
6AAC  519E     MOVF _PWMf_ENPWM2, W, BANKED
6AAE  E101     BNZ 0x6AB2
6AB0  D6F8     BRA 0x68A2
6AB2  0A01     XORLW 0x1
6AB4  E101     BNZ 0x6AB8
6AB6  D682     BRA 0x67BC
6AB8  0A03     XORLW 0x3
6ABA  E101     BNZ 0x6ABE
6ABC  D67F     BRA 0x67BC
6ABE  0A01     XORLW 0x1
6AC0  E101     BNZ 0x6AC4
6AC2  D6EF     BRA 0x68A2
6AC4  D770     BRA 0x69A6
2116:              {
2117:                  case _BITERM: //bitermiczny (miniterm)
2118:                  case _BITERM2: //bitermiczny (maxiterm)
2119:                  {
2120:                      if(!Mf_WYLACZ)
67BC  B80A     BTFSC Mf_pob_AL, 4, ACCESS
67BE  0012     RETURN 0
2121:                          if(Mf_ROZRUCH || _GRZEJ)
67C0  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
67C2  D002     BRA 0x67C8
67C4  A083     BTFSS PORTD, 0, ACCESS
67C6  0012     RETURN 0
2122:                          {
2123:                              if(!Mf_pob_KCW && !Mf_pob_KCO && !Mf_pob_SRW && !Mf_pob_CW && !Mf_pob_CO && !Mf_pob_DzCO && !Mf_pob_DzCW)
67C8  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
67CA  B60B     BTFSC Mf_pob_KCO, 3, ACCESS
67CC  D00B     BRA 0x67E4
67CE  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
67D0  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
67D2  D008     BRA 0x67E4
67D4  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
67D6  B20B     BTFSC Mf_pob_KCO, 1, ACCESS
67D8  D005     BRA 0x67E4
67DA  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
67DC  D003     BRA 0x67E4
2124:                              {
2125:                                  SetWylacz();
67DE  ECFF     CALL 0xCBFE, 0
67E0  F065     NOP
2126:                                  return;
67E2  0012     RETURN 0
2127:                              }
2128:                              if(Mf_RUSZ_PWR || Mf_RUSZ_PLOMIEN || Mf_RUSZ_CIAG || Mf_RUSZ_STB || Mf_RUSZ_NTC_CO || Mf_RUSZ_NTC_CW || Mf_RUSZ_POMPE || Mf_RUSZ_CISN || Mf_RUSZ_NCISN)
67E4  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
67E6  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
67E8  EFFF     GOTO 0xCBFE
67EA  F065     NOP
67EC  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
67EE  B20A     BTFSC Mf_pob_AL, 1, ACCESS
67F0  EFFF     GOTO 0xCBFE
67F2  F065     NOP
67F4  A409     BTFSS Mf_RUSZ_PWR, 2, ACCESS
67F6  B609     BTFSC Mf_RUSZ_PWR, 3, ACCESS
67F8  EFFF     GOTO 0xCBFE
67FA  F065     NOP
67FC  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
67FE  BE08     BTFSC Mf_ROZRUCH, 7, ACCESS
6800  EFFF     GOTO 0xCBFE
6802  F065     NOP
6804  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
2129:                              {
2130:                                  SetWylacz();
6806  EFFF     GOTO 0xCBFE
6808  F065     NOP
2131:                              }
2132:                              else
2133:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
680A  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
680C  D005     BRA 0x6818
2134:                              {
2135:                                  if(DtCWf_ad_CW) SetWylacz();
680E  A204     BTFSS DtCWf_err_CW, 1, ACCESS
6810  0012     RETURN 0
6812  ECFF     CALL 0xCBFE, 0
6814  F065     NOP
2136:                              }
6816  0012     RETURN 0
2137:                              else
2138:                                  if(Mf_pob_KCO) //konfiguracja obieg CO
6818  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
681A  D008     BRA 0x682C
2139:                              {
2140:                                  if(RdPrt(S_ADD_CO)) SetWylacz();
681C  0E13     MOVLW 0x13
681E  ECFD     CALL 0xE7FA, 0
6820  F073     NOP
6822  A0D8     BTFSS STATUS, 0, ACCESS
6824  0012     RETURN 0
6826  ECFF     CALL 0xCBFE, 0
6828  F065     NOP
2141:                              }
682A  0012     RETURN 0
2142:                              else
2143:                                  if(Mf_pob_SRW) //funkcja serwisowa
682C  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
682E  D005     BRA 0x683A
2144:                              {
2145:                                  if(DtCOf_ad_SRW_CO) SetWylacz();
6830  AA01     BTFSS DtCOf_err_CO, 5, ACCESS
6832  0012     RETURN 0
6834  ECFF     CALL 0xCBFE, 0
6836  F065     NOP
2146:                              }
6838  0012     RETURN 0
2147:                              else
2148:                                  if(Mf_pob_CW) //grzanie obiegu CW
683A  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
683C  D005     BRA 0x6848
2149:                              {
2150:                                  if(DtCWf_ad_CW) SetWylacz();
683E  A204     BTFSS DtCWf_err_CW, 1, ACCESS
6840  0012     RETURN 0
6842  ECFF     CALL 0xCBFE, 0
6844  F065     NOP
2151:                              }
6846  0012     RETURN 0
2152:                              else
2153:                                  if(Mf_pob_CO && (RdPrt(S_ADD_CO) || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //grzanie obiegu CO
6848  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
684A  D01C     BRA 0x6884
684C  0E13     MOVLW 0x13
684E  ECFD     CALL 0xE7FA, 0
6850  F073     NOP
6852  A0D8     BTFSS STATUS, 0, ACCESS
6854  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6856  D002     BRA 0x685C
6858  AE06     BTFSS DtKNFf_wymCO, 7, ACCESS
685A  D014     BRA 0x6884
2154:                              {
2155:                                  if(RdPrt(S_ADD_CO) && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S)
685C  0E13     MOVLW 0x13
685E  ECFD     CALL 0xE7FA, 0
6860  F073     NOP
6862  B0D8     BTFSC STATUS, 0, ACCESS
6864  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6866  EFFF     GOTO 0xCBFE
6868  F065     NOP
686A  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
686C  EFFF     GOTO 0xCBFE
686E  F065     NOP
2156:                                  {
2157:                                      Mf_BLOKUJ_3M = 1; //uaktywnij blokade L3
6870  8007     BSF Mf_BLOKUJ_3M, 0, ACCESS
2158:                                      M.BL3 = 0;
6872  0E00     MOVLW 0x0
6874  0100     MOVLB 0x0
6876  6B8B     CLRF _PFNf_prn_cs, BANKED
2159:                                      SetL3();
6878  EC12     CALL 0xF424, 0
687A  F07A     NOP
687C  EFFF     GOTO 0xCBFE
687E  F065     NOP
2160:                                  }
2161:                                  SetWylacz();
6880  EFFF     GOTO 0xCBFE
6882  F065     NOP
2162:                              }
2163:                              else
2164:                                  if(Mf_pob_DzCO && (DtCOf_ad_DZ_CO || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //temperatura dyzurna w obiegu CO
6884  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
6886  D007     BRA 0x6896
6888  A801     BTFSS DtCOf_err_CO, 4, ACCESS
688A  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
688C  EFFF     GOTO 0xCBFE
688E  F065     NOP
6890  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
2165:                              {
2166:                                  SetWylacz();
6892  EFFF     GOTO 0xCBFE
6894  F065     NOP
2167:                              }
2168:                              else
2169:                                  if(Mf_pob_DzCW && DtCWf_ad_DZ_CW) //temperatura dyzurna w obiegu CW
6896  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
6898  A404     BTFSS DtCWf_err_CW, 2, ACCESS
689A  0012     RETURN 0
2170:                              {
2171:                                  SetWylacz();
689C  ECFF     CALL 0xCBFE, 0
689E  F065     NOP
2172:                              }
2173:                          }
2174:                      break;
68A0  0012     RETURN 0
2175:                  }
2176:                  case _UNICO:
2177:                  case _MONOHB:
2178:                  {
2179:                      if(!Mf_WYLACZ)
68A2  B80A     BTFSC Mf_pob_AL, 4, ACCESS
68A4  0012     RETURN 0
2180:                          if(Mf_ROZRUCH || _GRZEJ)
68A6  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
68A8  D002     BRA 0x68AE
68AA  A083     BTFSS PORTD, 0, ACCESS
68AC  0012     RETURN 0
2181:                          {
2182:                              if(!Mf_pob_KCW && !Mf_pob_AL && !Mf_pob_KCO && !Mf_pob_SRW && !Mf_pob_CW && !Mf_pob_CO && !Mf_pob_DzCO && !Mf_pob_DzCW)
68AE  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
68B0  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
68B2  D00C     BRA 0x68CC
68B4  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
68B6  BA0B     BTFSC Mf_pob_KCO, 5, ACCESS
68B8  D009     BRA 0x68CC
68BA  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
68BC  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
68BE  D006     BRA 0x68CC
68C0  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
68C2  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
68C4  D003     BRA 0x68CC
2183:                              {
2184:                                  SetWylacz();
68C6  ECFF     CALL 0xCBFE, 0
68C8  F065     NOP
2185:                                  return;
68CA  0012     RETURN 0
2186:                              }
2187:                              if(Mf_RUSZ_PWR || Mf_RUSZ_PLOMIEN || Mf_RUSZ_CIAG || Mf_RUSZ_STB || Mf_RUSZ_NTC_CO || Mf_RUSZ_NTC_CW || Mf_RUSZ_POMPE || Mf_RUSZ_CISN || Mf_RUSZ_NCISN)
68CC  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
68CE  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
68D0  EFFF     GOTO 0xCBFE
68D2  F065     NOP
68D4  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
68D6  B20A     BTFSC Mf_pob_AL, 1, ACCESS
68D8  EFFF     GOTO 0xCBFE
68DA  F065     NOP
68DC  A409     BTFSS Mf_RUSZ_PWR, 2, ACCESS
68DE  B609     BTFSC Mf_RUSZ_PWR, 3, ACCESS
68E0  EFFF     GOTO 0xCBFE
68E2  F065     NOP
68E4  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
68E6  BE08     BTFSC Mf_ROZRUCH, 7, ACCESS
68E8  EFFF     GOTO 0xCBFE
68EA  F065     NOP
68EC  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
2188:                              {
2189:                                  SetWylacz();
68EE  EFFF     GOTO 0xCBFE
68F0  F065     NOP
2190:                              }
2191:                              else
2192:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
68F2  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
68F4  D007     BRA 0x6904
2193:                              {
2194:                                  if(DtCWf_ad_CW || !DtCOf_pz_CO) SetWylacz();
68F6  B204     BTFSC DtCWf_err_CW, 1, ACCESS
68F8  D002     BRA 0x68FE
68FA  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
68FC  0012     RETURN 0
68FE  ECFF     CALL 0xCBFE, 0
6900  F065     NOP
2195:                              }
6902  0012     RETURN 0
2196:                              else
2197:                                  if(Mf_pob_AL) //konfiguracja obieg CW
6904  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
6906  D005     BRA 0x6912
2198:                              {
2199:                                  if(!DtCOf_pz_CO) SetWylacz();
6908  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
690A  0012     RETURN 0
690C  ECFF     CALL 0xCBFE, 0
690E  F065     NOP
2200:                              }
6910  0012     RETURN 0
2201:                              else
2202:                                  if(Mf_pob_KCO) //konfiguracja obieg CO
6912  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
6914  D008     BRA 0x6926
2203:                              {
2204:                                  if(RdPrt(S_ADD_CO)) SetWylacz();
6916  0E13     MOVLW 0x13
6918  ECFD     CALL 0xE7FA, 0
691A  F073     NOP
691C  A0D8     BTFSS STATUS, 0, ACCESS
691E  0012     RETURN 0
6920  ECFF     CALL 0xCBFE, 0
6922  F065     NOP
2205:                              }
6924  0012     RETURN 0
2206:                              else
2207:                                  if(Mf_pob_SRW) //funkcja serwisowa
6926  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
6928  D005     BRA 0x6934
2208:                              {
2209:                                  if(DtCOf_ad_SRW_CO) SetWylacz();
692A  AA01     BTFSS DtCOf_err_CO, 5, ACCESS
692C  0012     RETURN 0
692E  ECFF     CALL 0xCBFE, 0
6930  F065     NOP
2210:                              }
6932  0012     RETURN 0
2211:                              else
2212:                                  if(Mf_pob_CW) //grzanie obiegu CW
6934  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
6936  D007     BRA 0x6946
2213:                              {
2214:                                  if(DtCWf_ad_CW || !DtCOf_pz_CO) SetWylacz();
6938  B204     BTFSC DtCWf_err_CW, 1, ACCESS
693A  D002     BRA 0x6940
693C  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
693E  0012     RETURN 0
6940  ECFF     CALL 0xCBFE, 0
6942  F065     NOP
2215:                              }
6944  0012     RETURN 0
2216:                              else
2217:                                  if(Mf_pob_CO && (RdPrt(S_ADD_CO) || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //grzanie obiegu CO
6946  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
6948  D01C     BRA 0x6982
694A  0E13     MOVLW 0x13
694C  ECFD     CALL 0xE7FA, 0
694E  F073     NOP
6950  A0D8     BTFSS STATUS, 0, ACCESS
6952  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6954  D002     BRA 0x695A
6956  AE06     BTFSS DtKNFf_wymCO, 7, ACCESS
6958  D014     BRA 0x6982
2218:                              {
2219:                                  if(RdPrt(S_ADD_CO) && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S)
695A  0E13     MOVLW 0x13
695C  ECFD     CALL 0xE7FA, 0
695E  F073     NOP
6960  B0D8     BTFSC STATUS, 0, ACCESS
6962  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6964  EFFF     GOTO 0xCBFE
6966  F065     NOP
6968  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
696A  EFFF     GOTO 0xCBFE
696C  F065     NOP
2220:                                  {
2221:                                      Mf_BLOKUJ_3M = 1; //uaktywnij blokade L3
696E  8007     BSF Mf_BLOKUJ_3M, 0, ACCESS
2222:                                      M.BL3 = 0;
6970  0E00     MOVLW 0x0
6972  0100     MOVLB 0x0
6974  6B8B     CLRF _PFNf_prn_cs, BANKED
2223:                                      SetL3();
6976  EC12     CALL 0xF424, 0
6978  F07A     NOP
697A  EFFF     GOTO 0xCBFE
697C  F065     NOP
2224:                                  }
2225:                                  SetWylacz();
697E  EFFF     GOTO 0xCBFE
6980  F065     NOP
2226:                              }
2227:                              else
2228:                                  if(Mf_pob_DzCO && (DtCOf_ad_DZ_CO || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //temperatura dyzurna w obiegu CO
6982  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
6984  D007     BRA 0x6994
6986  A801     BTFSS DtCOf_err_CO, 4, ACCESS
6988  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
698A  EFFF     GOTO 0xCBFE
698C  F065     NOP
698E  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
2229:                              {
2230:                                  SetWylacz();
6990  EFFF     GOTO 0xCBFE
6992  F065     NOP
2231:                              }
2232:                              else
2233:                                  if(Mf_pob_DzCW && (DtCWf_ad_DZ_CW || !DtCOf_pz_CO)) //temperatura dyzurna w obiegu CW
6994  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
6996  0012     RETURN 0
6998  B404     BTFSC DtCWf_err_CW, 2, ACCESS
699A  D002     BRA 0x69A0
699C  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
699E  0012     RETURN 0
2234:                              {
2235:                                  SetWylacz();
69A0  ECFF     CALL 0xCBFE, 0
69A2  F065     NOP
2236:                              }
2237:                          }
2238:                      break;
69A4  0012     RETURN 0
2239:                  }
2240:                  default: //domyslny monotermiczny
2241:                  {
2242:                      if(!Mf_WYLACZ)
69A6  B80A     BTFSC Mf_pob_AL, 4, ACCESS
69A8  0012     RETURN 0
2243:                          if(Mf_ROZRUCH || _GRZEJ)
69AA  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
69AC  D002     BRA 0x69B2
69AE  A083     BTFSS PORTD, 0, ACCESS
69B0  0012     RETURN 0
2244:                          {
2245:                              if(!Mf_pob_KCW && !Mf_pob_AL && !Mf_pob_KCO && !Mf_pob_SRW && !Mf_pob_CW && !Mf_pob_CO && !Mf_pob_DzCO && !Mf_pob_DzCW)
69B2  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
69B4  BC0A     BTFSC Mf_pob_AL, 6, ACCESS
69B6  D00C     BRA 0x69D0
69B8  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
69BA  BA0B     BTFSC Mf_pob_KCO, 5, ACCESS
69BC  D009     BRA 0x69D0
69BE  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
69C0  BE0A     BTFSC Mf_pob_AL, 7, ACCESS
69C2  D006     BRA 0x69D0
69C4  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
69C6  B40B     BTFSC Mf_pob_KCO, 2, ACCESS
69C8  D003     BRA 0x69D0
2246:                              {
2247:                                  SetWylacz();
69CA  ECFF     CALL 0xCBFE, 0
69CC  F065     NOP
2248:                                  return;
69CE  0012     RETURN 0
2249:                              }
2250:                              if(Mf_RUSZ_PWR || Mf_RUSZ_PLOMIEN || Mf_RUSZ_CIAG || Mf_RUSZ_STB || Mf_RUSZ_NTC_CO || Mf_RUSZ_NTC_CW || Mf_RUSZ_POMPE || Mf_RUSZ_CISN || Mf_RUSZ_NCISN)
69D0  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
69D2  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
69D4  EFFF     GOTO 0xCBFE
69D6  F065     NOP
69D8  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
69DA  B20A     BTFSC Mf_pob_AL, 1, ACCESS
69DC  EFFF     GOTO 0xCBFE
69DE  F065     NOP
69E0  A409     BTFSS Mf_RUSZ_PWR, 2, ACCESS
69E2  B609     BTFSC Mf_RUSZ_PWR, 3, ACCESS
69E4  EFFF     GOTO 0xCBFE
69E6  F065     NOP
69E8  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
69EA  BE08     BTFSC Mf_ROZRUCH, 7, ACCESS
69EC  EFFF     GOTO 0xCBFE
69EE  F065     NOP
69F0  B209     BTFSC Mf_RUSZ_PWR, 1, ACCESS
2251:                              {
2252:                                  SetWylacz();
69F2  EFFF     GOTO 0xCBFE
69F4  F065     NOP
2253:                              }
2254:                              else
2255:                                  if(Mf_pob_KCW) //konfiguracja obieg CW
69F6  A80B     BTFSS Mf_pob_KCO, 4, ACCESS
69F8  D007     BRA 0x6A08
2256:                              {
2257:                                  if(DtCWf_ad_CW || !DtCOf_pz_CO) SetWylacz();
69FA  B204     BTFSC DtCWf_err_CW, 1, ACCESS
69FC  D002     BRA 0x6A02
69FE  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
6A00  0012     RETURN 0
6A02  ECFF     CALL 0xCBFE, 0
6A04  F065     NOP
2258:                              }
6A06  0012     RETURN 0
2259:                              else
2260:                                  if(Mf_pob_AL) //konfiguracja obieg CW
6A08  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
6A0A  D005     BRA 0x6A16
2261:                              {
2262:                                  if(!DtCOf_pz_CO) SetWylacz();
6A0C  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
6A0E  0012     RETURN 0
6A10  ECFF     CALL 0xCBFE, 0
6A12  F065     NOP
2263:                              }
6A14  0012     RETURN 0
2264:                              else
2265:                                  if(Mf_pob_KCO) //konfiguracja obieg CO
6A16  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
6A18  D008     BRA 0x6A2A
2266:                              {
2267:                                  if(RdPrt(S_ADD_CO)) SetWylacz();
6A1A  0E13     MOVLW 0x13
6A1C  ECFD     CALL 0xE7FA, 0
6A1E  F073     NOP
6A20  A0D8     BTFSS STATUS, 0, ACCESS
6A22  0012     RETURN 0
6A24  ECFF     CALL 0xCBFE, 0
6A26  F065     NOP
2268:                              }
6A28  0012     RETURN 0
2269:                              else
2270:                                  if(Mf_pob_SRW) //funkcja serwisowa
6A2A  AA0B     BTFSS Mf_pob_KCO, 5, ACCESS
6A2C  D005     BRA 0x6A38
2271:                              {
2272:                                  if(DtCOf_ad_SRW_CO) SetWylacz();
6A2E  AA01     BTFSS DtCOf_err_CO, 5, ACCESS
6A30  0012     RETURN 0
6A32  ECFF     CALL 0xCBFE, 0
6A34  F065     NOP
2273:                              }
6A36  0012     RETURN 0
2274:                              else
2275:                                  if(Mf_pob_CW) //grzanie obiegu CW
6A38  A00B     BTFSS Mf_pob_KCO, 0, ACCESS
6A3A  D007     BRA 0x6A4A
2276:                              {
2277:                                  if(DtCWf_ad_CW || !DtCOf_pz_CO) SetWylacz();
6A3C  B204     BTFSC DtCWf_err_CW, 1, ACCESS
6A3E  D002     BRA 0x6A44
6A40  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
6A42  0012     RETURN 0
6A44  ECFF     CALL 0xCBFE, 0
6A46  F065     NOP
2278:                              }
6A48  0012     RETURN 0
2279:                              else
2280:                                  if(Mf_pob_CO && (RdPrt(S_ADD_CO) || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //grzanie obiegu CO
6A4A  AE0A     BTFSS Mf_pob_AL, 7, ACCESS
6A4C  D01C     BRA 0x6A86
6A4E  0E13     MOVLW 0x13
6A50  ECFD     CALL 0xE7FA, 0
6A52  F073     NOP
6A54  A0D8     BTFSS STATUS, 0, ACCESS
6A56  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6A58  D002     BRA 0x6A5E
6A5A  AE06     BTFSS DtKNFf_wymCO, 7, ACCESS
6A5C  D014     BRA 0x6A86
2281:                              {
2282:                                  if(RdPrt(S_ADD_CO) && !Mf_BLOKUJ_3M && !Mf_BLOKUJ_15S)
6A5E  0E13     MOVLW 0x13
6A60  ECFD     CALL 0xE7FA, 0
6A62  F073     NOP
6A64  B0D8     BTFSC STATUS, 0, ACCESS
6A66  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6A68  EFFF     GOTO 0xCBFE
6A6A  F065     NOP
6A6C  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
6A6E  EFFF     GOTO 0xCBFE
6A70  F065     NOP
2283:                                  {
2284:                                      Mf_BLOKUJ_3M = 1; //uaktywnij blokade L3
6A72  8007     BSF Mf_BLOKUJ_3M, 0, ACCESS
2285:                                      M.BL3 = 0;
6A74  0E00     MOVLW 0x0
6A76  0100     MOVLB 0x0
6A78  6B8B     CLRF _PFNf_prn_cs, BANKED
2286:                                      SetL3();
6A7A  EC12     CALL 0xF424, 0
6A7C  F07A     NOP
6A7E  EFFF     GOTO 0xCBFE
6A80  F065     NOP
2287:                                  }
2288:                                  SetWylacz();
6A82  EFFF     GOTO 0xCBFE
6A84  F065     NOP
2289:                              }
2290:                              else
2291:                                  if(Mf_pob_DzCO && (DtCOf_ad_DZ_CO || Mf_BLOKUJ_3M || Mf_BLOKUJ_15S)) //temperatura dyzurna w obiegu CO
6A86  A20B     BTFSS Mf_pob_KCO, 1, ACCESS
6A88  D007     BRA 0x6A98
6A8A  A801     BTFSS DtCOf_err_CO, 4, ACCESS
6A8C  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
6A8E  EFFF     GOTO 0xCBFE
6A90  F065     NOP
6A92  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
2292:                              {
2293:                                  SetWylacz();
6A94  EFFF     GOTO 0xCBFE
6A96  F065     NOP
2294:                              }
2295:                              else
2296:                                  if(Mf_pob_DzCW && (DtCWf_ad_DZ_CW || !DtCOf_pz_CO)) //temperatura dyzurna w obiegu CW
6A98  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
6A9A  0012     RETURN 0
6A9C  B404     BTFSC DtCWf_err_CW, 2, ACCESS
6A9E  D002     BRA 0x6AA4
6AA0  BA02     BTFSC DtCOf_su_CO, 5, ACCESS
6AA2  0012     RETURN 0
2297:                              {
2298:                                  SetWylacz();
6AA4  ECFF     CALL 0xCBFE, 0
6AA6  F065     NOP
2299:                              }
2300:                          }
2301:                      break;
2302:                  }
2303:              }
6AA8  0012     RETURN 0
2304:          }
6AC6  0012     RETURN 0
2305:          //Uruchomienie procedury wygaszenia palnika
2306:          
2307:          void SetWylacz(void)
2308:          {
2309:              GrzejOFF();
CBFE  ECCA     CALL 0xEF94, 0
CC00  F077     NOP
2310:              //-----
2311:              //operacje wykonywane po kazdej pracy w obiegu CW
2312:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
CC02  D01A     BRA 0xCC38
CC38  0100     MOVLB 0x0
CC3A  519E     MOVF _PWMf_ENPWM2, W, BANKED
CC3C  E0EF     BZ 0xCC1C
CC3E  0A01     XORLW 0x1
CC40  E0E1     BZ 0xCC04
CC42  0A03     XORLW 0x3
CC44  E0DF     BZ 0xCC04
CC46  0A01     XORLW 0x1
CC48  E0E9     BZ 0xCC1C
CC4A  D7EF     BRA 0xCC2A
2313:              {
2314:                  case _BITERM: //bitermiczny (miniterm)
2315:                  case _BITERM2: //bitermiczny (maxiterm)
2316:                  {
2317:                      if(!_POMPA) //obieg CW?
CC04  B483     BTFSC PORTD, 2, ACCESS
CC06  D005     BRA 0xCC12
2318:                      {
2319:                          Mf_KCW_PMP = 1; //ustaw znacznik obiegu CW
CC08  8607     BSF Mf_BLOKUJ_3M, 3, ACCESS
2320:                          Mf_BLOKUJ_15S = 1; //uaktywnij blokade 15s
CC0A  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2321:                          M.BL15 = 0;
CC0C  0100     MOVLB 0x0
CC0E  6B8C     CLRF _PFNf_prn_in, BANKED
2322:                      }
CC10  D002     BRA 0xCC16
2323:                      else Mf_KCW_PMP = 0;
CC12  9607     BCF Mf_BLOKUJ_3M, 3, ACCESS
CC14  D000     BRA 0xCC16
2324:                      ToObiegCO(); //po grzaniu w CW zmien obieg na CO
CC16  EC53     CALL 0xDEA6, 0
CC18  F06F     NOP
2325:                      break;
CC1A  D018     BRA 0xCC4C
2326:                  }
2327:                  case _UNICO:
2328:                  case _MONOHB:
2329:                  {
2330:                      if(!_KCO_CW) //obieg CW?
CC1C  B283     BTFSC PORTD, 1, ACCESS
CC1E  D016     BRA 0xCC4C
2331:                      {
2332:                          Mf_BLOKUJ_15S = 1; //uaktywnij blokade 15s
CC20  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2333:                          M.BL15 = 0;
CC22  0E00     MOVLW 0x0
CC24  0100     MOVLB 0x0
CC26  6F8C     MOVWF _PFNf_prn_in, BANKED
2334:                      }
2335:                      break;
CC28  D011     BRA 0xCC4C
2336:                  }
2337:                  default: //domyslny monotermiczny
2338:                  {
2339:                      if(!_KCO_CW) //obieg CW?
CC2A  B283     BTFSC PORTD, 1, ACCESS
CC2C  D00F     BRA 0xCC4C
2340:                      {
2341:                          Mf_BLOKUJ_15S = 1; //uaktywnij blokade 15s
CC2E  8E06     BSF DtKNFf_wymCO, 7, ACCESS
2342:                          M.BL15 = 0;
CC30  0E00     MOVLW 0x0
CC32  0100     MOVLB 0x0
CC34  6F8C     MOVWF _PFNf_prn_in, BANKED
2343:                      }
2344:                      break;
2345:                  }
2346:              }
CC36  D00A     BRA 0xCC4C
2347:              //-----
2348:              Mf_WYLACZ = 1; //uaktywnij procedure sterowania wybiegiem pompy
CC4C  880A     BSF Mf_pob_AL, 4, ACCESS
2349:              if(Mf_TURBO && _VNT) Mf_VWYBIEG = 1; //dla kotla turbo uaktywnij wybieg wentylatora
CC4E  B40A     BTFSC Mf_pob_AL, 2, ACCESS
CC50  A683     BTFSS PORTD, 3, ACCESS
CC52  D002     BRA 0xCC58
CC54  860A     BSF Mf_pob_AL, 3, ACCESS
CC56  D000     BRA 0xCC58
2350:              M.ROZ = 0;
CC58  0E00     MOVLW 0x0
CC5A  0100     MOVLB 0x0
CC5C  6F88     MOVWF _PFNf_plmCO, BANKED
2351:              M.MNM = 0;
CC5E  6F91     MOVWF _PFNf_set_aleg, BANKED
2352:              Mf_ROZRUCH = 0;
CC60  9008     BCF Mf_ROZRUCH, 0, ACCESS
2353:              Mf_RUN_MNMOD = 0;
CC62  9608     BCF Mf_ROZRUCH, 3, ACCESS
2354:          
2355:              //wyzeruj bity pobudzen od temperatur dyzurnych
2356:              DtCOf_on_DZ_CO = 0;
CC64  9602     BCF DtCOf_su_CO, 3, ACCESS
2357:              SetPrt(S_DZ_CO, 0);
CC66  0E00     MOVLW 0x0
CC68  0100     MOVLB 0x0
CC6A  6FDE     MOVWF __pcstackBANK0, BANKED
CC6C  0E09     MOVLW 0x9
CC6E  EC01     CALL 0xDA02, 0
CC70  F06D     NOP
2358:              DtCWf_on_DZ_CW = 0;
CC72  9E04     BCF DtCWf_err_CW, 7, ACCESS
2359:              SetPrt(S_DZ_CW, 0);
CC74  0E00     MOVLW 0x0
CC76  0100     MOVLB 0x0
CC78  6FDE     MOVWF __pcstackBANK0, BANKED
CC7A  0E0A     MOVLW 0xA
CC7C  EC01     CALL 0xDA02, 0
CC7E  F06D     NOP
2360:          }
CC80  0012     RETURN 0
2361:          //------------------
2362:          //------------------
2363:          
2364:          void FunkcjaSerwisowa(void)
2365:          {
2366:              if(Mf_AKTYWNE_KNF)
D53C  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
D53E  D02C     BRA 0xD598
2367:              {
2368:                  M.SRV = 0;
D540  0E00     MOVLW 0x0
D542  0100     MOVLB 0x0
D544  6F94     MOVWF _PFNf_set_ncw, BANKED
2369:                  Mf_AKTYWNE_SRW = 0; //deaktywacja funkcji serwisowej
D546  9C06     BCF DtKNFf_wymCO, 6, ACCESS
2370:              }
D548  0012     RETURN 0
2371:              else
2372:                  switch(M.SRV)
D54A  D026     BRA 0xD598
D598  0100     MOVLB 0x0
D59A  5194     MOVF _PFNf_set_ncw, W, BANKED
D59C  E0D7     BZ 0xD54C
D59E  0A01     XORLW 0x1
D5A0  E0E5     BZ 0xD56C
2373:                  {
2374:                      case 0:
2375:                      {
2376:                          //if((PFN.poz == _PFZMA) && (PFNf_fnserw && !PFNf_ofnserw))
2377:                          if(!Mf_AKTYWNE_SRW && (PFN.poz == _PFZMA) && PFNf_fnserw)
D54C  BC06     BTFSC DtKNFf_wymCO, 6, ACCESS
D54E  0012     RETURN 0
D550  0E03     MOVLW 0x3
D552  0101     MOVLB 0x1
D554  19F3     XORWF min, W, BANKED
D556  B4D8     BTFSC STATUS, 2, ACCESS
D558  AC0E     BTFSS PFNf_lato, 6, ACCESS
D55A  0012     RETURN 0
2378:                          {
2379:                              M.SRV = 1;
D55C  0E01     MOVLW 0x1
D55E  0100     MOVLB 0x0
D560  6F94     MOVWF _PFNf_set_ncw, BANKED
2380:                              Mf_AKTYWNE_SRW = 1; //aktywacja funkcji serwisowej
D562  8C06     BSF DtKNFf_wymCO, 6, ACCESS
2381:                              StartRTM(_RTSRV1);
D564  0E01     MOVLW 0x1
D566  EC80     CALL 0xE500, 0
D568  F072     NOP
2382:                          }
2383:                          break;
D56A  0012     RETURN 0
2384:                      }
2385:                      case 1:
2386:                      {
2387:                          //if((PFN.poz==_PFZMA)&&GetBit2(RSDT1.inSTAT0,_INITSRV)&&(RTM(_RTSRV1)<_TSRV1)) return;
2388:                          //if((PFN.poz == _PFZMA) && !PFNf_res && (RTM(_RTSRV1) < _TSRV1)) return;
2389:                          
2390:                          if((PFN.poz == _PFZMA) && PFNf_fnserw && (RTM(_RTSRV1) < _TSRV1)) return;
D56C  0E03     MOVLW 0x3
D56E  0101     MOVLB 0x1
D570  19F3     XORWF min, W, BANKED
D572  B4D8     BTFSC STATUS, 2, ACCESS
D574  AC0E     BTFSS PFNf_lato, 6, ACCESS
D576  D00A     BRA 0xD58C
D578  0E01     MOVLW 0x1
D57A  ECC0     CALL 0xEB80, 0
D57C  F075     NOP
D57E  0100     MOVLB 0x0
D580  6FDF     MOVWF pco, BANKED
D582  0E3C     MOVLW 0x3C
D584  61DF     CPFSLT pco, BANKED
D586  D002     BRA 0xD58C
D588  0C3C     RETLW 0x3C
D58A  0012     RETURN 0
2391:                          else
2392:                          {
2393:                              M.SRV = 0;
D58C  0E00     MOVLW 0x0
D58E  0100     MOVLB 0x0
D590  6F94     MOVWF _PFNf_set_ncw, BANKED
2394:                              PFNf_fnserw=0;
D592  9C0E     BCF PFNf_lato, 6, ACCESS
2395:                              Mf_AKTYWNE_SRW = 0; //deaktywacja funkcji serwisowej
D594  9C06     BCF DtKNFf_wymCO, 6, ACCESS
2396:                          }
2397:                          break;
2398:                      }
2399:                  }
D596  0012     RETURN 0
D5A2  0012     RETURN 0
2400:          }
D5A4  0012     RETURN 0
2401:          /*
2402:          void FunkcjaSerwisowa(void)
2403:          {
2404:                  if(Mf_AKTYWNE_KNF)
2405:                  {
2406:                          M.SRV=0;
2407:                          Mf_AKTYWNE_SRW=0;		//deaktywacja funkcji serwisowej
2408:                  }
2409:                  else
2410:                  switch(M.SRV)
2411:                  {
2412:                          case 0:
2413:                          {
2414:                                  if((PFN.poz==_PFZMA)&&PFNf_res)
2415:                                  {
2416:                                          M.SRV=1;
2417:                                          StartRTS(_RTSRV0);
2418:                                  }
2419:                                  break;
2420:                          }
2421:                          case 1:
2422:                          {
2423:                                  if((PFN.poz==_PFZMA)&&PFNf_res)
2424:                                  {
2425:                                          if(RTS(_RTSRV0)<_TSRV0) return;
2426:                                          M.SRV=2;
2427:                                          Mf_AKTYWNE_SRW=1;		//aktywacja funkcji serwisowej
2428:                                          StartRTM(_RTSRV1);
2429:                                  }
2430:                                  else
2431:                                  {
2432:                                          M.SRV=0;
2433:                                  }
2434:                          }
2435:                          case 2:
2436:                          {
2437:                                  if((PFN.poz==_PFZMA)&&(RTM(_RTSRV1)<_TSRV1)) return;
2438:                                  else
2439:                                  {
2440:                                          M.SRV=0;
2441:                                          Mf_AKTYWNE_SRW=0;		//deaktywacja funkcji serwisowej
2442:                                  }
2443:                          }
2444:                  }
2445:          }*/
2446:          //------------------
2447:          //------------------
2448:          //Blokada L3
2449:          
2450:          void BlokadaL3(void)
2451:          {
2452:              switch(M.BL3)
D748  D02B     BRA 0xD7A0
D7A0  0100     MOVLB 0x0
D7A2  518B     MOVF _PFNf_prn_cs, W, BANKED
D7A4  E0D2     BZ 0xD74A
D7A6  0A01     XORLW 0x1
D7A8  A4D8     BTFSS STATUS, 2, ACCESS
D7AA  0012     RETURN 0
D7AC  D7D5     BRA 0xD758
2453:              {
2454:                  case 0:
2455:                  {
2456:                      M.BL3 = 1;
D74A  0E01     MOVLW 0x1
D74C  0100     MOVLB 0x0
D74E  6F8B     MOVWF _PFNf_prn_cs, BANKED
2457:                      StartRTM(_RTBL3);
D750  0E02     MOVLW 0x2
D752  EC80     CALL 0xE500, 0
D754  F072     NOP
D756  D000     BRA 0xD758
2458:                  }
2459:                  case 1:
2460:                  {
2461:                      SetL3();
D758  EC12     CALL 0xF424, 0
D75A  F07A     NOP
2462:                      if((PFN.poz != _PFZMA && !Mf_ZMKCOCW) || Mf_pob_CW || (DtKNF.tpkt == _UNICO && DtCWf_wpz_CW)) //przelacznik funkcyjny na pozycji innej niz ZIMA lub aktywne?
D75C  0E03     MOVLW 0x3
D75E  0101     MOVLB 0x1
D760  19F3     XORWF min, W, BANKED
D762  E002     BZ 0xD768
D764  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
D766  D007     BRA 0xD776
D768  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
D76A  D005     BRA 0xD776
D76C  0100     MOVLB 0x0
D76E  519E     MOVF _PWMf_ENPWM2, W, BANKED
D770  B4D8     BTFSC STATUS, 2, ACCESS
D772  A405     BTFSS DtKNFf_enknf, 2, ACCESS
D774  D006     BRA 0xD782
2463:                      {
2464:                          Mf_BLOKUJ_3M = 0;
D776  9007     BCF Mf_BLOKUJ_3M, 0, ACCESS
2465:                          M.BL3 = 0;
D778  0100     MOVLB 0x0
D77A  6B8B     CLRF _PFNf_prn_cs, BANKED
2466:                          EndL3();
D77C  ECE1     CALL 0xF3C2, 0
D77E  F079     NOP
D780  D000     BRA 0xD782
2467:                      }
2468:                      if(RTM(_RTBL3) < _TBL3) return;
D782  0E02     MOVLW 0x2
D784  ECC0     CALL 0xEB80, 0
D786  F075     NOP
D788  0100     MOVLB 0x0
D78A  6FDF     MOVWF pco, BANKED
D78C  0E03     MOVLW 0x3
D78E  61DF     CPFSLT pco, BANKED
D790  D002     BRA 0xD796
D792  0C03     RETLW 0x3
D794  0012     RETURN 0
2469:                      Mf_BLOKUJ_3M = 0;
D796  9007     BCF Mf_BLOKUJ_3M, 0, ACCESS
2470:                      M.BL3 = 0;
D798  0100     MOVLB 0x0
D79A  6B8B     CLRF _PFNf_prn_cs, BANKED
2471:                      EndL3();
D79C  EFE1     GOTO 0xF3C2
D79E  F079     NOP
2472:                  }
2473:              }
2474:          }
D7AE  0012     RETURN 0
2475:          //------------------
2476:          //------------------
2477:          //Blokada 15s
2478:          
2479:          void Blokada15S(void)
2480:          {
2481:              switch(M.BL15)
D9A4  D026     BRA 0xD9F2
D9F2  0100     MOVLB 0x0
D9F4  518C     MOVF _PFNf_prn_in, W, BANKED
D9F6  E0D7     BZ 0xD9A6
D9F8  0A01     XORLW 0x1
D9FA  A4D8     BTFSS STATUS, 2, ACCESS
D9FC  0012     RETURN 0
D9FE  D7DA     BRA 0xD9B4
2482:              {
2483:                  case 0:
2484:                  {
2485:                      M.BL15 = 1;
D9A6  0E01     MOVLW 0x1
D9A8  0100     MOVLB 0x0
D9AA  6F8C     MOVWF _PFNf_prn_in, BANKED
2486:                      StartRTdS(_RTBL15);
D9AC  0E03     MOVLW 0x3
D9AE  ECA0     CALL 0xE540, 0
D9B0  F072     NOP
D9B2  D000     BRA 0xD9B4
2487:                  }
2488:                  case 1:
2489:                  {
2490:                      if((RTdS(_RTBL15) > 1) && (PFN.poz != _PFZMA)) //przelacznik funkcyjny na pozycji innej niz ZIMA?
D9B4  0E03     MOVLW 0x3
D9B6  ECD7     CALL 0xEBAE, 0
D9B8  F075     NOP
D9BA  0100     MOVLB 0x0
D9BC  6FDF     MOVWF pco, BANKED
D9BE  0E01     MOVLW 0x1
D9C0  65DF     CPFSGT pco, BANKED
D9C2  D008     BRA 0xD9D4
D9C4  0E03     MOVLW 0x3
D9C6  0101     MOVLB 0x1
D9C8  19F3     XORWF min, W, BANKED
D9CA  E004     BZ 0xD9D4
2491:                      { //1 sek. zwloki na filtracje momentu zalaczenia w pozycji LATO
2492:                          Mf_BLOKUJ_15S = 0;
D9CC  9E06     BCF DtKNFf_wymCO, 7, ACCESS
2493:                          M.BL15 = 0;
D9CE  0100     MOVLB 0x0
D9D0  6B8C     CLRF _PFNf_prn_in, BANKED
D9D2  D000     BRA 0xD9D4
2494:                      }
2495:                      if(RTdS(_RTBL15) < _TBL15S) return;
D9D4  0E03     MOVLW 0x3
D9D6  ECD7     CALL 0xEBAE, 0
D9D8  F075     NOP
D9DA  0100     MOVLB 0x0
D9DC  6FDF     MOVWF pco, BANKED
D9DE  0E96     MOVLW 0x96
D9E0  61DF     CPFSLT pco, BANKED
D9E2  D002     BRA 0xD9E8
D9E4  0C96     RETLW 0x96
D9E6  0012     RETURN 0
2496:                      Mf_BLOKUJ_15S = 0;
D9E8  9E06     BCF DtKNFf_wymCO, 7, ACCESS
2497:                      M.BL15 = 0;
D9EA  0E00     MOVLW 0x0
D9EC  0100     MOVLB 0x0
D9EE  6F8C     MOVWF _PFNf_prn_in, BANKED
2498:                  }
2499:              }
D9F0  0C00     RETLW 0x0
2500:          }
DA00  0012     RETURN 0
2501:          //------------------
2502:          //------------------
2503:          //Zalaczenie plytki zapalacza
2504:          
2505:          void GrzejON(void)
2506:          {
2507:              _GRZEJ = 1;
F126  8083     BSF PORTD, 0, ACCESS
2508:              asm("nop");
F128  F000     NOP
2509:              asm("nop");
F12A  F000     NOP
2510:              asm("nop");
F12C  F000     NOP
2511:              asm("nop");
F12E  F000     NOP
2512:              asm("nop");
F130  F000     NOP
2513:              asm("nop");
F132  F000     NOP
2514:              asm("nop");
F134  F000     NOP
2515:              asm("nop");
F136  F000     NOP
2516:              _VNT = 1;
F138  8683     BSF PORTD, 3, ACCESS
2517:          }
F13A  0012     RETURN 0
2518:          //------------------
2519:          //------------------
2520:          //Wylaczenie plytki zapalacza
2521:          
2522:          void GrzejOFF(void)
2523:          {
2524:              if(!Mf_TURBO)
EF94  B40A     BTFSC Mf_pob_AL, 2, ACCESS
EF96  D00B     BRA 0xEFAE
2525:              {
2526:                  _VNT = 0;
EF98  9683     BCF PORTD, 3, ACCESS
2527:                  asm("nop");
EF9A  F000     NOP
2528:                  asm("nop");
EF9C  F000     NOP
2529:                  asm("nop");
EF9E  F000     NOP
2530:                  asm("nop");
EFA0  F000     NOP
2531:                  asm("nop");
EFA2  F000     NOP
2532:                  asm("nop");
EFA4  F000     NOP
2533:                  asm("nop");
EFA6  F000     NOP
2534:                  asm("nop");
EFA8  F000     NOP
2535:                  _GRZEJ = 0;
EFAA  9083     BCF PORTD, 0, ACCESS
2536:              }
EFAC  0012     RETURN 0
2537:              else
2538:              {
2539:                  _GRZEJ = 0;
EFAE  9083     BCF PORTD, 0, ACCESS
EFB0  0012     RETURN 0
2540:              }
2541:          }
EFB2  0012     RETURN 0
2542:          //------------------
2543:          //------------------
2544:          //Procedura rozruchu kotla
2545:          
2546:          void Rozruch(void)
2547:          {
2548:              StartRTS(_RTWPWM);
73AA  0E0F     MOVLW 0xF
73AC  EC60     CALL 0xE4C0, 0
73AE  F072     NOP
2549:              switch(M.ROZ)
73B0  D146     BRA 0x763E
763E  0100     MOVLB 0x0
7640  5188     MOVF _PFNf_plmCO, W, BANKED
7642  E101     BNZ 0x7646
7644  D6B6     BRA 0x73B2
7646  0A01     XORLW 0x1
7648  E101     BNZ 0x764C
764A  D6C2     BRA 0x73D0
764C  0A03     XORLW 0x3
764E  E101     BNZ 0x7652
7650  D6FF     BRA 0x7450
7652  0A01     XORLW 0x1
7654  E101     BNZ 0x7658
7656  D711     BRA 0x747A
7658  0A07     XORLW 0x7
765A  E101     BNZ 0x765E
765C  D72E     BRA 0x74BA
765E  0A01     XORLW 0x1
7660  E101     BNZ 0x7664
7662  D74A     BRA 0x74F8
7664  0A03     XORLW 0x3
7666  E101     BNZ 0x766A
7668  D77D     BRA 0x7564
766A  0A01     XORLW 0x1
766C  A4D8     BTFSS STATUS, 2, ACCESS
766E  0012     RETURN 0
7670  D7BE     BRA 0x75EE
2550:              {
2551:                      //dla kotla z otwartym obiegiem wst?pne, kontrolne wylaczenie pompy
2552:                  case 0:
2553:                  {
2554:                      if(DtKNF.robg == _OTWARTY) //uniko z obiegiem otwartym?
73B2  0100     MOVLB 0x0
73B4  51A6     MOVF _mux, W, BANKED
73B6  E105     BNZ 0x73C2
2555:                      {
2556:                          if(Mf_ZMKCOCW) return; //odczekaj az minie procedura zmiany obiegu
73B8  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
73BA  0012     RETURN 0
73BC  D002     BRA 0x73C2
73BE  0012     RETURN 0
73C0  D000     BRA 0x73C2
2557:                      }
2558:                      M.ROZ = 1;
73C2  0E01     MOVLW 0x1
73C4  0100     MOVLB 0x0
73C6  6F88     MOVWF _PFNf_plmCO, BANKED
2559:                      StartRTS(_RTROZ);
73C8  0E01     MOVLW 0x1
73CA  EC60     CALL 0xE4C0, 0
73CC  F072     NOP
73CE  D000     BRA 0x73D0
2560:                  }
2561:                      //dla kotla z otwartym obiegiem oczekiwanie az sygnal przeplywu WG zniknie przy wylaczonej pompie
2562:                  case 1:
2563:                  {
2564:                      if(DtKNF.robg == _OTWARTY) //uklad z obiegiem otwartym?
73D0  0100     MOVLB 0x0
73D2  51A6     MOVF _mux, W, BANKED
73D4  E127     BNZ 0x7424
2565:                      {
2566:                          if(RTS(_RTROZ) < 1) return; //zwloka na klepanie przekaznikiem
73D6  0E01     MOVLW 0x1
73D8  ECA9     CALL 0xEB52, 0
73DA  F075     NOP
73DC  0900     IORLW 0x0
73DE  B4D8     BTFSC STATUS, 2, ACCESS
73E0  0012     RETURN 0
73E2  D001     BRA 0x73E6
73E4  0012     RETURN 0
2567:                          _POMPA = 0; //wylacz pompe
73E6  9483     BCF PORTD, 2, ACCESS
2568:                          if(!RdPrt(S_PRZ_CO)) //czekaj na stan brak przeplywu WG
73E8  0E01     MOVLW 0x1
73EA  ECFD     CALL 0xE7FA, 0
73EC  F073     NOP
73EE  E207     BC 0x73FE
2569:                          {
2570:                              M.ROZ = 2;
73F0  0E02     MOVLW 0x2
73F2  0100     MOVLB 0x0
73F4  6F88     MOVWF _PFNf_plmCO, BANKED
2571:                              StartRTS(_RTROZ);
73F6  0E01     MOVLW 0x1
73F8  EC60     CALL 0xE4C0, 0
73FA  F072     NOP
2572:                              return;
73FC  0012     RETURN 0
2573:                          }
2574:                          if(RTS(_RTROZ) < _TCPRO) return;
73FE  0E01     MOVLW 0x1
7400  ECA9     CALL 0xEB52, 0
7402  F075     NOP
7404  0103     MOVLB 0x3
7406  6F8B     MOVWF _PFNf_prn_cs, BANKED
7408  0E05     MOVLW 0x5
740A  618B     CPFSLT _PFNf_prn_cs, BANKED
740C  D002     BRA 0x7412
740E  0C05     RETLW 0x5
7410  0012     RETURN 0
2575:                          M.ERR_BTY = 0x05;
7412  0E05     MOVLW 0x5
7414  0100     MOVLB 0x0
7416  6F87     MOVWF _PFNf_pgd, BANKED
2576:                          SetErr(0x05);//PrintErr(0x05, 1); //wyswietl kod bledu
7418  0E05     MOVLW 0x5
741A  ECC7     CALL 0xF38E, 0
741C  F079     NOP
2577:                          ErrPTG(); //wylaczenie awaryjne z blokad?
741E  ECCC     CALL 0x8798, 0
7420  F043     NOP
2578:                          return;
7422  0012     RETURN 0
2579:                      }
2580:                      M.ROZ = 2;
7424  0E02     MOVLW 0x2
7426  0100     MOVLB 0x0
7428  6F88     MOVWF _PFNf_plmCO, BANKED
2581:                      StartRTS(_RTROZ);
742A  0E01     MOVLW 0x1
742C  EC60     CALL 0xE4C0, 0
742E  F072     NOP
2582:                  }
2583:                      //procedura rozruchu
2584:                  case 2:
2585:                  {
2586:                      switch(DtKNF.tpkt) //dla danego rodzaju kotla
7430  D00F     BRA 0x7450
7450  0100     MOVLB 0x0
7452  519E     MOVF _PWMf_ENPWM2, W, BANKED
7454  E0F5     BZ 0x7440
7456  0A01     XORLW 0x1
7458  E0EC     BZ 0x7432
745A  0A03     XORLW 0x3
745C  E0EA     BZ 0x7432
745E  0A01     XORLW 0x1
7460  E0EF     BZ 0x7440
7462  D7F2     BRA 0x7448
2587:                      {
2588:                          case _BITERM: //bitermiczny (miniterm)
2589:                          case _BITERM2: //bitermiczny (maxiterm)
2590:                          {
2591:                              if(!Mf_RPM_CW && (DtKNF.robg == _OTWARTY)) _POMPA = 1; //zalacz pompe dla obiegu CO
7432  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
7434  D017     BRA 0x7464
7436  0100     MOVLB 0x0
7438  51A6     MOVF _mux, W, BANKED
743A  E114     BNZ 0x7464
743C  D003     BRA 0x7444
2592:                              break;
743E  D012     BRA 0x7464
2593:                          }
2594:                          case _UNICO: //jednofunkcyjny
2595:                          case _MONOHB:
2596:                          {
2597:                              if(!Mf_ZMKCOCW) _POMPA = 1; //zalacz pompe
7440  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
7442  D010     BRA 0x7464
7444  8483     BSF PORTD, 2, ACCESS
2598:                              break;
7446  D00E     BRA 0x7464
2599:                          }
2600:                          default: //domyslny monotermiczny
2601:                          {
2602:                              if(!Mf_ZMKCOCW) _POMPA = 1; //zalacz pompe
7448  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
744A  D00C     BRA 0x7464
744C  8483     BSF PORTD, 2, ACCESS
2603:                              break;
2604:                          }
2605:                      }
744E  D00A     BRA 0x7464
2606:                      WritePWM(PWM.MDMOD);
7464  0100     MOVLB 0x0
7466  5167     MOVF _PFNf_b_set_ncw, W, BANKED
7468  ECDD     CALL 0xF1BA, 0
746A  F078     NOP
2607:                      M.ROZ = 3;
746C  0E03     MOVLW 0x3
746E  0100     MOVLB 0x0
7470  6F88     MOVWF _PFNf_plmCO, BANKED
2608:                      StartRTS(_RTROZ);
7472  0E01     MOVLW 0x1
7474  EC60     CALL 0xE4C0, 0
7476  F072     NOP
7478  D000     BRA 0x747A
2609:                  }
2610:                      //oczekiwanie az sygnal obecnosci ciagu zniknie przy wylaczonym wentylatorze
2611:                  case 3:
2612:                  {
2613:                      if(Mf_TURBO)
747A  A40A     BTFSS Mf_pob_AL, 2, ACCESS
747C  D017     BRA 0x74AC
2614:                      {
2615:                          if(RdPrt(S_CIG_NO) && !_VNT) //obecny sygnal ciagu?
747E  0E03     MOVLW 0x3
7480  ECFD     CALL 0xE7FA, 0
7482  F073     NOP
7484  B0D8     BTFSC STATUS, 0, ACCESS
7486  B683     BTFSC PORTD, 3, ACCESS
7488  D00F     BRA 0x74A8
2616:                          {
2617:                              if(RTS(_RTROZ) < _TCIRO) return;
748A  0E01     MOVLW 0x1
748C  ECA9     CALL 0xEB52, 0
748E  F075     NOP
7490  0103     MOVLB 0x3
7492  6F8B     MOVWF _PFNf_prn_cs, BANKED
7494  0E05     MOVLW 0x5
7496  618B     CPFSLT _PFNf_prn_cs, BANKED
7498  D002     BRA 0x749E
749A  0C05     RETLW 0x5
749C  0012     RETURN 0
2618:                              M.RCI = 0;
749E  0E00     MOVLW 0x0
74A0  0100     MOVLB 0x0
74A2  6F90     MOVWF _PFNf_res, BANKED
2619:                              Mf_RUSZ_CIAG = 1;
74A4  8C08     BSF Mf_ROZRUCH, 6, ACCESS
2620:                              return;
74A6  0012     RETURN 0
2621:                          }
2622:                          _VNT = 1; //uruchom wentylator
74A8  8683     BSF PORTD, 3, ACCESS
74AA  D000     BRA 0x74AC
2623:                      }
2624:                      M.ROZ = 4;
74AC  0E04     MOVLW 0x4
74AE  0100     MOVLB 0x0
74B0  6F88     MOVWF _PFNf_plmCO, BANKED
2625:                      StartRTS(_RTROZ);
74B2  0E01     MOVLW 0x1
74B4  EC60     CALL 0xE4C0, 0
74B6  F072     NOP
74B8  D000     BRA 0x74BA
2626:                  }
2627:                      //oczekiwanie na sygnal obecnosci ciagu przy zalaczonym wentylatorze
2628:                  case 4:
2629:                  {
2630:                      if(Mf_TURBO)
74BA  A40A     BTFSS Mf_pob_AL, 2, ACCESS
74BC  D016     BRA 0x74EA
2631:                      {
2632:                          if(!RdPrt(S_CIG_NO_1S) && _VNT) //nieobecny sygnal ciagu?
74BE  0E15     MOVLW 0x15
74C0  ECFD     CALL 0xE7FA, 0
74C2  F073     NOP
74C4  A0D8     BTFSS STATUS, 0, ACCESS
74C6  A683     BTFSS PORTD, 3, ACCESS
74C8  D010     BRA 0x74EA
2633:                          {
2634:                              if(RTS(_RTROZ) < _TCIRO) return;
74CA  0E01     MOVLW 0x1
74CC  ECA9     CALL 0xEB52, 0
74CE  F075     NOP
74D0  0103     MOVLB 0x3
74D2  6F8B     MOVWF _PFNf_prn_cs, BANKED
74D4  0E05     MOVLW 0x5
74D6  618B     CPFSLT _PFNf_prn_cs, BANKED
74D8  D002     BRA 0x74DE
74DA  0C05     RETLW 0x5
74DC  0012     RETURN 0
2635:                              M.RCI = 0;
74DE  0E00     MOVLW 0x0
74E0  0100     MOVLB 0x0
74E2  6F90     MOVWF _PFNf_res, BANKED
2636:                              Mf_RUSZ_CIAG = 1;
74E4  8C08     BSF Mf_ROZRUCH, 6, ACCESS
2637:                              return;
74E6  0012     RETURN 0
2638:                          }
74E8  D000     BRA 0x74EA
2639:                      }
2640:                      M.ROZ = 5;
74EA  0E05     MOVLW 0x5
74EC  0100     MOVLB 0x0
74EE  6F88     MOVWF _PFNf_plmCO, BANKED
2641:                      StartRTS(_RTROZ);
74F0  0E01     MOVLW 0x1
74F2  EC60     CALL 0xE4C0, 0
74F4  F072     NOP
74F6  D000     BRA 0x74F8
2642:                  }
2643:                      //kontrola poprawnosci dzialania ukladu detekcji plomienia
2644:                  case 5:
2645:                  {
2646:                      if(Mf_TURBO && !RdPrt(S_CIG_NO_1S)) //nieobecny sygnal ciagu?
74F8  A40A     BTFSS Mf_pob_AL, 2, ACCESS
74FA  D009     BRA 0x750E
74FC  0E15     MOVLW 0x15
74FE  ECFD     CALL 0xE7FA, 0
7500  F073     NOP
7502  E205     BC 0x750E
2647:                      {
2648:                          M.RCI = 0;
7504  0E00     MOVLW 0x0
7506  0100     MOVLB 0x0
7508  6F90     MOVWF _PFNf_res, BANKED
2649:                          Mf_RUSZ_CIAG = 1;
750A  8C08     BSF Mf_ROZRUCH, 6, ACCESS
2650:                          return;
750C  0012     RETURN 0
2651:                      }
2652:                      if(RdPrt(S_PLM) && !_GRZEJ) //obecny plomien mimo ze _GRZEJ=0?
750E  0E05     MOVLW 0x5
7510  ECFD     CALL 0xE7FA, 0
7512  F073     NOP
7514  B0D8     BTFSC STATUS, 0, ACCESS
7516  B083     BTFSC PORTD, 0, ACCESS
7518  D013     BRA 0x7540
2653:                      {
2654:                          if(RTS(_RTROZ) < _TBPL0) return;
751A  0E01     MOVLW 0x1
751C  ECA9     CALL 0xEB52, 0
751E  F075     NOP
7520  0103     MOVLB 0x3
7522  6F8B     MOVWF _PFNf_prn_cs, BANKED
7524  0E05     MOVLW 0x5
7526  618B     CPFSLT _PFNf_prn_cs, BANKED
7528  D002     BRA 0x752E
752A  0C05     RETLW 0x5
752C  0012     RETURN 0
2655:                          M.ERR_BTY = 0x06;
752E  0E06     MOVLW 0x6
7530  0100     MOVLB 0x0
7532  6F87     MOVWF _PFNf_pgd, BANKED
2656:                          SetErr(0x06);//PrintErr(0x06, 1); //wyswietl kod bledu
7534  0E06     MOVLW 0x6
7536  ECC7     CALL 0xF38E, 0
7538  F079     NOP
2657:                          ErrPTG();
753A  ECCC     CALL 0x8798, 0
753C  F043     NOP
753E  D000     BRA 0x7540
2658:                      }
2659:                      GrzejON(); //_GRZEJ=1;							//zapal plomien na palniku
7540  EC93     CALL 0xF126, 0
7542  F078     NOP
2660:                      M.ROZ = 6;
7544  0E06     MOVLW 0x6
7546  0100     MOVLB 0x0
7548  6F88     MOVWF _PFNf_plmCO, BANKED
2661:                      StartRTS(_RTROZ);
754A  0E01     MOVLW 0x1
754C  EC60     CALL 0xE4C0, 0
754E  F072     NOP
2662:                  }
2663:                      //zalaczenie pompy, oczekiwanie na sygnal obecnosci plomienia
2664:                  case 6:
2665:                  {
2666:                      switch(DtKNF.tpkt) //dla danego rodzaju kotla
7550  D009     BRA 0x7564
7564  0100     MOVLB 0x0
7566  519E     MOVF _PWMf_ENPWM2, W, BANKED
7568  E0F5     BZ 0x7554
756A  0A01     XORLW 0x1
756C  E005     BZ 0x7578
756E  0A03     XORLW 0x3
7570  E003     BZ 0x7578
7572  0A01     XORLW 0x1
7574  E0EF     BZ 0x7554
7576  D7F2     BRA 0x755C
2667:                      {
2668:                          case _BITERM: //bitermiczny (miniterm)
2669:                          case _BITERM2: //bitermiczny (maxiterm)
2670:                          {
2671:                              break;
7552  D012     BRA 0x7578
2672:                          }
2673:                          case _UNICO:
2674:                          case _MONOHB:
2675:                          {
2676:                              if(!Mf_ZMKCOCW) _POMPA = 1; //zalacz pompe (np po zmianie obiegu)
7554  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
7556  D010     BRA 0x7578
7558  8483     BSF PORTD, 2, ACCESS
2677:                              break;
755A  D00E     BRA 0x7578
2678:                          }
2679:                          default: //domyslny monotermiczny
2680:                          {
2681:                              if(!Mf_ZMKCOCW) _POMPA = 1; //zalacz pompe (np po zmianie obiegu)
755C  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
755E  D00C     BRA 0x7578
7560  8483     BSF PORTD, 2, ACCESS
2682:                              break;
2683:                          }
2684:                      }
7562  D00A     BRA 0x7578
2685:                      if(Mf_TURBO && !RdPrt(S_CIG_NO_1S)) //nieobecny sygnal ciagu?
7578  A40A     BTFSS Mf_pob_AL, 2, ACCESS
757A  D009     BRA 0x758E
757C  0E15     MOVLW 0x15
757E  ECFD     CALL 0xE7FA, 0
7580  F073     NOP
7582  E205     BC 0x758E
2686:                      {
2687:                          M.RCI = 0;
7584  0E00     MOVLW 0x0
7586  0100     MOVLB 0x0
7588  6F90     MOVWF _PFNf_res, BANKED
2688:                          Mf_RUSZ_CIAG = 1;
758A  8C08     BSF Mf_ROZRUCH, 6, ACCESS
2689:                          return;
758C  0012     RETURN 0
2690:                      }
2691:                      if(RdPrt(S_MOD_ON)) WritePWM(PWM.MSTART);
758E  0E08     MOVLW 0x8
7590  ECFD     CALL 0xE7FA, 0
7592  F073     NOP
7594  E305     BNC 0x75A0
7596  0100     MOVLB 0x0
7598  517C     MOVF _PFNf_oaleg, W, BANKED
759A  ECDD     CALL 0xF1BA, 0
759C  F078     NOP
759E  D005     BRA 0x75AA
2692:                      else WritePWM(PWM.MDMOD);
75A0  0100     MOVLB 0x0
75A2  5167     MOVF _PFNf_b_set_ncw, W, BANKED
75A4  ECDD     CALL 0xF1BA, 0
75A6  F078     NOP
75A8  D000     BRA 0x75AA
2693:          
2694:                      if(RTS(_RTROZ) < _TITPL) return; //okres czasu gdy ignorowany jest syg. plomien
75AA  0E01     MOVLW 0x1
75AC  ECA9     CALL 0xEB52, 0
75AE  F075     NOP
75B0  0103     MOVLB 0x3
75B2  6F8B     MOVWF _PFNf_prn_cs, BANKED
75B4  0E02     MOVLW 0x2
75B6  618B     CPFSLT _PFNf_prn_cs, BANKED
75B8  D002     BRA 0x75BE
75BA  0C02     RETLW 0x2
75BC  0012     RETURN 0
2695:          
2696:                      if(RTS(_RTROZ) < _TDTPL)
75BE  0E01     MOVLW 0x1
75C0  ECA9     CALL 0xEB52, 0
75C2  F075     NOP
75C4  0103     MOVLB 0x3
75C6  6F8B     MOVWF _PFNf_prn_cs, BANKED
75C8  0E07     MOVLW 0x7
75CA  618B     CPFSLT _PFNf_prn_cs, BANKED
75CC  D00D     BRA 0x75E8
2697:                      {
2698:                          if(RdPrt(S_PLM)) //stwierdzono obecnosc plomienia?
75CE  0E05     MOVLW 0x5
75D0  ECFD     CALL 0xE7FA, 0
75D2  F073     NOP
75D4  A0D8     BTFSS STATUS, 0, ACCESS
75D6  0012     RETURN 0
2699:                          {
2700:                              M.ROZ = 7;
75D8  0E07     MOVLW 0x7
75DA  0100     MOVLB 0x0
75DC  6F88     MOVWF _PFNf_plmCO, BANKED
2701:                              StartRTS(_RTROZ);
75DE  0E01     MOVLW 0x1
75E0  EC60     CALL 0xE4C0, 0
75E2  F072     NOP
2702:                          }
2703:                          return;
75E4  0012     RETURN 0
2704:                      }
75E6  D003     BRA 0x75EE
2705:                      else //nie stwierdzono plomienia w czasie _TDTPL?
2706:                      {
2707:                          DecyzjaPLM();
75E8  EC31     CALL 0xEC62, 0
75EA  F076     NOP
2708:                          return;
75EC  0012     RETURN 0
2709:                      }
2710:                  }
2711:                      //wybieg na mocy startowej
2712:                  case 7:
2713:                  {
2714:                      if(Mf_RPM_CW)
75EE  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
75F0  D005     BRA 0x75FC
2715:                      {
2716:                          Mf_ROZRUCH = 0;
75F2  9008     BCF Mf_ROZRUCH, 0, ACCESS
2717:                          M.ROZ = 0;
75F4  0E00     MOVLW 0x0
75F6  0100     MOVLB 0x0
75F8  6F88     MOVWF _PFNf_plmCO, BANKED
2718:                          return;
75FA  0012     RETURN 0
2719:                      }
2720:                      if(Mf_TURBO && !RdPrt(S_CIG_NO_1S)) //nieobecny sygnal ciagu?
75FC  A40A     BTFSS Mf_pob_AL, 2, ACCESS
75FE  D009     BRA 0x7612
7600  0E15     MOVLW 0x15
7602  ECFD     CALL 0xE7FA, 0
7604  F073     NOP
7606  E205     BC 0x7612
2721:                      {
2722:                          M.RCI = 0;
7608  0E00     MOVLW 0x0
760A  0100     MOVLB 0x0
760C  6F90     MOVWF _PFNf_res, BANKED
2723:                          Mf_RUSZ_CIAG = 1;
760E  8C08     BSF Mf_ROZRUCH, 6, ACCESS
2724:                          return;
7610  0012     RETURN 0
2725:                      }
2726:                      if(!RdPrt(S_PLM)) //stwierdzono brak plomienia?
7612  0E05     MOVLW 0x5
7614  ECFD     CALL 0xE7FA, 0
7616  F073     NOP
7618  E203     BC 0x7620
2727:                      {
2728:                          DecyzjaPLM2();
761A  ECB4     CALL 0xC168, 0
761C  F060     NOP
761E  D000     BRA 0x7620
2729:                          //return;
2730:                      }
2731:                      if(RTS(_RTROZ) < _TDWPL) return;
7620  0E01     MOVLW 0x1
7622  ECA9     CALL 0xEB52, 0
7624  F075     NOP
7626  0103     MOVLB 0x3
7628  6F8B     MOVWF _PFNf_prn_cs, BANKED
762A  0E02     MOVLW 0x2
762C  618B     CPFSLT _PFNf_prn_cs, BANKED
762E  D002     BRA 0x7634
7630  0C02     RETLW 0x2
7632  0012     RETURN 0
2732:                      Mf_ROZRUCH = 0;
7634  9008     BCF Mf_ROZRUCH, 0, ACCESS
2733:                      M.ROZ = 0;
7636  0E00     MOVLW 0x0
7638  0100     MOVLB 0x0
763A  6F88     MOVWF _PFNf_plmCO, BANKED
2734:                  }
2735:              }
763C  0C00     RETLW 0x0
2736:          }
7672  0012     RETURN 0
2737:          
2738:          void DecyzjaPLM(void)
2739:          {
2740:              if(Mf_OST_PL) //ostatnia proba?
EC62  AA07     BTFSS Mf_BLOKUJ_3M, 5, ACCESS
EC64  D008     BRA 0xEC76
2741:              {
2742:                  M.ERR_BTY = 0x01;
EC66  0E01     MOVLW 0x1
EC68  0100     MOVLB 0x0
EC6A  6F87     MOVWF _PFNf_pgd, BANKED
2743:                  SetErr(0x01);//PrintErr(0x01, 1);
EC6C  0E01     MOVLW 0x1
EC6E  ECC7     CALL 0xF38E, 0
EC70  F079     NOP
2744:                  ErrPTG();
EC72  EFCC     GOTO 0x8798
EC74  F043     NOP
2745:              }
2746:              else
2747:              {
2748:                  Mf_RUSZ_PLOMIEN = 1;
EC76  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
2749:                  if(!M.LICZNIK_PL) Mf_RUSZ_RPLM = 1; //znacznik pierwszej aktywacji proc. w trakcie rozruchu
EC78  0100     MOVLB 0x0
EC7A  5182     MOVF M, W, BANKED
EC7C  B4D8     BTFSC STATUS, 2, ACCESS
EC7E  800A     BSF Mf_pob_AL, 0, ACCESS
2750:                  Mf_ROZRUCH = 0;
EC80  9008     BCF Mf_ROZRUCH, 0, ACCESS
2751:                  M.ROZ = 0;
EC82  0E00     MOVLW 0x0
EC84  0100     MOVLB 0x0
EC86  6F88     MOVWF _PFNf_plmCO, BANKED
EC88  0C00     RETLW 0x0
2752:              }
2753:          }
EC8A  0012     RETURN 0
2754:          
2755:          void DecyzjaPLM2(void)
2756:          {
2757:              if(Mf_TURBO) //sterownik TURBO?
C168  A40A     BTFSS Mf_pob_AL, 2, ACCESS
C16A  D038     BRA 0xC1DC
2758:              {
2759:                  if(_VNT) //wentylator pracuje?
C16C  A683     BTFSS PORTD, 3, ACCESS
C16E  D01A     BRA 0xC1A4
2760:                  {
2761:                      //if(RdPrt(S_CIG_NO)&&RdPrt(S_STB))
2762:                      if(_CIG_NO && _STB)
C170  BC80     BTFSC PORTA, 6, ACCESS
C172  AE80     BTFSS PORTA, 7, ACCESS
C174  0012     RETURN 0
2763:                      {
2764:                          if(Mf_OST_PL) //ostatnia proba?
C176  AA07     BTFSS Mf_BLOKUJ_3M, 5, ACCESS
C178  D008     BRA 0xC18A
2765:                          {
2766:                              M.ERR_BTY = 0x01;
C17A  0E01     MOVLW 0x1
C17C  0100     MOVLB 0x0
C17E  6F87     MOVWF _PFNf_pgd, BANKED
2767:                              SetErr(0x01);//PrintErr(0x01, 1);
C180  0E01     MOVLW 0x1
C182  ECC7     CALL 0xF38E, 0
C184  F079     NOP
2768:                              ErrPTG();
C186  EFCC     GOTO 0x8798
C188  F043     NOP
2769:                          }
2770:                          else
2771:                          {
2772:                              M.RPL = 0;
C18A  0E00     MOVLW 0x0
C18C  0100     MOVLB 0x0
C18E  6F8F     MOVWF _PFNf_prnserw, BANKED
2773:                              Mf_RUSZ_PLOMIEN = 1;
C190  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
2774:                              if(!M.LICZNIK_PL) Mf_RUSZ_RPLM = 1; //znacznik pierwszej aktywacji proc. w trakcie rozruchu
C192  0100     MOVLB 0x0
C194  5182     MOVF M, W, BANKED
C196  B4D8     BTFSC STATUS, 2, ACCESS
C198  800A     BSF Mf_pob_AL, 0, ACCESS
2775:                              Mf_ROZRUCH = 0;
C19A  9008     BCF Mf_ROZRUCH, 0, ACCESS
2776:                              M.ROZ = 0;
C19C  0E00     MOVLW 0x0
C19E  0100     MOVLB 0x0
C1A0  6F88     MOVWF _PFNf_plmCO, BANKED
2777:                          }
2778:                      }
2779:                  }
C1A2  0012     RETURN 0
2780:                  else //wentylator nie pracuje
2781:                  {
2782:                      if(RdPrt(S_STB))
C1A4  0E04     MOVLW 0x4
C1A6  ECFD     CALL 0xE7FA, 0
C1A8  F073     NOP
C1AA  A0D8     BTFSS STATUS, 0, ACCESS
C1AC  0012     RETURN 0
2783:                      {
2784:                          if(Mf_OST_PL) //ostatnia proba?
C1AE  AA07     BTFSS Mf_BLOKUJ_3M, 5, ACCESS
C1B0  D008     BRA 0xC1C2
2785:                          {
2786:                              M.ERR_BTY = 0x01;
C1B2  0E01     MOVLW 0x1
C1B4  0100     MOVLB 0x0
C1B6  6F87     MOVWF _PFNf_pgd, BANKED
2787:                              SetErr(0x01);//PrintErr(0x01, 1);
C1B8  0E01     MOVLW 0x1
C1BA  ECC7     CALL 0xF38E, 0
C1BC  F079     NOP
2788:                              ErrPTG();
C1BE  EFCC     GOTO 0x8798
C1C0  F043     NOP
2789:                          }
2790:                          else
2791:                          {
2792:                              M.RPL = 0;
C1C2  0E00     MOVLW 0x0
C1C4  0100     MOVLB 0x0
C1C6  6F8F     MOVWF _PFNf_prnserw, BANKED
2793:                              Mf_RUSZ_PLOMIEN = 1;
C1C8  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
2794:                              if(!M.LICZNIK_PL) Mf_RUSZ_RPLM = 1; //znacznik pierwszej aktywacji proc. w trakcie rozruchu
C1CA  0100     MOVLB 0x0
C1CC  5182     MOVF M, W, BANKED
C1CE  B4D8     BTFSC STATUS, 2, ACCESS
C1D0  800A     BSF Mf_pob_AL, 0, ACCESS
2795:                              Mf_ROZRUCH = 0;
C1D2  9008     BCF Mf_ROZRUCH, 0, ACCESS
2796:                              M.ROZ = 0;
C1D4  0E00     MOVLW 0x0
C1D6  0100     MOVLB 0x0
C1D8  6F88     MOVWF _PFNf_plmCO, BANKED
2797:                          }
2798:                      }
2799:                  }
2800:              }
C1DA  0012     RETURN 0
2801:              else //sterownik ATMOSFERYCZNY
2802:              {
2803:                  //if(RdPrt(S_CIG_NC)&&RdPrt(S_STB))
2804:                  if(_CIG_NC && _STB)
C1DC  B082     BTFSC PORTC, 0, ACCESS
C1DE  AE80     BTFSS PORTA, 7, ACCESS
C1E0  0012     RETURN 0
2805:                  {
2806:                      if(Mf_OST_PL) //ostatnia proba?
C1E2  AA07     BTFSS Mf_BLOKUJ_3M, 5, ACCESS
C1E4  D008     BRA 0xC1F6
2807:                      {
2808:                          M.ERR_BTY = 0x01;
C1E6  0E01     MOVLW 0x1
C1E8  0100     MOVLB 0x0
C1EA  6F87     MOVWF _PFNf_pgd, BANKED
2809:                          SetErr(0x01);//PrintErr(0x01, 1);
C1EC  0E01     MOVLW 0x1
C1EE  ECC7     CALL 0xF38E, 0
C1F0  F079     NOP
2810:                          ErrPTG();
C1F2  EFCC     GOTO 0x8798
C1F4  F043     NOP
2811:                      }
2812:                      else
2813:                      {
2814:                          M.RPL = 0;
C1F6  0E00     MOVLW 0x0
C1F8  0100     MOVLB 0x0
C1FA  6F8F     MOVWF _PFNf_prnserw, BANKED
2815:                          Mf_RUSZ_PLOMIEN = 1;
C1FC  8A09     BSF Mf_RUSZ_PWR, 5, ACCESS
2816:                          if(!M.LICZNIK_PL) Mf_RUSZ_RPLM = 1; //znacznik pierwszej aktywacji proc. w trakcie rozruchu
C1FE  0100     MOVLB 0x0
C200  5182     MOVF M, W, BANKED
C202  B4D8     BTFSC STATUS, 2, ACCESS
C204  800A     BSF Mf_pob_AL, 0, ACCESS
2817:                          Mf_ROZRUCH = 0;
C206  9008     BCF Mf_ROZRUCH, 0, ACCESS
2818:                          M.ROZ = 0;
C208  0E00     MOVLW 0x0
C20A  0100     MOVLB 0x0
C20C  6F88     MOVWF _PFNf_plmCO, BANKED
2819:                      }
2820:                  }
C20E  0012     RETURN 0
2821:              }
2822:          }
C210  0012     RETURN 0
2823:          //------------------
2824:          //------------------
2825:          //Wybieg pompy
2826:          
2827:          void Wylacz(void)
2828:          {
2829:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
64A2  D17D     BRA 0x679E
679E  0100     MOVLB 0x0
67A0  519E     MOVF _PWMf_ENPWM2, W, BANKED
67A2  E091     BZ 0x66C6
67A4  0A01     XORLW 0x1
67A6  E101     BNZ 0x67AA
67A8  D6CF     BRA 0x6548
67AA  0A03     XORLW 0x3
67AC  E101     BNZ 0x67B0
67AE  D6CC     BRA 0x6548
67B0  0A01     XORLW 0x1
67B2  E101     BNZ 0x67B6
67B4  D72D     BRA 0x6610
67B6  D7EB     BRA 0x678E
2830:              {
2831:                  case _BITERM: //bitermiczny (miniterm)
2832:                  case _BITERM2: //bitermiczny (maxiterm)
2833:                  {
2834:                      switch(M.WYL)
64A4  D051     BRA 0x6548
6548  0100     MOVLB 0x0
654A  518D     MOVF _PFNf_prn_res, W, BANKED
654C  E0AC     BZ 0x64A6
654E  0A01     XORLW 0x1
6550  E0B1     BZ 0x64B4
6552  0A03     XORLW 0x3
6554  E0DD     BZ 0x6510
2835:                      {
2836:                          case 0:
2837:                          {
2838:                              M.WYL = 1;
64A6  0E01     MOVLW 0x1
64A8  0100     MOVLB 0x0
64AA  6F8D     MOVWF _PFNf_prn_res, BANKED
2839:                              StartRTS(_RTWYL);
64AC  0E06     MOVLW 0x6
64AE  EC60     CALL 0xE4C0, 0
64B0  F072     NOP
64B2  D000     BRA 0x64B4
2840:                          }
2841:                          case 1:
2842:                          {
2843:                              if(Mf_KCW_PMP) //wybieg po grzaniu w obiegu CW?
64B4  A607     BTFSS Mf_BLOKUJ_3M, 3, ACCESS
64B6  D01E     BRA 0x64F4
2844:                              {
2845:                                  if(RTS(_RTWYL) >= _TbtWBW0) //uplynol minimalny wybieg pompy?
64B8  0E06     MOVLW 0x6
64BA  ECA9     CALL 0xEB52, 0
64BC  F075     NOP
64BE  0100     MOVLB 0x0
64C0  6FE0     MOVWF bdat, BANKED
64C2  0E13     MOVLW 0x13
64C4  65E0     CPFSGT bdat, BANKED
64C6  D007     BRA 0x64D6
2846:                                  {
2847:                                      if(!DtCOf_err_CO && DtCOf_ptwp_CO) //temperatura CO osiagnela prog wylaczenia?
64C8  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
64CA  A802     BTFSS DtCOf_su_CO, 4, ACCESS
64CC  D004     BRA 0x64D6
2848:                                      {
2849:                                          M.WYL = 2;
64CE  0E02     MOVLW 0x2
64D0  6F8D     MOVWF _PFNf_prn_res, BANKED
2850:                                          return;
64D2  0012     RETURN 0
2851:                                      }
64D4  D000     BRA 0x64D6
2852:                                  }
2853:                                  if(RTS(_RTWYL) < _TbtWBW1) return; //uplynol maksymalny wybieg pompy?
64D6  0E06     MOVLW 0x6
64D8  ECA9     CALL 0xEB52, 0
64DA  F075     NOP
64DC  0100     MOVLB 0x0
64DE  6FE0     MOVWF bdat, BANKED
64E0  0EB4     MOVLW 0xB4
64E2  61E0     CPFSLT bdat, BANKED
64E4  D002     BRA 0x64EA
64E6  0CB4     RETLW 0xB4
64E8  0012     RETURN 0
2854:                                  M.WYL = 2;
64EA  0E02     MOVLW 0x2
64EC  0100     MOVLB 0x0
64EE  6F8D     MOVWF _PFNf_prn_res, BANKED
2855:                                  return;
64F0  0012     RETURN 0
2856:                              }
64F2  D00E     BRA 0x6510
2857:                              else //wybieg po grzaniu w obiegu CO
2858:                              {
2859:                                  if(RTS(_RTWYL) < _TWBCO) return; //uplynol maksymalny wybieg pompy?
64F4  0E06     MOVLW 0x6
64F6  ECA9     CALL 0xEB52, 0
64F8  F075     NOP
64FA  0100     MOVLB 0x0
64FC  6FE0     MOVWF bdat, BANKED
64FE  0EB4     MOVLW 0xB4
6500  61E0     CPFSLT bdat, BANKED
6502  D002     BRA 0x6508
6504  0CB4     RETLW 0xB4
6506  0012     RETURN 0
2860:                                  M.WYL = 2;
6508  0E02     MOVLW 0x2
650A  0100     MOVLB 0x0
650C  6F8D     MOVWF _PFNf_prn_res, BANKED
2861:                              }
650E  D000     BRA 0x6510
2862:                          }
2863:                          case 2:
2864:                          {
2865:                              if(RdPrt(S_ON_PMP)) return; //przekroczone wartosci graniczne temp w obiegu CO
6510  0E0D     MOVLW 0xD
6512  ECFD     CALL 0xE7FA, 0
6514  F073     NOP
6516  B0D8     BTFSC STATUS, 0, ACCESS
6518  0012     RETURN 0
651A  D001     BRA 0x651E
651C  0012     RETURN 0
2866:                              if(!Mf_KCW_PMP) //wybieg po grzaniu w obiegu CO?
651E  A607     BTFSS Mf_BLOKUJ_3M, 3, ACCESS
2867:                              {
2868:                                  if(!DtCOf_err_CO && !DtCOf_su_CO) return; //osiagnieto wartosc wylaczenia po pracy w ukladzie CO?
6520  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
6522  D005     BRA 0x652E
6524  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
6526  0012     RETURN 0
6528  D002     BRA 0x652E
652A  0012     RETURN 0
652C  D000     BRA 0x652E
2869:                              }
2870:                              if(DtKNF.robg == _OTWARTY) //z obiegiem otwartym?
652E  0100     MOVLB 0x0
6530  51A6     MOVF _mux, W, BANKED
6532  E104     BNZ 0x653C
2871:                              {
2872:                                  if(Mf_RUSZ_POMPE) return; //oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
6534  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
6536  0012     RETURN 0
6538  D001     BRA 0x653C
653A  0012     RETURN 0
2873:                              }
2874:                              Mf_KCW_PMP = 0;
653C  9607     BCF Mf_BLOKUJ_3M, 3, ACCESS
2875:                              Mf_WYLACZ = 0;
653E  980A     BCF Mf_pob_AL, 4, ACCESS
2876:                              M.WYL = 0;
6540  0E00     MOVLW 0x0
6542  0100     MOVLB 0x0
6544  6F8D     MOVWF _PFNf_prn_res, BANKED
2877:                          }
2878:                      }
6546  0C00     RETLW 0x0
2879:                      return;
6556  0012     RETURN 0
2880:                  }
2881:                  case _MONOHB:
2882:                  {
2883:                      switch(M.WYL)
6558  D05B     BRA 0x6610
6610  0100     MOVLB 0x0
6612  518D     MOVF _PFNf_prn_res, W, BANKED
6614  E0A2     BZ 0x655A
6616  0A01     XORLW 0x1
6618  E0A7     BZ 0x6568
661A  0A03     XORLW 0x3
661C  E0D3     BZ 0x65C4
2884:                      {
2885:                          case 0:
2886:                          {
2887:                              M.WYL = 1;
655A  0E01     MOVLW 0x1
655C  0100     MOVLB 0x0
655E  6F8D     MOVWF _PFNf_prn_res, BANKED
2888:                              StartRTS(_RTWYL);
6560  0E06     MOVLW 0x6
6562  EC60     CALL 0xE4C0, 0
6564  F072     NOP
6566  D000     BRA 0x6568
2889:                          }
2890:                          case 1:
2891:                          {
2892:                              if(Mf_RPM_CW) //obieg CW
6568  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
656A  D01E     BRA 0x65A8
2893:                              {
2894:                                  if(RTS(_RTWYL) >= _TmnWBW0) //uplynol minimalny wybieg pompy?
656C  0E06     MOVLW 0x6
656E  ECA9     CALL 0xEB52, 0
6570  F075     NOP
6572  0100     MOVLB 0x0
6574  6FE0     MOVWF bdat, BANKED
6576  0E13     MOVLW 0x13
6578  65E0     CPFSGT bdat, BANKED
657A  D007     BRA 0x658A
2895:                                  {
2896:                                      if(!DtCOf_err_CO && DtCOf_ptwp_CO) //temperatura CO osiagnela prog wylaczenia?
657C  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
657E  A802     BTFSS DtCOf_su_CO, 4, ACCESS
6580  D004     BRA 0x658A
2897:                                      {
2898:                                          M.WYL = 2;
6582  0E02     MOVLW 0x2
6584  6F8D     MOVWF _PFNf_prn_res, BANKED
2899:                                          return;
6586  0012     RETURN 0
2900:                                      }
6588  D000     BRA 0x658A
2901:                                  }
2902:                                  if(RTS(_RTWYL) < _TmnWBW1) return; //uplynol maksymalny wybieg pompy?
658A  0E06     MOVLW 0x6
658C  ECA9     CALL 0xEB52, 0
658E  F075     NOP
6590  0100     MOVLB 0x0
6592  6FE0     MOVWF bdat, BANKED
6594  0EB4     MOVLW 0xB4
6596  61E0     CPFSLT bdat, BANKED
6598  D002     BRA 0x659E
659A  0CB4     RETLW 0xB4
659C  0012     RETURN 0
2903:                                  M.WYL = 2;
659E  0E02     MOVLW 0x2
65A0  0100     MOVLB 0x0
65A2  6F8D     MOVWF _PFNf_prn_res, BANKED
2904:                                  return;
65A4  0012     RETURN 0
2905:                              }
65A6  D00E     BRA 0x65C4
2906:                              else //obieg CO
2907:                              {
2908:                                  if(RTS(_RTWYL) < _TWBCO) return; //uplynol maksymalny wybieg pompy?
65A8  0E06     MOVLW 0x6
65AA  ECA9     CALL 0xEB52, 0
65AC  F075     NOP
65AE  0100     MOVLB 0x0
65B0  6FE0     MOVWF bdat, BANKED
65B2  0EB4     MOVLW 0xB4
65B4  61E0     CPFSLT bdat, BANKED
65B6  D002     BRA 0x65BC
65B8  0CB4     RETLW 0xB4
65BA  0012     RETURN 0
2909:                                  M.WYL = 2;
65BC  0E02     MOVLW 0x2
65BE  0100     MOVLB 0x0
65C0  6F8D     MOVWF _PFNf_prn_res, BANKED
2910:                              }
65C2  D000     BRA 0x65C4
2911:                          }
2912:                          case 2:
2913:                          {
2914:                              if(!Mf_RPM_CW) //obieg CO
65C4  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
65C6  D00E     BRA 0x65E4
2915:                              {
2916:                                  if(RdPrt(S_ON_PMP)) return; //przekroczone wartosci graniczne temp w obiegu CO
65C8  0E0D     MOVLW 0xD
65CA  ECFD     CALL 0xE7FA, 0
65CC  F073     NOP
65CE  B0D8     BTFSC STATUS, 0, ACCESS
65D0  0012     RETURN 0
65D2  D001     BRA 0x65D6
65D4  0012     RETURN 0
2917:                                  if(!DtCOf_err_CO && !DtCOf_su_CO) return; //osiagnieto wartosc wylaczenia po pracy w ukladzie CO?
65D6  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
65D8  D00D     BRA 0x65F4
65DA  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
65DC  0012     RETURN 0
65DE  D00A     BRA 0x65F4
65E0  0012     RETURN 0
2918:                              }
65E2  D008     BRA 0x65F4
2919:                              else
2920:                              {
2921:                                  if(!DtCOf_err_CO && !DtCOf_ptwp_CO && Mf_pob_CW) return; //obieg CW, trwa wymuszenie CW a temp CO>od progu zalaczenia
65E4  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
65E6  B802     BTFSC DtCOf_su_CO, 4, ACCESS
65E8  D005     BRA 0x65F4
65EA  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
65EC  0012     RETURN 0
65EE  D002     BRA 0x65F4
65F0  0012     RETURN 0
65F2  D000     BRA 0x65F4
2922:                              }
2923:                              if(DtKNF.robg == _OTWARTY) //z obiegiem otwartym?
65F4  0100     MOVLB 0x0
65F6  51A6     MOVF _mux, W, BANKED
65F8  E104     BNZ 0x6602
2924:                              {
2925:                                  if(Mf_RUSZ_POMPE) return; //oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
65FA  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
65FC  0012     RETURN 0
65FE  D001     BRA 0x6602
6600  0012     RETURN 0
2926:                              }
2927:                              if(!Mf_ZMKCOCW) _POMPA = 0;
6602  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
6604  9483     BCF PORTD, 2, ACCESS
2928:                              Mf_WYLACZ = 0;
6606  980A     BCF Mf_pob_AL, 4, ACCESS
2929:                              M.WYL = 0;
6608  0E00     MOVLW 0x0
660A  0100     MOVLB 0x0
660C  6F8D     MOVWF _PFNf_prn_res, BANKED
2930:                          }
2931:                      }
660E  0C00     RETLW 0x0
2932:                      return;
661E  0012     RETURN 0
2933:                  }
2934:                  case _UNICO:
2935:                  {
2936:                      switch(M.WYL)
6620  D052     BRA 0x66C6
66C6  0100     MOVLB 0x0
66C8  518D     MOVF _PFNf_prn_res, W, BANKED
66CA  E0AB     BZ 0x6622
66CC  0A01     XORLW 0x1
66CE  E0B0     BZ 0x6630
66D0  0A03     XORLW 0x3
66D2  E0D3     BZ 0x667A
2937:                      {
2938:                          case 0:
2939:                          {
2940:                              M.WYL = 1;
6622  0E01     MOVLW 0x1
6624  0100     MOVLB 0x0
6626  6F8D     MOVWF _PFNf_prn_res, BANKED
2941:                              StartRTS(_RTWYL);
6628  0E06     MOVLW 0x6
662A  EC60     CALL 0xE4C0, 0
662C  F072     NOP
662E  D000     BRA 0x6630
2942:                          }
2943:                          case 1:
2944:                          {
2945:                              if(Mf_RPM_CW) //obieg CW
6630  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
6632  D015     BRA 0x665E
2946:                              {
2947:                                  if(RTS(_RTWYL) < _TzsWBW) return; //uplynol maksymalny wybieg pompy?
6634  0E06     MOVLW 0x6
6636  ECA9     CALL 0xEB52, 0
6638  F075     NOP
663A  0100     MOVLB 0x0
663C  6FE0     MOVWF bdat, BANKED
663E  0E3C     MOVLW 0x3C
6640  61E0     CPFSLT bdat, BANKED
6642  D002     BRA 0x6648
6644  0C3C     RETLW 0x3C
6646  0012     RETURN 0
2948:                                  if(!DtCOf_err_CO)
6648  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
664A  D013     BRA 0x6672
2949:                                  {
2950:                                      if(DtCOf_ptwp_CO) //temperatura CO osiagnela prog wylaczenia?
664C  A802     BTFSS DtCOf_su_CO, 4, ACCESS
664E  0012     RETURN 0
2951:                                      {
2952:                                          M.WYL = 2;
6650  0E02     MOVLW 0x2
6652  0100     MOVLB 0x0
6654  6F8D     MOVWF _PFNf_prn_res, BANKED
2953:                                      }
2954:                                      return;
6656  0012     RETURN 0
2955:                                  }
6658  D010     BRA 0x667A
2956:                                  else
2957:                                  {
2958:                                      M.WYL = 2;
665A  D00B     BRA 0x6672
2959:                                  }
2960:                              }
665C  D00E     BRA 0x667A
2961:                              else //obieg CO
2962:                              {
2963:                                  if(RTS(_RTWYL) < _TWBCO) return; //uplynol maksymalny wybieg pompy?
665E  0E06     MOVLW 0x6
6660  ECA9     CALL 0xEB52, 0
6662  F075     NOP
6664  0100     MOVLB 0x0
6666  6FE0     MOVWF bdat, BANKED
6668  0EB4     MOVLW 0xB4
666A  61E0     CPFSLT bdat, BANKED
666C  D002     BRA 0x6672
666E  0CB4     RETLW 0xB4
6670  0012     RETURN 0
2964:                                  M.WYL = 2;
6672  0E02     MOVLW 0x2
6674  0100     MOVLB 0x0
6676  6F8D     MOVWF _PFNf_prn_res, BANKED
2965:                              }
6678  D000     BRA 0x667A
2966:                          }
2967:                          case 2:
2968:                          {
2969:                              if(Mf_RPM_CW) //obieg CW
667A  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
667C  D008     BRA 0x668E
2970:                              {
2971:                                  if(RdPrt(S_ON_PMP_CW)) return; //przekroczone wartosci graniczne temp w obiegu CW
667E  0E11     MOVLW 0x11
6680  ECFD     CALL 0xE7FA, 0
6682  F073     NOP
6684  B0D8     BTFSC STATUS, 0, ACCESS
6686  0012     RETURN 0
6688  D010     BRA 0x66AA
668A  0012     RETURN 0
2972:                              }
668C  D00E     BRA 0x66AA
2973:                              else //obieg CO
2974:                              {
2975:                                  if(RdPrt(S_ON_PMP)) return; //przekroczone wartosci graniczne temp w obiegu CO
668E  0E0D     MOVLW 0xD
6690  ECFD     CALL 0xE7FA, 0
6692  F073     NOP
6694  B0D8     BTFSC STATUS, 0, ACCESS
6696  0012     RETURN 0
6698  D001     BRA 0x669C
669A  0012     RETURN 0
2976:                                  if(!DtCOf_err_CO && !DtCOf_su_CO) return; //osiagnieto wartosc wylaczenia po pracy w ukladzie CO?
669C  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
669E  D005     BRA 0x66AA
66A0  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
66A2  0012     RETURN 0
66A4  D002     BRA 0x66AA
66A6  0012     RETURN 0
66A8  D000     BRA 0x66AA
2977:                              }
2978:                              if(DtKNF.robg == _OTWARTY) //z obiegiem otwartym?
66AA  0100     MOVLB 0x0
66AC  51A6     MOVF _mux, W, BANKED
66AE  E104     BNZ 0x66B8
2979:                              {
2980:                                  if(Mf_RUSZ_POMPE) return; //oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
66B0  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
66B2  0012     RETURN 0
66B4  D001     BRA 0x66B8
66B6  0012     RETURN 0
2981:                              }
2982:                              if(!Mf_ZMKCOCW)
66B8  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
2983:                              {
2984:                                  _POMPA = 0;
66BA  9483     BCF PORTD, 2, ACCESS
2985:                              }
2986:                              Mf_WYLACZ = 0;
66BC  980A     BCF Mf_pob_AL, 4, ACCESS
2987:                              M.WYL = 0;
66BE  0E00     MOVLW 0x0
66C0  0100     MOVLB 0x0
66C2  6F8D     MOVWF _PFNf_prn_res, BANKED
2988:                          }
2989:                      }
66C4  0C00     RETLW 0x0
2990:                      return;
66D4  0012     RETURN 0
2991:                  }
2992:                  default: //domyslny monotermiczny
2993:                  {
2994:                      switch(M.WYL)
66D6  D05B     BRA 0x678E
678E  0100     MOVLB 0x0
6790  518D     MOVF _PFNf_prn_res, W, BANKED
6792  E0A2     BZ 0x66D8
6794  0A01     XORLW 0x1
6796  E0A7     BZ 0x66E6
6798  0A03     XORLW 0x3
679A  E0D3     BZ 0x6742
2995:                      {
2996:                          case 0:
2997:                          {
2998:                              M.WYL = 1;
66D8  0E01     MOVLW 0x1
66DA  0100     MOVLB 0x0
66DC  6F8D     MOVWF _PFNf_prn_res, BANKED
2999:                              StartRTS(_RTWYL);
66DE  0E06     MOVLW 0x6
66E0  EC60     CALL 0xE4C0, 0
66E2  F072     NOP
66E4  D000     BRA 0x66E6
3000:                          }
3001:                          case 1:
3002:                          {
3003:                              if(Mf_RPM_CW) //obieg CW
66E6  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
66E8  D01E     BRA 0x6726
3004:                              {
3005:                                  if(RTS(_RTWYL) >= _TmnWBW0) //uplynol minimalny wybieg pompy?
66EA  0E06     MOVLW 0x6
66EC  ECA9     CALL 0xEB52, 0
66EE  F075     NOP
66F0  0100     MOVLB 0x0
66F2  6FE0     MOVWF bdat, BANKED
66F4  0E13     MOVLW 0x13
66F6  65E0     CPFSGT bdat, BANKED
66F8  D007     BRA 0x6708
3006:                                  {
3007:                                      if(!DtCOf_err_CO && DtCOf_ptwp_CO) //temperatura CO osiagnela prog wylaczenia?
66FA  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
66FC  A802     BTFSS DtCOf_su_CO, 4, ACCESS
66FE  D004     BRA 0x6708
3008:                                      {
3009:                                          M.WYL = 2;
6700  0E02     MOVLW 0x2
6702  6F8D     MOVWF _PFNf_prn_res, BANKED
3010:                                          return;
6704  0012     RETURN 0
3011:                                      }
6706  D000     BRA 0x6708
3012:                                  }
3013:                                  if(RTS(_RTWYL) < _TmnWBW1) return; //uplynol maksymalny wybieg pompy?
6708  0E06     MOVLW 0x6
670A  ECA9     CALL 0xEB52, 0
670C  F075     NOP
670E  0100     MOVLB 0x0
6710  6FE0     MOVWF bdat, BANKED
6712  0EB4     MOVLW 0xB4
6714  61E0     CPFSLT bdat, BANKED
6716  D002     BRA 0x671C
6718  0CB4     RETLW 0xB4
671A  0012     RETURN 0
3014:                                  M.WYL = 2;
671C  0E02     MOVLW 0x2
671E  0100     MOVLB 0x0
6720  6F8D     MOVWF _PFNf_prn_res, BANKED
3015:                                  return;
6722  0012     RETURN 0
3016:                              }
6724  D00E     BRA 0x6742
3017:                              else //obieg CO
3018:                              {
3019:                                  if(RTS(_RTWYL) < _TWBCO) return; //uplynol maksymalny wybieg pompy?
6726  0E06     MOVLW 0x6
6728  ECA9     CALL 0xEB52, 0
672A  F075     NOP
672C  0100     MOVLB 0x0
672E  6FE0     MOVWF bdat, BANKED
6730  0EB4     MOVLW 0xB4
6732  61E0     CPFSLT bdat, BANKED
6734  D002     BRA 0x673A
6736  0CB4     RETLW 0xB4
6738  0012     RETURN 0
3020:                                  M.WYL = 2;
673A  0E02     MOVLW 0x2
673C  0100     MOVLB 0x0
673E  6F8D     MOVWF _PFNf_prn_res, BANKED
3021:                              }
6740  D000     BRA 0x6742
3022:                          }
3023:                          case 2:
3024:                          {
3025:                              if(!Mf_RPM_CW) //obieg CO
6742  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
6744  D00E     BRA 0x6762
3026:                              {
3027:                                  if(RdPrt(S_ON_PMP)) return; //przekroczone wartosci graniczne temp w obiegu CO
6746  0E0D     MOVLW 0xD
6748  ECFD     CALL 0xE7FA, 0
674A  F073     NOP
674C  B0D8     BTFSC STATUS, 0, ACCESS
674E  0012     RETURN 0
6750  D001     BRA 0x6754
6752  0012     RETURN 0
3028:                                  if(!DtCOf_err_CO && !DtCOf_su_CO) return; //osiagnieto wartosc wylaczenia po pracy w ukladzie CO?
6754  BE01     BTFSC DtCOf_err_CO, 7, ACCESS
6756  D00D     BRA 0x6772
6758  AE02     BTFSS DtCOf_su_CO, 7, ACCESS
675A  0012     RETURN 0
675C  D00A     BRA 0x6772
675E  0012     RETURN 0
3029:                              }
6760  D008     BRA 0x6772
3030:                              else
3031:                              {
3032:                                  if(!DtCOf_err_CO && !DtCOf_ptwp_CO && Mf_pob_CW) return; //obieg CW, trwa wymuszenie a temp CO>od progu zalaczenia
6762  AE01     BTFSS DtCOf_err_CO, 7, ACCESS
6764  B802     BTFSC DtCOf_su_CO, 4, ACCESS
6766  D005     BRA 0x6772
6768  B00B     BTFSC Mf_pob_KCO, 0, ACCESS
676A  0012     RETURN 0
676C  D002     BRA 0x6772
676E  0012     RETURN 0
6770  D000     BRA 0x6772
3033:                              }
3034:                              if(DtKNF.robg == _OTWARTY) //z obiegiem otwartym?
6772  0100     MOVLB 0x0
6774  51A6     MOVF _mux, W, BANKED
6776  E104     BNZ 0x6780
3035:                              {
3036:                                  if(Mf_RUSZ_POMPE) return; //oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
6778  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
677A  0012     RETURN 0
677C  D001     BRA 0x6780
677E  0012     RETURN 0
3037:                              }
3038:                              if(!Mf_ZMKCOCW) _POMPA = 0;
6780  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
6782  9483     BCF PORTD, 2, ACCESS
3039:                              Mf_WYLACZ = 0;
6784  980A     BCF Mf_pob_AL, 4, ACCESS
3040:                              M.WYL = 0;
6786  0E00     MOVLW 0x0
6788  0100     MOVLB 0x0
678A  6F8D     MOVWF _PFNf_prn_res, BANKED
3041:                          }
3042:                      }
678C  0C00     RETLW 0x0
3043:                      return;
3044:                  }
3045:              }
679C  0012     RETURN 0
3046:          }
67B8  0012     RETURN 0
3047:          //------------------
3048:          //------------------
3049:          //Wybieg wentylatora
3050:          
3051:          void VWybieg(void)
3052:          {
3053:              switch(M.VWB)
CEF8  D032     BRA 0xCF5E
CF5E  0100     MOVLB 0x0
CF60  5193     MOVF _PFNf_set_nco, W, BANKED
CF62  E0CB     BZ 0xCEFA
CF64  0A01     XORLW 0x1
CF66  E0D1     BZ 0xCF0A
CF68  0A03     XORLW 0x3
CF6A  A4D8     BTFSS STATUS, 2, ACCESS
CF6C  0012     RETURN 0
CF6E  D7E7     BRA 0xCF3E
3054:              {
3055:                  case 0:
3056:                  {
3057:                      M.VWB = 1;
CEFA  0E01     MOVLW 0x1
CEFC  0100     MOVLB 0x0
CEFE  6F93     MOVWF _PFNf_set_nco, BANKED
3058:                      Mf_DE_VNT = 1;
CF00  8407     BSF Mf_BLOKUJ_3M, 2, ACCESS
3059:                      StartRTS(_RTVWB);
CF02  0E05     MOVLW 0x5
CF04  EC60     CALL 0xE4C0, 0
CF06  F072     NOP
CF08  D000     BRA 0xCF0A
3060:                  }
3061:                  case 1:
3062:                  {
3063:                      if(RTS(_RTVWB) >= _TVWB0) Mf_DE_VNT = 0; //wyzeruj znacznik probnego wybiegu wentylatora
CF0A  0E05     MOVLW 0x5
CF0C  ECA9     CALL 0xEB52, 0
CF0E  F075     NOP
CF10  0100     MOVLB 0x0
CF12  6FDF     MOVWF pco, BANKED
CF14  0E01     MOVLW 0x1
CF16  65DF     CPFSGT pco, BANKED
CF18  D002     BRA 0xCF1E
CF1A  9407     BCF Mf_BLOKUJ_3M, 2, ACCESS
CF1C  D000     BRA 0xCF1E
3064:                      if(RTS(_RTVWB) < _TVWB1) return;
CF1E  0E05     MOVLW 0x5
CF20  ECA9     CALL 0xEB52, 0
CF22  F075     NOP
CF24  0100     MOVLB 0x0
CF26  6FDF     MOVWF pco, BANKED
CF28  0E0F     MOVLW 0xF
CF2A  61DF     CPFSLT pco, BANKED
CF2C  D002     BRA 0xCF32
CF2E  0C0F     RETLW 0xF
CF30  0012     RETURN 0
3065:          
3066:                      _VNT = 0; //wylacz wentylator
CF32  9683     BCF PORTD, 3, ACCESS
3067:                      Mf_DE_VNT = 1;
CF34  8407     BSF Mf_BLOKUJ_3M, 2, ACCESS
3068:                      M.VWB = 2;
CF36  0E02     MOVLW 0x2
CF38  0100     MOVLB 0x0
CF3A  6F93     MOVWF _PFNf_set_nco, BANKED
CF3C  D000     BRA 0xCF3E
3069:                  }
3070:                  case 2:
3071:                  {
3072:                      if(RTS(_RTVWB) < _TVWB1 + 2) return; //beznapieciowy wybieg wentylatora
CF3E  0E05     MOVLW 0x5
CF40  ECA9     CALL 0xEB52, 0
CF42  F075     NOP
CF44  0100     MOVLB 0x0
CF46  6FDF     MOVWF pco, BANKED
CF48  0E11     MOVLW 0x11
CF4A  61DF     CPFSLT pco, BANKED
CF4C  D002     BRA 0xCF52
CF4E  0C11     RETLW 0x11
CF50  0012     RETURN 0
3073:                      Mf_DE_VNT = 0;
CF52  9407     BCF Mf_BLOKUJ_3M, 2, ACCESS
3074:                      Mf_VWYBIEG = 0;
CF54  960A     BCF Mf_pob_AL, 3, ACCESS
3075:                      M.VWB = 0;
CF56  0E00     MOVLW 0x0
CF58  0100     MOVLB 0x0
CF5A  6F93     MOVWF _PFNf_set_nco, BANKED
3076:                  }
3077:              }
CF5C  0C00     RETLW 0x0
3078:          }
CF70  0012     RETURN 0
3079:          //------------------
3080:          //------------------
3081:          //Detekcja zaniku przeplywu WG (oczekuje przez pewien czas zanim uruchomi procedure rozruchu przeplywu)
3082:          
3083:          void DetekcjaPrzeplywuWG(void)
3084:          {
3085:              unsigned char pmp, prz;
3086:          
3087:              pmp = (_POMPA) ? 1 : 0;
C5E2  0E00     MOVLW 0x0
C5E4  B483     BTFSC PORTD, 2, ACCESS
C5E6  0E01     MOVLW 0x1
C5E8  0100     MOVLB 0x0
C5EA  6FE1     MOVWF GIE_BIT_VAL, BANKED
3088:              prz = (RdPrt(S_PRZ_CO)) ? 1 : 0;
C5EC  0E01     MOVLW 0x1
C5EE  ECFD     CALL 0xE7FA, 0
C5F0  F073     NOP
C5F2  0E01     MOVLW 0x1
C5F4  A0D8     BTFSS STATUS, 0, ACCESS
C5F6  0E00     MOVLW 0x0
C5F8  0100     MOVLB 0x0
C5FA  6FE2     MOVWF divisor, BANKED
3089:          
3090:              if(pmp) //pompa pracuje?
C5FC  0100     MOVLB 0x0
C5FE  51E1     MOVF GIE_BIT_VAL, W, BANKED
C600  E037     BZ 0xC670
3091:              {
3092:                  if(!prz && !Mf_DE_PMP) //zmiana stanu przep?ywu?
C602  51E2     MOVF divisor, W, BANKED
C604  B4D8     BTFSC STATUS, 2, ACCESS
C606  B207     BTFSC Mf_BLOKUJ_3M, 1, ACCESS
C608  D005     BRA 0xC614
3093:                  {
3094:                      Mf_DE_PMP = 1;
C60A  8207     BSF Mf_BLOKUJ_3M, 1, ACCESS
3095:                      M.DPR = 0;
C60C  0E00     MOVLW 0x0
C60E  0100     MOVLB 0x0
C610  6F97     MOVWF _PFNf_tdzCO, BANKED
C612  D000     BRA 0xC614
3096:                  }
3097:                  if(Mf_DE_PMP)
C614  A207     BTFSS Mf_BLOKUJ_3M, 1, ACCESS
C616  0012     RETURN 0
3098:                  {
3099:                      switch(M.DPR)
C618  D025     BRA 0xC664
C664  0100     MOVLB 0x0
C666  5197     MOVF _PFNf_tdzCO, W, BANKED
C668  E0D8     BZ 0xC61A
C66A  0A01     XORLW 0x1
C66C  E0DD     BZ 0xC628
3100:                      {
3101:                          case 0:
3102:                          {
3103:                              StartRTS(_RTDPR);
C61A  0E0B     MOVLW 0xB
C61C  EC60     CALL 0xE4C0, 0
C61E  F072     NOP
3104:                              M.DPR = 1;
C620  0E01     MOVLW 0x1
C622  0100     MOVLB 0x0
C624  6F97     MOVWF _PFNf_tdzCO, BANKED
C626  D000     BRA 0xC628
3105:                          }
3106:                          case 1:
3107:                          {
3108:                              if(prz) //dla przeplywu zakoncz procedure
C628  0100     MOVLB 0x0
C62A  51E2     MOVF divisor, W, BANKED
C62C  E005     BZ 0xC638
3109:                              {
3110:                                  Mf_DE_PMP = 0;
C62E  9207     BCF Mf_BLOKUJ_3M, 1, ACCESS
3111:                                  M.DPR = 0;
C630  0E00     MOVLW 0x0
C632  0100     MOVLB 0x0
C634  6F97     MOVWF _PFNf_tdzCO, BANKED
3112:                                  return;
C636  0012     RETURN 0
3113:                              }
3114:                              if(RTS(_RTDPR) < _TDPR1) return; //oczekuj przez zadany czas na przep?yw WG
C638  0E0B     MOVLW 0xB
C63A  ECA9     CALL 0xEB52, 0
C63C  F075     NOP
C63E  0100     MOVLB 0x0
C640  6FE0     MOVWF bdat, BANKED
C642  0E03     MOVLW 0x3
C644  61E0     CPFSLT bdat, BANKED
C646  D002     BRA 0xC64C
C648  0C03     RETLW 0x3
C64A  0012     RETURN 0
3115:                              if(!Mf_RUSZ_POMPE)
C64C  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
C64E  D005     BRA 0xC65A
3116:                              {
3117:                                  M.RPR = 0;
C650  0E00     MOVLW 0x0
C652  0100     MOVLB 0x0
C654  6F8E     MOVWF _PFNf_prnaleg, BANKED
3118:                                  Mf_RUSZ_POMPE = 1;
C656  8C09     BSF Mf_RUSZ_PWR, 6, ACCESS
C658  D000     BRA 0xC65A
3119:                              }
3120:                              Mf_DE_PMP = 0;
C65A  9207     BCF Mf_BLOKUJ_3M, 1, ACCESS
3121:                              M.DPR = 0;
C65C  0E00     MOVLW 0x0
C65E  0100     MOVLB 0x0
C660  6F97     MOVWF _PFNf_tdzCO, BANKED
3122:                          }
3123:                      }
C662  0C00     RETLW 0x0
3124:                  }
3125:              }
C66E  0012     RETURN 0
3126:              else
3127:              {
3128:                  Mf_DE_PMP = 0;
C670  9207     BCF Mf_BLOKUJ_3M, 1, ACCESS
3129:                  M.DPR = 0;
C672  0E00     MOVLW 0x0
C674  0100     MOVLB 0x0
C676  6F97     MOVWF _PFNf_tdzCO, BANKED
C678  0C00     RETLW 0x0
3130:              }
3131:          }
C67A  0012     RETURN 0
3132:          //------------------
3133:          //------------------
3134:          //Oczekiwanie na powrot przeplywu
3135:          
3136:          void OczekujNaPrzeplywWG(void)
3137:          {
3138:              unsigned char pmp, prz;
3139:          
3140:              pmp = (_POMPA) ? 1 : 0;
D066  0E00     MOVLW 0x0
D068  B483     BTFSC PORTD, 2, ACCESS
D06A  0E01     MOVLW 0x1
D06C  0103     MOVLB 0x3
D06E  6F8C     MOVWF _PFNf_prn_in, BANKED
3141:              prz = (RdPrt(S_PRZ_CO)) ? 1 : 0;
D070  0E01     MOVLW 0x1
D072  ECFD     CALL 0xE7FA, 0
D074  F073     NOP
D076  0E01     MOVLW 0x1
D078  A0D8     BTFSS STATUS, 0, ACCESS
D07A  0E00     MOVLW 0x0
D07C  0103     MOVLB 0x3
D07E  6F8D     MOVWF _PFNf_prn_res, BANKED
3142:          
3143:              switch(M.RPR)
D080  D026     BRA 0xD0CE
D0CE  0100     MOVLB 0x0
D0D0  518E     MOVF _PFNf_prnaleg, W, BANKED
D0D2  E0D7     BZ 0xD082
D0D4  0A01     XORLW 0x1
D0D6  A4D8     BTFSS STATUS, 2, ACCESS
D0D8  0012     RETURN 0
D0DA  D7DB     BRA 0xD092
3144:              {
3145:                  case 0:
3146:                  {
3147:                      M.RPR = 1;
D082  0E01     MOVLW 0x1
D084  0100     MOVLB 0x0
D086  6F8E     MOVWF _PFNf_prnaleg, BANKED
3148:                      Mf_prb_PRZ = 1;
D088  8E0B     BSF Mf_pob_KCO, 7, ACCESS
3149:                      StartRTS(_RTRPR);
D08A  0E0C     MOVLW 0xC
D08C  EC60     CALL 0xE4C0, 0
D08E  F072     NOP
D090  D000     BRA 0xD092
3150:                  }
3151:                  case 1:
3152:                  {
3153:                      if(prz && pmp) //powrocil przeplyw?
D092  0103     MOVLB 0x3
D094  518D     MOVF _PFNf_prn_res, W, BANKED
D096  E008     BZ 0xD0A8
D098  518C     MOVF _PFNf_prn_in, W, BANKED
D09A  E006     BZ 0xD0A8
3154:                      {
3155:                          M.RPR = 0;
D09C  0E00     MOVLW 0x0
D09E  0100     MOVLB 0x0
D0A0  6F8E     MOVWF _PFNf_prnaleg, BANKED
3156:                          Mf_RUSZ_POMPE = 0;
D0A2  9C09     BCF Mf_RUSZ_PWR, 6, ACCESS
3157:                          Mf_prb_PRZ = 0;
D0A4  9E0B     BCF Mf_pob_KCO, 7, ACCESS
3158:                          return;
D0A6  0012     RETURN 0
3159:                      }
3160:                      if(RTS(_RTRPR) < _TRPR1) return; //czekaj na powrot przeplywu
D0A8  0E0C     MOVLW 0xC
D0AA  ECA9     CALL 0xEB52, 0
D0AC  F075     NOP
D0AE  0103     MOVLB 0x3
D0B0  6F8B     MOVWF _PFNf_prn_cs, BANKED
D0B2  0EF0     MOVLW 0xF0
D0B4  618B     CPFSLT _PFNf_prn_cs, BANKED
D0B6  D002     BRA 0xD0BC
D0B8  0CF0     RETLW 0xF0
D0BA  0012     RETURN 0
3161:                      Mf_RUSZ_POMPE = 0;
D0BC  9C09     BCF Mf_RUSZ_PWR, 6, ACCESS
3162:                      M.ERR_BTY = 0x05;
D0BE  0E05     MOVLW 0x5
D0C0  0100     MOVLB 0x0
D0C2  6F87     MOVWF _PFNf_pgd, BANKED
3163:                      SetErr(0x05);//PrintErr(0x05, 1);
D0C4  0E05     MOVLW 0x5
D0C6  ECC7     CALL 0xF38E, 0
D0C8  F079     NOP
3164:                      ErrPTG(); //wylaczenie z blokada
D0CA  EFCC     GOTO 0x8798
D0CC  F043     NOP
3165:                  }
3166:              }
3167:          }
D0DC  0012     RETURN 0
3168:          //------------------
3169:          //------------------
3170:          //Zmiana kierunku obrotow pompy
3171:          
3172:          void ZmienKCOKCW(void)
3173:          {
3174:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
A948  D096     BRA 0xAA76
AA76  0100     MOVLB 0x0
AA78  519E     MOVF _PWMf_ENPWM2, W, BANKED
AA7A  E0B9     BZ 0xA9EE
AA7C  0A01     XORLW 0x1
AA7E  E101     BNZ 0xAA82
AA80  D77C     BRA 0xA97A
AA82  0A03     XORLW 0x3
AA84  E101     BNZ 0xAA88
AA86  D779     BRA 0xA97A
AA88  0A01     XORLW 0x1
AA8A  E0B1     BZ 0xA9EE
AA8C  D7EC     BRA 0xAA66
3175:              {
3176:                  case _BITERM: //bitermiczny (miniterm)
3177:                  case _BITERM2: //bitermiczny (maxiterm)
3178:                  {
3179:                      switch(M.ZKP)
A94A  D017     BRA 0xA97A
A97A  0100     MOVLB 0x0
A97C  5192     MOVF _PFNf_set_fnserw, W, BANKED
A97E  E0E6     BZ 0xA94C
A980  0A01     XORLW 0x1
A982  E0EC     BZ 0xA95C
3180:                      {
3181:                          case 0:
3182:                          {
3183:                              _POMPA = !_POMPA; //zalacz/wylacz pompe
A94C  7483     BTG PORTD, 2, ACCESS
3184:                              M.ZKP = 1;
A94E  0E01     MOVLW 0x1
A950  0100     MOVLB 0x0
A952  6F92     MOVWF _PFNf_set_fnserw, BANKED
3185:                              StartRTdS(_RTZKP);
A954  0E01     MOVLW 0x1
A956  ECA0     CALL 0xE540, 0
A958  F072     NOP
A95A  D000     BRA 0xA95C
3186:                          }
3187:                          case 1:
3188:                          {
3189:                              if(RTdS(_RTZKP) < _TZKP / 2) return;
A95C  0E01     MOVLW 0x1
A95E  ECD7     CALL 0xEBAE, 0
A960  F075     NOP
A962  0100     MOVLB 0x0
A964  6FDF     MOVWF pco, BANKED
A966  0E05     MOVLW 0x5
A968  61DF     CPFSLT pco, BANKED
A96A  D002     BRA 0xA970
A96C  0C05     RETLW 0x5
A96E  0012     RETURN 0
3190:                              Mf_ZMKCOCW = 0;
A970  9A0A     BCF Mf_pob_AL, 5, ACCESS
3191:                              M.ZKP = 0;
A972  0E00     MOVLW 0x0
A974  0100     MOVLB 0x0
A976  6F92     MOVWF _PFNf_set_fnserw, BANKED
3192:                          }
3193:                      }
A978  0C00     RETLW 0x0
3194:                      return;
A984  0012     RETURN 0
3195:                  }
3196:                  case _UNICO:
3197:                  case _MONOHB:
3198:                  {
3199:                      switch(M.ZKP)
A986  D033     BRA 0xA9EE
A9EE  0100     MOVLB 0x0
A9F0  5192     MOVF _PFNf_set_fnserw, W, BANKED
A9F2  E0CA     BZ 0xA988
A9F4  0A01     XORLW 0x1
A9F6  E0D0     BZ 0xA998
A9F8  0A03     XORLW 0x3
A9FA  E0DD     BZ 0xA9B6
3200:                      {
3201:                          case 0:
3202:                          {
3203:                              M.ZKP = 1;
A988  0E01     MOVLW 0x1
A98A  0100     MOVLB 0x0
A98C  6F92     MOVWF _PFNf_set_fnserw, BANKED
3204:                              _POMPA = 0; //wylacz pompe
A98E  9483     BCF PORTD, 2, ACCESS
3205:                              StartRTdS(_RTZKP);
A990  0E01     MOVLW 0x1
A992  ECA0     CALL 0xE540, 0
A994  F072     NOP
A996  D000     BRA 0xA998
3206:                          }
3207:                          case 1:
3208:                          {
3209:                              if(RTdS(_RTZKP) < _TZKP / 2) return;
A998  0E01     MOVLW 0x1
A99A  ECD7     CALL 0xEBAE, 0
A99C  F075     NOP
A99E  0100     MOVLB 0x0
A9A0  6FDF     MOVWF pco, BANKED
A9A2  0E05     MOVLW 0x5
A9A4  61DF     CPFSLT pco, BANKED
A9A6  D002     BRA 0xA9AC
A9A8  0C05     RETLW 0x5
A9AA  0012     RETURN 0
3210:                              _KCO_CW = !_KCO_CW; //zmian kierunku obrotu pompy
A9AC  7283     BTG PORTD, 1, ACCESS
3211:                              M.ZKP = 2;
A9AE  0E02     MOVLW 0x2
A9B0  0100     MOVLB 0x0
A9B2  6F92     MOVWF _PFNf_set_fnserw, BANKED
A9B4  D000     BRA 0xA9B6
3212:                          }
3213:                          case 2:
3214:                          {
3215:                              if(RTdS(_RTZKP) < _TZKP) return;
A9B6  0E01     MOVLW 0x1
A9B8  ECD7     CALL 0xEBAE, 0
A9BA  F075     NOP
A9BC  0100     MOVLB 0x0
A9BE  6FDF     MOVWF pco, BANKED
A9C0  0E0A     MOVLW 0xA
A9C2  61DF     CPFSLT pco, BANKED
A9C4  D002     BRA 0xA9CA
A9C6  0C0A     RETLW 0xA
A9C8  0012     RETURN 0
3216:                              Mf_ZMKCOCW = 0;
A9CA  9A0A     BCF Mf_pob_AL, 5, ACCESS
3217:                              M.ZKP = 0;
A9CC  0E00     MOVLW 0x0
A9CE  0100     MOVLB 0x0
A9D0  6F92     MOVWF _PFNf_set_fnserw, BANKED
3218:          
3219:                              //warunek ponownego zalaczenia pompy
3220:                              if(Mf_ROZRUCH || _GRZEJ || Mf_WYLACZ) _POMPA = 1; //wlacz pompe
A9D2  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
A9D4  B083     BTFSC PORTD, 0, ACCESS
A9D6  D002     BRA 0xA9DC
A9D8  A80A     BTFSS Mf_pob_AL, 4, ACCESS
A9DA  D002     BRA 0xA9E0
A9DC  8483     BSF PORTD, 2, ACCESS
A9DE  D000     BRA 0xA9E0
3221:                              if(DtKNF.robg == _OTWARTY) //uniko z obiegiem otwartym?
A9E0  0100     MOVLB 0x0
A9E2  51A6     MOVF _mux, W, BANKED
A9E4  B4D8     BTFSC STATUS, 2, ACCESS
3222:                              {
3223:                                  if(Mf_RUSZ_POMPE) _POMPA = 1; //trwa oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
A9E6  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
A9E8  0012     RETURN 0
A9EA  8483     BSF PORTD, 2, ACCESS
3224:                              }
3225:                          }
3226:                      }
A9EC  0012     RETURN 0
3227:                      return;
A9FC  0012     RETURN 0
3228:                  }
3229:                  default: //domyslny monotermiczny
3230:                  {
3231:                      switch(M.ZKP)
A9FE  D033     BRA 0xAA66
AA66  0100     MOVLB 0x0
AA68  5192     MOVF _PFNf_set_fnserw, W, BANKED
AA6A  E0CA     BZ 0xAA00
AA6C  0A01     XORLW 0x1
AA6E  E0D0     BZ 0xAA10
AA70  0A03     XORLW 0x3
AA72  E0DD     BZ 0xAA2E
3232:                      {
3233:                          case 0:
3234:                          {
3235:                              M.ZKP = 1;
AA00  0E01     MOVLW 0x1
AA02  0100     MOVLB 0x0
AA04  6F92     MOVWF _PFNf_set_fnserw, BANKED
3236:                              _POMPA = 0; //wylacz pompe
AA06  9483     BCF PORTD, 2, ACCESS
3237:                              StartRTdS(_RTZKP);
AA08  0E01     MOVLW 0x1
AA0A  ECA0     CALL 0xE540, 0
AA0C  F072     NOP
AA0E  D000     BRA 0xAA10
3238:                          }
3239:                          case 1:
3240:                          {
3241:                              if(RTdS(_RTZKP) < _TZKP / 2) return;
AA10  0E01     MOVLW 0x1
AA12  ECD7     CALL 0xEBAE, 0
AA14  F075     NOP
AA16  0100     MOVLB 0x0
AA18  6FDF     MOVWF pco, BANKED
AA1A  0E05     MOVLW 0x5
AA1C  61DF     CPFSLT pco, BANKED
AA1E  D002     BRA 0xAA24
AA20  0C05     RETLW 0x5
AA22  0012     RETURN 0
3242:                              _KCO_CW = !_KCO_CW; //zmian kierunku obrotu pompy
AA24  7283     BTG PORTD, 1, ACCESS
3243:                              M.ZKP = 2;
AA26  0E02     MOVLW 0x2
AA28  0100     MOVLB 0x0
AA2A  6F92     MOVWF _PFNf_set_fnserw, BANKED
AA2C  D000     BRA 0xAA2E
3244:                          }
3245:                          case 2:
3246:                          {
3247:                              if(RTdS(_RTZKP) < _TZKP) return;
AA2E  0E01     MOVLW 0x1
AA30  ECD7     CALL 0xEBAE, 0
AA32  F075     NOP
AA34  0100     MOVLB 0x0
AA36  6FDF     MOVWF pco, BANKED
AA38  0E0A     MOVLW 0xA
AA3A  61DF     CPFSLT pco, BANKED
AA3C  D002     BRA 0xAA42
AA3E  0C0A     RETLW 0xA
AA40  0012     RETURN 0
3248:                              Mf_ZMKCOCW = 0;
AA42  9A0A     BCF Mf_pob_AL, 5, ACCESS
3249:                              M.ZKP = 0;
AA44  0E00     MOVLW 0x0
AA46  0100     MOVLB 0x0
AA48  6F92     MOVWF _PFNf_set_fnserw, BANKED
3250:          
3251:                              //warunek ponownego zalaczenia pompy
3252:                              if(Mf_ROZRUCH || _GRZEJ || Mf_WYLACZ) _POMPA = 1; //wlacz pompe
AA4A  A008     BTFSS Mf_ROZRUCH, 0, ACCESS
AA4C  B083     BTFSC PORTD, 0, ACCESS
AA4E  D002     BRA 0xAA54
AA50  A80A     BTFSS Mf_pob_AL, 4, ACCESS
AA52  D002     BRA 0xAA58
AA54  8483     BSF PORTD, 2, ACCESS
AA56  D000     BRA 0xAA58
3253:                              if(DtKNF.robg == _OTWARTY) //uniko z obiegiem otwartym?
AA58  0100     MOVLB 0x0
AA5A  51A6     MOVF _mux, W, BANKED
AA5C  B4D8     BTFSC STATUS, 2, ACCESS
3254:                              {
3255:                                  if(Mf_RUSZ_POMPE) _POMPA = 1; //trwa oczekiwanie na powrot czujnika przeplywu WG do prawidlowej pozycji
AA5E  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
AA60  0012     RETURN 0
AA62  8483     BSF PORTD, 2, ACCESS
3256:                              }
3257:                          }
3258:                      }
AA64  0012     RETURN 0
3259:                      return;
3260:                  }
3261:              }
AA74  0012     RETURN 0
3262:          }
AA8E  0012     RETURN 0
3263:          //------------------
3264:          //------------------
3265:          //Awaryjny rozruch plomienia
3266:          
3267:          void RuszPlomien(void)
3268:          {
3269:              switch(M.RPL)
CE7E  D034     BRA 0xCEE8
CEE8  0100     MOVLB 0x0
CEEA  518F     MOVF _PFNf_prnserw, W, BANKED
CEEC  E0C9     BZ 0xCE80
CEEE  0A01     XORLW 0x1
CEF0  A4D8     BTFSS STATUS, 2, ACCESS
CEF2  0012     RETURN 0
CEF4  D7CC     BRA 0xCE8E
3270:              {
3271:                  case 0:
3272:                  {
3273:                      M.RPL = 1;
CE80  0E01     MOVLW 0x1
CE82  0100     MOVLB 0x0
CE84  6F8F     MOVWF _PFNf_prnserw, BANKED
3274:                      StartRTS(_RTRPL);
CE86  0E02     MOVLW 0x2
CE88  EC60     CALL 0xE4C0, 0
CE8A  F072     NOP
CE8C  D000     BRA 0xCE8E
3275:                  }
3276:                  case 1:
3277:                  {
3278:                      if(RTS(_RTRPL) < _TPLPR) return;
CE8E  0E02     MOVLW 0x2
CE90  ECA9     CALL 0xEB52, 0
CE92  F075     NOP
CE94  0100     MOVLB 0x0
CE96  6FDF     MOVWF pco, BANKED
CE98  0E1E     MOVLW 0x1E
CE9A  61DF     CPFSLT pco, BANKED
CE9C  D002     BRA 0xCEA2
CE9E  0C1E     RETLW 0x1E
CEA0  0012     RETURN 0
3279:                      M.LICZNIK_PL++;
CEA2  0100     MOVLB 0x0
CEA4  2B82     INCF M, F, BANKED
3280:                      if(Mf_RUSZ_RPLM) //procedura aktywowana w trakcie rozruchu?
CEA6  A00A     BTFSS Mf_pob_AL, 0, ACCESS
CEA8  D010     BRA 0xCECA
3281:                      {
3282:                          if(!PWMf_tpGZ) //gaz ziemny
CEAA  BE13     BTFSC PFNf_zima, 7, ACCESS
CEAC  D008     BRA 0xCEBE
3283:                          {
3284:                              x++;
CEAE  0101     MOVLB 0x1
CEB0  2B7C     INCF _PFNf_oaleg, F, BANKED
3285:                              if(M.LICZNIK_PL >= (_NCYKLI_PL - 1))
CEB2  0E01     MOVLW 0x1
CEB4  0100     MOVLB 0x0
CEB6  6582     CPFSGT M, BANKED
CEB8  D00F     BRA 0xCED8
CEBA  D004     BRA 0xCEC4
3286:                              {
3287:                                  Mf_OST_PL = 1;
3288:                                  Mf_RUSZ_RPLM = 0;
3289:                              }
3290:                          }
CEBC  D00D     BRA 0xCED8
3291:                          else
3292:                          {
3293:                              if(M.LICZNIK_PL >= (_NCYKLI_GPL - 1))
CEBE  0100     MOVLB 0x0
CEC0  5182     MOVF M, W, BANKED
CEC2  E00A     BZ 0xCED8
3294:                              {
3295:                                  Mf_OST_PL = 1;
CEC4  8A07     BSF Mf_BLOKUJ_3M, 5, ACCESS
3296:                                  Mf_RUSZ_RPLM = 0;
CEC6  900A     BCF Mf_pob_AL, 0, ACCESS
3297:                              }
3298:                          }
3299:                      }
CEC8  D007     BRA 0xCED8
3300:                      else
3301:                      {
3302:                          if(!PWMf_tpGZ) //gaz ziemny
CECA  BE13     BTFSC PFNf_zima, 7, ACCESS
CECC  D7F2     BRA 0xCEB2
3303:                          {
3304:                              if(M.LICZNIK_PL >= _NCYKLI_PL)
CECE  0E02     MOVLW 0x2
CED0  D7F1     BRA 0xCEB4
3305:                              {
3306:                                  Mf_OST_PL = 1;
3307:                                  Mf_RUSZ_RPLM = 0;
3308:                              }
3309:                          }
CED2  D002     BRA 0xCED8
3310:                          else
3311:                          {
3312:                              if(M.LICZNIK_PL >= _NCYKLI_GPL)
CED4  D7EE     BRA 0xCEB2
3313:                              {
3314:                                  Mf_OST_PL = 1;
3315:                                  Mf_RUSZ_RPLM = 0;
3316:                              }
3317:                          }
CED6  D000     BRA 0xCED8
3318:                      }
3319:                      StartRTdS(_RTRSPL);
CED8  0E04     MOVLW 0x4
CEDA  ECA0     CALL 0xE540, 0
CEDC  F072     NOP
3320:                      Mf_RUSZ_PLOMIEN = 0;
CEDE  9A09     BCF Mf_RUSZ_PWR, 5, ACCESS
3321:                      M.RPL = 0;
CEE0  0E00     MOVLW 0x0
CEE2  0100     MOVLB 0x0
CEE4  6F8F     MOVWF _PFNf_prnserw, BANKED
3322:                  }
3323:              }
CEE6  0C00     RETLW 0x0
3324:          }
CEF6  0012     RETURN 0
3325:          //Zerowanie procedury awaryjnego rozruchu plomienia
3326:          
3327:          void ReloadPlomien(void)
3328:          {
3329:              if(!Mf_RUSZ_PLOMIEN && !Mf_ZMKCOCW && !Mf_ROZRUCH && (RTdS(_RTRSPL) > 9))
ED34  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
ED36  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
ED38  0012     RETURN 0
ED3A  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
ED3C  0012     RETURN 0
ED3E  0E04     MOVLW 0x4
ED40  ECD7     CALL 0xEBAE, 0
ED42  F075     NOP
ED44  0100     MOVLB 0x0
ED46  6FDF     MOVWF pco, BANKED
ED48  0E09     MOVLW 0x9
ED4A  65DF     CPFSGT pco, BANKED
ED4C  0C09     RETLW 0x9
3330:              {
3331:                  Mf_RUSZ_RPLM = 0;
ED4E  900A     BCF Mf_pob_AL, 0, ACCESS
3332:                  Mf_OST_PL = 0;
ED50  9A07     BCF Mf_BLOKUJ_3M, 5, ACCESS
3333:                  M.LICZNIK_PL = 0;
ED52  0E00     MOVLW 0x0
ED54  0100     MOVLB 0x0
ED56  6F82     MOVWF M, BANKED
ED58  0C00     RETLW 0x0
3334:              }
3335:          }
ED5A  0012     RETURN 0
3336:          //------------------
3337:          //------------------
3338:          //Awaryjny rozruch ciagu
3339:          
3340:          void RuszCiag(void)
3341:          {
3342:              if(!Mf_TURBO) //sterownik atmosferyczny
A196  A40A     BTFSS Mf_pob_AL, 2, ACCESS
A198  D037     BRA 0xA208
A19A  D0C3     BRA 0xA322
3343:              {
3344:                  switch(M.RCI)
A19C  D035     BRA 0xA208
A208  0100     MOVLB 0x0
A20A  5190     MOVF _PFNf_res, W, BANKED
A20C  E0C8     BZ 0xA19E
A20E  0A01     XORLW 0x1
A210  E0D1     BZ 0xA1B4
3345:                  {
3346:                      case 0:
3347:                      {
3348:                          M.RCI = 1;
A19E  0E01     MOVLW 0x1
A1A0  0100     MOVLB 0x0
A1A2  6F90     MOVWF _PFNf_res, BANKED
3349:                          Mf_prb_CIG = 0;
A1A4  9C0B     BCF Mf_pob_KCO, 6, ACCESS
3350:                          StartRTS(_RTRCI);
A1A6  0E03     MOVLW 0x3
A1A8  EC60     CALL 0xE4C0, 0
A1AA  F072     NOP
3351:                          StartRTM(_RTRCI2);
A1AC  0E03     MOVLW 0x3
A1AE  EC80     CALL 0xE500, 0
A1B0  F072     NOP
A1B2  D000     BRA 0xA1B4
3352:                      }
3353:                      case 1:
3354:                      {
3355:                          if(RTS(_RTRCI) > 1) Mf_prb_CIG = 1;
A1B4  0E03     MOVLW 0x3
A1B6  ECA9     CALL 0xEB52, 0
A1B8  F075     NOP
A1BA  0103     MOVLB 0x3
A1BC  6F8B     MOVWF _PFNf_prn_cs, BANKED
A1BE  0E01     MOVLW 0x1
A1C0  658B     CPFSGT _PFNf_prn_cs, BANKED
A1C2  D002     BRA 0xA1C8
A1C4  8C0B     BSF Mf_pob_KCO, 6, ACCESS
A1C6  D000     BRA 0xA1C8
3356:                          if(RTM(_RTRCI2) < _TCIPR2) return;
A1C8  0E03     MOVLW 0x3
A1CA  ECC0     CALL 0xEB80, 0
A1CC  F075     NOP
A1CE  0103     MOVLB 0x3
A1D0  6F8B     MOVWF _PFNf_prn_cs, BANKED
A1D2  0E0F     MOVLW 0xF
A1D4  618B     CPFSLT _PFNf_prn_cs, BANKED
A1D6  D002     BRA 0xA1DC
A1D8  0C0F     RETLW 0xF
A1DA  0012     RETURN 0
3357:                          M.LICZNIK_CIG2++;
A1DC  0100     MOVLB 0x0
A1DE  2B84     INCF _PFNf_opKNF, F, BANKED
3358:                          if(M.LICZNIK_CIG2 >= _NCYKLI_CIG2)
A1E0  0E03     MOVLW 0x3
A1E2  0100     MOVLB 0x0
A1E4  6584     CPFSGT _PFNf_opKNF, BANKED
A1E6  D008     BRA 0xA1F8
3359:                          {
3360:                              M.LICZNIK_CIG2 = 0;
A1E8  6B84     CLRF _PFNf_opKNF, BANKED
3361:                              M.ERR_BTY = 0x03;
A1EA  6F87     MOVWF _PFNf_pgd, BANKED
3362:                              SetErr(0x03);//PrintErr(0x03, 1);
A1EC  0E03     MOVLW 0x3
A1EE  ECC7     CALL 0xF38E, 0
A1F0  F079     NOP
3363:                              ErrPTG();
A1F2  ECCC     CALL 0x8798, 0
A1F4  F043     NOP
A1F6  D000     BRA 0xA1F8
3364:                          }
3365:                          M.RCI = 0;
A1F8  0100     MOVLB 0x0
A1FA  6B90     CLRF _PFNf_res, BANKED
3366:                          Mf_RUSZ_CIAG = 0;
A1FC  9C08     BCF Mf_ROZRUCH, 6, ACCESS
3367:                          Mf_prb_CIG = 0;
A1FE  9C0B     BCF Mf_pob_KCO, 6, ACCESS
3368:                          StartRTM(_RTRCI3);
A200  0E06     MOVLW 0x6
A202  EC80     CALL 0xE500, 0
A204  F072     NOP
3369:                          return;
3370:                      }
3371:                  }
A206  0012     RETURN 0
3372:              }
A212  0012     RETURN 0
3373:              else //sterownik turbo
3374:              {
3375:                  switch(M.RCI)
A214  D086     BRA 0xA322
A322  0100     MOVLB 0x0
A324  5190     MOVF _PFNf_res, W, BANKED
A326  E101     BNZ 0xA32A
A328  D776     BRA 0xA216
A32A  0A01     XORLW 0x1
A32C  E085     BZ 0xA238
A32E  0A03     XORLW 0x3
A330  E0A5     BZ 0xA27C
A332  0A01     XORLW 0x1
A334  E0C8     BZ 0xA2C6
A336  0A07     XORLW 0x7
A338  E0E3     BZ 0xA300
3376:                  {
3377:                      case 0:
3378:                      {
3379:                          Mf_prb_CIG = 0;
A216  9C0B     BCF Mf_pob_KCO, 6, ACCESS
3380:                          StartRTS(_RTRCI);
A218  0E03     MOVLW 0x3
A21A  EC60     CALL 0xE4C0, 0
A21C  F072     NOP
3381:                          if(_VNT) //wentylator pracuje?
A21E  A683     BTFSS PORTD, 3, ACCESS
A220  D007     BRA 0xA230
3382:                          {
3383:                              Mf_VWYBIEG = 1; //zastartuj wybieg wentylatora
A222  860A     BSF Mf_pob_AL, 3, ACCESS
3384:                              M.VWB = 0;
A224  0E00     MOVLW 0x0
A226  0100     MOVLB 0x0
A228  6F93     MOVWF _PFNf_set_nco, BANKED
3385:                              M.RCI = 1;
A22A  0E01     MOVLW 0x1
A22C  6F90     MOVWF _PFNf_res, BANKED
3386:                          }
A22E  0C01     RETLW 0x1
3387:                          else M.RCI = 2;
A230  0E02     MOVLW 0x2
A232  0100     MOVLB 0x0
A234  6F90     MOVWF _PFNf_res, BANKED
3388:                          break;
A236  0012     RETURN 0
3389:                      }
3390:                      case 1: //wentylator pracuje - proba styku
3391:                      {
3392:                          if(RTS(_RTRCI) > 1) Mf_prb_CIG = 1;
A238  0E03     MOVLW 0x3
A23A  ECA9     CALL 0xEB52, 0
A23C  F075     NOP
A23E  0103     MOVLB 0x3
A240  6F8B     MOVWF _PFNf_prn_cs, BANKED
A242  0E01     MOVLW 0x1
A244  658B     CPFSGT _PFNf_prn_cs, BANKED
A246  D002     BRA 0xA24C
A248  8C0B     BSF Mf_pob_KCO, 6, ACCESS
A24A  D000     BRA 0xA24C
3393:                          //dla kotla turbo
3394:                          if(RdPrt(S_CIG_NO)) //pojawil sie sygnal ciagu?
A24C  0E03     MOVLW 0x3
A24E  ECFD     CALL 0xE7FA, 0
A250  F073     NOP
A252  E305     BNC 0xA25E
3395:                          {
3396:                              M.RCI = 4;
A254  0E04     MOVLW 0x4
A256  0100     MOVLB 0x0
A258  6F90     MOVWF _PFNf_res, BANKED
3397:                              M.LICZNIK_CIG3 = 0; //wyzeruj licznik prob
A25A  6B85     CLRF _PFNf_opgprg, BANKED
3398:                              StartRTS(_RTRCI);
A25C  D00C     BRA 0xA276
3399:                              break;
3400:                          }
3401:                          if(RTS(_RTRCI) < _TCIPR0 - 1) return;
A25E  0E03     MOVLW 0x3
A260  ECA9     CALL 0xEB52, 0
A262  F075     NOP
A264  0103     MOVLB 0x3
A266  6F8B     MOVWF _PFNf_prn_cs, BANKED
A268  0E0E     MOVLW 0xE
A26A  618B     CPFSLT _PFNf_prn_cs, BANKED
A26C  D002     BRA 0xA272
A26E  0C0E     RETLW 0xE
A270  0012     RETURN 0
3402:                          M.RCI = 3;
A272  0E03     MOVLW 0x3
A274  D012     BRA 0xA29A
3403:                          StartRTS(_RTRCI);
A276  0E03     MOVLW 0x3
A278  EF60     GOTO 0xE4C0
A27A  F072     NOP
3404:                          break;
3405:                      }
3406:                          //---------------------------------
3407:                      case 2: //wentylator nie pracuje - proba styku
3408:                      {
3409:                          if(RTS(_RTRCI) > 1) Mf_prb_CIG = 1;
A27C  0E03     MOVLW 0x3
A27E  ECA9     CALL 0xEB52, 0
A280  F075     NOP
A282  0103     MOVLB 0x3
A284  6F8B     MOVWF _PFNf_prn_cs, BANKED
A286  0E01     MOVLW 0x1
A288  658B     CPFSGT _PFNf_prn_cs, BANKED
A28A  D002     BRA 0xA290
A28C  8C0B     BSF Mf_pob_KCO, 6, ACCESS
A28E  D000     BRA 0xA290
3410:                          //dla kotla turbo
3411:                          if(!RdPrt(S_CIG_NO)) //zanikl sygnal ciagu
A290  0E03     MOVLW 0x3
A292  ECFD     CALL 0xE7FA, 0
A294  F073     NOP
A296  E204     BC 0xA2A0
A298  D030     BRA 0xA2FA
3412:                          {
3413:                              M.RCI = 4;
A29A  0100     MOVLB 0x0
A29C  6F90     MOVWF _PFNf_res, BANKED
3414:                              StartRTS(_RTRCI);
A29E  D7EB     BRA 0xA276
3415:                              break;
3416:                          }
3417:                          if(RTS(_RTRCI) < _TCIPR0 - 1) return;
A2A0  0E03     MOVLW 0x3
A2A2  ECA9     CALL 0xEB52, 0
A2A4  F075     NOP
A2A6  0103     MOVLB 0x3
A2A8  6F8B     MOVWF _PFNf_prn_cs, BANKED
A2AA  0E0E     MOVLW 0xE
A2AC  618B     CPFSLT _PFNf_prn_cs, BANKED
A2AE  D002     BRA 0xA2B4
A2B0  0C0E     RETLW 0xE
A2B2  0012     RETURN 0
3418:                          M.ERR_BTY = 0x03;
A2B4  0E03     MOVLW 0x3
A2B6  0100     MOVLB 0x0
A2B8  6F87     MOVWF _PFNf_pgd, BANKED
3419:                          SetErr(0x03);//PrintErr(0x03, 1);
A2BA  0E03     MOVLW 0x3
A2BC  ECC7     CALL 0xF38E, 0
A2BE  F079     NOP
3420:                          ErrPTG();
A2C0  ECCC     CALL 0x8798, 0
A2C2  F043     NOP
A2C4  D000     BRA 0xA2C6
3421:                      }
3422:                          //-----------------------------------
3423:                      case 3: //blokada 5 sek.
3424:                      {
3425:                          _VNT = 0; //stop wentylatora
A2C6  9683     BCF PORTD, 3, ACCESS
3426:                          if(RTS(_RTRCI) < _TCIBLK - 1) return;
A2C8  0E03     MOVLW 0x3
A2CA  ECA9     CALL 0xEB52, 0
A2CC  F075     NOP
A2CE  0103     MOVLB 0x3
A2D0  6F8B     MOVWF _PFNf_prn_cs, BANKED
A2D2  0E04     MOVLW 0x4
A2D4  618B     CPFSLT _PFNf_prn_cs, BANKED
A2D6  D002     BRA 0xA2DC
A2D8  0C04     RETLW 0x4
A2DA  0012     RETURN 0
3427:                          M.LICZNIK_CIG3++;
A2DC  0100     MOVLB 0x0
A2DE  2B85     INCF _PFNf_opgprg, F, BANKED
3428:                          if(M.LICZNIK_CIG3 >= _NCYKLI_CIG3) //ostatnia proba?
A2E0  0E09     MOVLW 0x9
A2E2  0100     MOVLB 0x0
A2E4  6585     CPFSGT _PFNf_opgprg, BANKED
A2E6  D009     BRA 0xA2FA
3429:                          {
3430:                              M.LICZNIK_CIG3 = 0;
A2E8  6B85     CLRF _PFNf_opgprg, BANKED
3431:                              M.ERR_BTY = 0x03;
A2EA  0E03     MOVLW 0x3
A2EC  6F87     MOVWF _PFNf_pgd, BANKED
3432:                              SetErr(0x03);//PrintErr(0x03, 1);
A2EE  0E03     MOVLW 0x3
A2F0  ECC7     CALL 0xF38E, 0
A2F2  F079     NOP
3433:                              ErrPTG();
A2F4  ECCC     CALL 0x8798, 0
A2F6  F043     NOP
A2F8  D000     BRA 0xA2FA
3434:                          }
3435:                          M.RCI = 4;
A2FA  0E04     MOVLW 0x4
A2FC  D7CE     BRA 0xA29A
3436:                          StartRTS(_RTRCI);
A2FE  D7BB     BRA 0xA276
3437:                          break;
3438:                      }
3439:                      case 4: //podtrzymanie stanu (zapobieganie impulsowemu zalaczeniu)
3440:                      {
3441:                          if(RTS(_RTRCI) < _TCIPR1) return;
A300  0E03     MOVLW 0x3
A302  ECA9     CALL 0xEB52, 0
A304  F075     NOP
A306  0900     IORLW 0x0
A308  B4D8     BTFSC STATUS, 2, ACCESS
A30A  0012     RETURN 0
A30C  D001     BRA 0xA310
A30E  0012     RETURN 0
3442:                          StartRTS(_RTRSCI2);
A310  0E0D     MOVLW 0xD
A312  EC60     CALL 0xE4C0, 0
A314  F072     NOP
3443:                          Mf_prb_CIG = 0;
A316  9C0B     BCF Mf_pob_KCO, 6, ACCESS
3444:                          Mf_RUSZ_CIAG = 0;
A318  9C08     BCF Mf_ROZRUCH, 6, ACCESS
3445:                          M.RCI = 0;
A31A  0E00     MOVLW 0x0
A31C  0100     MOVLB 0x0
A31E  6F90     MOVWF _PFNf_res, BANKED
3446:                          return;
3447:                      }
3448:                  }
A320  0012     RETURN 0
A33A  0012     RETURN 0
3449:              }
3450:          }
A33C  0012     RETURN 0
3451:          //------------------
3452:          //------------------
3453:          //Zerowanie licznuka ponowien awarii ciagu
3454:          
3455:          void ReloadCiag(void)
3456:          {
3457:              if(!Mf_TURBO) //sterownik atmosferyczny
DDB8  B40A     BTFSC Mf_pob_AL, 2, ACCESS
DDBA  D00D     BRA 0xDDD6
3458:              {
3459:                  if(!Mf_RUSZ_CIAG && RTM(_RTRCI3) > _TCIPR3) M.LICZNIK_CIG2 = 0; //wyzeruj licznik ponowien procedury po 60min.
DDBC  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
DDBE  0012     RETURN 0
DDC0  0E06     MOVLW 0x6
DDC2  ECC0     CALL 0xEB80, 0
DDC4  F075     NOP
DDC6  0100     MOVLB 0x0
DDC8  6FDF     MOVWF pco, BANKED
DDCA  0E3C     MOVLW 0x3C
DDCC  65DF     CPFSGT pco, BANKED
DDCE  0C3C     RETLW 0x3C
DDD0  0E00     MOVLW 0x0
DDD2  6F84     MOVWF _PFNf_opKNF, BANKED
3460:              }
DDD4  0012     RETURN 0
3461:              else
3462:              {
3463:                  if(RTS(_RTRSCI) > _TCIRLP) //(turbo) po minucie wyzeruj licznik_zaników_ci?gu/min
DDD6  0E09     MOVLW 0x9
DDD8  ECA9     CALL 0xEB52, 0
DDDA  F075     NOP
DDDC  0100     MOVLB 0x0
DDDE  6FDF     MOVWF pco, BANKED
DDE0  0E3C     MOVLW 0x3C
DDE2  65DF     CPFSGT pco, BANKED
DDE4  D003     BRA 0xDDEC
3464:                  {
3465:                      M.LICZNIK_CIG = 0;
DDE6  0E00     MOVLW 0x0
DDE8  6F83     MOVWF _PFNf_ofzima, BANKED
DDEA  D000     BRA 0xDDEC
3466:                  }
3467:                  if(!Mf_RUSZ_CIAG && (RTS(_RTRSCI2) > _TCITRS)) //(turbo) po minucie wyzeruj licznik_prob_ci?gu/min
DDEC  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
DDEE  0012     RETURN 0
DDF0  0E0D     MOVLW 0xD
DDF2  ECA9     CALL 0xEB52, 0
DDF4  F075     NOP
DDF6  0100     MOVLB 0x0
DDF8  6FDF     MOVWF pco, BANKED
DDFA  0E3C     MOVLW 0x3C
DDFC  65DF     CPFSGT pco, BANKED
DDFE  0C3C     RETLW 0x3C
3468:                  {
3469:                      M.LICZNIK_CIG3 = 0;
DE00  0E00     MOVLW 0x0
DE02  6F85     MOVWF _PFNf_opgprg, BANKED
3470:                  }
DE04  0012     RETURN 0
3471:              }
3472:          }
DE06  0012     RETURN 0
3473:          //------------------
3474:          //------------------
3475:          //Awaryjny rozruch pompy
3476:          
3477:          void Proba48(void)
3478:          {
3479:          #if _SRV48H==0
3480:              if(Mf_RUSZ_48 || Mf_RUSZ_48Z3) return;
E9D2  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
E9D4  BA08     BTFSC Mf_ROZRUCH, 5, ACCESS
E9D6  0012     RETURN 0
E9D8  D001     BRA 0xE9DC
E9DA  0012     RETURN 0
3481:              if(_POMPA) StartRTG(_RTR48);
E9DC  A483     BTFSS PORTD, 2, ACCESS
E9DE  D003     BRA 0xE9E6
E9E0  0E00     MOVLW 0x0
E9E2  EF40     GOTO 0xE480
E9E4  F072     NOP
3482:              else
3483:              {
3484:                  if(RTG(_RTR48) >= _TPR48)
E9E6  0E00     MOVLW 0x0
E9E8  EC92     CALL 0xEB24, 0
E9EA  F075     NOP
E9EC  0100     MOVLB 0x0
E9EE  6FDF     MOVWF pco, BANKED
E9F0  0E17     MOVLW 0x17
E9F2  65DF     CPFSGT pco, BANKED
E9F4  0C17     RETLW 0x17
3485:                  {
3486:                      M.R48 = 0;
E9F6  6B89     CLRF _PFNf_plmCW, BANKED
3487:                      Mf_RUSZ_48 = 1;
E9F8  8808     BSF Mf_ROZRUCH, 4, ACCESS
3488:                      StartRTG(_RTR48);
E9FA  0E00     MOVLW 0x0
E9FC  EC40     CALL 0xE480, 0
E9FE  F072     NOP
3489:                  }
EA00  0012     RETURN 0
3490:              }
3491:          #else
3492:              if(Mf_RUSZ_48 || Mf_RUSZ_48Z3) return;
3493:              if(_POMPA) StartRTM(_SRVRTANL);
3494:              else
3495:              {
3496:                  if(RTM(_SRVRTANL) >= 10)
3497:                  {
3498:                      M.R48 = 0;
3499:                      Mf_RUSZ_48 = 1;
3500:                      StartRTM(_SRVRTANL);
3501:                  }
3502:              }
3503:          #endif
3504:          }
EA02  0012     RETURN 0
3505:          
3506:          //------------------
3507:          //------------------
3508:          //Wybieg pompy po 48h
3509:          
3510:          void Rusz48(void)
3511:          {
3512:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
B2D8  D07B     BRA 0xB3D0
B3D0  0100     MOVLB 0x0
B3D2  519E     MOVF _PWMf_ENPWM2, W, BANKED
B3D4  E0CE     BZ 0xB372
B3D6  0A01     XORLW 0x1
B3D8  E0A3     BZ 0xB320
B3DA  0A03     XORLW 0x3
B3DC  E0A1     BZ 0xB320
B3DE  0A01     XORLW 0x1
B3E0  E0C8     BZ 0xB372
B3E2  D7F0     BRA 0xB3C4
3513:              {
3514:                  case _BITERM: //bitermiczny (miniterm)
3515:                  case _BITERM2: //bitermiczny (maxiterm)
3516:                  {
3517:                      switch(M.R48)
B2DA  D022     BRA 0xB320
B320  0100     MOVLB 0x0
B322  5189     MOVF _PFNf_plmCW, W, BANKED
B324  E0DB     BZ 0xB2DC
B326  0A01     XORLW 0x1
B328  E0E6     BZ 0xB2F6
3518:                      {
3519:                          case 0:
3520:                          {
3521:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B2DC  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B2DE  0012     RETURN 0
B2E0  D001     BRA 0xB2E4
B2E2  0012     RETURN 0
3522:                              StartRTS(_RTWB48);
B2E4  0E04     MOVLW 0x4
B2E6  EC60     CALL 0xE4C0, 0
B2E8  F072     NOP
3523:                              ToObiegCO(); //zalacz pompe
B2EA  EC53     CALL 0xDEA6, 0
B2EC  F06F     NOP
3524:                              M.R48 = 1;
B2EE  0E01     MOVLW 0x1
B2F0  0100     MOVLB 0x0
B2F2  6F89     MOVWF _PFNf_plmCW, BANKED
B2F4  D000     BRA 0xB2F6
3525:                          }
3526:                          case 1:
3527:                          {
3528:                              if(RTS(_RTWB48) < _TWB48) return;
B2F6  0E04     MOVLW 0x4
B2F8  ECA9     CALL 0xEB52, 0
B2FA  F075     NOP
B2FC  0100     MOVLB 0x0
B2FE  6FDF     MOVWF pco, BANKED
B300  0EB4     MOVLW 0xB4
B302  61DF     CPFSLT pco, BANKED
B304  D002     BRA 0xB30A
B306  0CB4     RETLW 0xB4
B308  0012     RETURN 0
3529:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B30A  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B30C  0012     RETURN 0
B30E  D001     BRA 0xB312
B310  0012     RETURN 0
3530:                              ToObiegCW(); //wylacz pompe
B312  EC3E     CALL 0xC67C, 0
B314  F063     NOP
3531:                              Mf_RUSZ_48 = 0;
B316  9808     BCF Mf_ROZRUCH, 4, ACCESS
3532:                              M.R48 = 0;
B318  0E00     MOVLW 0x0
B31A  0100     MOVLB 0x0
B31C  6F89     MOVWF _PFNf_plmCW, BANKED
3533:                          }
3534:                      }
B31E  0C00     RETLW 0x0
3535:                      break;
B32A  0012     RETURN 0
3536:                  }
3537:                  case _UNICO:
3538:                  case _MONOHB:
3539:                  {
3540:                      switch(M.R48)
B32C  D022     BRA 0xB372
B372  0100     MOVLB 0x0
B374  5189     MOVF _PFNf_plmCW, W, BANKED
B376  E0DB     BZ 0xB32E
B378  0A01     XORLW 0x1
B37A  E0E7     BZ 0xB34A
3541:                      {
3542:                          case 0:
3543:                          {
3544:                              ToObiegCO();
B32E  EC53     CALL 0xDEA6, 0
B330  F06F     NOP
3545:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B332  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B334  0012     RETURN 0
B336  D001     BRA 0xB33A
B338  0012     RETURN 0
3546:                              StartRTS(_RTWB48);
B33A  0E04     MOVLW 0x4
B33C  EC60     CALL 0xE4C0, 0
B33E  F072     NOP
3547:                              _POMPA = 1; //zalacz pompe
B340  8483     BSF PORTD, 2, ACCESS
3548:                              M.R48 = 1;
B342  0E01     MOVLW 0x1
B344  0100     MOVLB 0x0
B346  6F89     MOVWF _PFNf_plmCW, BANKED
B348  D000     BRA 0xB34A
3549:                          }
3550:                          case 1:
3551:                          {
3552:                              if(RTS(_RTWB48) < _TWB48) return;
B34A  0E04     MOVLW 0x4
B34C  ECA9     CALL 0xEB52, 0
B34E  F075     NOP
B350  0100     MOVLB 0x0
B352  6FDF     MOVWF pco, BANKED
B354  0EB4     MOVLW 0xB4
B356  61DF     CPFSLT pco, BANKED
B358  D002     BRA 0xB35E
B35A  0CB4     RETLW 0xB4
B35C  0012     RETURN 0
3553:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B35E  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B360  0012     RETURN 0
B362  D001     BRA 0xB366
B364  0012     RETURN 0
3554:                              _POMPA = 0; //wylacz pompe
B366  9483     BCF PORTD, 2, ACCESS
3555:                              Mf_RUSZ_48 = 0;
B368  9808     BCF Mf_ROZRUCH, 4, ACCESS
3556:                              M.R48 = 0;
B36A  0E00     MOVLW 0x0
B36C  0100     MOVLB 0x0
B36E  6F89     MOVWF _PFNf_plmCW, BANKED
3557:                          }
3558:                      }
B370  0C00     RETLW 0x0
3559:                      break;
B37C  0012     RETURN 0
3560:                  }
3561:                  default: //domyslny monotermiczny
3562:                  {
3563:                      switch(M.R48)
B37E  D022     BRA 0xB3C4
B3C4  0100     MOVLB 0x0
B3C6  5189     MOVF _PFNf_plmCW, W, BANKED
B3C8  E0DB     BZ 0xB380
B3CA  0A01     XORLW 0x1
B3CC  E0E7     BZ 0xB39C
3564:                      {
3565:                          case 0:
3566:                          {
3567:                              ToObiegCO();
B380  EC53     CALL 0xDEA6, 0
B382  F06F     NOP
3568:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B384  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B386  0012     RETURN 0
B388  D001     BRA 0xB38C
B38A  0012     RETURN 0
3569:                              StartRTS(_RTWB48);
B38C  0E04     MOVLW 0x4
B38E  EC60     CALL 0xE4C0, 0
B390  F072     NOP
3570:                              _POMPA = 1; //zalacz pompe
B392  8483     BSF PORTD, 2, ACCESS
3571:                              M.R48 = 1;
B394  0E01     MOVLW 0x1
B396  0100     MOVLB 0x0
B398  6F89     MOVWF _PFNf_plmCW, BANKED
B39A  D000     BRA 0xB39C
3572:                          }
3573:                          case 1:
3574:                          {
3575:                              if(RTS(_RTWB48) < _TWB48) return;
B39C  0E04     MOVLW 0x4
B39E  ECA9     CALL 0xEB52, 0
B3A0  F075     NOP
B3A2  0100     MOVLB 0x0
B3A4  6FDF     MOVWF pco, BANKED
B3A6  0EB4     MOVLW 0xB4
B3A8  61DF     CPFSLT pco, BANKED
B3AA  D002     BRA 0xB3B0
B3AC  0CB4     RETLW 0xB4
B3AE  0012     RETURN 0
3576:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
B3B0  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
B3B2  0012     RETURN 0
B3B4  D001     BRA 0xB3B8
B3B6  0012     RETURN 0
3577:                              _POMPA = 0; //wylacz pompe
B3B8  9483     BCF PORTD, 2, ACCESS
3578:                              Mf_RUSZ_48 = 0;
B3BA  9808     BCF Mf_ROZRUCH, 4, ACCESS
3579:                              M.R48 = 0;
B3BC  0E00     MOVLW 0x0
B3BE  0100     MOVLB 0x0
B3C0  6F89     MOVWF _PFNf_plmCW, BANKED
3580:                          }
3581:                      }
B3C2  0C00     RETLW 0x0
3582:                      break;
3583:                  }
3584:              }
B3CE  0012     RETURN 0
3585:          }
B3E4  0012     RETURN 0
3586:          //-----------------------------------
3587:          //Awaryjny rozruch pompy
3588:          
3589:          void Proba48Z3(void)
3590:          {
3591:          #if _SRV48H==0
3592:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
DFDC  D01E     BRA 0xE01A
E01A  0100     MOVLB 0x0
E01C  519E     MOVF _PWMf_ENPWM2, W, BANKED
E01E  0A03     XORLW 0x3
E020  A4D8     BTFSS STATUS, 2, ACCESS
E022  0012     RETURN 0
E024  D7DC     BRA 0xDFDE
3593:              {
3594:                  case _MONOHB: //uklady sterowania z hydroblokiem?
3595:                  {
3596:                      if(Mf_RUSZ_48Z3 || Mf_RUSZ_48) return;
DFDE  AA08     BTFSS Mf_ROZRUCH, 5, ACCESS
DFE0  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
DFE2  0012     RETURN 0
DFE4  D001     BRA 0xDFE8
DFE6  0012     RETURN 0
3597:                      if(_POMPA && !_KCO_CW) StartRTG(_RTR48Z3); //pompa pracuje w obiegu WU?
DFE8  B483     BTFSC PORTD, 2, ACCESS
DFEA  B283     BTFSC PORTD, 1, ACCESS
DFEC  D003     BRA 0xDFF4
DFEE  0E02     MOVLW 0x2
DFF0  EF40     GOTO 0xE480
DFF2  F072     NOP
3598:                      else
3599:                      {
3600:                          if(_POMPA || Mf_ZMKCOCW) return;
DFF4  A483     BTFSS PORTD, 2, ACCESS
DFF6  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
DFF8  0012     RETURN 0
DFFA  D001     BRA 0xDFFE
DFFC  0012     RETURN 0
3601:                          if(RTG(_RTR48Z3) >= _TPR48Z3)
DFFE  0E02     MOVLW 0x2
E000  EC92     CALL 0xEB24, 0
E002  F075     NOP
E004  0100     MOVLB 0x0
E006  6FDF     MOVWF pco, BANKED
E008  0E2E     MOVLW 0x2E
E00A  65DF     CPFSGT pco, BANKED
E00C  0C2E     RETLW 0x2E
3602:                          {
3603:                              M.R48Z3 = 0;
E00E  6B8A     CLRF _PFNf_pmpPWM, BANKED
3604:                              Mf_RUSZ_48Z3 = 1;
E010  8A08     BSF Mf_ROZRUCH, 5, ACCESS
3605:                              StartRTG(_RTR48Z3);
E012  0E02     MOVLW 0x2
E014  EC40     CALL 0xE480, 0
E016  F072     NOP
3606:                          }
3607:                      }
3608:                      break;
3609:                  }
3610:              }
E018  0012     RETURN 0
3611:          #else
3612:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
3613:              {
3614:                  case _MONOHB: //uklady sterowania z hydroblokiem?
3615:                  {
3616:                      if(Mf_RUSZ_48Z3 || Mf_RUSZ_48) return;
3617:                      if(_POMPA && !_KCO_CW) StartRTM(_RTMAL); //pompa pracuje w obiegu WU?
3618:                      else
3619:                      {
3620:                          if(_POMPA || Mf_ZMKCOCW) return;
3621:                          if(RTM(_RTMAL) >= 9)
3622:                          {
3623:                              M.R48Z3 = 0;
3624:                              Mf_RUSZ_48Z3 = 1;
3625:                              StartRTM(_RTMAL);
3626:                          }
3627:                      }
3628:                      break;
3629:                  }
3630:              }
3631:          #endif
3632:          }
E026  0012     RETURN 0
3633:          //------------------
3634:          //------------------
3635:          //Wybieg pompy po 48h dla WU
3636:          
3637:          void Rusz48Z3(void)
3638:          {
3639:              switch(DtKNF.tpkt) //dla danego rodzaju kotla
D942  D029     BRA 0xD996
D996  0100     MOVLB 0x0
D998  519E     MOVF _PWMf_ENPWM2, W, BANKED
D99A  0A03     XORLW 0x3
D99C  A4D8     BTFSS STATUS, 2, ACCESS
D99E  0012     RETURN 0
D9A0  D7F4     BRA 0xD98A
3640:              {
3641:                  case _MONOHB:
3642:                  {
3643:                      switch(M.R48Z3)
D944  D022     BRA 0xD98A
D98A  0100     MOVLB 0x0
D98C  518A     MOVF _PFNf_pmpPWM, W, BANKED
D98E  E0DB     BZ 0xD946
D990  0A01     XORLW 0x1
D992  E0E7     BZ 0xD962
3644:                      {
3645:                          case 0:
3646:                          {
3647:                              ToObiegCW();
D946  EC3E     CALL 0xC67C, 0
D948  F063     NOP
3648:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
D94A  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
D94C  0012     RETURN 0
D94E  D001     BRA 0xD952
D950  0012     RETURN 0
3649:                              StartRTS(_RTWB48);
D952  0E04     MOVLW 0x4
D954  EC60     CALL 0xE4C0, 0
D956  F072     NOP
3650:                              _POMPA = 1; //zalacz pompe
D958  8483     BSF PORTD, 2, ACCESS
3651:                              M.R48Z3 = 1;
D95A  0E01     MOVLW 0x1
D95C  0100     MOVLB 0x0
D95E  6F8A     MOVWF _PFNf_pmpPWM, BANKED
D960  D000     BRA 0xD962
3652:                          }
3653:                          case 1:
3654:                          {
3655:                              if(RTS(_RTWB48) < _TWB48Z3) return;
D962  0E04     MOVLW 0x4
D964  ECA9     CALL 0xEB52, 0
D966  F075     NOP
D968  0100     MOVLB 0x0
D96A  6FDF     MOVWF pco, BANKED
D96C  0E0F     MOVLW 0xF
D96E  61DF     CPFSLT pco, BANKED
D970  D002     BRA 0xD976
D972  0C0F     RETLW 0xF
D974  0012     RETURN 0
3656:                              if(Mf_ZMKCOCW) return; //odczekaj az zakonczy sie procedura zmiany obiegu
D976  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
D978  0012     RETURN 0
D97A  D001     BRA 0xD97E
D97C  0012     RETURN 0
3657:                              _POMPA = 0; //wylacz pompe
D97E  9483     BCF PORTD, 2, ACCESS
3658:                              Mf_RUSZ_48Z3 = 0;
D980  9A08     BCF Mf_ROZRUCH, 5, ACCESS
3659:                              M.R48Z3 = 0;
D982  0E00     MOVLW 0x0
D984  0100     MOVLB 0x0
D986  6F8A     MOVWF _PFNf_pmpPWM, BANKED
3660:                          }
3661:                      }
D988  0C00     RETLW 0x0
3662:                      break;
3663:                  }
3664:              }
D994  0012     RETURN 0
3665:          }
D9A2  0012     RETURN 0
3666:          //------------------
3667:          //------------------
3668:          //------------------
3669:          //------------------
3670:          //------------------
3671:          //------------------
3672:          //wygaszenie diod roboczych
3673:          /*void ClearDiode(void)
3674:          {
3675:                  SetDiode(_DPL,0);
3676:                  SetDiode(_DCO,0);
3677:                  SetDiode(_DCW,0);
3678:          }*/
3679:          //------------------
3680:          //------------------
3681:          //Reakcja na bledne podlaczenie do sieci
3682:          /*void ErrDTF(void)
3683:          {
3684:                  PrintErr(0x11,1);
3685:                  ClearDiode();
3686:                  while(1)
3687:                  {
3688:                          CLRWDT();
3689:                          if(!RdPrt(S_DTF)) 			//prawidlowe podlaczenie fazy?
3690:                          {
3691:                                  EndErr();				//wygas kod bledu
3692:                                  return;					//wyjdz z petli
3693:                          }
3694:                  }
3695:          }*/
3696:          
3697:          //------------------
3698:          //------------------
3699:          
3700:          bit KeyRes(void)
3701:          {
3702:              if(RdPrt(S_OFF))
DD64  0E16     MOVLW 0x16
DD66  ECFD     CALL 0xE7FA, 0
DD68  F073     NOP
DD6A  E302     BNC 0xDD70
3703:              {
3704:                  PFNf_res = 1;
DD6C  8012     BSF PFNf_str_nco, 0, ACCESS
3705:              }
DD6E  D01B     BRA 0xDDA6
3706:              else PFNf_res = 0;
DD70  9012     BCF PFNf_str_nco, 0, ACCESS
3707:              switch(M.KRS)
DD72  D019     BRA 0xDDA6
DDA6  0100     MOVLB 0x0
DDA8  5195     MOVF _PFNf_str_nco, W, BANKED
DDAA  E0E4     BZ 0xDD74
DDAC  0A01     XORLW 0x1
DDAE  E0EB     BZ 0xDD86
DDB0  D000     BRA 0xDDB2
3708:              {
3709:                  case 0:
3710:                  {
3711:                      if(PFNf_res)
DD74  A012     BTFSS PFNf_str_nco, 0, ACCESS
DD76  D01D     BRA 0xDDB2
3712:                      {
3713:                          M.KRS = 1;
DD78  0E01     MOVLW 0x1
DD7A  0100     MOVLB 0x0
DD7C  6F95     MOVWF _PFNf_str_nco, BANKED
3714:                          StartRTS(_RTSRV0);
DD7E  0E07     MOVLW 0x7
DD80  EC60     CALL 0xE4C0, 0
DD82  F072     NOP
3715:                      }
3716:                      break;
DD84  D016     BRA 0xDDB2
3717:                  }
3718:                  case 1:
3719:                  {
3720:                      if(PFNf_res)
DD86  A012     BTFSS PFNf_str_nco, 0, ACCESS
DD88  D00A     BRA 0xDD9E
3721:                      {
3722:                          if(RTS(_RTSRV0) < _TKRES) return 0;
DD8A  0E07     MOVLW 0x7
DD8C  ECA9     CALL 0xEB52, 0
DD8E  F075     NOP
DD90  0900     IORLW 0x0
DD92  E102     BNZ 0xDD98
DD94  90D8     BCF STATUS, 0, ACCESS
DD96  0012     RETURN 0
3723:                          return 1;
DD98  80D8     BSF STATUS, 0, ACCESS
DD9A  0012     RETURN 0
3724:          
3725:                      }
DD9C  D00A     BRA 0xDDB2
3726:                      else
3727:                      {
3728:                          M.KRS = 0;
DD9E  0E00     MOVLW 0x0
DDA0  0100     MOVLB 0x0
DDA2  6F95     MOVWF _PFNf_str_nco, BANKED
3729:                      }
3730:                  }
3731:              }
DDA4  D006     BRA 0xDDB2
3732:              return 0;
DDB2  90D8     BCF STATUS, 0, ACCESS
DDB4  0012     RETURN 0
3733:          }
DDB6  0012     RETURN 0
3734:          //------------------
3735:          //------------------
3736:          //Przerwa czasowa na wypadek stanow nieustalonych przy zaniku napiecia
3737:          
3738:          void VZPauza(void)
3739:          {
3740:              //ClsScr();
3741:              StartRTS(_RTROZ);
E440  0E01     MOVLW 0x1
E442  EC60     CALL 0xE4C0, 0
E444  F072     NOP
3742:              while(1)
E47C  D7E4     BRA 0xE446
3743:              {
3744:                  CLRWDT();
E446  0004     CLRWDT
3745:                  DecWSW();
E448  EC46     CALL 0x488C, 0
E44A  F024     NOP
3746:                  if(M.ERR_BTY == 2)
E44C  0E02     MOVLW 0x2
E44E  0100     MOVLB 0x0
E450  1987     XORWF _PFNf_pgd, W, BANKED
E452  E10C     BNZ 0xE46C
3747:                  {
3748:                      if(RTS(_RTROZ) >= 3)
E454  0E01     MOVLW 0x1
E456  ECA9     CALL 0xEB52, 0
E458  F075     NOP
E45A  0103     MOVLB 0x3
E45C  6F8A     MOVWF _PFNf_pmpPWM, BANKED
E45E  0E02     MOVLW 0x2
E460  0103     MOVLB 0x3
E462  658A     CPFSGT _PFNf_pmpPWM, BANKED
E464  D7F0     BRA 0xE446
E466  0012     RETURN 0
3749:                      {
3750:                          //EndClsScr();
3751:                          return;
E468  0012     RETURN 0
3752:                      }
3753:                  }
E46A  D7ED     BRA 0xE446
3754:                  else
3755:                  {
3756:                      if(RTS(_RTROZ) >= 2)
E46C  0E01     MOVLW 0x1
E46E  ECA9     CALL 0xEB52, 0
E470  F075     NOP
E472  0103     MOVLB 0x3
E474  6F8A     MOVWF _PFNf_pmpPWM, BANKED
E476  0E01     MOVLW 0x1
E478  D7F3     BRA 0xE460
3757:                      {
3758:                          //EndClsScr();
3759:                          return;
E47A  0012     RETURN 0
3760:                      }
3761:                  }
3762:              }
3763:          }
E47E  0012     RETURN 0
3764:          //------------------
3765:          //------------------
3766:          //Petla wylaczenia awaryjnego
3767:          
3768:          void ErrPTG(void)
3769:          {
3770:              GrzejOFF(); //_GRZEJ=0;
8798  ECCA     CALL 0xEF94, 0
879A  F077     NOP
3771:              VZPauza();
879C  EC20     CALL 0xE440, 0
879E  F072     NOP
3772:              if(DtKNF.robg == _OTWARTY) //uklad z obiegiem otwartym?
87A0  0100     MOVLB 0x0
87A2  51A6     MOVF _mux, W, BANKED
87A4  E10E     BNZ 0x87C2
3773:              {
3774:                  if(M.ERR_BTY == 5) //dozwolony kod bledu?
87A6  0E05     MOVLW 0x5
87A8  1987     XORWF _PFNf_pgd, W, BANKED
87AA  E10B     BNZ 0x87C2
3775:                  {
3776:                      eeprom_write(_ADRERR, M.ERR_BTY);
87AC  ECFE     CALL 0xF3FC, 0
87AE  F079     NOP
87B0  0100     MOVLB 0x0
87B2  6BDF     CLRF pco, BANKED
87B4  0EC0     MOVLW 0xC0
87B6  6FDE     MOVWF __pcstackBANK0, BANKED
87B8  C087     MOVFF _PFNf_pgd, bdat
87BA  F0E0     NOP
87BC  EC58     CALL 0xE2B0, 0
87BE  F071     NOP
3777:                  }
87C0  D000     BRA 0x87C2
3778:              } //przerwa czasowa na wypadek stanow nieustalonych
3779:              if((M.ERR_BTY >= 1) && (M.ERR_BTY <= 3)) eeprom_write(_ADRERR, M.ERR_BTY); //WriteEEPROM(_ADRERR,M.ERR_BTY); 	//zapis kodu bledu do pamieci
87C2  0100     MOVLB 0x0
87C4  5187     MOVF _PFNf_pgd, W, BANKED
87C6  E00E     BZ 0x87E4
87C8  0E04     MOVLW 0x4
87CA  6187     CPFSLT _PFNf_pgd, BANKED
87CC  D00B     BRA 0x87E4
87CE  ECFE     CALL 0xF3FC, 0
87D0  F079     NOP
87D2  0100     MOVLB 0x0
87D4  6BDF     CLRF pco, BANKED
87D6  0EC0     MOVLW 0xC0
87D8  6FDE     MOVWF __pcstackBANK0, BANKED
87DA  C087     MOVFF _PFNf_pgd, bdat
87DC  F0E0     NOP
87DE  EC58     CALL 0xE2B0, 0
87E0  F071     NOP
87E2  D000     BRA 0x87E4
3780:              Mf_RUSZ_POMPE = 0;
87E4  9C09     BCF Mf_RUSZ_PWR, 6, ACCESS
3781:              Mf_ROZRUCH = 0;
87E6  9008     BCF Mf_ROZRUCH, 0, ACCESS
3782:              Mf_MODULUJ = 0;
87E8  9807     BCF Mf_BLOKUJ_3M, 4, ACCESS
3783:              WritePWM(0);
87EA  0E00     MOVLW 0x0
87EC  ECDD     CALL 0xF1BA, 0
87EE  F078     NOP
3784:              if(!Mf_WYLACZ) //aktywacja wybiegu pompy
87F0  B80A     BTFSC Mf_pob_AL, 4, ACCESS
87F2  D016     BRA 0x8820
3785:              {
3786:                  M.WYL = 0;
87F4  0100     MOVLB 0x0
87F6  6B8D     CLRF _PFNf_prn_res, BANKED
3787:                  switch(DtKNF.tpkt) //dla danego rodzaju kotla
87F8  D00A     BRA 0x880E
880E  0100     MOVLB 0x0
8810  519E     MOVF _PWMf_ENPWM2, W, BANKED
8812  E0F7     BZ 0x8802
8814  0A01     XORLW 0x1
8816  E0F7     BZ 0x8806
8818  0A03     XORLW 0x3
881A  E0F5     BZ 0x8806
881C  0A01     XORLW 0x1
881E  D7F1     BRA 0x8802
3788:                  {
3789:                      case _BITERM: //bitermiczny (miniterm)
3790:                      case _BITERM2: //bitermiczny (maxiterm)
87FA  D005     BRA 0x8806
3791:                      {
3792:                          if(_POMPA) Mf_WYLACZ = 1;
3793:                          break;
87FC  D011     BRA 0x8820
3794:                      }
3795:                      case _UNICO:
3796:                      case _MONOHB:
87FE  D001     BRA 0x8802
3797:                      {
3798:                          if(Mf_ZMKCOCW) Mf_WYLACZ = 1;
3799:                          else
3800:                              if(_POMPA) Mf_WYLACZ = 1;
3801:                          break;
8800  D00F     BRA 0x8820
3802:                      }
3803:                      default: //domyslny monotermiczny
3804:                      {
3805:                          if(Mf_ZMKCOCW) Mf_WYLACZ = 1;
8802  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8804  D002     BRA 0x880A
3806:                          else
3807:                              if(_POMPA) Mf_WYLACZ = 1;
8806  A483     BTFSS PORTD, 2, ACCESS
8808  D00B     BRA 0x8820
880A  880A     BSF Mf_pob_AL, 4, ACCESS
3808:                          break;
3809:                      }
3810:                  }
880C  D009     BRA 0x8820
3811:              }
3812:              if(Mf_TURBO && _VNT) Mf_VWYBIEG = 1; //aktywacja wybiegu wentylatora
8820  B40A     BTFSC Mf_pob_AL, 2, ACCESS
8822  A683     BTFSS PORTD, 3, ACCESS
8824  D001     BRA 0x8828
8826  860A     BSF Mf_pob_AL, 3, ACCESS
3813:              Mf_RUSZ_PWR = 0;
8828  9E09     BCF Mf_RUSZ_PWR, 7, ACCESS
3814:              M.HVZ = 0;
882A  0E00     MOVLW 0x0
882C  0100     MOVLB 0x0
882E  6F96     MOVWF _PFNf_str_ncw, BANKED
3815:              M.KRS = 0;
8830  6F95     MOVWF _PFNf_str_nco, BANKED
3816:              //k=0;
3817:              //------
3818:              while(1)
89D2  D72F     BRA 0x8832
3819:              {
3820:                  CLRWDT();
8832  0004     CLRWDT
3821:                  PFNf_opgprg = 0;
8834  9A10     BCF PFNf_ofnserw, 5, ACCESS
3822:                  PFNf_opgres = 1;
8836  8C10     BSF PFNf_ofnserw, 6, ACCESS
3823:                  PFNf_ferr = 1;
8838  840E     BSF PFNf_lato, 2, ACCESS
3824:                  //BitSet2(&RSDT1.outSTAT0,_PGPRG,0);
3825:                  //BitSet2(&RSDT1.outSTAT0,_PGRES,1);		//znacznik petli wylaczenia awaryjnego
3826:                  //BitSet2(&RSDT1.outSTAT1,_ERR,1);
3827:          
3828:                  //ReceptDataLCD();
3829:                  //ClearDiode();			//wygaszenie diod roboczych
3830:                  //blok pomiarowy
3831:                  PomiarPCO(); //wartosc nastawy CO
883A  EC8A     CALL 0xC714, 0
883C  F063     NOP
3832:                  PomiarPCW(); //wartosc nastawy CW
883E  EC65     CALL 0xC8CA, 0
8840  F064     NOP
3833:                  PomiarPFN(); //stan przelacznika funkcji
8842  EC35     CALL 0xE26A, 0
8844  F071     NOP
3834:                  PomiarCO(); //wartosc temperatury CO
8846  EC03     CALL 0x3806, 0
8848  F01C     NOP
3835:                  PomiarCW(); //wartosc temperatury CW
884A  ECF5     CALL 0xA7EA, 0
884C  F053     NOP
3836:                  PomiarCS(); //wartosc cisnienia w instalacji CO
884E  EC88     CALL 0x8310, 0
8850  F041     NOP
3837:                  //blok decyzyjny
3838:                  Proba48(); //zegar 48h wybiegu pompy
8852  ECE9     CALL 0xE9D2, 0
8854  F074     NOP
3839:                  Proba48Z3(); //zegar 48h wybiegu pompy dla WU
8856  ECEE     CALL 0xDFDC, 0
8858  F06F     NOP
3840:                  //sygnalizacja stanu pracy dla modulu LCD
3841:                  RefInterfaceData();
885A  EC47     CALL 0xB08E, 0
885C  F058     NOP
3842:                  DecWSW();
885E  EC46     CALL 0x488C, 0
8860  F024     NOP
3843:                  //wybor obiegu
3844:                  switch(DtKNF.tpkt) //dla danego rodzaju kotla
8862  D08F     BRA 0x8982
8982  0100     MOVLB 0x0
8984  519E     MOVF _PWMf_ENPWM2, W, BANKED
8986  E0AB     BZ 0x88DE
8988  0A01     XORLW 0x1
898A  E101     BNZ 0x898E
898C  D76B     BRA 0x8864
898E  0A03     XORLW 0x3
8990  E101     BNZ 0x8994
8992  D768     BRA 0x8864
8994  0A01     XORLW 0x1
8996  E101     BNZ 0x899A
8998  D77C     BRA 0x8892
899A  D7D3     BRA 0x8942
3845:                  {
3846:                      case _BITERM: //bitermiczny (miniterm)
3847:                      case _BITERM2: //bitermiczny (maxiterm)
3848:                      {
3849:                          //zalaczenie/wylaczenie pompy
3850:                          if(!Mf_RUSZ_PWR && !Mf_ZMKCOCW && RdPrt(S_ON_PMP)) ToObiegCO(); //temperatura CO poza dozwolonym zakresem?
8864  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
8866  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8868  D007     BRA 0x8878
886A  0E0D     MOVLW 0xD
886C  ECFD     CALL 0xE7FA, 0
886E  F073     NOP
8870  E303     BNC 0x8878
8872  EC53     CALL 0xDEA6, 0
8874  F06F     NOP
8876  D008     BRA 0x8888
3851:                          else
3852:                              if(!Mf_ZMKCOCW && !Mf_WYLACZ && !Mf_RUSZ_48) ToObiegCW(); //nieaktywna pompa?
8878  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
887A  B80A     BTFSC Mf_pob_AL, 4, ACCESS
887C  D005     BRA 0x8888
887E  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
8880  D003     BRA 0x8888
8882  EC3E     CALL 0xC67C, 0
8884  F063     NOP
8886  D000     BRA 0x8888
3853:                          //aktywacja wybiegu
3854:                          if(!Mf_WYLACZ && _POMPA)
8888  A80A     BTFSS Mf_pob_AL, 4, ACCESS
888A  A483     BTFSS PORTD, 2, ACCESS
888C  D087     BRA 0x899C
3855:                          {
3856:                              Mf_WYLACZ = 1; //uaktywnij wybieg pompy							 									//uaktywnij procedure wybiegu pompy
888E  880A     BSF Mf_pob_AL, 4, ACCESS
3857:                          }
3858:                          break;
8890  D085     BRA 0x899C
3859:                      }
3860:                      case _MONOHB:
3861:                      {
3862:                          //wybor obiegu
3863:                          if(!Mf_ZMKCOCW && RdPrt(S_ON_PMP)) ToObiegCO(); //temperatura CO poza dozwolonym zakresem?
8892  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8894  D007     BRA 0x88A4
8896  0E0D     MOVLW 0xD
8898  ECFD     CALL 0xE7FA, 0
889A  F073     NOP
889C  E303     BNC 0x88A4
889E  EC53     CALL 0xDEA6, 0
88A0  F06F     NOP
88A2  D00C     BRA 0x88BC
3864:                          else
3865:                              if(!Mf_ZMKCOCW && !Mf_WYLACZ && !Mf_RUSZ_48 && (!_POMPA || Mf_RUSZ_48Z3)) ToObiegCW(); //nieaktywna pompa?
88A4  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
88A6  B80A     BTFSC Mf_pob_AL, 4, ACCESS
88A8  D009     BRA 0x88BC
88AA  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
88AC  D007     BRA 0x88BC
88AE  A483     BTFSS PORTD, 2, ACCESS
88B0  D002     BRA 0x88B6
88B2  AA08     BTFSS Mf_ROZRUCH, 5, ACCESS
88B4  D003     BRA 0x88BC
88B6  EC3E     CALL 0xC67C, 0
88B8  F063     NOP
88BA  D000     BRA 0x88BC
3866:                          //aktywacja wybiegu, zalaczenie pompy
3867:                          if(!Mf_RUSZ_PWR && !Mf_ZMKCOCW && !_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48 && !Mf_RUSZ_48Z3)
88BC  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
88BE  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
88C0  D06D     BRA 0x899C
88C2  A483     BTFSS PORTD, 2, ACCESS
88C4  B80A     BTFSC Mf_pob_AL, 4, ACCESS
88C6  D06A     BRA 0x899C
88C8  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
88CA  BA08     BTFSC Mf_ROZRUCH, 5, ACCESS
88CC  D067     BRA 0x899C
3868:                          {
3869:                              if(!Mf_RPM_CW && RdPrt(S_ON_PMP)) //temperatura CO/CW poza dozwolonym zakresem?
88CE  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
88D0  D065     BRA 0x899C
88D2  0E0D     MOVLW 0xD
88D4  ECFD     CALL 0xE7FA, 0
88D6  F073     NOP
88D8  E361     BNC 0x899C
88DA  D030     BRA 0x893C
3870:                              {
3871:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy							 									//uaktywnij procedure wybiegu pompy
3872:                                  _POMPA = 1; //zalacz pompe
3873:                              }
3874:                          }
3875:                          break;
88DC  D05F     BRA 0x899C
3876:                      }
3877:                      case _UNICO:
3878:                      {
3879:                          //wybor obiegu
3880:                          if(!Mf_ZMKCOCW && RdPrt(S_ON_PMP)) ToObiegCO(); //temperatura CO poza dozwolonym zakresem?
88DE  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
88E0  D007     BRA 0x88F0
88E2  0E0D     MOVLW 0xD
88E4  ECFD     CALL 0xE7FA, 0
88E6  F073     NOP
88E8  E303     BNC 0x88F0
88EA  EC53     CALL 0xDEA6, 0
88EC  F06F     NOP
88EE  D012     BRA 0x8914
3881:                          else
3882:                              if(!Mf_ZMKCOCW && RdPrt(S_DZ_CW)) ToObiegCW(); //temperatura dyzurna CW?
88F0  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
88F2  D007     BRA 0x8902
88F4  0E0A     MOVLW 0xA
88F6  ECFD     CALL 0xE7FA, 0
88F8  F073     NOP
88FA  E303     BNC 0x8902
88FC  EC3E     CALL 0xC67C, 0
88FE  F063     NOP
8900  D009     BRA 0x8914
3883:                          else
3884:                              if(!Mf_ZMKCOCW && !_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48) ToObiegCW(); //nieaktywna pompa?
8902  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
8904  B483     BTFSC PORTD, 2, ACCESS
8906  D006     BRA 0x8914
8908  A80A     BTFSS Mf_pob_AL, 4, ACCESS
890A  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
890C  D003     BRA 0x8914
890E  EC3E     CALL 0xC67C, 0
8910  F063     NOP
3885:                          //aktywacja wybiegu, zalaczenie pompy
3886:                          if(!Mf_RUSZ_PWR && !Mf_ZMKCOCW && !_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48)
8912  D000     BRA 0x8914
8914  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
8916  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8918  D041     BRA 0x899C
891A  A483     BTFSS PORTD, 2, ACCESS
891C  B80A     BTFSC Mf_pob_AL, 4, ACCESS
891E  D03E     BRA 0x899C
8920  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
8922  D03C     BRA 0x899C
3887:                          {
3888:                              if((!Mf_RPM_CW && RdPrt(S_ON_PMP)) || (Mf_RPM_CW && RdPrt(S_DZ_CW))) //temperatura CO/CW poza dozwolonym zakresem?
8924  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
8926  D004     BRA 0x8930
8928  0E0D     MOVLW 0xD
892A  ECFD     CALL 0xE7FA, 0
892C  F073     NOP
892E  E206     BC 0x893C
8930  A208     BTFSS Mf_ROZRUCH, 1, ACCESS
8932  D034     BRA 0x899C
8934  0E0A     MOVLW 0xA
8936  ECFD     CALL 0xE7FA, 0
8938  F073     NOP
893A  D7CE     BRA 0x88D8
3889:                              {
3890:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy							 									//uaktywnij procedure wybiegu pompy
893C  880A     BSF Mf_pob_AL, 4, ACCESS
3891:                                  _POMPA = 1; //zalacz pompe
893E  8483     BSF PORTD, 2, ACCESS
3892:                              }
3893:                          }
3894:                          break;
8940  D02D     BRA 0x899C
3895:                      }
3896:                      default: //domyslny monotermiczny
3897:                      {
3898:                          //wybor obiegu
3899:                          if(!Mf_ZMKCOCW && RdPrt(S_ON_PMP)) ToObiegCO(); //temperatura CO poza dozwolonym zakresem?
8942  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
8944  D007     BRA 0x8954
8946  0E0D     MOVLW 0xD
8948  ECFD     CALL 0xE7FA, 0
894A  F073     NOP
894C  E303     BNC 0x8954
894E  EC53     CALL 0xDEA6, 0
8950  F06F     NOP
8952  D009     BRA 0x8966
3900:                          else
3901:                              if(!Mf_ZMKCOCW && !_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48) ToObiegCW(); //nieaktywna pompa?
8954  AA0A     BTFSS Mf_pob_AL, 5, ACCESS
8956  B483     BTFSC PORTD, 2, ACCESS
8958  D006     BRA 0x8966
895A  A80A     BTFSS Mf_pob_AL, 4, ACCESS
895C  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
895E  D003     BRA 0x8966
8960  EC3E     CALL 0xC67C, 0
8962  F063     NOP
8964  D000     BRA 0x8966
3902:                          //aktywacja wybiegu, zalaczenie pompy
3903:                          if(!Mf_RUSZ_PWR && !Mf_ZMKCOCW && !_POMPA && !Mf_WYLACZ && !Mf_RUSZ_48)
8966  AE09     BTFSS Mf_RUSZ_PWR, 7, ACCESS
8968  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
896A  D018     BRA 0x899C
896C  A483     BTFSS PORTD, 2, ACCESS
896E  B80A     BTFSC Mf_pob_AL, 4, ACCESS
8970  D015     BRA 0x899C
8972  A808     BTFSS Mf_ROZRUCH, 4, ACCESS
3904:                          {
3905:                              if(!Mf_RPM_CW && RdPrt(S_ON_PMP)) //temperatura CO/CW poza dozwolonym zakresem?
8974  B208     BTFSC Mf_ROZRUCH, 1, ACCESS
8976  D012     BRA 0x899C
8978  0E0D     MOVLW 0xD
897A  ECFD     CALL 0xE7FA, 0
897C  F073     NOP
897E  D7AC     BRA 0x88D8
3906:                              {
3907:                                  Mf_WYLACZ = 1; //uaktywnij wybieg pompy							 									//uaktywnij procedure wybiegu pompy
3908:                                  _POMPA = 1; //zalacz pompe
3909:                              }
3910:                          }
3911:                          break;
3912:                      }
3913:                  }
8980  D00D     BRA 0x899C
3914:                  //blok wykonawczy
3915:                  if(Mf_ZMKCOCW) ZmienKCOKCW(); //zmiana kierunku obrotu pompy
899C  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
899E  ECA4     CALL 0xA948, 0
89A0  F054     NOP
89A2  D000     BRA 0x89A4
3916:                  if(Mf_WYLACZ) Wylacz(); //kontrola wybiegu pompy
89A4  B80A     BTFSC Mf_pob_AL, 4, ACCESS
89A6  EC51     CALL 0x64A2, 0
89A8  F032     NOP
89AA  D000     BRA 0x89AC
3917:                  if(Mf_VWYBIEG) VWybieg(); //wybieg wentylatora
89AC  B60A     BTFSC Mf_pob_AL, 3, ACCESS
89AE  EC7C     CALL 0xCEF8, 0
89B0  F067     NOP
89B2  D000     BRA 0x89B4
3918:                  if(Mf_RUSZ_48) Rusz48(); //wybieg pompy co 48h
89B4  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
89B6  EC6C     CALL 0xB2D8, 0
89B8  F059     NOP
89BA  D000     BRA 0x89BC
3919:                  if(Mf_RUSZ_48Z3) Rusz48Z3(); //wybieg pompy co 48h w obiegu WU
89BC  BA08     BTFSC Mf_ROZRUCH, 5, ACCESS
89BE  ECA1     CALL 0xD942, 0
89C0  F06C     NOP
3920:          
3921:                  //obsluga przycisku RESET
3922:                  if(KeyRes())
89C2  ECB2     CALL 0xDD64, 0
89C4  F06E     NOP
89C6  E201     BC 0x89CA
89C8  D734     BRA 0x8832
3923:                  {
3924:                      _VNT = 0;
89CA  9683     BCF PORTD, 3, ACCESS
3925:                      _POMPA = 0;
89CC  9483     BCF PORTD, 2, ACCESS
3926:                      ToReset();
89CE  ECFD     CALL 0xEDFA, 0
89D0  F076     NOP
3927:                  }
3928:              }
3929:          }
89D4  0012     RETURN 0
3930:          //Wymuszenie resetu sterownika.
3931:          
3932:          void ToReset(void)
3933:          {
3934:              _VNT = 0;
EDFA  9683     BCF PORTD, 3, ACCESS
3935:              _POMPA = 0;
EDFC  9483     BCF PORTD, 2, ACCESS
3936:              ClsScr();
EDFE  EC0C     CALL 0xF418, 0
EE00  F07A     NOP
3937:              EndErr();
EE02  EC43     CALL 0xF286, 0
EE04  F079     NOP
3938:              PFNf_opgprg = 0;
EE06  9A10     BCF PFNf_ofnserw, 5, ACCESS
3939:              PFNf_opgres = 0;
EE08  9C10     BCF PFNf_ofnserw, 6, ACCESS
3940:              eeprom_write(_ADRERR, 0x00);
EE0A  ECFE     CALL 0xF3FC, 0
EE0C  F079     NOP
EE0E  0100     MOVLB 0x0
EE10  6BDF     CLRF pco, BANKED
EE12  0EC0     MOVLW 0xC0
EE14  6FDE     MOVWF __pcstackBANK0, BANKED
EE16  6BE0     CLRF bdat, BANKED
EE18  EC58     CALL 0xE2B0, 0
EE1A  F071     NOP
3941:              while(1);
EE1C  D7FF     BRA 0xEE1C
3942:          }
EE1E  0012     RETURN 0
3943:          //------------------
3944:          //------------------
3945:          
3946:          void InitGlobal(void)
3947:          {
3948:              //RCON
3949:              IPEN = 1; //enable priority levels
F3DC  8ED0     BSF RCON, 7, ACCESS
3950:              //INTCON
3951:              GIEH = 1; //enable oll un-masked interrupts
F3DE  8EF2     BSF INTCON, 7, ACCESS
3952:              GIEL = 1; //enable oll un-masked interrupts
F3E0  8CF2     BSF INTCON, 6, ACCESS
3953:          }
F3E2  0012     RETURN 0
3954:          
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/konsola.c  -------------------------------
1:             /*konsola.c*/
2:             //Funkcje obslugi przycisków p³ytki interfejsu
3:             // (!) Bazuje na funkcjach z plikow: rtimer.c
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"			//parametry globalne
7:             #include "konsola.h"			//parametry lokalne
8:             #include "main.tp.h"
9:             #include "print.h"
10:            
11:            //extern unsigned char x,y;
12:            /*---------------------------------------------------------------------------------*/
13:            extern tpMAIN M;
14:            extern DataPFN PFN;
15:            //extern tpRSDTA1 RSDT1;
16:            
17:            #if _SRVTRB==1						//aktywny tryb serwisowy kompilacji?
18:            unsigned char mypwm = _MG2_MOD;
19:            #endif
20:            extern StPin xxky[];
21:            extern StPin ky[];
22:            
23:            
24:            //Zapis nastawy PCW po ustalonym czasie do EEPROM
25:            /*void WriteParam(unsigned char *zapis)
26:            {
27:                            if(*zapis&&RTdS(_RTPCW)>=_TWRTPCW)
28:                            {
29:             *zapis=0;
30:                                    StartRTdS(_RTPCW);
31:                                    //WriteEEPCW();
32:                            }
33:            }*/
34:            /*---------------------------------------------------------------------------------*/
35:            //Inkrementacja/Dekrementacja parametru
36:            //gdzie:
37:            //param- adres modyfikowanego parametru (16bit)
38:            //zmiana - znacznik ze wartosc parametru ulegla zmianie (0- brak zmianay, 1 - tylko podglad min/max, 2 - wartosc zmniejszona, 3 - wartosc zwiekszona)
39:            //zapis - znacznik sugestji/aktywacji zapisu parametru do pamieci
40:            //min- minimalna wartosc jaka moze przyjac parametr
41:            //max- maksymalna wartosc jaka moze przyjac parametr
42:            //rckl - po osiagnieciu max+1 nastepuje przeladowanie wartoscia min i odwrotnie po osiagnieciu min-1 nastepuje przeladowanie wartoscia max
43:            //fst - aktywacja funkcji przyspieszajacej inkrementacji/dekrementacji
44:            
45:            void ReadParam(volatile unsigned int *param, unsigned char *zmiana, unsigned char *zapis, unsigned int min, unsigned int max, unsigned char rckl, unsigned char fst)
46:            {
47:                volatile static unsigned char pnst;
48:                volatile unsigned char stp, ovi, ovd;
49:            
50:                ovi = 0;
7674  0103     MOVLB 0x3
7676  6B84     CLRF _PFNf_opKNF, BANKED
51:                ovd = 0;
7678  6B85     CLRF _PFNf_opgprg, BANKED
52:                if(*param < min) *param = min;
767A  C375     MOVFF __pcstackBANK3, FSR2
767C  FFD9     NOP
767E  C376     MOVFF k, FSR2H
7680  FFDA     NOP
7682  0103     MOVLB 0x3
7684  517B     MOVF _PFNf_newPFN, W, BANKED
7686  5CDE     SUBWF POSTINC2, W, ACCESS
7688  517C     MOVF _PFNf_oaleg, W, BANKED
768A  58DE     SUBWFB POSTINC2, W, ACCESS
768C  E209     BC 0x76A0
768E  C375     MOVFF __pcstackBANK3, FSR2
7690  FFD9     NOP
7692  C376     MOVFF k, FSR2H
7694  FFDA     NOP
7696  C37B     MOVFF min, POSTINC2
7698  FFDE     NOP
769A  C37C     MOVFF 0x37C, POSTDEC2
769C  FFDD     NOP
769E  D000     BRA 0x76A0
53:                if(*param > max) *param = max;
76A0  C375     MOVFF __pcstackBANK3, FSR2
76A2  FFD9     NOP
76A4  C376     MOVFF k, FSR2H
76A6  FFDA     NOP
76A8  50DE     MOVF POSTINC2, W, ACCESS
76AA  0103     MOVLB 0x3
76AC  5D7D     SUBWF _PFNf_obgCO, W, BANKED
76AE  50DE     MOVF POSTINC2, W, ACCESS
76B0  597E     SUBWFB _PFNf_obgCW, W, BANKED
76B2  E209     BC 0x76C6
76B4  C375     MOVFF __pcstackBANK3, FSR2
76B6  FFD9     NOP
76B8  C376     MOVFF k, FSR2H
76BA  FFDA     NOP
76BC  C37D     MOVFF max, POSTINC2
76BE  FFDE     NOP
76C0  C37E     MOVFF p, POSTDEC2
76C2  FFDD     NOP
76C4  D000     BRA 0x76C6
54:                if((max - min) > 99) stp = 5;
76C6  C37B     MOVFF min, __pcstackBANK2
76C8  F2FA     NOP
76CA  C37C     MOVFF 0x37C, min
76CC  F2FB     NOP
76CE  0102     MOVLB 0x2
76D0  1FFA     COMF pco, F, BANKED
76D2  1FFB     COMF d, F, BANKED
76D4  4BFA     INFSNZ pco, F, BANKED
76D6  2BFB     INCF d, F, BANKED
76D8  0103     MOVLB 0x3
76DA  517D     MOVF _PFNf_obgCO, W, BANKED
76DC  0102     MOVLB 0x2
76DE  27FA     ADDWF pco, F, BANKED
76E0  0103     MOVLB 0x3
76E2  517E     MOVF _PFNf_obgCW, W, BANKED
76E4  0102     MOVLB 0x2
76E6  23FB     ADDWFC d, F, BANKED
76E8  51FB     MOVF d, W, BANKED
76EA  E103     BNZ 0x76F2
76EC  0E64     MOVLW 0x64
76EE  5DFA     SUBWF pco, W, BANKED
76F0  E302     BNC 0x76F6
76F2  0E05     MOVLW 0x5
76F4  D001     BRA 0x76F8
55:                else stp = 1;
76F6  0E01     MOVLW 0x1
76F8  0103     MOVLB 0x3
76FA  6F83     MOVWF _PFNf_ofzima, BANKED
76FC  D000     BRA 0x76FE
56:                if(!(RdPrt(S_KDW) && RdPrt(S_KUP))) //nie nacisnieto jednoczesnie obu przyciskow?
76FE  0E19     MOVLW 0x19
7700  ECFD     CALL 0xE7FA, 0
7702  F073     NOP
7704  E305     BNC 0x7710
7706  0E18     MOVLW 0x18
7708  ECFD     CALL 0xE7FA, 0
770A  F073     NOP
770C  E301     BNC 0x7710
770E  D104     BRA 0x7918
57:                {
58:                    if(!RdPrt(S_KDW))
7710  0E19     MOVLW 0x19
7712  ECFD     CALL 0xE7FA, 0
7714  F073     NOP
7716  E24C     BC 0x77B0
59:                    {
60:                        ReadDataXONLID(RdPrt(S_KUP), &xxky[SS_KUP], param, &ovi, 1, min, max, 1, stp, fst);
7718  0E5C     MOVLW 0x5C
771A  0100     MOVLB 0x0
771C  6FEC     MOVWF dt, BANKED
771E  0E03     MOVLW 0x3
7720  6FED     MOVWF min, BANKED
7722  C375     MOVFF __pcstackBANK3, dt
7724  F0EE     NOP
7726  C376     MOVFF k, 0xEF
7728  F0EF     NOP
772A  0E84     MOVLW 0x84
772C  6FF0     MOVWF p, BANKED
772E  0E03     MOVLW 0x3
7730  6FF1     MOVWF m, BANKED
7732  0E01     MOVLW 0x1
7734  6FF2     MOVWF tid, BANKED
7736  C37B     MOVFF min, min
7738  F0F3     NOP
773A  C37C     MOVFF 0x37C, pco
773C  F0F4     NOP
773E  C37D     MOVFF max, max
7740  F0F5     NOP
7742  C37E     MOVFF p, ehi
7744  F0F6     NOP
7746  6FF7     MOVWF step, BANKED
7748  C383     MOVFF stp, step2
774A  F0F8     NOP
774C  C380     MOVFF pdw, fst
774E  F0F9     NOP
7750  0E18     MOVLW 0x18
7752  ECFD     CALL 0xE7FA, 0
7754  F073     NOP
7756  0E01     MOVLW 0x1
7758  A0D8     BTFSS STATUS, 0, ACCESS
775A  0E00     MOVLW 0x0
775C  ECD1     CALL 0x33A2, 0
775E  F019     NOP
61:                        if(rckl && ovi) *param = min;
7760  0103     MOVLB 0x3
7762  517F     MOVF _PFNf_off, W, BANKED
7764  E00B     BZ 0x777C
7766  5184     MOVF _PFNf_opKNF, W, BANKED
7768  E009     BZ 0x777C
776A  C375     MOVFF __pcstackBANK3, FSR2
776C  FFD9     NOP
776E  C376     MOVFF k, FSR2H
7770  FFDA     NOP
7772  C37B     MOVFF min, POSTINC2
7774  FFDE     NOP
7776  C37C     MOVFF 0x37C, POSTDEC2
7778  FFDD     NOP
777A  D000     BRA 0x777C
62:                        if(!rckl && RdPrt(S_KUP) && (*param == max)) *zmiana = 1; //wymuszony wskaz nastawy dla maksimum
777C  0103     MOVLB 0x3
777E  517F     MOVF _PFNf_off, W, BANKED
7780  E15F     BNZ 0x7840
7782  0E18     MOVLW 0x18
7784  ECFD     CALL 0xE7FA, 0
7786  F073     NOP
7788  E35B     BNC 0x7840
778A  C375     MOVFF __pcstackBANK3, FSR2
778C  FFD9     NOP
778E  C376     MOVFF k, FSR2H
7790  FFDA     NOP
7792  0103     MOVLB 0x3
7794  517D     MOVF _PFNf_obgCO, W, BANKED
7796  18DE     XORWF POSTINC2, W, ACCESS
7798  E153     BNZ 0x7840
779A  517E     MOVF _PFNf_obgCW, W, BANKED
779C  18DE     XORWF POSTINC2, W, ACCESS
779E  A4D8     BTFSS STATUS, 2, ACCESS
77A0  D04F     BRA 0x7840
77A2  C377     MOVFF zmiana, FSR2
77A4  FFD9     NOP
77A6  C378     MOVFF 0x378, FSR2H
77A8  FFDA     NOP
77AA  0E01     MOVLW 0x1
77AC  6EDF     MOVWF INDF2, ACCESS
63:                    }
77AE  D048     BRA 0x7840
64:                    else
65:                        if(!RdPrt(S_KUP))
77B0  0E18     MOVLW 0x18
77B2  ECFD     CALL 0xE7FA, 0
77B4  F073     NOP
77B6  E244     BC 0x7840
66:                    {
67:                        ReadDataXONLID(RdPrt(S_KDW), &xxky[SS_KDW], param, &ovd, 0, min, max, 1, stp, fst);
77B8  0E61     MOVLW 0x61
77BA  0100     MOVLB 0x0
77BC  6FEC     MOVWF dt, BANKED
77BE  0E03     MOVLW 0x3
77C0  6FED     MOVWF min, BANKED
77C2  C375     MOVFF __pcstackBANK3, dt
77C4  F0EE     NOP
77C6  C376     MOVFF k, 0xEF
77C8  F0EF     NOP
77CA  0E85     MOVLW 0x85
77CC  6FF0     MOVWF p, BANKED
77CE  0E03     MOVLW 0x3
77D0  6FF1     MOVWF m, BANKED
77D2  6BF2     CLRF tid, BANKED
77D4  C37B     MOVFF min, min
77D6  F0F3     NOP
77D8  C37C     MOVFF 0x37C, pco
77DA  F0F4     NOP
77DC  C37D     MOVFF max, max
77DE  F0F5     NOP
77E0  C37E     MOVFF p, ehi
77E2  F0F6     NOP
77E4  0E01     MOVLW 0x1
77E6  6FF7     MOVWF step, BANKED
77E8  C383     MOVFF stp, step2
77EA  F0F8     NOP
77EC  C380     MOVFF pdw, fst
77EE  F0F9     NOP
77F0  0E19     MOVLW 0x19
77F2  ECFD     CALL 0xE7FA, 0
77F4  F073     NOP
77F6  0E01     MOVLW 0x1
77F8  A0D8     BTFSS STATUS, 0, ACCESS
77FA  0E00     MOVLW 0x0
77FC  ECD1     CALL 0x33A2, 0
77FE  F019     NOP
68:                        if(rckl && ovd) *param = max;
7800  0103     MOVLB 0x3
7802  517F     MOVF _PFNf_off, W, BANKED
7804  E00B     BZ 0x781C
7806  5185     MOVF _PFNf_opgprg, W, BANKED
7808  E009     BZ 0x781C
780A  C375     MOVFF __pcstackBANK3, FSR2
780C  FFD9     NOP
780E  C376     MOVFF k, FSR2H
7810  FFDA     NOP
7812  C37D     MOVFF max, POSTINC2
7814  FFDE     NOP
7816  C37E     MOVFF p, POSTDEC2
7818  FFDD     NOP
781A  D000     BRA 0x781C
69:                        if(!rckl && RdPrt(S_KDW) && (*param == min)) *zmiana = 1; //wymuszony wskaz nastawy dla minimum
781C  0103     MOVLB 0x3
781E  517F     MOVF _PFNf_off, W, BANKED
7820  E10F     BNZ 0x7840
7822  0E19     MOVLW 0x19
7824  ECFD     CALL 0xE7FA, 0
7826  F073     NOP
7828  E30B     BNC 0x7840
782A  C375     MOVFF __pcstackBANK3, FSR2
782C  FFD9     NOP
782E  C376     MOVFF k, FSR2H
7830  FFDA     NOP
7832  0103     MOVLB 0x3
7834  517B     MOVF _PFNf_newPFN, W, BANKED
7836  18DE     XORWF POSTINC2, W, ACCESS
7838  E103     BNZ 0x7840
783A  517C     MOVF _PFNf_oaleg, W, BANKED
783C  D7AF     BRA 0x779C
70:                    }
783E  D000     BRA 0x7840
71:                    if(!RdPrt(S_KDW) && !RdPrt(S_KUP)) //oba przyciski wycisniete
7840  0E19     MOVLW 0x19
7842  ECFD     CALL 0xE7FA, 0
7844  F073     NOP
7846  E212     BC 0x786C
7848  0E18     MOVLW 0x18
784A  ECFD     CALL 0xE7FA, 0
784C  F073     NOP
784E  E20E     BC 0x786C
72:                    {
73:                        if(RTdS(_RTPCW) > _TFLPCW) *zmiana = 0; //podtrzymanie stanu znacznika modyfikacji przez czas _TWRTPCW-1
7850  0E06     MOVLW 0x6
7852  ECD7     CALL 0xEBAE, 0
7854  F075     NOP
7856  0102     MOVLB 0x2
7858  6FFA     MOVWF pco, BANKED
785A  0E05     MOVLW 0x5
785C  65FA     CPFSGT pco, BANKED
785E  D006     BRA 0x786C
7860  C377     MOVFF zmiana, FSR2
7862  FFD9     NOP
7864  C378     MOVFF 0x378, FSR2H
7866  FFDA     NOP
7868  6ADF     CLRF INDF2, ACCESS
786A  D000     BRA 0x786C
74:                    }
75:            
76:                    if(*param != pnst) //nastapila zmiana nastawy?
786C  C375     MOVFF __pcstackBANK3, FSR2
786E  FFD9     NOP
7870  C376     MOVFF k, FSR2H
7872  FFDA     NOP
7874  0101     MOVLB 0x1
7876  5174     MOVF _PFNf_fnoCS, W, BANKED
7878  0102     MOVLB 0x2
787A  6FFC     MOVWF 0xFC, BANKED
787C  6BFD     CLRF 0xFD, BANKED
787E  50DE     MOVF POSTINC2, W, ACCESS
7880  19FC     XORWF 0xFC, W, BANKED
7882  E104     BNZ 0x788C
7884  50DE     MOVF POSTINC2, W, ACCESS
7886  19FD     XORWF 0xFD, W, BANKED
7888  B4D8     BTFSC STATUS, 2, ACCESS
788A  0012     RETURN 0
77:                    {
78:                        if(rckl && ovi) *zmiana = 3;
788C  0103     MOVLB 0x3
788E  517F     MOVF _PFNf_off, W, BANKED
7890  E008     BZ 0x78A2
7892  5184     MOVF _PFNf_opKNF, W, BANKED
7894  E006     BZ 0x78A2
7896  C377     MOVFF zmiana, FSR2
7898  FFD9     NOP
789A  C378     MOVFF 0x378, FSR2H
789C  FFDA     NOP
789E  0E03     MOVLW 0x3
78A0  D00A     BRA 0x78B6
79:                        else
80:                            if(rckl && ovd) *zmiana = 2;
78A2  0103     MOVLB 0x3
78A4  517F     MOVF _PFNf_off, W, BANKED
78A6  E009     BZ 0x78BA
78A8  5185     MOVF _PFNf_opgprg, W, BANKED
78AA  E007     BZ 0x78BA
78AC  C377     MOVFF zmiana, FSR2
78AE  FFD9     NOP
78B0  C378     MOVFF 0x378, FSR2H
78B2  FFDA     NOP
78B4  0E02     MOVLW 0x2
78B6  6EDF     MOVWF INDF2, ACCESS
78B8  D01E     BRA 0x78F6
81:                        else *zmiana = (pnst<*param) ? 3 : 2; //znacznik zmiany nastawy
78BA  C375     MOVFF __pcstackBANK3, FSR2
78BC  FFD9     NOP
78BE  C376     MOVFF k, FSR2H
78C0  FFDA     NOP
78C2  0101     MOVLB 0x1
78C4  5174     MOVF _PFNf_fnoCS, W, BANKED
78C6  0102     MOVLB 0x2
78C8  6FFC     MOVWF 0xFC, BANKED
78CA  6BFD     CLRF 0xFD, BANKED
78CC  50DE     MOVF POSTINC2, W, ACCESS
78CE  5DFC     SUBWF 0xFC, W, BANKED
78D0  50DE     MOVF POSTINC2, W, ACCESS
78D2  59FD     SUBWFB 0xFD, W, BANKED
78D4  E304     BNC 0x78DE
78D6  0103     MOVLB 0x3
78D8  6B82     CLRF M, BANKED
78DA  0E02     MOVLW 0x2
78DC  D003     BRA 0x78E4
78DE  0103     MOVLB 0x3
78E0  6B82     CLRF M, BANKED
78E2  0E03     MOVLW 0x3
78E4  6F81     MOVWF _PFNf_ofnserw, BANKED
78E6  D000     BRA 0x78E8
78E8  C377     MOVFF zmiana, FSR2
78EA  FFD9     NOP
78EC  C378     MOVFF 0x378, FSR2H
78EE  FFDA     NOP
78F0  C381     MOVFF pup, INDF2
78F2  FFDF     NOP
78F4  D000     BRA 0x78F6
82:                        pnst = *param;
78F6  C375     MOVFF __pcstackBANK3, FSR2
78F8  FFD9     NOP
78FA  C376     MOVFF k, FSR2H
78FC  FFDA     NOP
78FE  50DF     MOVF INDF2, W, ACCESS
7900  0101     MOVLB 0x1
7902  6F74     MOVWF _PFNf_fnoCS, BANKED
83:                        StartRTdS(_RTPCW); //zegar podtrzymania znacznika modyfikacji nastawy
7904  0E06     MOVLW 0x6
7906  ECA0     CALL 0xE540, 0
7908  F072     NOP
84:                        *zapis = 1; //sugestia zapisu dla nowej nastawy (uwaga po zapisie nalezy wyzerowac)
790A  C379     MOVFF zapis, FSR2
790C  FFD9     NOP
790E  C37A     MOVFF 0x37A, FSR2H
7910  FFDA     NOP
7912  0E01     MOVLW 0x1
7914  6EDF     MOVWF INDF2, ACCESS
85:                    }
86:                }
7916  0012     RETURN 0
87:                else *zmiana = 0; //nacisnieto dwa przyciski jednoczesnie
7918  C377     MOVFF zmiana, FSR2
791A  FFD9     NOP
791C  C378     MOVFF 0x378, FSR2H
791E  FFDA     NOP
7920  0E00     MOVLW 0x0
7922  6EDF     MOVWF INDF2, ACCESS
7924  0C00     RETLW 0x0
88:            }
7926  0012     RETURN 0
89:            
90:            /*---------------------------------------------------------------------------------*/
91:            void TrybPracy(void)
92:            {
93:                //static bit bf_oaleg;
94:                volatile unsigned char key, key2, ExtR, ExtR2, tm;
95:            
96:                if(!PFNf_aktywne_KNF && !PFNf_opgres)
2382  A40C     BTFSS PFNf_b_set_nco, 2, ACCESS
2384  BC10     BTFSC PFNf_ofnserw, 6, ACCESS
2386  D2F8     BRA 0x2978
97:                {
98:                    //--------------------------PRZELACZNIK FUNKCJI------------------------------
99:                    //przytrzymano przycisk RESET (wylaczenie/zalaczenie sterownika)
100:                   if(!RdPrt(S_SET))
2388  0E17     MOVLW 0x17
238A  ECFD     CALL 0xE7FA, 0
238C  F073     NOP
238E  E23C     BC 0x2408
101:                   {
102:                       key = PresKeyEX(RdPrt(S_OFF), &ky[SS_OFF]);
2390  0EA6     MOVLW 0xA6
2392  0100     MOVLB 0x0
2394  6FE0     MOVWF bdat, BANKED
2396  0E01     MOVLW 0x1
2398  6FE1     MOVWF GIE_BIT_VAL, BANKED
239A  0E16     MOVLW 0x16
239C  ECFD     CALL 0xE7FA, 0
239E  F073     NOP
23A0  0E01     MOVLW 0x1
23A2  A0D8     BTFSS STATUS, 0, ACCESS
23A4  0E00     MOVLW 0x0
23A6  ECAB     CALL 0x8556, 0
23A8  F042     NOP
23AA  0100     MOVLB 0x0
23AC  6FED     MOVWF min, BANKED
103:                       if(key != _KDFST && key >= _TKOFF)
23AE  0E64     MOVLW 0x64
23B0  0100     MOVLB 0x0
23B2  19ED     XORWF min, W, BANKED
23B4  E029     BZ 0x2408
23B6  0E0F     MOVLW 0xF
23B8  65ED     CPFSGT min, BANKED
23BA  D026     BRA 0x2408
104:                       {
105:                           WaitToLowEx(&ky[SS_OFF]);
23BC  0EA6     MOVLW 0xA6
23BE  6FDE     MOVWF __pcstackBANK0, BANKED
23C0  0E01     MOVLW 0x1
23C2  6FDF     MOVWF pco, BANKED
23C4  EC10     CALL 0xEE20, 0
23C6  F077     NOP
106:                           PFNf_off = !PFNf_off;
23C8  7E0F     BTG PFNf_off, 7, ACCESS
107:                           PFNf_set_nco = 0;
23CA  9612     BCF PFNf_str_nco, 3, ACCESS
108:                           PFNf_set_ncw = 0;
23CC  9812     BCF PFNf_str_nco, 4, ACCESS
109:                           PFNf_str_nco = 0;
23CE  9A12     BCF PFNf_str_nco, 5, ACCESS
110:                           PFNf_str_ncw = 0;
23D0  9C12     BCF PFNf_str_nco, 6, ACCESS
111:                           PFNf_prn_res = 0;
23D2  9A11     BCF PFNf_prn_res, 5, ACCESS
112:                           PFNf_set_fnserw = 0;
23D4  9412     BCF PFNf_str_nco, 2, ACCESS
113:                           PFNf_fnserw = 0;
23D6  9C0E     BCF PFNf_lato, 6, ACCESS
114:                           PFNf_set_aleg = 0;
23D8  9212     BCF PFNf_str_nco, 1, ACCESS
115:                           PFNf_aleg = 0;
23DA  960C     BCF PFNf_b_set_nco, 3, ACCESS
116:                           ResBufKeyEx(&ky[SS_KUP]);
23DC  0EB0     MOVLW 0xB0
23DE  0100     MOVLB 0x0
23E0  6FDE     MOVWF __pcstackBANK0, BANKED
23E2  0E01     MOVLW 0x1
23E4  6FDF     MOVWF pco, BANKED
23E6  EC7B     CALL 0xEAF6, 0
23E8  F075     NOP
117:                           ResBufKeyEx(&ky[SS_KDW]);
23EA  0EB5     MOVLW 0xB5
23EC  0100     MOVLB 0x0
23EE  6FDE     MOVWF __pcstackBANK0, BANKED
23F0  0E01     MOVLW 0x1
23F2  6FDF     MOVWF pco, BANKED
23F4  EC7B     CALL 0xEAF6, 0
23F6  F075     NOP
118:                           ResBufKeyEx(&ky[SS_SET]);
23F8  0EAB     MOVLW 0xAB
23FA  0100     MOVLB 0x0
23FC  6FDE     MOVWF __pcstackBANK0, BANKED
23FE  0E01     MOVLW 0x1
2400  6FDF     MOVWF pco, BANKED
2402  EC7B     CALL 0xEAF6, 0
2404  F075     NOP
119:                       }
2406  D000     BRA 0x2408
120:                   }
121:                   //---------------------
122:                   if(!PFNf_off && !PFNf_lato && !PFNf_zima) //stan nieustalony?
2408  AE0F     BTFSS PFNf_off, 7, ACCESS
240A  BE0E     BTFSC PFNf_lato, 7, ACCESS
240C  D005     BRA 0x2418
240E  B613     BTFSC PFNf_zima, 3, ACCESS
2410  D003     BRA 0x2418
123:                   {
124:                       PFNf_lato = 0;
2412  9E0E     BCF PFNf_lato, 7, ACCESS
125:                       PFNf_zima = 1;
2414  8613     BSF PFNf_zima, 3, ACCESS
2416  D000     BRA 0x2418
126:                   }
127:                   //przytrzymano przycisk SET (zmiana trybu pracy)
128:                   if(!RdPrt(S_OFF) && !RdPrt(S_KUP) && !RdPrt(S_KDW) && !PFNf_off && !PFNf_fnserw && !PFNf_aleg)
2418  0E16     MOVLW 0x16
241A  ECFD     CALL 0xE7FA, 0
241C  F073     NOP
241E  E235     BC 0x248A
2420  0E18     MOVLW 0x18
2422  ECFD     CALL 0xE7FA, 0
2424  F073     NOP
2426  E231     BC 0x248A
2428  0E19     MOVLW 0x19
242A  ECFD     CALL 0xE7FA, 0
242C  F073     NOP
242E  A0D8     BTFSS STATUS, 0, ACCESS
2430  BE0F     BTFSC PFNf_off, 7, ACCESS
2432  D02B     BRA 0x248A
2434  AC0E     BTFSS PFNf_lato, 6, ACCESS
2436  B60C     BTFSC PFNf_b_set_nco, 3, ACCESS
2438  D028     BRA 0x248A
129:                   {
130:                       key = PresKeyEX(RdPrt(S_SET), &ky[SS_SET]);
243A  0EAB     MOVLW 0xAB
243C  0100     MOVLB 0x0
243E  6FE0     MOVWF bdat, BANKED
2440  0E01     MOVLW 0x1
2442  6FE1     MOVWF GIE_BIT_VAL, BANKED
2444  0E17     MOVLW 0x17
2446  ECFD     CALL 0xE7FA, 0
2448  F073     NOP
244A  0E01     MOVLW 0x1
244C  A0D8     BTFSS STATUS, 0, ACCESS
244E  0E00     MOVLW 0x0
2450  ECAB     CALL 0x8556, 0
2452  F042     NOP
2454  0100     MOVLB 0x0
2456  6FED     MOVWF min, BANKED
131:                       if(key != _KDFST && key >= _TKSET)
2458  0E64     MOVLW 0x64
245A  0100     MOVLB 0x0
245C  19ED     XORWF min, W, BANKED
245E  E015     BZ 0x248A
2460  0E07     MOVLW 0x7
2462  65ED     CPFSGT min, BANKED
2464  D012     BRA 0x248A
132:                       {
133:                           WaitToLowEx(&ky[SS_SET]);
2466  0EAB     MOVLW 0xAB
2468  6FDE     MOVWF __pcstackBANK0, BANKED
246A  0E01     MOVLW 0x1
246C  6FDF     MOVWF pco, BANKED
246E  EC10     CALL 0xEE20, 0
2470  F077     NOP
134:                           PFNf_lato = !PFNf_lato;
2472  7E0E     BTG PFNf_lato, 7, ACCESS
135:                           PFNf_zima = !PFNf_lato;
2474  BE0E     BTFSC PFNf_lato, 7, ACCESS
2476  D002     BRA 0x247C
2478  8613     BSF PFNf_zima, 3, ACCESS
247A  D001     BRA 0x247E
247C  9613     BCF PFNf_zima, 3, ACCESS
136:                           PFNf_set_nco = 0;
247E  9612     BCF PFNf_str_nco, 3, ACCESS
137:                           PFNf_set_ncw = 0;
2480  9812     BCF PFNf_str_nco, 4, ACCESS
138:                           PFNf_fnserw = 0; //przerwanie funkcji serwisowej
2482  9C0E     BCF PFNf_lato, 6, ACCESS
139:                           PFNf_aleg = 0; //przerwanie funkcji antylegionella
2484  960C     BCF PFNf_b_set_nco, 3, ACCESS
140:                           PFNf_prn_res = 0;
2486  9A11     BCF PFNf_prn_res, 5, ACCESS
141:                       }
2488  D000     BRA 0x248A
142:                   }
143:                   //--------------------------NASTAWY------------------------------
144:                   //nacisnieto przycisk SET (wybor nastawy CO, funkcji serwisowej, antylegionella)
145:                   if(PFNf_oaleg) PFNf_set_aleg = 0;
248A  B80F     BTFSC PFNf_off, 4, ACCESS
248C  9212     BCF PFNf_str_nco, 1, ACCESS
146:                   if(PFNf_ofnserw) PFNf_set_fnserw = 0;
248E  B210     BTFSC PFNf_ofnserw, 1, ACCESS
2490  9412     BCF PFNf_str_nco, 2, ACCESS
2492  D000     BRA 0x2494
147:           
148:                   if(!RdPrt(S_OFF) && !RdPrt(S_KUP) && !RdPrt(S_KDW) && !PFNf_off && !PFNf_fnserw && !PFNf_aleg)
2494  0E16     MOVLW 0x16
2496  ECFD     CALL 0xE7FA, 0
2498  F073     NOP
249A  E301     BNC 0x249E
249C  D0B4     BRA 0x2606
249E  0E18     MOVLW 0x18
24A0  ECFD     CALL 0xE7FA, 0
24A2  F073     NOP
24A4  E301     BNC 0x24A8
24A6  D0AF     BRA 0x2606
24A8  0E19     MOVLW 0x19
24AA  ECFD     CALL 0xE7FA, 0
24AC  F073     NOP
24AE  A0D8     BTFSS STATUS, 0, ACCESS
24B0  BE0F     BTFSC PFNf_off, 7, ACCESS
24B2  D0A9     BRA 0x2606
24B4  AC0E     BTFSS PFNf_lato, 6, ACCESS
24B6  B60C     BTFSC PFNf_b_set_nco, 3, ACCESS
24B8  D0A6     BRA 0x2606
149:                   {
150:                       key = PresKeyEX(RdPrt(S_SET), &ky[SS_SET]);
24BA  0EAB     MOVLW 0xAB
24BC  0100     MOVLB 0x0
24BE  6FE0     MOVWF bdat, BANKED
24C0  0E01     MOVLW 0x1
24C2  6FE1     MOVWF GIE_BIT_VAL, BANKED
24C4  0E17     MOVLW 0x17
24C6  ECFD     CALL 0xE7FA, 0
24C8  F073     NOP
24CA  0E01     MOVLW 0x1
24CC  A0D8     BTFSS STATUS, 0, ACCESS
24CE  0E00     MOVLW 0x0
24D0  ECAB     CALL 0x8556, 0
24D2  F042     NOP
24D4  0100     MOVLB 0x0
24D6  6FED     MOVWF min, BANKED
151:                       if(key == _KDFST)
24D8  0E64     MOVLW 0x64
24DA  0100     MOVLB 0x0
24DC  19ED     XORWF min, W, BANKED
24DE  E001     BZ 0x24E2
24E0  D092     BRA 0x2606
152:                       {
153:                           ResBufKeyEx(&ky[SS_SET]); //resetuj podtrzymanie
24E2  0EAB     MOVLW 0xAB
24E4  6FDE     MOVWF __pcstackBANK0, BANKED
24E6  0E01     MOVLW 0x1
24E8  6FDF     MOVWF pco, BANKED
24EA  EC7B     CALL 0xEAF6, 0
24EC  F075     NOP
154:                           PFNf_b_set_nco = 0;
24EE  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
155:                           PFNf_b_set_ncw = 0;
24F0  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
156:                           PFNf_set_ncw = 0;
24F2  9812     BCF PFNf_str_nco, 4, ACCESS
157:                           PFNf_prn_res = 0;
24F4  9A11     BCF PFNf_prn_res, 5, ACCESS
158:                           if(PFNf_set_nco)
24F6  A612     BTFSS PFNf_str_nco, 3, ACCESS
24F8  D060     BRA 0x25BA
159:                           {
160:                               if(PFNf_newPCO) //nastawa ulegla zmianie (potraktuj klawisz SET jako potwierdzenie
24FA  A20F     BTFSS PFNf_off, 1, ACCESS
24FC  D028     BRA 0x254E
161:                               {
162:                                   PFNf_newPCO = 0;
24FE  920F     BCF PFNf_off, 1, ACCESS
163:                                   PFNf_set_nco = 0;
2500  9612     BCF PFNf_str_nco, 3, ACCESS
164:                                   PFNf_b_set_nco = 0;
2502  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
165:                                   PFNf_set_ncw = 0;
2504  9812     BCF PFNf_str_nco, 4, ACCESS
166:                                   PFNf_b_set_ncw = 0;
2506  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
167:                                   PFNf_set_fnserw = 0;
2508  9412     BCF PFNf_str_nco, 2, ACCESS
168:                                   PFNf_set_aleg = 0;
250A  9212     BCF PFNf_str_nco, 1, ACCESS
169:                                   SetPrt(S_KDW, 0);
250C  0E00     MOVLW 0x0
250E  0100     MOVLB 0x0
2510  6FDE     MOVWF __pcstackBANK0, BANKED
2512  0E19     MOVLW 0x19
2514  EC01     CALL 0xDA02, 0
2516  F06D     NOP
170:                                   SetPrt(S_KUP, 0);
2518  0E00     MOVLW 0x0
251A  0100     MOVLB 0x0
251C  6FDE     MOVWF __pcstackBANK0, BANKED
251E  0E18     MOVLW 0x18
2520  EC01     CALL 0xDA02, 0
2522  F06D     NOP
171:                                   SetPrt(S_SET, 0);
2524  0E00     MOVLW 0x0
2526  0100     MOVLB 0x0
2528  6FDE     MOVWF __pcstackBANK0, BANKED
252A  0E17     MOVLW 0x17
252C  EC01     CALL 0xDA02, 0
252E  F06D     NOP
172:                                   ResBufKeyEx(&ky[SS_KDW]); //resetuj podtrzymanie
2530  0EB5     MOVLW 0xB5
2532  0100     MOVLB 0x0
2534  6FDE     MOVWF __pcstackBANK0, BANKED
2536  0E01     MOVLW 0x1
2538  6FDF     MOVWF pco, BANKED
253A  EC7B     CALL 0xEAF6, 0
253C  F075     NOP
173:                                   ResBufKeyEx(&ky[SS_KUP]); //resetuj podtrzymanie
253E  0EB0     MOVLW 0xB0
2540  0100     MOVLB 0x0
2542  6FDE     MOVWF __pcstackBANK0, BANKED
2544  0E01     MOVLW 0x1
2546  6FDF     MOVWF pco, BANKED
2548  EC7B     CALL 0xEAF6, 0
254A  F075     NOP
174:                               }
254C  D052     BRA 0x25F2
175:                               else
176:                               if(PFNf_zima && !PFNf_obgCW && !PFNf_set_fnserw)
254E  B613     BTFSC PFNf_zima, 3, ACCESS
2550  BC0F     BTFSC PFNf_off, 6, ACCESS
2552  D006     BRA 0x2560
2554  B412     BTFSC PFNf_str_nco, 2, ACCESS
2556  D004     BRA 0x2560
177:                               {
178:                                   PFNf_set_nco = 0;
2558  9612     BCF PFNf_str_nco, 3, ACCESS
179:                                   PFNf_set_fnserw = 1;
255A  8412     BSF PFNf_str_nco, 2, ACCESS
180:                                   PFNf_fns_max = 1;
255C  8A0E     BSF PFNf_lato, 5, ACCESS
181:                               }
255E  D049     BRA 0x25F2
182:                               else
183:                               if(PFNf_EnAleg && !PFNf_set_aleg)
2560  B00C     BTFSC PFNf_b_set_nco, 0, ACCESS
2562  B212     BTFSC PFNf_str_nco, 1, ACCESS
2564  D002     BRA 0x256A
184:                               {
185:                                   PFNf_set_nco = 0;
2566  9612     BCF PFNf_str_nco, 3, ACCESS
2568  D031     BRA 0x25CC
186:                                   PFNf_set_aleg = 1;
187:                               }
188:                               else
189:                               {
190:                                   PFNf_newPCO = 0;
256A  920F     BCF PFNf_off, 1, ACCESS
191:                                   PFNf_set_nco = 0;
256C  9612     BCF PFNf_str_nco, 3, ACCESS
192:                                   PFNf_b_set_nco = 0;
256E  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
193:                                   PFNf_set_ncw = 0;
2570  9812     BCF PFNf_str_nco, 4, ACCESS
194:                                   PFNf_b_set_ncw = 0;
2572  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
195:                                   PFNf_set_fnserw = 0;
2574  9412     BCF PFNf_str_nco, 2, ACCESS
196:                                   PFNf_set_aleg = 0;
2576  9212     BCF PFNf_str_nco, 1, ACCESS
197:                                   SetPrt(S_KDW, 0);
2578  0E00     MOVLW 0x0
257A  0100     MOVLB 0x0
257C  6FDE     MOVWF __pcstackBANK0, BANKED
257E  0E19     MOVLW 0x19
2580  EC01     CALL 0xDA02, 0
2582  F06D     NOP
198:                                   SetPrt(S_KUP, 0);
2584  0E00     MOVLW 0x0
2586  0100     MOVLB 0x0
2588  6FDE     MOVWF __pcstackBANK0, BANKED
258A  0E18     MOVLW 0x18
258C  EC01     CALL 0xDA02, 0
258E  F06D     NOP
199:                                   SetPrt(S_SET, 0);
2590  0E00     MOVLW 0x0
2592  0100     MOVLB 0x0
2594  6FDE     MOVWF __pcstackBANK0, BANKED
2596  0E17     MOVLW 0x17
2598  EC01     CALL 0xDA02, 0
259A  F06D     NOP
200:                                   ResBufKeyEx(&ky[SS_KDW]); //resetuj podtrzymanie
259C  0EB5     MOVLW 0xB5
259E  0100     MOVLB 0x0
25A0  6FDE     MOVWF __pcstackBANK0, BANKED
25A2  0E01     MOVLW 0x1
25A4  6FDF     MOVWF pco, BANKED
25A6  EC7B     CALL 0xEAF6, 0
25A8  F075     NOP
201:                                   ResBufKeyEx(&ky[SS_KUP]); //resetuj podtrzymanie
25AA  0EB0     MOVLW 0xB0
25AC  0100     MOVLB 0x0
25AE  6FDE     MOVWF __pcstackBANK0, BANKED
25B0  0E01     MOVLW 0x1
25B2  6FDF     MOVWF pco, BANKED
25B4  EC7B     CALL 0xEAF6, 0
25B6  F075     NOP
202:                               }
203:                           }
25B8  D01C     BRA 0x25F2
204:                           else
205:                           if(PFNf_set_fnserw && !PFNf_ferr && !PFNf_fmsg)
25BA  B412     BTFSC PFNf_str_nco, 2, ACCESS
25BC  B40E     BTFSC PFNf_lato, 2, ACCESS
25BE  D008     BRA 0x25D0
25C0  B60E     BTFSC PFNf_lato, 3, ACCESS
25C2  D006     BRA 0x25D0
206:                           {
207:                               if(PFNf_EnAleg && !PFNf_set_aleg)
25C4  B00C     BTFSC PFNf_b_set_nco, 0, ACCESS
25C6  B212     BTFSC PFNf_str_nco, 1, ACCESS
25C8  D008     BRA 0x25DA
208:                               {
209:                                   PFNf_set_fnserw = 0;
25CA  9412     BCF PFNf_str_nco, 2, ACCESS
210:                                   PFNf_set_aleg = 1;
25CC  8212     BSF PFNf_str_nco, 1, ACCESS
211:                               }
212:                               else
213:                               {
214:                                   PFNf_newPCO = 0;
215:                                   PFNf_set_nco = 0;
216:                                   PFNf_b_set_nco = 0;
217:                                   PFNf_set_ncw = 0;
218:                                   PFNf_b_set_ncw = 0;
219:                                   PFNf_set_fnserw = 0;
220:                                   PFNf_set_aleg = 0;
221:                               }
222:                           }
25CE  D011     BRA 0x25F2
223:                           else
224:                           if(PFNf_set_aleg && !PFNf_ferr && !PFNf_fmsg)
25D0  B212     BTFSC PFNf_str_nco, 1, ACCESS
25D2  B40E     BTFSC PFNf_lato, 2, ACCESS
25D4  D00A     BRA 0x25EA
25D6  B60E     BTFSC PFNf_lato, 3, ACCESS
25D8  D008     BRA 0x25EA
225:                           {
226:                               PFNf_newPCO = 0;
25DA  920F     BCF PFNf_off, 1, ACCESS
227:                               PFNf_set_nco = 0;
25DC  9612     BCF PFNf_str_nco, 3, ACCESS
228:                               PFNf_b_set_nco = 0;
25DE  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
229:                               PFNf_set_ncw = 0;
25E0  9812     BCF PFNf_str_nco, 4, ACCESS
230:                               PFNf_b_set_ncw = 0;
25E2  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
231:                               PFNf_set_fnserw = 0;
25E4  9412     BCF PFNf_str_nco, 2, ACCESS
232:                               PFNf_set_aleg = 0;
25E6  9212     BCF PFNf_str_nco, 1, ACCESS
233:                           }
25E8  D004     BRA 0x25F2
234:                           else
235:                           {
236:                               PFNf_set_fnserw = 0;
25EA  9412     BCF PFNf_str_nco, 2, ACCESS
237:                               PFNf_set_aleg = 0;
25EC  9212     BCF PFNf_str_nco, 1, ACCESS
238:                               PFNf_set_nco = 1;
25EE  8612     BSF PFNf_str_nco, 3, ACCESS
239:                           }
25F0  D000     BRA 0x25F2
240:                           StartRTdS(_RTSET);
25F2  0E09     MOVLW 0x9
25F4  ECA0     CALL 0xE540, 0
25F6  F072     NOP
241:                           if(PFNf_set_nco)
25F8  A612     BTFSS PFNf_str_nco, 3, ACCESS
25FA  D005     BRA 0x2606
242:                           {
243:                               PFNf_b_set_nco = 0;
25FC  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
244:                               RestartKol(_WS_NCWCO);
25FE  0E02     MOVLW 0x2
2600  ECC2     CALL 0xED84, 0
2602  F076     NOP
245:                           }
2604  D000     BRA 0x2606
246:                       }
247:                   }
248:                   if(RTdS(_RTSET) > _TSETNST) //uplynal czas podtrzymania wybranego parametru?
2606  0E09     MOVLW 0x9
2608  ECD7     CALL 0xEBAE, 0
260A  F075     NOP
260C  0100     MOVLB 0x0
260E  6FE7     MOVWF sign, BANKED
2610  0E1E     MOVLW 0x1E
2612  65E7     CPFSGT sign, BANKED
2614  D007     BRA 0x2624
249:                   {
250:                       PFNf_set_nco = 0;
2616  9612     BCF PFNf_str_nco, 3, ACCESS
251:                       PFNf_b_set_nco = 0;
2618  9C0C     BCF PFNf_b_set_nco, 6, ACCESS
252:                       PFNf_set_ncw = 0;
261A  9812     BCF PFNf_str_nco, 4, ACCESS
253:                       PFNf_b_set_ncw = 0;
261C  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
254:                       PFNf_set_fnserw = 0;
261E  9412     BCF PFNf_str_nco, 2, ACCESS
255:                       PFNf_set_aleg = 0;
2620  9212     BCF PFNf_str_nco, 1, ACCESS
2622  D000     BRA 0x2624
256:                   }
257:           
258:                   if(!RdPrt(S_OFF) && !RdPrt(S_KDW) && !PFNf_off && !PFNf_fnserw && !PFNf_aleg)
2624  0E16     MOVLW 0x16
2626  ECFD     CALL 0xE7FA, 0
2628  F073     NOP
262A  E251     BC 0x26CE
262C  0E19     MOVLW 0x19
262E  ECFD     CALL 0xE7FA, 0
2630  F073     NOP
2632  A0D8     BTFSS STATUS, 0, ACCESS
2634  BE0F     BTFSC PFNf_off, 7, ACCESS
2636  D04B     BRA 0x26CE
2638  AC0E     BTFSS PFNf_lato, 6, ACCESS
263A  B60C     BTFSC PFNf_b_set_nco, 3, ACCESS
263C  D048     BRA 0x26CE
259:                   {
260:                       if(PFNf_set_fnserw)
263E  A412     BTFSS PFNf_str_nco, 2, ACCESS
2640  D022     BRA 0x2686
261:                       {
262:                           key = PresKeyEX(RdPrt(S_KUP), &ky[SS_KUP]);
2642  0EB0     MOVLW 0xB0
2644  0100     MOVLB 0x0
2646  6FE0     MOVWF bdat, BANKED
2648  0E01     MOVLW 0x1
264A  6FE1     MOVWF GIE_BIT_VAL, BANKED
264C  0E18     MOVLW 0x18
264E  ECFD     CALL 0xE7FA, 0
2650  F073     NOP
2652  0E01     MOVLW 0x1
2654  A0D8     BTFSS STATUS, 0, ACCESS
2656  0E00     MOVLW 0x0
2658  ECAB     CALL 0x8556, 0
265A  F042     NOP
265C  0100     MOVLB 0x0
265E  6FED     MOVWF min, BANKED
263:                           if(key != _KDFST && key >= _TKALG)
2660  0E64     MOVLW 0x64
2662  0100     MOVLB 0x0
2664  19ED     XORWF min, W, BANKED
2666  E00F     BZ 0x2686
2668  0E09     MOVLW 0x9
266A  65ED     CPFSGT min, BANKED
266C  D00C     BRA 0x2686
264:                           {
265:                               WaitToLowEx(&ky[SS_KUP]);
266E  0EB0     MOVLW 0xB0
2670  6FDE     MOVWF __pcstackBANK0, BANKED
2672  0E01     MOVLW 0x1
2674  6FDF     MOVWF pco, BANKED
2676  EC10     CALL 0xEE20, 0
2678  F077     NOP
266:                               PFNf_fnserw = 1;
267A  8C0E     BSF PFNf_lato, 6, ACCESS
267:                               PFNf_prn_res = 0;
267C  9A11     BCF PFNf_prn_res, 5, ACCESS
268:                               PFNf_set_nco = 0;
267E  9612     BCF PFNf_str_nco, 3, ACCESS
269:                               PFNf_set_ncw = 0;
2680  9812     BCF PFNf_str_nco, 4, ACCESS
270:                               PFNf_b_ofnserw = 0;
2682  9A0C     BCF PFNf_b_set_nco, 5, ACCESS
271:                           }
2684  D000     BRA 0x2686
272:                       }
273:                       if(PFNf_set_aleg)
2686  A212     BTFSS PFNf_str_nco, 1, ACCESS
2688  D022     BRA 0x26CE
274:                       {
275:                           key = PresKeyEX(RdPrt(S_KUP), &ky[SS_KUP]);
268A  0EB0     MOVLW 0xB0
268C  0100     MOVLB 0x0
268E  6FE0     MOVWF bdat, BANKED
2690  0E01     MOVLW 0x1
2692  6FE1     MOVWF GIE_BIT_VAL, BANKED
2694  0E18     MOVLW 0x18
2696  ECFD     CALL 0xE7FA, 0
2698  F073     NOP
269A  0E01     MOVLW 0x1
269C  A0D8     BTFSS STATUS, 0, ACCESS
269E  0E00     MOVLW 0x0
26A0  ECAB     CALL 0x8556, 0
26A2  F042     NOP
26A4  0100     MOVLB 0x0
26A6  6FED     MOVWF min, BANKED
276:                           if(key != _KDFST && key >= _TKSRV)
26A8  0E64     MOVLW 0x64
26AA  0100     MOVLB 0x0
26AC  19ED     XORWF min, W, BANKED
26AE  E00F     BZ 0x26CE
26B0  0E09     MOVLW 0x9
26B2  65ED     CPFSGT min, BANKED
26B4  D00C     BRA 0x26CE
277:                           {
278:                               WaitToLowEx(&ky[SS_KUP]);
26B6  0EB0     MOVLW 0xB0
26B8  6FDE     MOVWF __pcstackBANK0, BANKED
26BA  0E01     MOVLW 0x1
26BC  6FDF     MOVWF pco, BANKED
26BE  EC10     CALL 0xEE20, 0
26C0  F077     NOP
279:                               PFNf_aleg = 1;
26C2  860C     BSF PFNf_b_set_nco, 3, ACCESS
280:                               PFNf_prn_res = 0;
26C4  9A11     BCF PFNf_prn_res, 5, ACCESS
281:                               PFNf_set_nco = 0;
26C6  9612     BCF PFNf_str_nco, 3, ACCESS
282:                               PFNf_set_ncw = 0;
26C8  9812     BCF PFNf_str_nco, 4, ACCESS
283:                               PFNf_b_oaleg = 0;
26CA  980C     BCF PFNf_b_set_nco, 4, ACCESS
284:                           }
285:                       }
26CC  D000     BRA 0x26CE
286:                   }
287:                   //---------------------
288:                   //nacisnieto przycisk UP lub DW (zmiana nastawy CW)
289:                   //if(!RdPrt(S_OFF) && !RdPrt(S_SET) && !PFNf_off && !PFNf_fnserw && !PFNf_aleg && !PFNf_set_fnserw && !PFNf_set_aleg && !PFNf_set_nco && !PFNf_set_ncw)
290:                   if(!RdPrt(S_OFF) && !RdPrt(S_SET) && !PFNf_off && !PFNf_prnserw && !PFNf_prnaleg && !PFNf_set_nco && !PFNf_set_ncw)
26CE  0E16     MOVLW 0x16
26D0  ECFD     CALL 0xE7FA, 0
26D2  F073     NOP
26D4  E250     BC 0x2776
26D6  0E17     MOVLW 0x17
26D8  ECFD     CALL 0xE7FA, 0
26DA  F073     NOP
26DC  A0D8     BTFSS STATUS, 0, ACCESS
26DE  BE0F     BTFSC PFNf_off, 7, ACCESS
26E0  D04A     BRA 0x2776
26E2  AE11     BTFSS PFNf_prn_res, 7, ACCESS
26E4  BC11     BTFSC PFNf_prn_res, 6, ACCESS
26E6  D047     BRA 0x2776
26E8  A612     BTFSS PFNf_str_nco, 3, ACCESS
26EA  B812     BTFSC PFNf_str_nco, 4, ACCESS
26EC  D044     BRA 0x2776
291:                   {
292:                       key = PresKeyEX(RdPrt(S_KDW), &ky[SS_KDW]);
26EE  0EB5     MOVLW 0xB5
26F0  0100     MOVLB 0x0
26F2  6FE0     MOVWF bdat, BANKED
26F4  0E01     MOVLW 0x1
26F6  6FE1     MOVWF GIE_BIT_VAL, BANKED
26F8  0E19     MOVLW 0x19
26FA  ECFD     CALL 0xE7FA, 0
26FC  F073     NOP
26FE  0E01     MOVLW 0x1
2700  A0D8     BTFSS STATUS, 0, ACCESS
2702  0E00     MOVLW 0x0
2704  ECAB     CALL 0x8556, 0
2706  F042     NOP
2708  0100     MOVLB 0x0
270A  6FED     MOVWF min, BANKED
293:                       key2 = PresKeyEX(RdPrt(S_KUP), &ky[SS_KUP]);
270C  0EB0     MOVLW 0xB0
270E  6FE0     MOVWF bdat, BANKED
2710  0E01     MOVLW 0x1
2712  6FE1     MOVWF GIE_BIT_VAL, BANKED
2714  0E18     MOVLW 0x18
2716  ECFD     CALL 0xE7FA, 0
2718  F073     NOP
271A  0E01     MOVLW 0x1
271C  A0D8     BTFSS STATUS, 0, ACCESS
271E  0E00     MOVLW 0x0
2720  ECAB     CALL 0x8556, 0
2722  F042     NOP
2724  0100     MOVLB 0x0
2726  6FEC     MOVWF dt, BANKED
294:                       if(key == _KDFST || key >= _TKSET2 || key2 == _KDFST || key2 >= _TKSET2) //key>=_TKSET
2728  0E64     MOVLW 0x64
272A  0100     MOVLB 0x0
272C  19ED     XORWF min, W, BANKED
272E  E00A     BZ 0x2744
2730  0E02     MOVLW 0x2
2732  61ED     CPFSLT min, BANKED
2734  D007     BRA 0x2744
2736  0E64     MOVLW 0x64
2738  19EC     XORWF dt, W, BANKED
273A  E004     BZ 0x2744
273C  0E01     MOVLW 0x1
273E  65EC     CPFSGT dt, BANKED
2740  D01A     BRA 0x2776
2742  D000     BRA 0x2744
295:                       {
296:                           ResBufKeyEx(&ky[SS_KDW]); //resetuj podtrzymanie
2744  0EB5     MOVLW 0xB5
2746  0100     MOVLB 0x0
2748  6FDE     MOVWF __pcstackBANK0, BANKED
274A  0E01     MOVLW 0x1
274C  6FDF     MOVWF pco, BANKED
274E  EC7B     CALL 0xEAF6, 0
2750  F075     NOP
297:                           ResBufKeyEx(&ky[SS_KUP]); //resetuj podtrzymanie
2752  0EB0     MOVLW 0xB0
2754  0100     MOVLB 0x0
2756  6FDE     MOVWF __pcstackBANK0, BANKED
2758  0E01     MOVLW 0x1
275A  6FDF     MOVWF pco, BANKED
275C  EC7B     CALL 0xEAF6, 0
275E  F075     NOP
298:                           RestartKol(_WS_NCWCO);
2760  0E02     MOVLW 0x2
2762  ECC2     CALL 0xED84, 0
2764  F076     NOP
299:                           //				RestartKol2(_KL_NCWCO);
300:                           //				RestartKol(_KL_NCWCO);
301:                           PFNf_b_set_ncw = 0;
2766  9E0C     BCF PFNf_b_set_nco, 7, ACCESS
302:                           PFNf_prn_res = 0;
2768  9A11     BCF PFNf_prn_res, 5, ACCESS
303:                           PFNf_set_ncw = 1;
276A  8812     BSF PFNf_str_nco, 4, ACCESS
304:                           PFNf_mod_ncw = 0;
276C  900F     BCF PFNf_off, 0, ACCESS
305:                           StartRTdS(_RTSET);
276E  0E09     MOVLW 0x9
2770  ECA0     CALL 0xE540, 0
2772  F072     NOP
306:                       }
2774  D000     BRA 0x2776
307:                   }
308:                   //--------------------------FUNKCJE SPECJALNE------------------------------
309:                   ExtR = (!PFNf_pmpPWM || PFNf_errIN || !PFNf_ofzima || PFNf_obgCW || !PFNf_obgCO) ? 0 : 1;
2776  0100     MOVLB 0x0
2778  6BE8     CLRF quotient, BANKED
277A  B411     BTFSC PFNf_prn_res, 2, ACCESS
277C  B00E     BTFSC PFNf_lato, 0, ACCESS
277E  D009     BRA 0x2792
2780  B610     BTFSC PFNf_ofnserw, 3, ACCESS
2782  BC0F     BTFSC PFNf_off, 6, ACCESS
2784  D006     BRA 0x2792
2786  AA0F     BTFSS PFNf_off, 5, ACCESS
2788  D004     BRA 0x2792
278A  0E01     MOVLW 0x1
278C  0100     MOVLB 0x0
278E  6FE8     MOVWF quotient, BANKED
2790  D000     BRA 0x2792
2792  C0E8     MOVFF quotient, tim
2794  F0EA     NOP
310:                   //ExtR2 = (PFNf_errIN || !PFNf_obgCO) ? 0 : 1;
311:                   ExtR2=(PFNf_errIN||(PFNf_oflato&&!PFNf_obgCO)||PFNf_obgCW)?0:1;				//odwrotny warunek wskazu CS,IN
2796  0100     MOVLB 0x0
2798  6BE9     CLRF p, BANKED
279A  B00E     BTFSC PFNf_lato, 0, ACCESS
279C  D00A     BRA 0x27B2
279E  A010     BTFSS PFNf_ofnserw, 0, ACCESS
27A0  D002     BRA 0x27A6
27A2  AA0F     BTFSS PFNf_off, 5, ACCESS
27A4  D006     BRA 0x27B2
27A6  BC0F     BTFSC PFNf_off, 6, ACCESS
27A8  D004     BRA 0x27B2
27AA  0E01     MOVLW 0x1
27AC  0100     MOVLB 0x0
27AE  6FE9     MOVWF p, BANKED
27B0  D000     BRA 0x27B2
27B2  C0E9     MOVFF p, pop
27B4  F0EB     NOP
312:                   
313:                   //if(!ExtR) tm=_TPCS;
314:           		//else tm=2*_TPCS;
315:                   if(RTdS(_RTPCS) > _TPCS) //uplynal czas podtrzymania wskazu cisnienia?       
27B6  0E0A     MOVLW 0xA
27B8  ECD7     CALL 0xEBAE, 0
27BA  F075     NOP
27BC  0100     MOVLB 0x0
27BE  6FE7     MOVWF sign, BANKED
27C0  0E32     MOVLW 0x32
27C2  65E7     CPFSGT sign, BANKED
27C4  D001     BRA 0x27C8
316:                   {
317:                       PFNf_prn_res = 0;
27C6  9A11     BCF PFNf_prn_res, 5, ACCESS
318:                   }
319:                   if(PFNf_prn_res && (PFNf_errCS || PFNf_fnoCS) && (PFNf_obgCW || PFNf_oflato)) //awaria CS lub brak CS i (aktywny obieg CW lub tryb LATO)?
27C8  AA11     BTFSS PFNf_prn_res, 5, ACCESS
27CA  D007     BRA 0x27DA
27CC  BC0D     BTFSC PFNf_b_str_nco, 6, ACCESS
27CE  D002     BRA 0x27D4
27D0  A80E     BTFSS PFNf_lato, 4, ACCESS
27D2  D003     BRA 0x27DA
27D4  AC0F     BTFSS PFNf_off, 6, ACCESS
27D6  B010     BTFSC PFNf_ofnserw, 0, ACCESS
320:                   {
321:                       PFNf_prn_res = 0;
27D8  9A11     BCF PFNf_prn_res, 5, ACCESS
322:                   }
323:                   if(PFNf_prn_res && (PFNf_errCS || PFNf_fnoCS) && PFNf_errIN) //nie ma co pokazywac?
27DA  AA11     BTFSS PFNf_prn_res, 5, ACCESS
27DC  D006     BRA 0x27EA
27DE  BC0D     BTFSC PFNf_b_str_nco, 6, ACCESS
27E0  D002     BRA 0x27E6
27E2  A80E     BTFSS PFNf_lato, 4, ACCESS
27E4  D002     BRA 0x27EA
27E6  B00E     BTFSC PFNf_lato, 0, ACCESS
324:                   {
325:                       PFNf_prn_res = 0;
27E8  9A11     BCF PFNf_prn_res, 5, ACCESS
326:                   }
327:           
328:                   if(!PFNf_prn_res)
27EA  AA11     BTFSS PFNf_prn_res, 5, ACCESS
27EC  D045     BRA 0x2878
329:                   {
330:                       PFNf_prn_cs = 0;
331:                       PFNf_prn_in = 0;
332:                   }
333:                   else
334:                   {
335:                       if(ExtR) //Dzielony wskaz CS, IN
27EE  0100     MOVLB 0x0
27F0  51EA     MOVF tim, W, BANKED
27F2  E00E     BZ 0x2810
336:                       {
337:                           if(RTdS(_RTPCS)<(_TPCS / 2))
27F4  0E0A     MOVLW 0xA
27F6  ECD7     CALL 0xEBAE, 0
27F8  F075     NOP
27FA  0100     MOVLB 0x0
27FC  6FE7     MOVWF sign, BANKED
27FE  0E19     MOVLW 0x19
2800  61E7     CPFSLT sign, BANKED
2802  D003     BRA 0x280A
2804  D036     BRA 0x2872
338:                           {
339:                               PFNf_prn_cs = 1;
340:                               PFNf_prn_in = 0;
2806  9811     BCF PFNf_prn_res, 4, ACCESS
341:                           }
2808  D03A     BRA 0x287E
342:                           else
343:                           {
344:                               PFNf_prn_cs = 0;
280A  9611     BCF PFNf_prn_res, 3, ACCESS
345:                               PFNf_prn_in = 1;
280C  8811     BSF PFNf_prn_res, 4, ACCESS
346:                           }
347:                       }
280E  D037     BRA 0x287E
348:                       else
349:                       {
350:                           if(ExtR2) //Dzielony wskaz CS i IN?
2810  0100     MOVLB 0x0
2812  51EB     MOVF pop, W, BANKED
2814  E023     BZ 0x285C
351:                           {
352:                               if(PFNf_errCS || PFNf_fnoCS)
2816  BC0D     BTFSC PFNf_b_str_nco, 6, ACCESS
2818  D002     BRA 0x281E
281A  A80E     BTFSS PFNf_lato, 4, ACCESS
281C  D00A     BRA 0x2832
353:                               {
354:                                   if(RTdS(_RTPCS) < _TPCS) //nadszedl czas podtrzymania wskazu temp wlotowej?
281E  0E0A     MOVLW 0xA
2820  ECD7     CALL 0xEBAE, 0
2822  F075     NOP
2824  0100     MOVLB 0x0
2826  6FE7     MOVWF sign, BANKED
2828  0E32     MOVLW 0x32
282A  61E7     CPFSLT sign, BANKED
282C  D028     BRA 0x287E
282E  D7ED     BRA 0x280A
355:                                   {
356:                                       PFNf_prn_cs = 0;
357:                                       PFNf_prn_in = 1;
358:                                   }
359:                               }
2830  D026     BRA 0x287E
360:                               else
361:                               {
362:                                   if(RTdS(_RTPCS)<(_TPCS / 2)) //nadszedl czas podtrzymania wskazu temp wlotowej?
2832  0E0A     MOVLW 0xA
2834  ECD7     CALL 0xEBAE, 0
2836  F075     NOP
2838  0100     MOVLB 0x0
283A  6FE7     MOVWF sign, BANKED
283C  0E19     MOVLW 0x19
283E  61E7     CPFSLT sign, BANKED
2840  D001     BRA 0x2844
2842  D017     BRA 0x2872
363:                                   {
364:                                       PFNf_prn_cs = 1;
365:                                       PFNf_prn_in = 0;
366:                                   }
367:                                   else
368:                                   {
369:                                       if(!PFNf_errIN)
2844  B00E     BTFSC PFNf_lato, 0, ACCESS
2846  D015     BRA 0x2872
370:                                       {
371:                                           if(RTdS(_RTPCS) >= (_TPCS / 2)) //nadszedl czas podtrzymania wskazu temp wlotowej?
2848  0E0A     MOVLW 0xA
284A  ECD7     CALL 0xEBAE, 0
284C  F075     NOP
284E  0100     MOVLB 0x0
2850  6FE7     MOVWF sign, BANKED
2852  0E18     MOVLW 0x18
2854  65E7     CPFSGT sign, BANKED
2856  D013     BRA 0x287E
2858  D7D8     BRA 0x280A
372:                                           {
373:                                               PFNf_prn_cs = 0;
374:                                               PFNf_prn_in = 1;
375:                                           }
376:                                       }
377:                                       else
378:                                       {
379:                                           PFNf_prn_cs = 1;
380:                                           PFNf_prn_in = 0;
381:                                       }
382:                                   }
383:                               }
384:                           }
285A  D011     BRA 0x287E
385:                           else //Wylaczny wskaz CS
386:                           {
387:                               if(!(PFNf_errCS || PFNf_fnoCS))
285C  AC0D     BTFSS PFNf_b_str_nco, 6, ACCESS
285E  B80E     BTFSC PFNf_lato, 4, ACCESS
2860  D00B     BRA 0x2878
388:                               {
389:                                   if(RTdS(_RTPCS) < _TPCS) //nadszedl czas podtrzymania wskazu temp wlotowej?
2862  0E0A     MOVLW 0xA
2864  ECD7     CALL 0xEBAE, 0
2866  F075     NOP
2868  0100     MOVLB 0x0
286A  6FE7     MOVWF sign, BANKED
286C  0E32     MOVLW 0x32
286E  61E7     CPFSLT sign, BANKED
2870  D006     BRA 0x287E
390:                                   {
391:                                       PFNf_prn_cs = 1;
2872  8611     BSF PFNf_prn_res, 3, ACCESS
2874  D7C8     BRA 0x2806
392:                                       PFNf_prn_in = 0;
393:                                   }
394:                               }
2876  D003     BRA 0x287E
395:                               else
396:                               {
397:                                   PFNf_prn_cs = 0;
2878  9611     BCF PFNf_prn_res, 3, ACCESS
287A  D7C5     BRA 0x2806
398:                                   PFNf_prn_in = 0;
399:                               }
400:                           }
287C  D000     BRA 0x287E
401:                       }
402:                   }
403:                   //---------------------
404:                   if(!PFNf_off && (PFNf_fnserw || PFNf_ofnserw)) //aktywna funkcja serwisowa?
287E  BE0F     BTFSC PFNf_off, 7, ACCESS
2880  D034     BRA 0x28EA
2882  BC0E     BTFSC PFNf_lato, 6, ACCESS
2884  D002     BRA 0x288A
2886  A210     BTFSS PFNf_ofnserw, 1, ACCESS
2888  D030     BRA 0x28EA
405:                   {
406:                       if(PresKeyEX(RdPrt(S_KUP), &ky[SS_KUP]) > 0) //nacisnieto przycisk +?
288A  0EB0     MOVLW 0xB0
288C  0100     MOVLB 0x0
288E  6FE0     MOVWF bdat, BANKED
2890  0E01     MOVLW 0x1
2892  6FE1     MOVWF GIE_BIT_VAL, BANKED
2894  0E18     MOVLW 0x18
2896  ECFD     CALL 0xE7FA, 0
2898  F073     NOP
289A  0E01     MOVLW 0x1
289C  A0D8     BTFSS STATUS, 0, ACCESS
289E  0E00     MOVLW 0x0
28A0  ECAB     CALL 0x8556, 0
28A2  F042     NOP
28A4  0900     IORLW 0x0
28A6  E009     BZ 0x28BA
407:                       {
408:                           ResBufKeyEx(&ky[SS_KUP]); //resetuj podtrzymanie
28A8  0EB0     MOVLW 0xB0
28AA  0100     MOVLB 0x0
28AC  6FDE     MOVWF __pcstackBANK0, BANKED
28AE  0E01     MOVLW 0x1
28B0  6FDF     MOVWF pco, BANKED
28B2  EC7B     CALL 0xEAF6, 0
28B4  F075     NOP
409:                           PFNf_fns_max = 1;
28B6  8A0E     BSF PFNf_lato, 5, ACCESS
28B8  D000     BRA 0x28BA
410:                       }
411:                       if(PresKeyEX(RdPrt(S_KDW), &ky[SS_KDW]) > 0) //nacisnieto przycisk -?
28BA  0EB5     MOVLW 0xB5
28BC  0100     MOVLB 0x0
28BE  6FE0     MOVWF bdat, BANKED
28C0  0E01     MOVLW 0x1
28C2  6FE1     MOVWF GIE_BIT_VAL, BANKED
28C4  0E19     MOVLW 0x19
28C6  ECFD     CALL 0xE7FA, 0
28C8  F073     NOP
28CA  0E01     MOVLW 0x1
28CC  A0D8     BTFSS STATUS, 0, ACCESS
28CE  0E00     MOVLW 0x0
28D0  ECAB     CALL 0x8556, 0
28D2  F042     NOP
28D4  0900     IORLW 0x0
28D6  E009     BZ 0x28EA
412:                       {
413:                           ResBufKeyEx(&ky[SS_KDW]); //resetuj podtrzymanie
28D8  0EB5     MOVLW 0xB5
28DA  0100     MOVLB 0x0
28DC  6FDE     MOVWF __pcstackBANK0, BANKED
28DE  0E01     MOVLW 0x1
28E0  6FDF     MOVWF pco, BANKED
28E2  EC7B     CALL 0xEAF6, 0
28E4  F075     NOP
414:                           PFNf_fns_max = 0;
28E6  9A0E     BCF PFNf_lato, 5, ACCESS
415:                       }
28E8  D000     BRA 0x28EA
416:                   }
417:                   //--------------------------RESET------------------------------
418:                   //nacisnieto przycisk RESET
419:                   key = PresKeyEX(RdPrt(S_OFF), &ky[SS_OFF]);
28EA  0EA6     MOVLW 0xA6
28EC  0100     MOVLB 0x0
28EE  6FE0     MOVWF bdat, BANKED
28F0  0E01     MOVLW 0x1
28F2  6FE1     MOVWF GIE_BIT_VAL, BANKED
28F4  0E16     MOVLW 0x16
28F6  ECFD     CALL 0xE7FA, 0
28F8  F073     NOP
28FA  0E01     MOVLW 0x1
28FC  A0D8     BTFSS STATUS, 0, ACCESS
28FE  0E00     MOVLW 0x0
2900  ECAB     CALL 0x8556, 0
2902  F042     NOP
2904  0100     MOVLB 0x0
2906  6FED     MOVWF min, BANKED
420:                   if(key == _KDFST)
2908  0E64     MOVLW 0x64
290A  0100     MOVLB 0x0
290C  19ED     XORWF min, W, BANKED
290E  E13A     BNZ 0x2984
421:                   {
422:                       //if(PFNf_set_nco || PFNf_set_ncw || PFNf_str_nco || PFNf_str_ncw || PFNf_prn_res || PFNf_set_fnserw || PFNf_fnserw || PFNf_set_aleg || PFNf_aleg)
423:                       if(PFNf_set_nco || PFNf_set_ncw || PFNf_str_nco || PFNf_str_ncw || PFNf_prn_res || PFNf_prnserw || PFNf_prnaleg)
2910  A612     BTFSS PFNf_str_nco, 3, ACCESS
2912  B812     BTFSC PFNf_str_nco, 4, ACCESS
2914  D008     BRA 0x2926
2916  AA12     BTFSS PFNf_str_nco, 5, ACCESS
2918  BC12     BTFSC PFNf_str_nco, 6, ACCESS
291A  D005     BRA 0x2926
291C  AA11     BTFSS PFNf_prn_res, 5, ACCESS
291E  BE11     BTFSC PFNf_prn_res, 7, ACCESS
2920  D002     BRA 0x2926
2922  AC11     BTFSS PFNf_prn_res, 6, ACCESS
2924  D012     BRA 0x294A
424:                       {
425:                           WaitToLowEx(&ky[SS_OFF]);
2926  0EA6     MOVLW 0xA6
2928  0100     MOVLB 0x0
292A  6FDE     MOVWF __pcstackBANK0, BANKED
292C  0E01     MOVLW 0x1
292E  6FDF     MOVWF pco, BANKED
2930  EC10     CALL 0xEE20, 0
2932  F077     NOP
426:                           PFNf_set_nco = 0;
2934  9612     BCF PFNf_str_nco, 3, ACCESS
427:                           PFNf_set_ncw = 0;
2936  9812     BCF PFNf_str_nco, 4, ACCESS
428:                           PFNf_str_nco = 0;
2938  9A12     BCF PFNf_str_nco, 5, ACCESS
429:                           PFNf_str_ncw = 0;
293A  9C12     BCF PFNf_str_nco, 6, ACCESS
430:                           PFNf_mod_ncw = 0;
293C  900F     BCF PFNf_off, 0, ACCESS
431:                           PFNf_prn_res = 0;
293E  D020     BRA 0x2980
432:                           PFNf_set_fnserw = 0;
2940  9412     BCF PFNf_str_nco, 2, ACCESS
433:                           PFNf_fnserw = 0;
2942  9C0E     BCF PFNf_lato, 6, ACCESS
434:                           PFNf_set_aleg = 0;
2944  9212     BCF PFNf_str_nco, 1, ACCESS
435:                           PFNf_aleg = 0;
2946  960C     BCF PFNf_b_set_nco, 3, ACCESS
436:                           //PFNf_blkcs = 1;
437:                           //StartRTdS(_RTPCS);
438:                       }
2948  D01D     BRA 0x2984
439:                       else
440:                       {
441:                           //if(PFNf_blkcs&&RTdS(_RTPCS)>50) {PFNf_blkcs=0;PFNf_prn_res = 0;}
442:                           
443:                           //if(!PFNf_blkcs)
444:                           if(!PFNf_off && !PFNf_ferr && !PFNf_fmsg)
294A  AE0F     BTFSS PFNf_off, 7, ACCESS
294C  B40E     BTFSC PFNf_lato, 2, ACCESS
294E  D01A     BRA 0x2984
2950  B60E     BTFSC PFNf_lato, 3, ACCESS
2952  D018     BRA 0x2984
445:                           {
446:                               WaitToLowEx(&ky[SS_OFF]);
2954  0EA6     MOVLW 0xA6
2956  0100     MOVLB 0x0
2958  6FDE     MOVWF __pcstackBANK0, BANKED
295A  0E01     MOVLW 0x1
295C  6FDF     MOVWF pco, BANKED
295E  EC10     CALL 0xEE20, 0
2960  F077     NOP
447:                               if(!PFNf_errCS || (PFNf_fnoCS && !PFNf_errIN))
2962  AC0D     BTFSS PFNf_b_str_nco, 6, ACCESS
2964  D003     BRA 0x296C
2966  B80E     BTFSC PFNf_lato, 4, ACCESS
2968  B00E     BTFSC PFNf_lato, 0, ACCESS
296A  D002     BRA 0x2970
448:                               {
449:                                   PFNf_prn_res = 1;
296C  8A11     BSF PFNf_prn_res, 5, ACCESS
296E  D000     BRA 0x2970
450:                               }
451:                               StartRTdS(_RTPCS);
2970  0E0A     MOVLW 0xA
2972  ECA0     CALL 0xE540, 0
2974  F072     NOP
452:                           }
453:                       }
454:                   }
455:           
456:               }
2976  D006     BRA 0x2984
457:               else
458:               {
459:                   PFNf_set_nco = 0;
2978  9612     BCF PFNf_str_nco, 3, ACCESS
460:                   PFNf_set_ncw = 0;
297A  9812     BCF PFNf_str_nco, 4, ACCESS
461:                   PFNf_str_nco = 0;
297C  9A12     BCF PFNf_str_nco, 5, ACCESS
462:                   PFNf_str_ncw = 0;
297E  9C12     BCF PFNf_str_nco, 6, ACCESS
463:                   PFNf_prn_res = 0;
2980  9A11     BCF PFNf_prn_res, 5, ACCESS
2982  D7DE     BRA 0x2940
464:                   PFNf_set_fnserw = 0;
465:                   PFNf_fnserw = 0;
466:                   PFNf_set_aleg = 0;
467:                   PFNf_aleg = 0;
468:               }
469:               //stan przycisku RESET
470:               if(RdPrt(S_OFF))
2984  0E16     MOVLW 0x16
2986  ECFD     CALL 0xE7FA, 0
2988  F073     NOP
298A  E302     BNC 0x2990
471:               {
472:                   PFNf_res = 1;
298C  8012     BSF PFNf_str_nco, 0, ACCESS
473:               }
298E  0012     RETURN 0
474:               else PFNf_res = 0;
2990  9012     BCF PFNf_str_nco, 0, ACCESS
2992  0012     RETURN 0
475:           }
2994  0012     RETURN 0
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/konfig2.c  -------------------------------
1:             /*konfig2.c*/
2:             //Procedury zwiazane z wyborem typu gazu i poziomow
3:             //mocy startowej oraz majksymalnej dla CO i CW
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include <htc.h>
7:             #include "global.h"					//parametry globalne
8:             #include "konfig2.h"					//parametry lokalne
9:             #include "eeprom.h"
10:            #include "pomiar.h"
11:            #include "wsw.h"
12:            #include "main.tp.h"
13:            #include "keypad.tp.h"
14:            #include "print.h"
15:            #include "konsola.h"
16:            
17:            volatile DtKONF DtKNF;
18:            
19:            //extern unsigned char x,y;
20:            
21:            //extern MGSRSData MGSD;
22:            extern tpMAIN M;
23:            extern DataPFN PFN;
24:            extern DataCO DtCO; //pomiar.c
25:            extern DataZW DtZW;
26:            extern DataCW DtCW;
27:            extern DataIN DtIN;
28:            
29:            //extern tpRSDTA1 RSDT1;
30:            extern StPin ky[];
31:            extern StPin xxky[];
32:            
33:            DtPZK PZK[_KNPAR1] ={
34:                0, 0, 0, 0, 0, 0, 0, 1, //moc startowa
35:                0, 0, 0, 0, 0, 0, 0, 1, //moc maksymalna CW
36:                0, 0, 0, 0, 0, 0, 0, 1, //moc maksymalna CO
37:                0, 0, 0, 0, 0, 0, 1, 1, //wybor rodzaju gazu
38:                0, 0, 0, 0, 0, 0, 1, 1, //aktywacja zegara antylegionella
39:                0, 0, 0, 0, 0, 0, 1, 0, //wybor typu kotla
40:                0, 0, 0, 0, 0, 0, 1, 1, //aktywacja czujnika przeplywu
41:                0, 0, 0, 0, 0, 0, 1, 1, //ogrzewanie podlogowe
42:                0, 0, 0, 0, 0, 0, 1, 1, //wybor rodzaju czujnika cisnienia
43:                0, 0, 0, 0, 0, 0, 1, 1, //rodzaj pompy
44:                0, 0, 0, 0, 0, 0, 1, 1, //delta T dla pompy
45:                0, 0, 0, 0, 0, 0, 1, 1, //minimalny wydatek pompy
46:                0, 0, 0, 0, 0, 0, 1, 1  //maksymalny wydatek pompy            
47:            };
48:            /*---------------------------------------------------------------------------------*/
49:            //Odblokowanie procedury wejsciowej konfiguracji
50:            //po uruchomieniu sterownika na pozycji OFF
51:            //UEAGA: umiescic przed petla glowna
52:            
53:            void EnKonf(void)
54:            {
55:                DtKNFf_enknf = 1; //odblokuj mozliwosc wejscia do konf.(znacznik wysylany w RefLCDData())
F192  8E05     BSF DtKNFf_enknf, 7, ACCESS
56:                DtKNF.KRK = 0;
F194  0100     MOVLB 0x0
F196  6B99     CLRF _PFNf_toInit, BANKED
57:                DtKNF.PRM = 0;
F198  6B98     CLRF DtKNF, BANKED
58:                PFNf_enKNF = 1;
F19A  880D     BSF PFNf_b_str_nco, 4, ACCESS
59:                PFNf_aktywne_KNF = 0;
F19C  940C     BCF PFNf_b_set_nco, 2, ACCESS
60:                StartRTS(_RTKONF1); //start zegara dla czasu w ktorym mozna aktywowac procedure konfiguracji
F19E  0E00     MOVLW 0x0
F1A0  EC60     CALL 0xE4C0, 0
F1A2  F072     NOP
61:            }
F1A4  0012     RETURN 0
62:            /*---------------------------------------------------------------------------------*/
63:            //wyjscie z procedury konfiguracji po modyfikacji parametrow
64:            
65:            void ExitKonf(void)
66:            {
67:                PFNf_aktywne_KNF = 0;
E89E  940C     BCF PFNf_b_set_nco, 2, ACCESS
68:                Mf_AKTYWNE_KNF = 0;
E8A0  9806     BCF DtKNFf_wymCO, 4, ACCESS
69:                DtKNFf_wymCO = 0; //wylacz wymuszenie CO
E8A2  9006     BCF DtKNFf_wymCO, 0, ACCESS
70:                DtKNFf_wymCW = 0;
E8A4  9206     BCF DtKNFf_wymCO, 1, ACCESS
71:                EndPR(); //wygas wskaz parametru
E8A6  ECEA     CALL 0xF3D4, 0
E8A8  F079     NOP
72:                DtKNF.PRM = 0;
E8AA  0100     MOVLB 0x0
E8AC  6B98     CLRF DtKNF, BANKED
73:                DtKNF.KRK = 0;
E8AE  0100     MOVLB 0x0
E8B0  6B99     CLRF _PFNf_toInit, BANKED
74:                WaitToLowEx(&ky[S_OFF]);
E8B2  0E14     MOVLW 0x14
E8B4  0100     MOVLB 0x0
E8B6  6FDE     MOVWF __pcstackBANK0, BANKED
E8B8  0E02     MOVLW 0x2
E8BA  6FDF     MOVWF pco, BANKED
E8BC  EC10     CALL 0xEE20, 0
E8BE  F077     NOP
75:                WaitToLowEx(&ky[S_SET]);
E8C0  0E19     MOVLW 0x19
E8C2  0100     MOVLB 0x0
E8C4  6FDE     MOVWF __pcstackBANK0, BANKED
E8C6  0E02     MOVLW 0x2
E8C8  6FDF     MOVWF pco, BANKED
E8CA  EC10     CALL 0xEE20, 0
E8CC  F077     NOP
76:                PFNf_KnfDisErr = 0;
E8CE  920C     BCF PFNf_b_set_nco, 1, ACCESS
77:            }
E8D0  0012     RETURN 0
78:            unsigned int nrp = 0;
79:            unsigned char zm, zp;
80:            
81:            void UpdateKnfPar(unsigned char par)
B69C  0100     MOVLB 0x0
B69E  6FDE     MOVWF __pcstackBANK0, BANKED
82:            {
83:                switch(par)
B6A0  D04F     BRA 0xB740
B740  0100     MOVLB 0x0
B742  51DE     MOVF __pcstackBANK0, W, BANKED
B744  E0AE     BZ 0xB6A2
B746  0A01     XORLW 0x1
B748  E0AF     BZ 0xB6A8
B74A  0A03     XORLW 0x3
B74C  E0B0     BZ 0xB6AE
B74E  0A01     XORLW 0x1
B750  E0B1     BZ 0xB6B4
B752  0A07     XORLW 0x7
B754  E0B2     BZ 0xB6BA
B756  0A01     XORLW 0x1
B758  E0B3     BZ 0xB6C0
B75A  0A03     XORLW 0x3
B75C  E0BC     BZ 0xB6D6
B75E  0A01     XORLW 0x1
B760  E0BD     BZ 0xB6DC
B762  0A0F     XORLW 0xF
B764  E0BE     BZ 0xB6E2
B766  0A01     XORLW 0x1
B768  E0BF     BZ 0xB6E8
B76A  0A03     XORLW 0x3
B76C  E0CC     BZ 0xB706
B76E  0A01     XORLW 0x1
B770  E0CD     BZ 0xB70C
B772  0A07     XORLW 0x7
B774  A4D8     BTFSS STATUS, 2, ACCESS
B776  0012     RETURN 0
B778  D7D6     BRA 0xB726
84:                {
85:                    case 0:
86:                        DtKNF.mstr = PZK[0].dta;
B6A2  C285     MOVFF PZK, _PFNf_trbECO
B6A4  F09A     NOP
87:                        break;
B6A6  0012     RETURN 0
88:                    case 1:
89:                        DtKNF.mxcw = PZK[1].dta;
B6A8  C28E     MOVFF 0x28E, _PFNf_zima
B6AA  F09B     NOP
90:                        break;
B6AC  0012     RETURN 0
91:                    case 2:
92:                        DtKNF.mxco = PZK[2].dta;
B6AE  C297     MOVFF 0x297, _PWMf_ENOSC
B6B0  F09C     NOP
93:                        break;
B6B2  0012     RETURN 0
94:                    case 3:
95:                        DtKNF.rdgz = PZK[3].dta;
B6B4  C2A0     MOVFF 0x2A0, _PWMf_tpGZ
B6B6  F09F     NOP
96:                        break;
B6B8  0012     RETURN 0
97:                    case 4:
98:                        DtKNF.aleg = PZK[4].dta;
B6BA  C2A9     MOVFF 0x2A9, _rglf_del1s
B6BC  F0A9     NOP
99:                        break;
B6BE  0012     RETURN 0
100:                   case 5:
101:                       DtKNF.tpkt = PZK[5].dta;
B6C0  C2B2     MOVFF 0x2B2, _PWMf_ENPWM2
B6C2  F09E     NOP
102:                       if(DtKNF.tpkt==_UNICO)
B6C4  0100     MOVLB 0x0
B6C6  519E     MOVF _PWMf_ENPWM2, W, BANKED
B6C8  E103     BNZ 0xB6D0
103:                       {
104:                           PZK[4].shw=1;
B6CA  0102     MOVLB 0x2
B6CC  87B1     BSF 0xB1, 3, BANKED
105:                       }
B6CE  0012     RETURN 0
106:                       else
107:                       {
108:                           PZK[4].shw=0;        
B6D0  0102     MOVLB 0x2
B6D2  97B1     BCF 0xB1, 3, BANKED
109:                       }            
110:                       break;
B6D4  0012     RETURN 0
111:                   case 6:
112:                       DtKNF.robg = PZK[6].dta;
B6D6  C2BB     MOVFF 0x2BB, _mux
B6D8  F0A6     NOP
113:                       break;
B6DA  0012     RETURN 0
114:                   case 7:
115:                       DtKNF.opdg = PZK[7].dta;
B6DC  C2C4     MOVFF 0x2C4, _rglf_btco
B6DE  F0A7     NOP
116:                       break;
B6E0  0012     RETURN 0
117:                   case 8:
118:                       DtKNF.tpcs = PZK[8].dta;
B6E2  C2CD     MOVFF 0x2CD, _rglf_btcw
B6E4  F0A8     NOP
119:                       break;
B6E6  0012     RETURN 0
120:                   case 9:
121:                   {
122:                       DtKNF.rdpm = PZK[9].dta;
B6E8  C2D6     MOVFF 0x2D6, _UADtf_RData
B6EA  F0A0     NOP
123:                       if(!DtKNF.rdpm)
B6EC  0100     MOVLB 0x0
B6EE  51A0     MOVF _UADtf_RData, W, BANKED
B6F0  E105     BNZ 0xB6FC
124:                       {
125:                           PZK[10].shw=0;
B6F2  0102     MOVLB 0x2
B6F4  97E7     BCF sign, 3, BANKED
126:                           PZK[11].shw=0;
B6F6  97F0     BCF p, 3, BANKED
127:                           PZK[12].shw=0;        
B6F8  97F9     BCF fst, 3, BANKED
128:                       }
B6FA  0012     RETURN 0
129:                       else
130:                       {
131:                           PZK[10].shw=1;
B6FC  0102     MOVLB 0x2
B6FE  87E7     BSF sign, 3, BANKED
132:                           PZK[11].shw=1;
B700  87F0     BSF p, 3, BANKED
133:                           PZK[12].shw=1;          
B702  87F9     BSF fst, 3, BANKED
134:                       }            
135:                       break;
B704  0012     RETURN 0
136:                   }
137:                   case 10:
138:                       DtKNF.dtpm = PZK[10].dta;
B706  C2DF     MOVFF 0x2DF, _UADtf_REnd
B708  F0A1     NOP
139:                       break;
B70A  0012     RETURN 0
140:                   case 11:
141:                       DtKNF.mdpm = PZK[11].dta;
B70C  C2E8     MOVFF 0x2E8, _UADtf_RErrBUF
B70E  F0A2     NOP
142:                       if(DtKNF.mdpm>DtKNF.mgpm)
B710  0100     MOVLB 0x0
B712  51A2     MOVF _UADtf_RErrBUF, W, BANKED
B714  5DA3     SUBWF _UADtf_RErrREC, W, BANKED
B716  B0D8     BTFSC STATUS, 0, ACCESS
B718  0012     RETURN 0
143:                       {
144:                           if(DtKNF.mgpm>=_KMINMNP) DtKNF.mdpm=DtKNF.mgpm;
B71A  0E0E     MOVLW 0xE
B71C  65A3     CPFSGT _UADtf_RErrREC, BANKED
B71E  0C0E     RETLW 0xE
B720  C0A3     MOVFF _UADtf_RErrREC, _UADtf_RErrBUF
B722  F0A2     NOP
145:                       }
146:                       break;
B724  0012     RETURN 0
147:                   case 12:
148:                       DtKNF.mgpm = PZK[12].dta;
B726  C2F1     MOVFF 0x2F1, _UADtf_RErrREC
B728  F0A3     NOP
149:                       if(DtKNF.mgpm<DtKNF.mdpm)
B72A  0100     MOVLB 0x0
B72C  51A2     MOVF _UADtf_RErrBUF, W, BANKED
B72E  5DA3     SUBWF _UADtf_RErrREC, W, BANKED
B730  B0D8     BTFSC STATUS, 0, ACCESS
B732  0012     RETURN 0
150:                       {
151:                           if(DtKNF.mdpm<=_KMAXMXP) DtKNF.mgpm=DtKNF.mdpm;
B734  0E64     MOVLW 0x64
B736  61A2     CPFSLT _UADtf_RErrBUF, BANKED
B738  0C64     RETLW 0x64
B73A  C0A2     MOVFF _UADtf_RErrBUF, _UADtf_RErrREC
B73C  F0A3     NOP
152:                       }    
153:                       break;            
154:               }
B73E  0012     RETURN 0
155:           }
B77A  0012     RETURN 0
156:           
157:           void ReadAllPar(void)
158:           {
159:               PZK[0].dta = PZK[0].bfdta = DtKNF.mstr;
9FE6  C09A     MOVFF _PFNf_trbECO, 0x28B
9FE8  F28B     NOP
9FEA  0102     MOVLB 0x2
9FEC  6B8C     CLRF _PFNf_prn_in, BANKED
9FEE  C28B     MOVFF 0x28B, PZK
9FF0  F285     NOP
9FF2  C28C     MOVFF 0x28C, 0x286
9FF4  F286     NOP
160:               PZK[0].min = _KMINMST;
9FF6  0102     MOVLB 0x2
9FF8  6B88     CLRF _PFNf_plmCO, BANKED
9FFA  6B87     CLRF _PFNf_pgd, BANKED
161:               PZK[0].max = _KMAXMST;
9FFC  6B8A     CLRF _PFNf_pmpPWM, BANKED
9FFE  0E63     MOVLW 0x63
A000  6F89     MOVWF _PFNf_plmCW, BANKED
162:               PZK[1].dta = PZK[1].bfdta = DtKNF.mxcw;
A002  C09B     MOVFF _PFNf_zima, 0x294
A004  F294     NOP
A006  0102     MOVLB 0x2
A008  6B95     CLRF _PFNf_str_nco, BANKED
A00A  C294     MOVFF 0x294, 0x28E
A00C  F28E     NOP
A00E  C295     MOVFF 0x295, 0x28F
A010  F28F     NOP
163:               PZK[1].min = _KMINMCW;
A012  6B91     CLRF _PFNf_set_aleg, BANKED
A014  6B90     CLRF _PFNf_res, BANKED
164:               PZK[1].max = _KMAXMCW;
A016  6B93     CLRF _PFNf_set_nco, BANKED
A018  0E63     MOVLW 0x63
A01A  6F92     MOVWF _PFNf_set_fnserw, BANKED
165:               PZK[2].dta = PZK[2].bfdta = DtKNF.mxco;
A01C  C09C     MOVFF _PWMf_ENOSC, 0x29D
A01E  F29D     NOP
A020  0102     MOVLB 0x2
A022  6B9E     CLRF _PWMf_ENPWM2, BANKED
A024  C29D     MOVFF 0x29D, 0x297
A026  F297     NOP
A028  C29E     MOVFF 0x29E, 0x298
A02A  F298     NOP
166:               PZK[2].min = _KMINMCO;
A02C  6B9A     CLRF _PFNf_trbECO, BANKED
A02E  6B99     CLRF _PFNf_toInit, BANKED
167:               PZK[2].max = _KMAXMCO;
A030  6B9C     CLRF _PWMf_ENOSC, BANKED
A032  0E63     MOVLW 0x63
A034  6F9B     MOVWF _PFNf_zima, BANKED
168:               PZK[3].dta = PZK[3].bfdta = DtKNF.rdgz;
A036  C09F     MOVFF _PWMf_tpGZ, 0x2A6
A038  F2A6     NOP
A03A  0102     MOVLB 0x2
A03C  6BA7     CLRF _rglf_btco, BANKED
A03E  C2A6     MOVFF 0x2A6, 0x2A0
A040  F2A0     NOP
A042  C2A7     MOVFF 0x2A7, 0x2A1
A044  F2A1     NOP
169:               PZK[3].min = _KMINRGZ;
A046  6BA3     CLRF _UADtf_RErrREC, BANKED
A048  6BA2     CLRF _UADtf_RErrBUF, BANKED
170:               PZK[3].max = _KMAXRGZ;
A04A  6BA5     CLRF _UADtf_TEnd, BANKED
A04C  0E01     MOVLW 0x1
A04E  6FA4     MOVWF _UADtf_TData, BANKED
171:               PZK[4].dta = PZK[4].bfdta = DtKNF.aleg;
A050  C0A9     MOVFF _rglf_del1s, 0x2AF
A052  F2AF     NOP
A054  0102     MOVLB 0x2
A056  6BB0     CLRF 0xB0, BANKED
A058  C2AF     MOVFF 0x2AF, 0x2A9
A05A  F2A9     NOP
A05C  C2B0     MOVFF 0x2B0, 0x2AA
A05E  F2AA     NOP
172:               PZK[4].min = _KMINEAL;
A060  0E00     MOVLW 0x0
A062  6FAC     MOVWF _rglf_fz, BANKED
A064  6FAB     MOVWF _rglf_fast_up, BANKED
173:               PZK[4].max = _KMAXEAL;
A066  6FAE     MOVWF _rglf_med_up, BANKED
A068  0E01     MOVLW 0x1
A06A  6FAD     MOVWF _rglf_inv_mod, BANKED
174:               if(DtKNF.tpkt==_UNICO)
A06C  0100     MOVLB 0x0
A06E  519E     MOVF _PWMf_ENPWM2, W, BANKED
A070  E103     BNZ 0xA078
175:               {
176:                   PZK[4].shw=1;
A072  0102     MOVLB 0x2
A074  87B1     BSF 0xB1, 3, BANKED
177:               }
A076  D002     BRA 0xA07C
178:               else
179:               {
180:                   PZK[4].shw=0;        
A078  0102     MOVLB 0x2
A07A  97B1     BCF 0xB1, 3, BANKED
181:               }    
182:               PZK[5].dta = PZK[5].bfdta = DtKNF.tpkt;
A07C  C09E     MOVFF _PWMf_ENPWM2, 0x2B8
A07E  F2B8     NOP
A080  0102     MOVLB 0x2
A082  6BB9     CLRF 0xB9, BANKED
A084  C2B8     MOVFF 0x2B8, 0x2B2
A086  F2B2     NOP
A088  C2B9     MOVFF 0x2B9, 0x2B3
A08A  F2B3     NOP
183:               PZK[5].min = _KMINWTK;
A08C  0102     MOVLB 0x2
A08E  6BB5     CLRF 0xB5, BANKED
A090  6BB4     CLRF 0xB4, BANKED
184:               PZK[5].max = _KMAXWTK;
A092  6BB7     CLRF UADt, BANKED
A094  0E03     MOVLW 0x3
A096  6FB6     MOVWF 0xB6, BANKED
185:               PZK[5].shw = (_KNF) ? 0 : 1;
A098  0102     MOVLB 0x2
A09A  87BA     BSF 0xBA, 3, BANKED
A09C  BC81     BTFSC PORTB, 6, ACCESS
A09E  97BA     BCF 0xBA, 3, BANKED
186:               if(PZK[5].shw) DtKNF.PRM = nrp = 5; //aktywny parametr - wybor typu kotla
A0A0  0102     MOVLB 0x2
A0A2  A7BA     BTFSS 0xBA, 3, BANKED
A0A4  D004     BRA 0xA0AE
A0A6  0101     MOVLB 0x1
A0A8  6BFD     CLRF 0xFD, BANKED
A0AA  0E05     MOVLW 0x5
A0AC  D003     BRA 0xA0B4
187:               else DtKNF.PRM = nrp = 0; //aktywny pierwszy parametr
A0AE  0E00     MOVLW 0x0
A0B0  0101     MOVLB 0x1
A0B2  6BFD     CLRF 0xFD, BANKED
A0B4  6FFC     MOVWF 0xFC, BANKED
A0B6  C1FC     MOVFF nrp, DtKNF
A0B8  F098     NOP
A0BA  D000     BRA 0xA0BC
188:              
189:               PZK[6].dta = PZK[6].bfdta = DtKNF.robg;
A0BC  C0A6     MOVFF _mux, 0x2C1
A0BE  F2C1     NOP
A0C0  0102     MOVLB 0x2
A0C2  6BC2     CLRF LedData, BANKED
A0C4  C2C1     MOVFF 0x2C1, 0x2BB
A0C6  F2BB     NOP
A0C8  C2C2     MOVFF 0x2C2, 0x2BC
A0CA  F2BC     NOP
190:               PZK[6].min = _KMINOBG;
A0CC  6BBE     CLRF 0xBE, BANKED
A0CE  6BBD     CLRF 0xBD, BANKED
191:               PZK[6].max = _KMAXOBG;
A0D0  6BC0     CLRF 0xC0, BANKED
A0D2  0E01     MOVLW 0x1
A0D4  6FBF     MOVWF CommRT, BANKED
192:               PZK[7].dta = PZK[7].bfdta = DtKNF.opdg;
A0D6  C0A7     MOVFF _rglf_btco, 0x2CA
A0D8  F2CA     NOP
A0DA  0102     MOVLB 0x2
A0DC  6BCB     CLRF DtCS, BANKED
A0DE  C2CA     MOVFF 0x2CA, 0x2C4
A0E0  F2C4     NOP
A0E2  C2CB     MOVFF 0x2CB, 0x2C5
A0E4  F2C5     NOP
193:               PZK[7].min = _KMINOGP;
A0E6  6BC7     CLRF s, BANKED
A0E8  6BC6     CLRF 0xC6, BANKED
194:               PZK[7].max = _KMAXOGP;
A0EA  6BC9     CLRF iu, BANKED
A0EC  0E01     MOVLW 0x1
A0EE  6FC8     MOVWF pcs, BANKED
195:               PZK[8].dta = PZK[8].bfdta = DtKNF.tpcs;
A0F0  C0A8     MOVFF _rglf_btcw, 0x2D3
A0F2  F2D3     NOP
A0F4  0102     MOVLB 0x2
A0F6  6BD4     CLRF 0xD4, BANKED
A0F8  C2D3     MOVFF 0x2D3, 0x2CD
A0FA  F2CD     NOP
A0FC  C2D4     MOVFF 0x2D4, 0x2CE
A0FE  F2CE     NOP
196:               PZK[8].min = _KMINTCS;
A100  6BD0     CLRF 0xD0, BANKED
A102  6BCF     CLRF DtCO, BANKED
197:               PZK[8].max = _KMAXTCS;
A104  6BD2     CLRF 0xD2, BANKED
A106  0E01     MOVLW 0x1
A108  6FD1     MOVWF 0xD1, BANKED
198:               PZK[9].dta = PZK[9].bfdta = DtKNF.rdpm;
A10A  C0A0     MOVFF _UADtf_RData, 0x2DC
A10C  F2DC     NOP
A10E  0102     MOVLB 0x2
A110  6BDD     CLRF zmn, BANKED
A112  C2DC     MOVFF 0x2DC, 0x2D6
A114  F2D6     NOP
A116  C2DD     MOVFF 0x2DD, 0x2D7
A118  F2D7     NOP
199:               PZK[9].min = _KMINRDP;
A11A  0E00     MOVLW 0x0
A11C  6FD9     MOVWF 0xD9, BANKED
A11E  6FD8     MOVWF 0xD8, BANKED
200:               PZK[9].max = _KMAXRDP;
A120  6FDB     MOVWF 0xDB, BANKED
A122  0E01     MOVLW 0x1
A124  6FDA     MOVWF 0xDA, BANKED
201:               if(!DtKNF.rdpm)
A126  0100     MOVLB 0x0
A128  51A0     MOVF _UADtf_RData, W, BANKED
A12A  E105     BNZ 0xA136
202:               {
203:                   PZK[10].shw=0;
A12C  0102     MOVLB 0x2
A12E  97E7     BCF sign, 3, BANKED
204:                   PZK[11].shw=0;
A130  97F0     BCF p, 3, BANKED
205:                   PZK[12].shw=0;        
A132  97F9     BCF fst, 3, BANKED
206:               }
A134  D004     BRA 0xA13E
207:               else
208:               {
209:                   PZK[10].shw=1;
A136  0102     MOVLB 0x2
A138  87E7     BSF sign, 3, BANKED
210:                   PZK[11].shw=1;
A13A  87F0     BSF p, 3, BANKED
211:                   PZK[12].shw=1;          
A13C  87F9     BSF fst, 3, BANKED
212:               }
213:               PZK[10].dta = PZK[10].bfdta = DtKNF.dtpm;
A13E  C0A1     MOVFF _UADtf_REnd, 0x2E5
A140  F2E5     NOP
A142  0102     MOVLB 0x2
A144  6BE6     CLRF counter, BANKED
A146  C2E5     MOVFF 0x2E5, 0x2DF
A148  F2DF     NOP
A14A  C2E6     MOVFF 0x2E6, 0x2E0
A14C  F2E0     NOP
214:               PZK[10].min = _KMINDLP;
A14E  0102     MOVLB 0x2
A150  6BE2     CLRF divisor, BANKED
A152  0E05     MOVLW 0x5
A154  6FE1     MOVWF GIE_BIT_VAL, BANKED
215:               PZK[10].max = _KMAXDLP;
A156  6BE4     CLRF k, BANKED
A158  0E19     MOVLW 0x19
A15A  6FE3     MOVWF a, BANKED
216:               PZK[11].dta = PZK[11].bfdta = DtKNF.mdpm;
A15C  C0A2     MOVFF _UADtf_RErrBUF, 0x2EE
A15E  F2EE     NOP
A160  0102     MOVLB 0x2
A162  6BEF     CLRF 0xEF, BANKED
A164  C2EE     MOVFF 0x2EE, 0x2E8
A166  F2E8     NOP
A168  C2EF     MOVFF 0x2EF, 0x2E9
A16A  F2E9     NOP
217:               PZK[11].min = _KMINMNP;
A16C  6BEB     CLRF pop, BANKED
A16E  0E0F     MOVLW 0xF
A170  6FEA     MOVWF tim, BANKED
218:               PZK[11].max = _KMAXMNP;
A172  6BED     CLRF min, BANKED
A174  0E63     MOVLW 0x63
A176  6FEC     MOVWF dt, BANKED
219:               PZK[12].dta = PZK[12].bfdta = DtKNF.mgpm;
A178  C0A3     MOVFF _UADtf_RErrREC, 0x2F7
A17A  F2F7     NOP
A17C  0102     MOVLB 0x2
A17E  6BF8     CLRF step2, BANKED
A180  C2F7     MOVFF 0x2F7, 0x2F1
A182  F2F1     NOP
A184  C2F8     MOVFF 0x2F8, 0x2F2
A186  F2F2     NOP
220:               PZK[12].min = _KMINMXP;
A188  6BF4     CLRF pco, BANKED
A18A  0E0F     MOVLW 0xF
A18C  6FF3     MOVWF min, BANKED
221:               PZK[12].max = _KMAXMXP;    
A18E  6BF6     CLRF ehi, BANKED
A190  0E63     MOVLW 0x63
A192  6FF5     MOVWF max, BANKED
222:           }
A194  0012     RETURN 0
223:           //Obsluga parametrow modyfikowanych dynamicznie
224:           
225:           void RunDynamicParam(unsigned char prm, unsigned char ddta)
D7B0  0100     MOVLB 0x0
D7B2  6FF7     MOVWF step, BANKED
226:           {
227:               //Parametry modyfikowane dynamicznie
228:               switch(prm)
D7B4  D026     BRA 0xD802
D802  0100     MOVLB 0x0
D804  51F7     MOVF step, W, BANKED
D806  E0D7     BZ 0xD7B6
D808  0A01     XORLW 0x1
D80A  E0DE     BZ 0xD7C8
D80C  0A03     XORLW 0x3
D80E  A4D8     BTFSS STATUS, 2, ACCESS
D810  0012     RETURN 0
D812  D7EE     BRA 0xD7F0
229:               {
230:                       //moc startowa (0...99)
231:                   case 0:
232:                   {
233:                       DtKNF.mstr = ddta; //dana dynamiczna
D7B6  C0F6     MOVFF ehi, _PFNf_trbECO
D7B8  F09A     NOP
234:                       MocStart(DtKNF.mstr);
D7BA  0100     MOVLB 0x0
D7BC  519A     MOVF _PFNf_trbECO, W, BANKED
D7BE  ECF0     CALL 0xBDE0, 0
D7C0  F05E     NOP
235:                       DtKNFf_wymCO = 1; //zalacz wymuszenie CO
D7C2  8006     BSF DtKNFf_wymCO, 0, ACCESS
236:                       DtKNFf_wymCW = 0; //wylacz wymuszenie CW
D7C4  9206     BCF DtKNFf_wymCO, 1, ACCESS
237:                       break;
D7C6  0012     RETURN 0
238:                   }
239:                       //moc maksymalna WU (0...99)
240:                   case 1:
241:                   {
242:                       DtKNF.mxcw = ddta; //dana dynamiczna
D7C8  C0F6     MOVFF ehi, _PFNf_zima
D7CA  F09B     NOP
243:                       MocMaksCW(DtKNF.mxcw);
D7CC  0100     MOVLB 0x0
D7CE  519B     MOVF _PFNf_zima, W, BANKED
D7D0  EC37     CALL 0xCA6E, 0
D7D2  F065     NOP
244:                       DtKNFf_wymCO = 0; //wylacz wymuszenie CO
D7D4  9006     BCF DtKNFf_wymCO, 0, ACCESS
245:                       if(DtKNF.tpkt == _UNICO) //kociol UniCO?
D7D6  0100     MOVLB 0x0
D7D8  519E     MOVF _PWMf_ENPWM2, W, BANKED
D7DA  E102     BNZ 0xD7E0
246:                       {
247:                           DtKNFf_wymCW = 1; //zalacz wymuszenie CW niezaleznie od stanu czujnika przeplywu
D7DC  8206     BSF DtKNFf_wymCO, 1, ACCESS
248:                       }
D7DE  0012     RETURN 0
249:                       else
250:                       {
251:                           if(RdPrt(S_WCW)) DtKNFf_wymCW = 1; //zalacz wymuszenie CW dla aktywnego przeplywu
D7E0  0E0B     MOVLW 0xB
D7E2  ECFD     CALL 0xE7FA, 0
D7E4  F073     NOP
D7E6  E302     BNC 0xD7EC
D7E8  8206     BSF DtKNFf_wymCO, 1, ACCESS
D7EA  0012     RETURN 0
252:                           else DtKNFf_wymCW = 0;
D7EC  9206     BCF DtKNFf_wymCO, 1, ACCESS
253:                       }
254:                       break;
D7EE  0012     RETURN 0
255:                   }
256:                       //moc maksymalna WG (0...99)
257:                   case 2:
258:                   {
259:                       DtKNF.mxco = ddta; //dana dynamiczna
D7F0  C0F6     MOVFF ehi, _PWMf_ENOSC
D7F2  F09C     NOP
260:                       MocMaksCO(DtKNF.mxco);
D7F4  0100     MOVLB 0x0
D7F6  519C     MOVF _PWMf_ENOSC, W, BANKED
D7F8  EC7A     CALL 0xCAF4, 0
D7FA  F065     NOP
261:                       DtKNFf_wymCO = 1; //zalacz wymuszenie CO
D7FC  8006     BSF DtKNFf_wymCO, 0, ACCESS
262:                       DtKNFf_wymCW = 0; //wylacz wymuszenie CW
D7FE  9206     BCF DtKNFf_wymCO, 1, ACCESS
263:                       break;
264:                   }
265:               }
D800  0012     RETURN 0
266:           }
D814  0012     RETURN 0
267:           //Glowna procedura konfiguracji (wykonywana w petli glownej)
268:           
269:           void MKonfiguracja(void)
270:           {
271:               unsigned char key, fst;
272:           
273:               Mf_AKTYWNE_KNF = PFNf_aktywne_KNF;
2996  A40C     BTFSS PFNf_b_set_nco, 2, ACCESS
2998  D002     BRA 0x299E
299A  8806     BSF DtKNFf_wymCO, 4, ACCESS
299C  D001     BRA 0x29A0
299E  9806     BCF DtKNFf_wymCO, 4, ACCESS
274:           
275:               //wyzerowanie flagi zezwolenia na aktywacje trybu konfiguracji
276:               if(PFNf_enKNF && (PFNf_aktywne_KNF || (RTS(_RTKONF1) >= _TKNFDIS))) //konfiguracja juz aktywna lub uplynal czas mozliwosci wejscia do konf.?
29A0  A80D     BTFSS PFNf_b_str_nco, 4, ACCESS
29A2  D00C     BRA 0x29BC
29A4  B40C     BTFSC PFNf_b_set_nco, 2, ACCESS
29A6  D008     BRA 0x29B8
29A8  0E00     MOVLW 0x0
29AA  ECA9     CALL 0xEB52, 0
29AC  F075     NOP
29AE  0103     MOVLB 0x3
29B0  6F86     MOVWF _PFNf_opgres, BANKED
29B2  0E13     MOVLW 0x13
29B4  6586     CPFSGT _PFNf_opgres, BANKED
29B6  D002     BRA 0x29BC
277:               {
278:                   DtKNFf_enknf = 0;
29B8  9E05     BCF DtKNFf_enknf, 7, ACCESS
279:                   PFNf_enKNF = 0;
29BA  980D     BCF PFNf_b_str_nco, 4, ACCESS
280:               }
281:           
282:               if(PFNf_aktywne_KNF && ((RTM(_RTKONF3) >= _TKNFEXT) || PFNf_opgres)) //uplynol maksymalny dozwolony czas aktywnosci procedury lub wylaczenie awaryjne z blokada w ukladzie UNI-02?
29BC  A40C     BTFSS PFNf_b_set_nco, 2, ACCESS
29BE  D2AB     BRA 0x2F16
29C0  0E00     MOVLW 0x0
29C2  ECC0     CALL 0xEB80, 0
29C4  F075     NOP
29C6  0103     MOVLB 0x3
29C8  6F86     MOVWF _PFNf_opgres, BANKED
29CA  0E0A     MOVLW 0xA
29CC  6186     CPFSLT _PFNf_opgres, BANKED
29CE  D002     BRA 0x29D4
29D0  AC10     BTFSS PFNf_ofnserw, 6, ACCESS
29D2  D2A1     BRA 0x2F16
283:               {
284:                   ExitKonf();
29D4  EC4F     CALL 0xE89E, 0
29D6  F074     NOP
285:                   return;
29D8  0012     RETURN 0
286:               }
287:               switch(DtKNF.KRK)
29DA  D29D     BRA 0x2F16
2F16  0100     MOVLB 0x0
2F18  5199     MOVF _PFNf_toInit, W, BANKED
2F1A  E101     BNZ 0x2F1E
2F1C  D55F     BRA 0x29DC
2F1E  0A01     XORLW 0x1
2F20  E101     BNZ 0x2F24
2F22  D5A8     BRA 0x2A74
2F24  0A03     XORLW 0x3
2F26  E101     BNZ 0x2F2A
2F28  D684     BRA 0x2C32
2F2A  0A01     XORLW 0x1
2F2C  A4D8     BTFSS STATUS, 2, ACCESS
2F2E  0012     RETURN 0
2F30  D7EB     BRA 0x2F08
288:               {
289:                       //warunek wejscia do procedury modyfikacji parametrow
290:                   case 0:
291:                   {
292:                       if(!PFNf_off || !PFNf_enKNF) return; //aktywny tryb OFF?
29DC  BE0F     BTFSC PFNf_off, 7, ACCESS
29DE  A80D     BTFSS PFNf_b_str_nco, 4, ACCESS
29E0  0012     RETURN 0
29E2  D001     BRA 0x29E6
29E4  0012     RETURN 0
293:           
294:                       //przytrzymano przycisk wejscia do procedury konfiguracji
295:                       key = PresKeyEX(RdPrt(S_OFF) && RdPrt(S_SET), &ky[SS_OFF_SET]);
29E6  0103     MOVLB 0x3
29E8  6B8C     CLRF _PFNf_prn_in, BANKED
29EA  0E16     MOVLW 0x16
29EC  ECFD     CALL 0xE7FA, 0
29EE  F073     NOP
29F0  E308     BNC 0x2A02
29F2  0E17     MOVLW 0x17
29F4  ECFD     CALL 0xE7FA, 0
29F6  F073     NOP
29F8  E304     BNC 0x2A02
29FA  0E01     MOVLW 0x1
29FC  0103     MOVLB 0x3
29FE  6F8C     MOVWF _PFNf_prn_in, BANKED
2A00  D000     BRA 0x2A02
2A02  0EC4     MOVLW 0xC4
2A04  0100     MOVLB 0x0
2A06  6FE0     MOVWF bdat, BANKED
2A08  0E01     MOVLW 0x1
2A0A  6FE1     MOVWF GIE_BIT_VAL, BANKED
2A0C  0103     MOVLB 0x3
2A0E  518C     MOVF _PFNf_prn_in, W, BANKED
2A10  ECAB     CALL 0x8556, 0
2A12  F042     NOP
2A14  0103     MOVLB 0x3
2A16  6F8D     MOVWF _PFNf_prn_res, BANKED
296:           
297:                       if(key != 100 && key >= 50)
2A18  0E64     MOVLW 0x64
2A1A  0103     MOVLB 0x3
2A1C  198D     XORWF _PFNf_prn_res, W, BANKED
2A1E  E025     BZ 0x2A6A
2A20  0E31     MOVLW 0x31
2A22  658D     CPFSGT _PFNf_prn_res, BANKED
2A24  D022     BRA 0x2A6A
298:                       {
299:                           WaitToLowEx(&ky[SS_OFF_SET]);
2A26  0EC4     MOVLW 0xC4
2A28  0100     MOVLB 0x0
2A2A  6FDE     MOVWF __pcstackBANK0, BANKED
2A2C  0E01     MOVLW 0x1
2A2E  6FDF     MOVWF pco, BANKED
2A30  EC10     CALL 0xEE20, 0
2A32  F077     NOP
300:                           WaitToLowEx(&ky[SS_OFF]);
2A34  0EA6     MOVLW 0xA6
2A36  0100     MOVLB 0x0
2A38  6FDE     MOVWF __pcstackBANK0, BANKED
2A3A  0E01     MOVLW 0x1
2A3C  6FDF     MOVWF pco, BANKED
2A3E  EC10     CALL 0xEE20, 0
2A40  F077     NOP
301:                           WaitToLowEx(&ky[SS_SET]);
2A42  0EAB     MOVLW 0xAB
2A44  0100     MOVLB 0x0
2A46  6FDE     MOVWF __pcstackBANK0, BANKED
2A48  0E01     MOVLW 0x1
2A4A  6FDF     MOVWF pco, BANKED
2A4C  EC10     CALL 0xEE20, 0
2A4E  F077     NOP
302:                           PFNf_aktywne_KNF = 1;
2A50  840C     BSF PFNf_b_set_nco, 2, ACCESS
303:                           ReadAllPar(); //wstepny odczyt aktualnych wartosci parametrow
2A52  ECF3     CALL 0x9FE6, 0
2A54  F04F     NOP
304:                           StartRTM(_RTKONF3); //start timera aktywnosci proc. konfig
2A56  0E00     MOVLW 0x0
2A58  EC80     CALL 0xE500, 0
2A5A  F072     NOP
305:                           DtKNF.PRM = 0; //aktywacja pierwszego parametru
2A5C  0E00     MOVLW 0x0
2A5E  0100     MOVLB 0x0
2A60  6F98     MOVWF DtKNF, BANKED
306:                           DtKNF.KRK = 1; //aktywacja proc. konfiguracji
2A62  0E01     MOVLW 0x1
2A64  0100     MOVLB 0x0
2A66  6F99     MOVWF _PFNf_toInit, BANKED
307:                       }
2A68  0C01     RETLW 0x1
308:                       else
309:                       {
310:                           DtKNF.PRM = 0;
2A6A  0E00     MOVLW 0x0
2A6C  0100     MOVLB 0x0
2A6E  6F98     MOVWF DtKNF, BANKED
311:                           DtKNF.KRK = 0;
2A70  6F99     MOVWF _PFNf_toInit, BANKED
312:                           return;
313:                       }
314:                       break;
2A72  0012     RETURN 0
315:                   }
316:                       //wybor parametru
317:                   case 1:
318:                   {
319:                       DtKNFf_wymCO = 0; //wylacz wymuszenie CO
2A74  9006     BCF DtKNFf_wymCO, 0, ACCESS
320:                       DtKNFf_wymCW = 0; //wylacz wymuszenie CO
2A76  9206     BCF DtKNFf_wymCO, 1, ACCESS
321:                       PFNf_off = 1;
2A78  8E0F     BSF PFNf_off, 7, ACCESS
322:                       PFNf_lato = 0;
2A7A  9E0E     BCF PFNf_lato, 7, ACCESS
323:                       PFNf_zima = 0;
2A7C  9613     BCF PFNf_zima, 3, ACCESS
324:                       PFNf_KnfDisErr = 1;
2A7E  820C     BSF PFNf_b_set_nco, 1, ACCESS
325:                       if(PZK[nrp].shw) //parametr moze byc wyswietlony?
2A80  C1FC     MOVFF nrp, __pcstackBANK0
2A82  F0DE     NOP
2A84  C1FD     MOVFF 0x1FD, pco
2A86  F0DF     NOP
2A88  0100     MOVLB 0x0
2A8A  6BE1     CLRF GIE_BIT_VAL, BANKED
2A8C  0E09     MOVLW 0x9
2A8E  6FE0     MOVWF bdat, BANKED
2A90  EC5B     CALL 0xECB6, 0
2A92  F076     NOP
2A94  0E08     MOVLW 0x8
2A96  0100     MOVLB 0x0
2A98  27DE     ADDWF __pcstackBANK0, F, BANKED
2A9A  0E00     MOVLW 0x0
2A9C  23DF     ADDWFC pco, F, BANKED
2A9E  0E85     MOVLW 0x85
2AA0  25DE     ADDWF __pcstackBANK0, W, BANKED
2AA2  6ED9     MOVWF FSR2, ACCESS
2AA4  0E02     MOVLW 0x2
2AA6  21DF     ADDWFC pco, W, BANKED
2AA8  6EDA     MOVWF FSR2H, ACCESS
2AAA  A6DF     BTFSS INDF2, 3, ACCESS
2AAC  D023     BRA 0x2AF4
326:                       {
327:                           ReadParam(&nrp, &zm, &zp, 0, _KNPAR1 - 1, 1, 0);
2AAE  0EFC     MOVLW 0xFC
2AB0  0103     MOVLB 0x3
2AB2  6F75     MOVWF _PFNf_fns_max, BANKED
2AB4  0E01     MOVLW 0x1
2AB6  6F76     MOVWF _PFNf_fnserw, BANKED
2AB8  0EDC     MOVLW 0xDC
2ABA  6F77     MOVWF _PFNf_lato, BANKED
2ABC  0E00     MOVLW 0x0
2ABE  6F78     MOVWF _PFNf_mod_ncw, BANKED
2AC0  0EFE     MOVLW 0xFE
2AC2  6F79     MOVWF _PFNf_newPCO, BANKED
2AC4  0E01     MOVLW 0x1
2AC6  6F7A     MOVWF _PFNf_newPCW, BANKED
2AC8  6B7C     CLRF _PFNf_oaleg, BANKED
2ACA  6B7B     CLRF _PFNf_newPFN, BANKED
2ACC  6B7E     CLRF _PFNf_obgCW, BANKED
2ACE  0E0C     MOVLW 0xC
2AD0  6F7D     MOVWF _PFNf_obgCO, BANKED
2AD2  0E01     MOVLW 0x1
2AD4  6F7F     MOVWF _PFNf_off, BANKED
2AD6  6B80     CLRF _PFNf_oflato, BANKED
2AD8  EC3A     CALL 0x7674, 0
2ADA  F03B     NOP
328:                           DtKNF.PRM = nrp;
2ADC  C1FC     MOVFF nrp, DtKNF
2ADE  F098     NOP
329:                           if(zm==2||zm==3) RestartPR();
2AE0  0E02     MOVLW 0x2
2AE2  0100     MOVLB 0x0
2AE4  19DC     XORWF zm, W, BANKED
2AE6  E003     BZ 0x2AEE
2AE8  0E03     MOVLW 0x3
2AEA  19DC     XORWF zm, W, BANKED
2AEC  E139     BNZ 0x2B60
2AEE  ECE6     CALL 0xF3CC, 0
2AF0  F079     NOP
330:                       }
2AF2  D036     BRA 0x2B60
331:                       else
332:                       {
333:                           if(zm == 3) //zmiana w gore?
2AF4  0E03     MOVLW 0x3
2AF6  0100     MOVLB 0x0
2AF8  19DC     XORWF zm, W, BANKED
2AFA  E110     BNZ 0x2B1C
334:                           {
335:                               if(nrp < _KNPAR1 - 1) nrp++;
2AFC  0101     MOVLB 0x1
2AFE  51FD     MOVF 0xFD, W, BANKED
2B00  E108     BNZ 0x2B12
2B02  0E0C     MOVLW 0xC
2B04  5DFC     SUBWF 0xFC, W, BANKED
2B06  B0D8     BTFSC STATUS, 0, ACCESS
2B08  D004     BRA 0x2B12
2B0A  0101     MOVLB 0x1
2B0C  4BFC     INFSNZ 0xFC, F, BANKED
2B0E  2BFD     INCF 0xFD, F, BANKED
2B10  0012     RETURN 0
336:                               else nrp = 0;
2B12  0E00     MOVLW 0x0
2B14  0101     MOVLB 0x1
2B16  6FFD     MOVWF 0xFD, BANKED
2B18  6FFC     MOVWF 0xFC, BANKED
337:                           }
2B1A  0012     RETURN 0
338:                           else
339:                               if(zm == 2) //zmiana w dol?
2B1C  0E02     MOVLW 0x2
2B1E  0100     MOVLB 0x0
2B20  19DC     XORWF zm, W, BANKED
2B22  E10E     BNZ 0x2B40
340:                           {
341:                               if(nrp > 0) nrp--;
2B24  0101     MOVLB 0x1
2B26  51FC     MOVF 0xFC, W, BANKED
2B28  11FD     IORWF 0xFD, W, BANKED
2B2A  E004     BZ 0x2B34
2B2C  07FC     DECF 0xFC, F, BANKED
2B2E  A0D8     BTFSS STATUS, 0, ACCESS
2B30  07FD     DECF 0xFD, F, BANKED
2B32  0012     RETURN 0
342:                               else nrp = _KNPAR1 - 1;
2B34  0E00     MOVLW 0x0
2B36  0101     MOVLB 0x1
2B38  6FFD     MOVWF 0xFD, BANKED
2B3A  0E0C     MOVLW 0xC
2B3C  6FFC     MOVWF 0xFC, BANKED
343:                           }
2B3E  0012     RETURN 0
344:                           else //gdy pierwsze parametr ukryty
345:                           {
346:                               if(nrp < _KNPAR1 - 1) nrp++;
2B40  0101     MOVLB 0x1
2B42  51FD     MOVF 0xFD, W, BANKED
2B44  E108     BNZ 0x2B56
2B46  0E0C     MOVLW 0xC
2B48  5DFC     SUBWF 0xFC, W, BANKED
2B4A  B0D8     BTFSC STATUS, 0, ACCESS
2B4C  D004     BRA 0x2B56
2B4E  0101     MOVLB 0x1
2B50  4BFC     INFSNZ 0xFC, F, BANKED
2B52  2BFD     INCF 0xFD, F, BANKED
2B54  0012     RETURN 0
347:                               else nrp = 0;
2B56  0E00     MOVLW 0x0
2B58  0101     MOVLB 0x1
2B5A  6FFD     MOVWF 0xFD, BANKED
2B5C  6FFC     MOVWF 0xFC, BANKED
348:                           }
349:                           break;
2B5E  0012     RETURN 0
350:                       }
351:                       PrintPR(led_P, DtKNF.PRM + 1, 0); //kod rx
2B60  0100     MOVLB 0x0
2B62  2998     INCF DtKNF, W, BANKED
2B64  6FE6     MOVWF counter, BANKED
2B66  0E00     MOVLW 0x0
2B68  6FE7     MOVWF sign, BANKED
2B6A  0E1A     MOVLW 0x1A
2B6C  ECB2     CALL 0xAF64, 0
2B6E  F057     NOP
352:                       key = PresKeyEX(RdPrt(S_SET), &ky[SS_SET]);
2B70  0EAB     MOVLW 0xAB
2B72  0100     MOVLB 0x0
2B74  6FE0     MOVWF bdat, BANKED
2B76  0E01     MOVLW 0x1
2B78  6FE1     MOVWF GIE_BIT_VAL, BANKED
2B7A  0E17     MOVLW 0x17
2B7C  ECFD     CALL 0xE7FA, 0
2B7E  F073     NOP
2B80  0E01     MOVLW 0x1
2B82  A0D8     BTFSS STATUS, 0, ACCESS
2B84  0E00     MOVLW 0x0
2B86  ECAB     CALL 0x8556, 0
2B88  F042     NOP
2B8A  0103     MOVLB 0x3
2B8C  6F8D     MOVWF _PFNf_prn_res, BANKED
353:                       if(key > 0) //wybrano parametr
2B8E  0103     MOVLB 0x3
2B90  518D     MOVF _PFNf_prn_res, W, BANKED
2B92  E02D     BZ 0x2BEE
354:                       {
355:                           WaitToLowEx(&ky[SS_SET]);
2B94  0EAB     MOVLW 0xAB
2B96  0100     MOVLB 0x0
2B98  6FDE     MOVWF __pcstackBANK0, BANKED
2B9A  0E01     MOVLW 0x1
2B9C  6FDF     MOVWF pco, BANKED
2B9E  EC10     CALL 0xEE20, 0
2BA0  F077     NOP
356:                           WaitToLowEx(&ky[SS_OFF]);
2BA2  0EA6     MOVLW 0xA6
2BA4  0100     MOVLB 0x0
2BA6  6FDE     MOVWF __pcstackBANK0, BANKED
2BA8  0E01     MOVLW 0x1
2BAA  6FDF     MOVWF pco, BANKED
2BAC  EC10     CALL 0xEE20, 0
2BAE  F077     NOP
357:                           EndPR();
2BB0  ECEA     CALL 0xF3D4, 0
2BB2  F079     NOP
358:                           PZK[DtKNF.PRM].bfdta = PZK[DtKNF.PRM].dta;
2BB4  0100     MOVLB 0x0
2BB6  5198     MOVF DtKNF, W, BANKED
2BB8  0D09     MULLW 0x9
2BBA  0E85     MOVLW 0x85
2BBC  24F3     ADDWF PROD, W, ACCESS
2BBE  6ED9     MOVWF FSR2, ACCESS
2BC0  0E02     MOVLW 0x2
2BC2  20F4     ADDWFC PRODH, W, ACCESS
2BC4  6EDA     MOVWF FSR2H, ACCESS
2BC6  5198     MOVF DtKNF, W, BANKED
2BC8  0D09     MULLW 0x9
2BCA  0E06     MOVLW 0x6
2BCC  26F3     ADDWF PROD, F, ACCESS
2BCE  0E00     MOVLW 0x0
2BD0  22F4     ADDWFC PRODH, F, ACCESS
2BD2  0E85     MOVLW 0x85
2BD4  24F3     ADDWF PROD, W, ACCESS
2BD6  6EE1     MOVWF FSR1, ACCESS
2BD8  0E02     MOVLW 0x2
2BDA  20F4     ADDWFC PRODH, W, ACCESS
2BDC  6EE2     MOVWF FSR1H, ACCESS
2BDE  CFDE     MOVFF POSTINC2, POSTINC1
2BE0  FFE6     NOP
2BE2  CFDD     MOVFF POSTDEC2, POSTDEC1
2BE4  FFE5     NOP
359:                           DtKNF.KRK = 2; //tryb modyfikacji parametru
2BE6  0E02     MOVLW 0x2
2BE8  0100     MOVLB 0x0
2BEA  6F99     MOVWF _PFNf_toInit, BANKED
2BEC  D000     BRA 0x2BEE
360:                       }
361:                       key = PresKeyEX(RdPrt(S_OFF), &ky[SS_OFF]);
2BEE  0EA6     MOVLW 0xA6
2BF0  0100     MOVLB 0x0
2BF2  6FE0     MOVWF bdat, BANKED
2BF4  0E01     MOVLW 0x1
2BF6  6FE1     MOVWF GIE_BIT_VAL, BANKED
2BF8  0E16     MOVLW 0x16
2BFA  ECFD     CALL 0xE7FA, 0
2BFC  F073     NOP
2BFE  0E01     MOVLW 0x1
2C00  A0D8     BTFSS STATUS, 0, ACCESS
2C02  0E00     MOVLW 0x0
2C04  ECAB     CALL 0x8556, 0
2C06  F042     NOP
2C08  0103     MOVLB 0x3
2C0A  6F8D     MOVWF _PFNf_prn_res, BANKED
362:                       if(key != 100 && key >= 20)
2C0C  0E64     MOVLW 0x64
2C0E  0103     MOVLB 0x3
2C10  198D     XORWF _PFNf_prn_res, W, BANKED
2C12  B4D8     BTFSC STATUS, 2, ACCESS
2C14  0012     RETURN 0
2C16  0E13     MOVLW 0x13
2C18  658D     CPFSGT _PFNf_prn_res, BANKED
2C1A  0C13     RETLW 0x13
363:                       {
364:                           WaitToLowEx(&ky[SS_OFF]); //start timera zapisu
2C1C  0EA6     MOVLW 0xA6
2C1E  0100     MOVLB 0x0
2C20  6FDE     MOVWF __pcstackBANK0, BANKED
2C22  0E01     MOVLW 0x1
2C24  6FDF     MOVWF pco, BANKED
2C26  EC10     CALL 0xEE20, 0
2C28  F077     NOP
365:                           DtKNF.KRK = 3;
2C2A  0E03     MOVLW 0x3
2C2C  0100     MOVLB 0x0
2C2E  6F99     MOVWF _PFNf_toInit, BANKED
366:                       }
367:                       break;
2C30  0012     RETURN 0
368:                   }
369:                       //modyfikacji wartosci parametru
370:                   case 2:
371:                   {
372:                       PFNf_off = 0;
2C32  9E0F     BCF PFNf_off, 7, ACCESS
373:                       PFNf_lato = 1;
2C34  8E0E     BSF PFNf_lato, 7, ACCESS
374:                       PFNf_zima = 0;
2C36  9613     BCF PFNf_zima, 3, ACCESS
375:                       PFNf_KnfDisErr = PZK[DtKNF.PRM].no_msg;
2C38  0100     MOVLB 0x0
2C3A  5198     MOVF DtKNF, W, BANKED
2C3C  0D09     MULLW 0x9
2C3E  0E08     MOVLW 0x8
2C40  26F3     ADDWF PROD, F, ACCESS
2C42  0E00     MOVLW 0x0
2C44  22F4     ADDWFC PRODH, F, ACCESS
2C46  0E85     MOVLW 0x85
2C48  24F3     ADDWF PROD, W, ACCESS
2C4A  6ED9     MOVWF FSR2, ACCESS
2C4C  0E02     MOVLW 0x2
2C4E  20F4     ADDWFC PRODH, W, ACCESS
2C50  6EDA     MOVWF FSR2H, ACCESS
2C52  A4DF     BTFSS INDF2, 2, ACCESS
2C54  D004     BRA 0x2C5E
2C56  0103     MOVLB 0x3
2C58  6B86     CLRF _PFNf_opgres, BANKED
2C5A  2B86     INCF _PFNf_opgres, F, BANKED
2C5C  D002     BRA 0x2C62
2C5E  0103     MOVLB 0x3
2C60  6B86     CLRF _PFNf_opgres, BANKED
2C62  0103     MOVLB 0x3
2C64  3186     RRCF _PFNf_opgres, W, BANKED
2C66  B0D8     BTFSC STATUS, 0, ACCESS
2C68  D002     BRA 0x2C6E
2C6A  920C     BCF PFNf_b_set_nco, 1, ACCESS
2C6C  D001     BRA 0x2C70
2C6E  820C     BSF PFNf_b_set_nco, 1, ACCESS
376:                       if((PZK[DtKNF.PRM].max - PZK[DtKNF.PRM].min) > 10) fst = 1; //decyzja o zmiennej szybkosci inkrementacji/dekrementacji
2C70  0100     MOVLB 0x0
2C72  5198     MOVF DtKNF, W, BANKED
2C74  0D09     MULLW 0x9
2C76  0E04     MOVLW 0x4
2C78  26F3     ADDWF PROD, F, ACCESS
2C7A  0E00     MOVLW 0x0
2C7C  22F4     ADDWFC PRODH, F, ACCESS
2C7E  0E85     MOVLW 0x85
2C80  24F3     ADDWF PROD, W, ACCESS
2C82  6ED9     MOVWF FSR2, ACCESS
2C84  0E02     MOVLW 0x2
2C86  20F4     ADDWFC PRODH, W, ACCESS
2C88  6EDA     MOVWF FSR2H, ACCESS
2C8A  CFDE     MOVFF POSTINC2, 0x386
2C8C  F386     NOP
2C8E  CFDD     MOVFF POSTDEC2, 0x387
2C90  F387     NOP
2C92  5198     MOVF DtKNF, W, BANKED
2C94  0D09     MULLW 0x9
2C96  0E02     MOVLW 0x2
2C98  26F3     ADDWF PROD, F, ACCESS
2C9A  0E00     MOVLW 0x0
2C9C  22F4     ADDWFC PRODH, F, ACCESS
2C9E  0E85     MOVLW 0x85
2CA0  24F3     ADDWF PROD, W, ACCESS
2CA2  6ED9     MOVWF FSR2, ACCESS
2CA4  0E02     MOVLW 0x2
2CA6  20F4     ADDWFC PRODH, W, ACCESS
2CA8  6EDA     MOVWF FSR2H, ACCESS
2CAA  CFDE     MOVFF POSTINC2, 0x388
2CAC  F388     NOP
2CAE  CFDD     MOVFF POSTDEC2, 0x389
2CB0  F389     NOP
2CB2  0103     MOVLB 0x3
2CB4  1F88     COMF _PFNf_plmCO, F, BANKED
2CB6  1F89     COMF _PFNf_plmCW, F, BANKED
2CB8  4B88     INFSNZ _PFNf_plmCO, F, BANKED
2CBA  2B89     INCF _PFNf_plmCW, F, BANKED
2CBC  5186     MOVF _PFNf_opgres, W, BANKED
2CBE  2788     ADDWF _PFNf_plmCO, F, BANKED
2CC0  5187     MOVF _PFNf_pgd, W, BANKED
2CC2  2389     ADDWFC _PFNf_plmCW, F, BANKED
2CC4  5189     MOVF _PFNf_plmCW, W, BANKED
2CC6  E103     BNZ 0x2CCE
2CC8  0E0B     MOVLW 0xB
2CCA  5D88     SUBWF _PFNf_plmCO, W, BANKED
2CCC  E302     BNC 0x2CD2
2CCE  0E01     MOVLW 0x1
2CD0  D001     BRA 0x2CD4
377:                       else fst = 0;
2CD2  0E00     MOVLW 0x0
2CD4  0103     MOVLB 0x3
2CD6  6F8B     MOVWF _PFNf_prn_cs, BANKED
2CD8  D000     BRA 0x2CDA
378:                       ReadParam(&(PZK[DtKNF.PRM].bfdta), &zm, &zp, PZK[DtKNF.PRM].min, PZK[DtKNF.PRM].max, PZK[DtKNF.PRM].rld, fst);
2CDA  0100     MOVLB 0x0
2CDC  5198     MOVF DtKNF, W, BANKED
2CDE  0D09     MULLW 0x9
2CE0  0E06     MOVLW 0x6
2CE2  26F3     ADDWF PROD, F, ACCESS
2CE4  0E00     MOVLW 0x0
2CE6  22F4     ADDWFC PRODH, F, ACCESS
2CE8  0E85     MOVLW 0x85
2CEA  24F3     ADDWF PROD, W, ACCESS
2CEC  0103     MOVLB 0x3
2CEE  6F75     MOVWF _PFNf_fns_max, BANKED
2CF0  0E02     MOVLW 0x2
2CF2  20F4     ADDWFC PRODH, W, ACCESS
2CF4  6F76     MOVWF _PFNf_fnserw, BANKED
2CF6  0EDC     MOVLW 0xDC
2CF8  6F77     MOVWF _PFNf_lato, BANKED
2CFA  0E00     MOVLW 0x0
2CFC  6F78     MOVWF _PFNf_mod_ncw, BANKED
2CFE  0EFE     MOVLW 0xFE
2D00  6F79     MOVWF _PFNf_newPCO, BANKED
2D02  0E01     MOVLW 0x1
2D04  6F7A     MOVWF _PFNf_newPCW, BANKED
2D06  0100     MOVLB 0x0
2D08  5198     MOVF DtKNF, W, BANKED
2D0A  0D09     MULLW 0x9
2D0C  0E02     MOVLW 0x2
2D0E  26F3     ADDWF PROD, F, ACCESS
2D10  0E00     MOVLW 0x0
2D12  22F4     ADDWFC PRODH, F, ACCESS
2D14  0E85     MOVLW 0x85
2D16  24F3     ADDWF PROD, W, ACCESS
2D18  6ED9     MOVWF FSR2, ACCESS
2D1A  0E02     MOVLW 0x2
2D1C  20F4     ADDWFC PRODH, W, ACCESS
2D1E  6EDA     MOVWF FSR2H, ACCESS
2D20  CFDE     MOVFF POSTINC2, min
2D22  F37B     NOP
2D24  CFDD     MOVFF POSTDEC2, 0x37C
2D26  F37C     NOP
2D28  5198     MOVF DtKNF, W, BANKED
2D2A  0D09     MULLW 0x9
2D2C  0E04     MOVLW 0x4
2D2E  26F3     ADDWF PROD, F, ACCESS
2D30  0E00     MOVLW 0x0
2D32  22F4     ADDWFC PRODH, F, ACCESS
2D34  0E85     MOVLW 0x85
2D36  24F3     ADDWF PROD, W, ACCESS
2D38  6ED9     MOVWF FSR2, ACCESS
2D3A  0E02     MOVLW 0x2
2D3C  20F4     ADDWFC PRODH, W, ACCESS
2D3E  6EDA     MOVWF FSR2H, ACCESS
2D40  CFDE     MOVFF POSTINC2, max
2D42  F37D     NOP
2D44  CFDD     MOVFF POSTDEC2, p
2D46  F37E     NOP
2D48  5198     MOVF DtKNF, W, BANKED
2D4A  0D09     MULLW 0x9
2D4C  0E08     MOVLW 0x8
2D4E  26F3     ADDWF PROD, F, ACCESS
2D50  0E00     MOVLW 0x0
2D52  22F4     ADDWFC PRODH, F, ACCESS
2D54  0E85     MOVLW 0x85
2D56  24F3     ADDWF PROD, W, ACCESS
2D58  6ED9     MOVWF FSR2, ACCESS
2D5A  0E02     MOVLW 0x2
2D5C  20F4     ADDWFC PRODH, W, ACCESS
2D5E  6EDA     MOVWF FSR2H, ACCESS
2D60  0E00     MOVLW 0x0
2D62  B2DF     BTFSC INDF2, 1, ACCESS
2D64  0E01     MOVLW 0x1
2D66  0103     MOVLB 0x3
2D68  6F7F     MOVWF _PFNf_off, BANKED
2D6A  C38B     MOVFF w, pdw
2D6C  F380     NOP
2D6E  EC3A     CALL 0x7674, 0
2D70  F03B     NOP
379:                       RunDynamicParam(DtKNF.PRM, (char)PZK[DtKNF.PRM].bfdta); //obsluga parametrow dynamicznych
2D72  0100     MOVLB 0x0
2D74  5198     MOVF DtKNF, W, BANKED
2D76  0D09     MULLW 0x9
2D78  0E06     MOVLW 0x6
2D7A  26F3     ADDWF PROD, F, ACCESS
2D7C  0E00     MOVLW 0x0
2D7E  22F4     ADDWFC PRODH, F, ACCESS
2D80  0E85     MOVLW 0x85
2D82  24F3     ADDWF PROD, W, ACCESS
2D84  6ED9     MOVWF FSR2, ACCESS
2D86  0E02     MOVLW 0x2
2D88  20F4     ADDWFC PRODH, W, ACCESS
2D8A  6EDA     MOVWF FSR2H, ACCESS
2D8C  50DF     MOVF INDF2, W, ACCESS
2D8E  6FF6     MOVWF ehi, BANKED
2D90  5198     MOVF DtKNF, W, BANKED
2D92  ECD8     CALL 0xD7B0, 0
2D94  F06B     NOP
380:                       PrintWPR((char)PZK[DtKNF.PRM].bfdta);
2D96  0100     MOVLB 0x0
2D98  5198     MOVF DtKNF, W, BANKED
2D9A  0D09     MULLW 0x9
2D9C  0E06     MOVLW 0x6
2D9E  26F3     ADDWF PROD, F, ACCESS
2DA0  0E00     MOVLW 0x0
2DA2  22F4     ADDWFC PRODH, F, ACCESS
2DA4  0E85     MOVLW 0x85
2DA6  24F3     ADDWF PROD, W, ACCESS
2DA8  6ED9     MOVWF FSR2, ACCESS
2DAA  0E02     MOVLW 0x2
2DAC  20F4     ADDWFC PRODH, W, ACCESS
2DAE  6EDA     MOVWF FSR2H, ACCESS
2DB0  50DF     MOVF INDF2, W, ACCESS
2DB2  ECAB     CALL 0xD156, 0
2DB4  F068     NOP
381:                       key = PresKeyEX(RdPrt(S_SET), &ky[SS_SET]);
2DB6  0EAB     MOVLW 0xAB
2DB8  0100     MOVLB 0x0
2DBA  6FE0     MOVWF bdat, BANKED
2DBC  0E01     MOVLW 0x1
2DBE  6FE1     MOVWF GIE_BIT_VAL, BANKED
2DC0  0E17     MOVLW 0x17
2DC2  ECFD     CALL 0xE7FA, 0
2DC4  F073     NOP
2DC6  0E01     MOVLW 0x1
2DC8  A0D8     BTFSS STATUS, 0, ACCESS
2DCA  0E00     MOVLW 0x0
2DCC  ECAB     CALL 0x8556, 0
2DCE  F042     NOP
2DD0  0103     MOVLB 0x3
2DD2  6F8D     MOVWF _PFNf_prn_res, BANKED
382:                       if(key > 0) //wybrano parametr
2DD4  0103     MOVLB 0x3
2DD6  518D     MOVF _PFNf_prn_res, W, BANKED
2DD8  E05C     BZ 0x2E92
383:                       {
384:                           WaitToLowEx(&ky[SS_SET]);
2DDA  0EAB     MOVLW 0xAB
2DDC  0100     MOVLB 0x0
2DDE  6FDE     MOVWF __pcstackBANK0, BANKED
2DE0  0E01     MOVLW 0x1
2DE2  6FDF     MOVWF pco, BANKED
2DE4  EC10     CALL 0xEE20, 0
2DE6  F077     NOP
385:                           PZK[DtKNF.PRM].zps = (PZK[DtKNF.PRM].dta != PZK[DtKNF.PRM].bfdta);
2DE8  0100     MOVLB 0x0
2DEA  5198     MOVF DtKNF, W, BANKED
2DEC  0D09     MULLW 0x9
2DEE  0E06     MOVLW 0x6
2DF0  26F3     ADDWF PROD, F, ACCESS
2DF2  0E00     MOVLW 0x0
2DF4  22F4     ADDWFC PRODH, F, ACCESS
2DF6  0E85     MOVLW 0x85
2DF8  24F3     ADDWF PROD, W, ACCESS
2DFA  6ED9     MOVWF FSR2, ACCESS
2DFC  0E02     MOVLW 0x2
2DFE  20F4     ADDWFC PRODH, W, ACCESS
2E00  6EDA     MOVWF FSR2H, ACCESS
2E02  5198     MOVF DtKNF, W, BANKED
2E04  0D09     MULLW 0x9
2E06  0E85     MOVLW 0x85
2E08  24F3     ADDWF PROD, W, ACCESS
2E0A  6EE1     MOVWF FSR1, ACCESS
2E0C  0E02     MOVLW 0x2
2E0E  20F4     ADDWFC PRODH, W, ACCESS
2E10  6EE2     MOVWF FSR1H, ACCESS
2E12  50DE     MOVF POSTINC2, W, ACCESS
2E14  18E6     XORWF POSTINC1, W, ACCESS
2E16  E103     BNZ 0x2E1E
2E18  50DE     MOVF POSTINC2, W, ACCESS
2E1A  18E6     XORWF POSTINC1, W, ACCESS
2E1C  E004     BZ 0x2E26
2E1E  0103     MOVLB 0x3
2E20  6B8A     CLRF _PFNf_pmpPWM, BANKED
2E22  2B8A     INCF _PFNf_pmpPWM, F, BANKED
2E24  D002     BRA 0x2E2A
2E26  0103     MOVLB 0x3
2E28  6B8A     CLRF _PFNf_pmpPWM, BANKED
2E2A  0100     MOVLB 0x0
2E2C  5198     MOVF DtKNF, W, BANKED
2E2E  0D09     MULLW 0x9
2E30  0E08     MOVLW 0x8
2E32  26F3     ADDWF PROD, F, ACCESS
2E34  0E00     MOVLW 0x0
2E36  22F4     ADDWFC PRODH, F, ACCESS
2E38  0E85     MOVLW 0x85
2E3A  24F3     ADDWF PROD, W, ACCESS
2E3C  6ED9     MOVWF FSR2, ACCESS
2E3E  0E02     MOVLW 0x2
2E40  20F4     ADDWFC PRODH, W, ACCESS
2E42  6EDA     MOVWF FSR2H, ACCESS
2E44  50DF     MOVF INDF2, W, ACCESS
2E46  0103     MOVLB 0x3
2E48  198A     XORWF _PFNf_pmpPWM, W, BANKED
2E4A  0BFE     ANDLW 0xFE
2E4C  198A     XORWF _PFNf_pmpPWM, W, BANKED
2E4E  6EDF     MOVWF INDF2, ACCESS
386:                           PZK[DtKNF.PRM].dta = PZK[DtKNF.PRM].bfdta;
2E50  0100     MOVLB 0x0
2E52  5198     MOVF DtKNF, W, BANKED
2E54  0D09     MULLW 0x9
2E56  0E06     MOVLW 0x6
2E58  26F3     ADDWF PROD, F, ACCESS
2E5A  0E00     MOVLW 0x0
2E5C  22F4     ADDWFC PRODH, F, ACCESS
2E5E  0E85     MOVLW 0x85
2E60  24F3     ADDWF PROD, W, ACCESS
2E62  6ED9     MOVWF FSR2, ACCESS
2E64  0E02     MOVLW 0x2
2E66  20F4     ADDWFC PRODH, W, ACCESS
2E68  6EDA     MOVWF FSR2H, ACCESS
2E6A  5198     MOVF DtKNF, W, BANKED
2E6C  0D09     MULLW 0x9
2E6E  0E85     MOVLW 0x85
2E70  24F3     ADDWF PROD, W, ACCESS
2E72  6EE1     MOVWF FSR1, ACCESS
2E74  0E02     MOVLW 0x2
2E76  20F4     ADDWFC PRODH, W, ACCESS
2E78  6EE2     MOVWF FSR1H, ACCESS
2E7A  CFDE     MOVFF POSTINC2, POSTINC1
2E7C  FFE6     NOP
2E7E  CFDD     MOVFF POSTDEC2, POSTDEC1
2E80  FFE5     NOP
387:                           UpdateKnfPar(DtKNF.PRM);
2E82  0100     MOVLB 0x0
2E84  5198     MOVF DtKNF, W, BANKED
2E86  EC4E     CALL 0xB69C, 0
2E88  F05B     NOP
388:                           DtKNF.KRK = 1;
2E8A  0E01     MOVLW 0x1
2E8C  0100     MOVLB 0x0
2E8E  6F99     MOVWF _PFNf_toInit, BANKED
2E90  D000     BRA 0x2E92
389:                       }
390:                       key = PresKeyEX(RdPrt(S_OFF), &ky[SS_OFF]);
2E92  0EA6     MOVLW 0xA6
2E94  0100     MOVLB 0x0
2E96  6FE0     MOVWF bdat, BANKED
2E98  0E01     MOVLW 0x1
2E9A  6FE1     MOVWF GIE_BIT_VAL, BANKED
2E9C  0E16     MOVLW 0x16
2E9E  ECFD     CALL 0xE7FA, 0
2EA0  F073     NOP
2EA2  0E01     MOVLW 0x1
2EA4  A0D8     BTFSS STATUS, 0, ACCESS
2EA6  0E00     MOVLW 0x0
2EA8  ECAB     CALL 0x8556, 0
2EAA  F042     NOP
2EAC  0103     MOVLB 0x3
2EAE  6F8D     MOVWF _PFNf_prn_res, BANKED
391:                       if(key > 0)
2EB0  0103     MOVLB 0x3
2EB2  518D     MOVF _PFNf_prn_res, W, BANKED
2EB4  B4D8     BTFSC STATUS, 2, ACCESS
2EB6  0012     RETURN 0
392:                       {
393:                           WaitToLowEx(&ky[SS_OFF]);
2EB8  0EA6     MOVLW 0xA6
2EBA  0100     MOVLB 0x0
2EBC  6FDE     MOVWF __pcstackBANK0, BANKED
2EBE  0E01     MOVLW 0x1
2EC0  6FDF     MOVWF pco, BANKED
2EC2  EC10     CALL 0xEE20, 0
2EC4  F077     NOP
394:                           PZK[DtKNF.PRM].bfdta = PZK[DtKNF.PRM].dta;
2EC6  0100     MOVLB 0x0
2EC8  5198     MOVF DtKNF, W, BANKED
2ECA  0D09     MULLW 0x9
2ECC  0E85     MOVLW 0x85
2ECE  24F3     ADDWF PROD, W, ACCESS
2ED0  6ED9     MOVWF FSR2, ACCESS
2ED2  0E02     MOVLW 0x2
2ED4  20F4     ADDWFC PRODH, W, ACCESS
2ED6  6EDA     MOVWF FSR2H, ACCESS
2ED8  5198     MOVF DtKNF, W, BANKED
2EDA  0D09     MULLW 0x9
2EDC  0E06     MOVLW 0x6
2EDE  26F3     ADDWF PROD, F, ACCESS
2EE0  0E00     MOVLW 0x0
2EE2  22F4     ADDWFC PRODH, F, ACCESS
2EE4  0E85     MOVLW 0x85
2EE6  24F3     ADDWF PROD, W, ACCESS
2EE8  6EE1     MOVWF FSR1, ACCESS
2EEA  0E02     MOVLW 0x2
2EEC  20F4     ADDWFC PRODH, W, ACCESS
2EEE  6EE2     MOVWF FSR1H, ACCESS
2EF0  CFDE     MOVFF POSTINC2, POSTINC1
2EF2  FFE6     NOP
2EF4  CFDD     MOVFF POSTDEC2, POSTDEC1
2EF6  FFE5     NOP
395:                           UpdateKnfPar(DtKNF.PRM);
2EF8  0100     MOVLB 0x0
2EFA  5198     MOVF DtKNF, W, BANKED
2EFC  EC4E     CALL 0xB69C, 0
2EFE  F05B     NOP
396:                           DtKNF.KRK = 1;
2F00  0E01     MOVLW 0x1
2F02  0100     MOVLB 0x0
2F04  6F99     MOVWF _PFNf_toInit, BANKED
397:                       }
398:                       break;
2F06  0012     RETURN 0
399:                   }
400:                   case 3:
401:                   {
402:                       SaveKnfPar();
2F08  EC25     CALL 0x544A, 0
2F0A  F02A     NOP
403:                       RdEEParam();
2F0C  EC36     CALL 0xA66C, 0
2F0E  F053     NOP
404:                       ExitKonf();
2F10  EC4F     CALL 0xE89E, 0
2F12  F074     NOP
405:                       return;
406:                   }
407:               }
2F14  0012     RETURN 0
408:           }
2F32  0012     RETURN 0
409:           
410:           void SaveKnfPar(void)
411:           {
412:               if((DtKNF.mstr > _KMINMST) && (DtKNF.mstr < _KMAXMST) || DtKNF.mstr == _KMINMST || DtKNF.mstr == _KMAXMST)
544A  0100     MOVLB 0x0
544C  519A     MOVF _PFNf_trbECO, W, BANKED
544E  E004     BZ 0x5458
5450  0E62     MOVLW 0x62
5452  659A     CPFSGT _PFNf_trbECO, BANKED
5454  D007     BRA 0x5464
5456  D000     BRA 0x5458
5458  0100     MOVLB 0x0
545A  519A     MOVF _PFNf_trbECO, W, BANKED
545C  E003     BZ 0x5464
545E  0E63     MOVLW 0x63
5460  199A     XORWF _PFNf_trbECO, W, BANKED
5462  E114     BNZ 0x548C
413:                   if(DtKNF.mstr != eeprom_read(_ADRMST)) eeprom_write(_ADRMST, DtKNF.mstr);
5464  0100     MOVLB 0x0
5466  6BDF     CLRF pco, BANKED
5468  0EC1     MOVLW 0xC1
546A  6FDE     MOVWF __pcstackBANK0, BANKED
546C  EC2E     CALL 0xF05C, 0
546E  F078     NOP
5470  0100     MOVLB 0x0
5472  199A     XORWF _PFNf_trbECO, W, BANKED
5474  E00B     BZ 0x548C
5476  ECFE     CALL 0xF3FC, 0
5478  F079     NOP
547A  0100     MOVLB 0x0
547C  6BDF     CLRF pco, BANKED
547E  0EC1     MOVLW 0xC1
5480  6FDE     MOVWF __pcstackBANK0, BANKED
5482  C09A     MOVFF _PFNf_trbECO, bdat
5484  F0E0     NOP
5486  EC58     CALL 0xE2B0, 0
5488  F071     NOP
548A  D000     BRA 0x548C
414:               if((DtKNF.mxcw > _KMINMCW) && (DtKNF.mxcw < _KMAXMCW) || DtKNF.mxcw == _KMINMCW || DtKNF.mxcw == _KMAXMCW)
548C  0100     MOVLB 0x0
548E  519B     MOVF _PFNf_zima, W, BANKED
5490  E004     BZ 0x549A
5492  0E62     MOVLW 0x62
5494  659B     CPFSGT _PFNf_zima, BANKED
5496  D007     BRA 0x54A6
5498  D000     BRA 0x549A
549A  0100     MOVLB 0x0
549C  519B     MOVF _PFNf_zima, W, BANKED
549E  E003     BZ 0x54A6
54A0  0E63     MOVLW 0x63
54A2  199B     XORWF _PFNf_zima, W, BANKED
54A4  E114     BNZ 0x54CE
415:                   if(DtKNF.mxcw != eeprom_read(_ADRMCW)) eeprom_write(_ADRMCW, DtKNF.mxcw);
54A6  0100     MOVLB 0x0
54A8  6BDF     CLRF pco, BANKED
54AA  0EC2     MOVLW 0xC2
54AC  6FDE     MOVWF __pcstackBANK0, BANKED
54AE  EC2E     CALL 0xF05C, 0
54B0  F078     NOP
54B2  0100     MOVLB 0x0
54B4  199B     XORWF _PFNf_zima, W, BANKED
54B6  E00B     BZ 0x54CE
54B8  ECFE     CALL 0xF3FC, 0
54BA  F079     NOP
54BC  0100     MOVLB 0x0
54BE  6BDF     CLRF pco, BANKED
54C0  0EC2     MOVLW 0xC2
54C2  6FDE     MOVWF __pcstackBANK0, BANKED
54C4  C09B     MOVFF _PFNf_zima, bdat
54C6  F0E0     NOP
54C8  EC58     CALL 0xE2B0, 0
54CA  F071     NOP
54CC  D000     BRA 0x54CE
416:               if((DtKNF.mxco > _KMINMCO) && (DtKNF.mxco < _KMAXMCO) || DtKNF.mxco == _KMINMCO || DtKNF.mxco == _KMAXMCO)
54CE  0100     MOVLB 0x0
54D0  519C     MOVF _PWMf_ENOSC, W, BANKED
54D2  E004     BZ 0x54DC
54D4  0E62     MOVLW 0x62
54D6  659C     CPFSGT _PWMf_ENOSC, BANKED
54D8  D007     BRA 0x54E8
54DA  D000     BRA 0x54DC
54DC  0100     MOVLB 0x0
54DE  519C     MOVF _PWMf_ENOSC, W, BANKED
54E0  E003     BZ 0x54E8
54E2  0E63     MOVLW 0x63
54E4  199C     XORWF _PWMf_ENOSC, W, BANKED
54E6  E114     BNZ 0x5510
417:                   if(DtKNF.mxco != eeprom_read(_ADRMCO)) eeprom_write(_ADRMCO, DtKNF.mxco);
54E8  0100     MOVLB 0x0
54EA  6BDF     CLRF pco, BANKED
54EC  0EC3     MOVLW 0xC3
54EE  6FDE     MOVWF __pcstackBANK0, BANKED
54F0  EC2E     CALL 0xF05C, 0
54F2  F078     NOP
54F4  0100     MOVLB 0x0
54F6  199C     XORWF _PWMf_ENOSC, W, BANKED
54F8  E00B     BZ 0x5510
54FA  ECFE     CALL 0xF3FC, 0
54FC  F079     NOP
54FE  0100     MOVLB 0x0
5500  6BDF     CLRF pco, BANKED
5502  0EC3     MOVLW 0xC3
5504  6FDE     MOVWF __pcstackBANK0, BANKED
5506  C09C     MOVFF _PWMf_ENOSC, bdat
5508  F0E0     NOP
550A  EC58     CALL 0xE2B0, 0
550C  F071     NOP
550E  D000     BRA 0x5510
418:               if((DtKNF.rdgz > _KMINRGZ) && (DtKNF.rdgz < _KMAXRGZ) || DtKNF.rdgz == _KMINRGZ || DtKNF.rdgz == _KMAXRGZ)
5510  0100     MOVLB 0x0
5512  519F     MOVF _PWMf_tpGZ, W, BANKED
5514  E002     BZ 0x551A
5516  519F     MOVF _PWMf_tpGZ, W, BANKED
5518  E005     BZ 0x5524
551A  0100     MOVLB 0x0
551C  519F     MOVF _PWMf_tpGZ, W, BANKED
551E  E002     BZ 0x5524
5520  059F     DECF _PWMf_tpGZ, W, BANKED
5522  E11A     BNZ 0x5558
419:               {
420:                   if(DtKNF.rdgz != eeprom_read(_ADRRGZ))
5524  0100     MOVLB 0x0
5526  6BDF     CLRF pco, BANKED
5528  0EC4     MOVLW 0xC4
552A  6FDE     MOVWF __pcstackBANK0, BANKED
552C  EC2E     CALL 0xF05C, 0
552E  F078     NOP
5530  0100     MOVLB 0x0
5532  199F     XORWF _PWMf_tpGZ, W, BANKED
5534  E011     BZ 0x5558
421:                   {
422:                       eeprom_write(_ADRRGZ, DtKNF.rdgz);
5536  ECFE     CALL 0xF3FC, 0
5538  F079     NOP
553A  0100     MOVLB 0x0
553C  6BDF     CLRF pco, BANKED
553E  0EC4     MOVLW 0xC4
5540  6FDE     MOVWF __pcstackBANK0, BANKED
5542  C09F     MOVFF _PWMf_tpGZ, bdat
5544  F0E0     NOP
5546  EC58     CALL 0xE2B0, 0
5548  F071     NOP
423:                       ModParam(DtKNF.tpkt, DtKNF.rdgz); //nowe parametry modulatora dla wybranego typu kotla i rodzaju gazu
554A  C09F     MOVFF _PWMf_tpGZ, bdat
554C  F0E0     NOP
554E  0100     MOVLB 0x0
5550  519E     MOVF _PWMf_ENPWM2, W, BANKED
5552  EC43     CALL 0x5086, 0
5554  F028     NOP
424:                   }
5556  D000     BRA 0x5558
425:               }
426:               if(DtKNF.aleg == _KMINEAL || DtKNF.aleg == _KMAXEAL)
5558  0100     MOVLB 0x0
555A  51A9     MOVF _rglf_del1s, W, BANKED
555C  E002     BZ 0x5562
555E  05A9     DECF _rglf_del1s, W, BANKED
5560  E120     BNZ 0x55A2
427:               {
428:                   if(DtKNF.aleg != eeprom_read(_ADRTAL))
5562  0100     MOVLB 0x0
5564  6BDF     CLRF pco, BANKED
5566  0EC6     MOVLW 0xC6
5568  6FDE     MOVWF __pcstackBANK0, BANKED
556A  EC2E     CALL 0xF05C, 0
556C  F078     NOP
556E  0100     MOVLB 0x0
5570  19A9     XORWF _rglf_del1s, W, BANKED
5572  E017     BZ 0x55A2
429:                   {
430:                       StartRTG(_RTANL);
5574  0E01     MOVLW 0x1
5576  EC40     CALL 0xE480, 0
5578  F072     NOP
431:                       eeprom_write(_ADRRTA, 0);
557A  ECFE     CALL 0xF3FC, 0
557C  F079     NOP
557E  0100     MOVLB 0x0
5580  6BDF     CLRF pco, BANKED
5582  0EC7     MOVLW 0xC7
5584  6FDE     MOVWF __pcstackBANK0, BANKED
5586  6BE0     CLRF bdat, BANKED
5588  EC58     CALL 0xE2B0, 0
558A  F071     NOP
432:                       eeprom_write(_ADRTAL, DtKNF.aleg);
558C  ECFE     CALL 0xF3FC, 0
558E  F079     NOP
5590  0100     MOVLB 0x0
5592  6BDF     CLRF pco, BANKED
5594  0EC6     MOVLW 0xC6
5596  6FDE     MOVWF __pcstackBANK0, BANKED
5598  C0A9     MOVFF _rglf_del1s, bdat
559A  F0E0     NOP
559C  EC58     CALL 0xE2B0, 0
559E  F071     NOP
433:                   }
55A0  D000     BRA 0x55A2
434:               }
435:               if((DtKNF.tpkt > _KMINWTK) && (DtKNF.tpkt < _KMAXWTK) || DtKNF.tpkt == _KMINWTK || DtKNF.tpkt == _KMAXWTK)
55A2  0100     MOVLB 0x0
55A4  519E     MOVF _PWMf_ENPWM2, W, BANKED
55A6  E004     BZ 0x55B0
55A8  0E02     MOVLW 0x2
55AA  659E     CPFSGT _PWMf_ENPWM2, BANKED
55AC  D007     BRA 0x55BC
55AE  D000     BRA 0x55B0
55B0  0100     MOVLB 0x0
55B2  519E     MOVF _PWMf_ENPWM2, W, BANKED
55B4  E003     BZ 0x55BC
55B6  0E03     MOVLW 0x3
55B8  199E     XORWF _PWMf_ENPWM2, W, BANKED
55BA  E128     BNZ 0x560C
436:               {
437:                   if(DtKNF.tpkt != eeprom_read(_ADRWTK))
55BC  0100     MOVLB 0x0
55BE  6BDF     CLRF pco, BANKED
55C0  0EC5     MOVLW 0xC5
55C2  6FDE     MOVWF __pcstackBANK0, BANKED
55C4  EC2E     CALL 0xF05C, 0
55C6  F078     NOP
55C8  0100     MOVLB 0x0
55CA  199E     XORWF _PWMf_ENPWM2, W, BANKED
55CC  E01F     BZ 0x560C
438:                   {
439:                       SetTpKtParam(); //ustaw param. ukryte dla wybr. kotla
55CE  EC39     CALL 0xE072, 0
55D0  F070     NOP
440:                       if((DtKNF.rdgz > _KMINRGZ) && (DtKNF.rdgz < _KMAXRGZ) || DtKNF.rdgz == _KMINRGZ || DtKNF.rdgz == _KMAXRGZ)
55D2  0100     MOVLB 0x0
55D4  519F     MOVF _PWMf_tpGZ, W, BANKED
55D6  E002     BZ 0x55DC
55D8  519F     MOVF _PWMf_tpGZ, W, BANKED
55DA  E005     BZ 0x55E6
55DC  0100     MOVLB 0x0
55DE  519F     MOVF _PWMf_tpGZ, W, BANKED
55E0  E002     BZ 0x55E6
55E2  059F     DECF _PWMf_tpGZ, W, BANKED
55E4  E106     BNZ 0x55F2
441:                           ModParam(DtKNF.tpkt, DtKNF.rdgz); //nowe parametry modulatora dla wybranego typu kotla i rodzaju gazu
55E6  C09F     MOVFF _PWMf_tpGZ, bdat
55E8  F0E0     NOP
55EA  0100     MOVLB 0x0
55EC  519E     MOVF _PWMf_ENPWM2, W, BANKED
55EE  EC43     CALL 0x5086, 0
55F0  F028     NOP
442:                       SetDefaultValue(); //parametry domyslne dla danego typu kotla
55F2  EC7B     CALL 0xE2F6, 0
55F4  F071     NOP
443:                       eeprom_write(_ADRWTK, DtKNF.tpkt);
55F6  ECFE     CALL 0xF3FC, 0
55F8  F079     NOP
55FA  0100     MOVLB 0x0
55FC  6BDF     CLRF pco, BANKED
55FE  0EC5     MOVLW 0xC5
5600  6FDE     MOVWF __pcstackBANK0, BANKED
5602  C09E     MOVFF _PWMf_ENPWM2, bdat
5604  F0E0     NOP
5606  EC58     CALL 0xE2B0, 0
5608  F071     NOP
444:                   }
560A  D000     BRA 0x560C
445:               }
446:               if(DtKNF.robg == _KMINOBG || DtKNF.robg == _KMAXOBG)
560C  0100     MOVLB 0x0
560E  51A6     MOVF _mux, W, BANKED
5610  E002     BZ 0x5616
5612  05A6     DECF _mux, W, BANKED
5614  E114     BNZ 0x563E
447:                   if(DtKNF.robg != eeprom_read(_ADROBG)) eeprom_write(_ADROBG, DtKNF.robg);
5616  0100     MOVLB 0x0
5618  6BDF     CLRF pco, BANKED
561A  0EC8     MOVLW 0xC8
561C  6FDE     MOVWF __pcstackBANK0, BANKED
561E  EC2E     CALL 0xF05C, 0
5620  F078     NOP
5622  0100     MOVLB 0x0
5624  19A6     XORWF _mux, W, BANKED
5626  E00B     BZ 0x563E
5628  ECFE     CALL 0xF3FC, 0
562A  F079     NOP
562C  0100     MOVLB 0x0
562E  6BDF     CLRF pco, BANKED
5630  0EC8     MOVLW 0xC8
5632  6FDE     MOVWF __pcstackBANK0, BANKED
5634  C0A6     MOVFF _mux, bdat
5636  F0E0     NOP
5638  EC58     CALL 0xE2B0, 0
563A  F071     NOP
563C  D000     BRA 0x563E
448:               if(DtKNF.opdg == _KMINOGP || DtKNF.opdg == _KMAXOGP)
563E  0100     MOVLB 0x0
5640  51A7     MOVF _rglf_btco, W, BANKED
5642  E002     BZ 0x5648
5644  05A7     DECF _rglf_btco, W, BANKED
5646  E114     BNZ 0x5670
449:                   if(DtKNF.opdg != eeprom_read(_ADRPDG)) eeprom_write(_ADRPDG, DtKNF.opdg);
5648  0100     MOVLB 0x0
564A  6BDF     CLRF pco, BANKED
564C  0ECC     MOVLW 0xCC
564E  6FDE     MOVWF __pcstackBANK0, BANKED
5650  EC2E     CALL 0xF05C, 0
5652  F078     NOP
5654  0100     MOVLB 0x0
5656  19A7     XORWF _rglf_btco, W, BANKED
5658  E00B     BZ 0x5670
565A  ECFE     CALL 0xF3FC, 0
565C  F079     NOP
565E  0100     MOVLB 0x0
5660  6BDF     CLRF pco, BANKED
5662  0ECC     MOVLW 0xCC
5664  6FDE     MOVWF __pcstackBANK0, BANKED
5666  C0A7     MOVFF _rglf_btco, bdat
5668  F0E0     NOP
566A  EC58     CALL 0xE2B0, 0
566C  F071     NOP
566E  D000     BRA 0x5670
450:               if(DtKNF.tpcs == _KMINTCS || DtKNF.tpcs == _KMAXTCS)
5670  0100     MOVLB 0x0
5672  51A8     MOVF _rglf_btcw, W, BANKED
5674  E002     BZ 0x567A
5676  05A8     DECF _rglf_btcw, W, BANKED
5678  E114     BNZ 0x56A2
451:                   if(DtKNF.tpcs != eeprom_read(_ADRCS5)) eeprom_write(_ADRCS5, DtKNF.tpcs);
567A  0100     MOVLB 0x0
567C  6BDF     CLRF pco, BANKED
567E  0ECD     MOVLW 0xCD
5680  6FDE     MOVWF __pcstackBANK0, BANKED
5682  EC2E     CALL 0xF05C, 0
5684  F078     NOP
5686  0100     MOVLB 0x0
5688  19A8     XORWF _rglf_btcw, W, BANKED
568A  E00B     BZ 0x56A2
568C  ECFE     CALL 0xF3FC, 0
568E  F079     NOP
5690  0100     MOVLB 0x0
5692  6BDF     CLRF pco, BANKED
5694  0ECD     MOVLW 0xCD
5696  6FDE     MOVWF __pcstackBANK0, BANKED
5698  C0A8     MOVFF _rglf_btcw, bdat
569A  F0E0     NOP
569C  EC58     CALL 0xE2B0, 0
569E  F071     NOP
56A0  D000     BRA 0x56A2
452:           
453:               if((DtKNF.rdpm > _KMINRDP) && (DtKNF.rdpm < _KMAXRDP) || DtKNF.rdpm == _KMINRDP || DtKNF.rdpm == _KMAXRDP)
56A2  0100     MOVLB 0x0
56A4  51A0     MOVF _UADtf_RData, W, BANKED
56A6  E002     BZ 0x56AC
56A8  51A0     MOVF _UADtf_RData, W, BANKED
56AA  E005     BZ 0x56B6
56AC  0100     MOVLB 0x0
56AE  51A0     MOVF _UADtf_RData, W, BANKED
56B0  E002     BZ 0x56B6
56B2  05A0     DECF _UADtf_RData, W, BANKED
56B4  E114     BNZ 0x56DE
454:                   if(DtKNF.rdpm != eeprom_read(_ADRRDPM)) eeprom_write(_ADRRDPM, DtKNF.rdpm);
56B6  0100     MOVLB 0x0
56B8  6BDF     CLRF pco, BANKED
56BA  0ED0     MOVLW 0xD0
56BC  6FDE     MOVWF __pcstackBANK0, BANKED
56BE  EC2E     CALL 0xF05C, 0
56C0  F078     NOP
56C2  0100     MOVLB 0x0
56C4  19A0     XORWF _UADtf_RData, W, BANKED
56C6  E00B     BZ 0x56DE
56C8  ECFE     CALL 0xF3FC, 0
56CA  F079     NOP
56CC  0100     MOVLB 0x0
56CE  6BDF     CLRF pco, BANKED
56D0  0ED0     MOVLW 0xD0
56D2  6FDE     MOVWF __pcstackBANK0, BANKED
56D4  C0A0     MOVFF _UADtf_RData, bdat
56D6  F0E0     NOP
56D8  EC58     CALL 0xE2B0, 0
56DA  F071     NOP
56DC  D000     BRA 0x56DE
455:           
456:               if((DtKNF.dtpm > _KMINDLP) && (DtKNF.dtpm < _KMAXDLP) || DtKNF.dtpm == _KMINDLP || DtKNF.dtpm == _KMAXDLP)
56DE  0E05     MOVLW 0x5
56E0  0100     MOVLB 0x0
56E2  65A1     CPFSGT _UADtf_REnd, BANKED
56E4  D004     BRA 0x56EE
56E6  0E18     MOVLW 0x18
56E8  65A1     CPFSGT _UADtf_REnd, BANKED
56EA  D008     BRA 0x56FC
56EC  D000     BRA 0x56EE
56EE  0E05     MOVLW 0x5
56F0  0100     MOVLB 0x0
56F2  19A1     XORWF _UADtf_REnd, W, BANKED
56F4  E003     BZ 0x56FC
56F6  0E19     MOVLW 0x19
56F8  19A1     XORWF _UADtf_REnd, W, BANKED
56FA  E114     BNZ 0x5724
457:                   if(DtKNF.dtpm != eeprom_read(_ADRDLPM)) eeprom_write(_ADRDLPM, DtKNF.dtpm);
56FC  0100     MOVLB 0x0
56FE  6BDF     CLRF pco, BANKED
5700  0ED1     MOVLW 0xD1
5702  6FDE     MOVWF __pcstackBANK0, BANKED
5704  EC2E     CALL 0xF05C, 0
5706  F078     NOP
5708  0100     MOVLB 0x0
570A  19A1     XORWF _UADtf_REnd, W, BANKED
570C  E00B     BZ 0x5724
570E  ECFE     CALL 0xF3FC, 0
5710  F079     NOP
5712  0100     MOVLB 0x0
5714  6BDF     CLRF pco, BANKED
5716  0ED1     MOVLW 0xD1
5718  6FDE     MOVWF __pcstackBANK0, BANKED
571A  C0A1     MOVFF _UADtf_REnd, bdat
571C  F0E0     NOP
571E  EC58     CALL 0xE2B0, 0
5720  F071     NOP
5722  D000     BRA 0x5724
458:           
459:               if((DtKNF.mdpm > _KMINMNP) && (DtKNF.mdpm < _KMAXMNP) || DtKNF.mdpm == _KMINMNP || DtKNF.mdpm == _KMAXMNP)
5724  0E0F     MOVLW 0xF
5726  0100     MOVLB 0x0
5728  65A2     CPFSGT _UADtf_RErrBUF, BANKED
572A  D004     BRA 0x5734
572C  0E62     MOVLW 0x62
572E  65A2     CPFSGT _UADtf_RErrBUF, BANKED
5730  D008     BRA 0x5742
5732  D000     BRA 0x5734
5734  0E0F     MOVLW 0xF
5736  0100     MOVLB 0x0
5738  19A2     XORWF _UADtf_RErrBUF, W, BANKED
573A  E003     BZ 0x5742
573C  0E63     MOVLW 0x63
573E  19A2     XORWF _UADtf_RErrBUF, W, BANKED
5740  E11E     BNZ 0x577E
460:               {
461:                   if(DtKNF.mdpm>DtKNF.mgpm)
5742  0100     MOVLB 0x0
5744  51A2     MOVF _UADtf_RErrBUF, W, BANKED
5746  5DA3     SUBWF _UADtf_RErrREC, W, BANKED
5748  E206     BC 0x5756
462:                   {
463:                       if(DtKNF.mgpm>=_KMINMNP) DtKNF.mdpm=DtKNF.mgpm;
574A  0E0E     MOVLW 0xE
574C  65A3     CPFSGT _UADtf_RErrREC, BANKED
574E  D003     BRA 0x5756
5750  C0A3     MOVFF _UADtf_RErrREC, _UADtf_RErrBUF
5752  F0A2     NOP
5754  D000     BRA 0x5756
464:                   }
465:                   if(DtKNF.mdpm != eeprom_read(_ADRMNPM)) eeprom_write(_ADRMNPM, DtKNF.mdpm);
5756  0100     MOVLB 0x0
5758  6BDF     CLRF pco, BANKED
575A  0ED2     MOVLW 0xD2
575C  6FDE     MOVWF __pcstackBANK0, BANKED
575E  EC2E     CALL 0xF05C, 0
5760  F078     NOP
5762  0100     MOVLB 0x0
5764  19A2     XORWF _UADtf_RErrBUF, W, BANKED
5766  E00B     BZ 0x577E
5768  ECFE     CALL 0xF3FC, 0
576A  F079     NOP
576C  0100     MOVLB 0x0
576E  6BDF     CLRF pco, BANKED
5770  0ED2     MOVLW 0xD2
5772  6FDE     MOVWF __pcstackBANK0, BANKED
5774  C0A2     MOVFF _UADtf_RErrBUF, bdat
5776  F0E0     NOP
5778  EC58     CALL 0xE2B0, 0
577A  F071     NOP
577C  D000     BRA 0x577E
466:               }
467:               if((DtKNF.mgpm>_KMINMXP)&&(DtKNF.mgpm<_KMAXMXP)||DtKNF.mgpm==_KMINMXP||DtKNF.mgpm==_KMAXMXP)
577E  0E0F     MOVLW 0xF
5780  0100     MOVLB 0x0
5782  65A3     CPFSGT _UADtf_RErrREC, BANKED
5784  D004     BRA 0x578E
5786  0E62     MOVLW 0x62
5788  65A3     CPFSGT _UADtf_RErrREC, BANKED
578A  D009     BRA 0x579E
578C  D000     BRA 0x578E
578E  0E0F     MOVLW 0xF
5790  0100     MOVLB 0x0
5792  19A3     XORWF _UADtf_RErrREC, W, BANKED
5794  E004     BZ 0x579E
5796  0E63     MOVLW 0x63
5798  19A3     XORWF _UADtf_RErrREC, W, BANKED
579A  A4D8     BTFSS STATUS, 2, ACCESS
579C  0012     RETURN 0
468:               {
469:                   if(DtKNF.mgpm<DtKNF.mdpm)
579E  0100     MOVLB 0x0
57A0  51A2     MOVF _UADtf_RErrBUF, W, BANKED
57A2  5DA3     SUBWF _UADtf_RErrREC, W, BANKED
57A4  E206     BC 0x57B2
470:                   {
471:                       if(DtKNF.mdpm<=_KMAXMXP) DtKNF.mgpm=DtKNF.mdpm;
57A6  0E64     MOVLW 0x64
57A8  61A2     CPFSLT _UADtf_RErrBUF, BANKED
57AA  D003     BRA 0x57B2
57AC  C0A2     MOVFF _UADtf_RErrBUF, _UADtf_RErrREC
57AE  F0A3     NOP
57B0  D000     BRA 0x57B2
472:                   }
473:                   if(DtKNF.mgpm!=eeprom_read(_ADRMXPM)) eeprom_write(_ADRMXPM,DtKNF.mgpm);
57B2  0100     MOVLB 0x0
57B4  6BDF     CLRF pco, BANKED
57B6  0ED5     MOVLW 0xD5
57B8  6FDE     MOVWF __pcstackBANK0, BANKED
57BA  EC2E     CALL 0xF05C, 0
57BC  F078     NOP
57BE  0100     MOVLB 0x0
57C0  19A3     XORWF _UADtf_RErrREC, W, BANKED
57C2  B4D8     BTFSC STATUS, 2, ACCESS
57C4  0012     RETURN 0
57C6  ECFE     CALL 0xF3FC, 0
57C8  F079     NOP
57CA  0100     MOVLB 0x0
57CC  6BDF     CLRF pco, BANKED
57CE  0ED5     MOVLW 0xD5
57D0  6FDE     MOVWF __pcstackBANK0, BANKED
57D2  C0A3     MOVFF _UADtf_RErrREC, bdat
57D4  F0E0     NOP
57D6  EC58     CALL 0xE2B0, 0
57D8  F071     NOP
57DA  0012     RETURN 0
474:               }    
475:           }
57DC  0012     RETURN 0
476:           
477:           void SetNST(void)
478:           {
479:               PomiarZW(); //temperatura z czujnika zewnetrznego
CD04  EC1B     CALL 0xEC36, 0
CD06  F076     NOP
480:               if(!DtZWf_on_ZW)
CD08  B406     BTFSC DtKNFf_wymCO, 2, ACCESS
CD0A  D00D     BRA 0xCD26
481:               {
482:                   if(!DtKNF.opdg)
CD0C  0100     MOVLB 0x0
CD0E  51A7     MOVF _rglf_btco, W, BANKED
CD10  E104     BNZ 0xCD1A
483:                   {
484:                       DtCO.minPCO = _MIN_PCO;
CD12  0E28     MOVLW 0x28
CD14  6FD2     MOVWF 0xD2, BANKED
485:                       DtCO.maxPCO = _MAX_PCO;
CD16  0E55     MOVLW 0x55
CD18  D010     BRA 0xCD3A
486:                   }
487:                   else
488:                   {
489:                       DtCO.minPCO = _MIN_PDCO;
CD1A  0E23     MOVLW 0x23
CD1C  0100     MOVLB 0x0
CD1E  6FD2     MOVWF 0xD2, BANKED
490:                       DtCO.maxPCO = _MAX_PDCO;
CD20  0E37     MOVLW 0x37
CD22  D00B     BRA 0xCD3A
491:                   }
492:               }
CD24  D00D     BRA 0xCD40
493:               else
494:               {
495:                   Mf_AKTYWNE_PGD = 1;
CD26  8A06     BSF DtKNFf_wymCO, 5, ACCESS
496:                   SetPrt(S_PGD, 1);
CD28  0E01     MOVLW 0x1
CD2A  0100     MOVLB 0x0
CD2C  6FDE     MOVWF __pcstackBANK0, BANKED
CD2E  0E14     MOVLW 0x14
CD30  EC01     CALL 0xDA02, 0
CD32  F06D     NOP
497:                   DtCO.minPCO = _MIN_PGD;
CD34  0100     MOVLB 0x0
CD36  6BD2     CLRF 0xD2, BANKED
498:                   DtCO.maxPCO = _MAX_PGD;
CD38  0E63     MOVLW 0x63
CD3A  0100     MOVLB 0x0
CD3C  6FD3     MOVWF 0xD3, BANKED
CD3E  D000     BRA 0xCD40
499:               }
500:               if(DtCO.PCO < DtCO.minPCO) DtCO.PCO = DtCO.minPCO;
CD40  0100     MOVLB 0x0
CD42  51D2     MOVF 0xD2, W, BANKED
CD44  5DD0     SUBWF 0xD0, W, BANKED
CD46  E203     BC 0xCD4E
CD48  C0D2     MOVFF 0xD2, 0xD0
CD4A  F0D0     NOP
CD4C  D000     BRA 0xCD4E
501:               if(DtCO.PCO > DtCO.maxPCO) DtCO.PCO = DtCO.maxPCO;
CD4E  0100     MOVLB 0x0
CD50  51D0     MOVF 0xD0, W, BANKED
CD52  5DD3     SUBWF 0xD3, W, BANKED
CD54  E203     BC 0xCD5C
CD56  C0D3     MOVFF 0xD3, 0xD0
CD58  F0D0     NOP
CD5A  D000     BRA 0xCD5C
502:               if(DtCO.PCO != eeprom_read(_ADRPCO)) eeprom_write(_ADRPCO, DtCO.PCO);
CD5C  0100     MOVLB 0x0
CD5E  6BDF     CLRF pco, BANKED
CD60  0EC9     MOVLW 0xC9
CD62  6FDE     MOVWF __pcstackBANK0, BANKED
CD64  EC2E     CALL 0xF05C, 0
CD66  F078     NOP
CD68  0100     MOVLB 0x0
CD6A  19D0     XORWF 0xD0, W, BANKED
CD6C  B4D8     BTFSC STATUS, 2, ACCESS
CD6E  0012     RETURN 0
CD70  ECFE     CALL 0xF3FC, 0
CD72  F079     NOP
CD74  0100     MOVLB 0x0
CD76  6BDF     CLRF pco, BANKED
CD78  0EC9     MOVLW 0xC9
CD7A  6FDE     MOVWF __pcstackBANK0, BANKED
CD7C  C0D0     MOVFF 0xD0, bdat
CD7E  F0E0     NOP
CD80  EF58     GOTO 0xE2B0
CD82  F071     NOP
503:           }
CD84  0012     RETURN 0
504:           /*---------------------------------------------------------------------------------*/
505:           //Odczytuje i interpretuje parametry zapisane w pamieci EEPROM
506:           
507:           void RdEEParam(void)
508:           {
509:               //-----
510:               DtKNF.tpkt = eeprom_read(_ADRWTK); //typ kotla
A66C  0100     MOVLB 0x0
A66E  6BDF     CLRF pco, BANKED
A670  0EC5     MOVLW 0xC5
A672  6FDE     MOVWF __pcstackBANK0, BANKED
A674  EC2E     CALL 0xF05C, 0
A676  F078     NOP
A678  0100     MOVLB 0x0
A67A  6F9E     MOVWF _PWMf_ENPWM2, BANKED
511:               SetTpKtParam(); //ustaw param. ukryte dla wybr. typu kotla
A67C  EC39     CALL 0xE072, 0
A67E  F070     NOP
512:               //-----
513:               ModParam(DtKNF.tpkt, DtKNF.rdgz = eeprom_read(_ADRRGZ)); //parametry modulatora dla wybranego typu kotla i rodzaju gazu
A680  0100     MOVLB 0x0
A682  6BDF     CLRF pco, BANKED
A684  0EC4     MOVLW 0xC4
A686  6FDE     MOVWF __pcstackBANK0, BANKED
A688  EC2E     CALL 0xF05C, 0
A68A  F078     NOP
A68C  0100     MOVLB 0x0
A68E  6F9F     MOVWF _PWMf_tpGZ, BANKED
A690  C09F     MOVFF _PWMf_tpGZ, bdat
A692  F0E0     NOP
A694  519E     MOVF _PWMf_ENPWM2, W, BANKED
A696  EC43     CALL 0x5086, 0
A698  F028     NOP
514:               MocStart(DtKNF.mstr = eeprom_read(_ADRMST)); //moc startowa
A69A  0100     MOVLB 0x0
A69C  6BDF     CLRF pco, BANKED
A69E  0EC1     MOVLW 0xC1
A6A0  6FDE     MOVWF __pcstackBANK0, BANKED
A6A2  EC2E     CALL 0xF05C, 0
A6A4  F078     NOP
A6A6  0100     MOVLB 0x0
A6A8  6F9A     MOVWF _PFNf_trbECO, BANKED
A6AA  519A     MOVF _PFNf_trbECO, W, BANKED
A6AC  ECF0     CALL 0xBDE0, 0
A6AE  F05E     NOP
515:               MocMaksCW(DtKNF.mxcw = eeprom_read(_ADRMCW)); //moc maksymalna CW
A6B0  0100     MOVLB 0x0
A6B2  6BDF     CLRF pco, BANKED
A6B4  0EC2     MOVLW 0xC2
A6B6  6FDE     MOVWF __pcstackBANK0, BANKED
A6B8  EC2E     CALL 0xF05C, 0
A6BA  F078     NOP
A6BC  0100     MOVLB 0x0
A6BE  6F9B     MOVWF _PFNf_zima, BANKED
A6C0  519B     MOVF _PFNf_zima, W, BANKED
A6C2  EC37     CALL 0xCA6E, 0
A6C4  F065     NOP
516:               MocMaksCO(DtKNF.mxco = eeprom_read(_ADRMCO)); //moc maksymalna CO
A6C6  0100     MOVLB 0x0
A6C8  6BDF     CLRF pco, BANKED
A6CA  0EC3     MOVLW 0xC3
A6CC  6FDE     MOVWF __pcstackBANK0, BANKED
A6CE  EC2E     CALL 0xF05C, 0
A6D0  F078     NOP
A6D2  0100     MOVLB 0x0
A6D4  6F9C     MOVWF _PWMf_ENOSC, BANKED
A6D6  519C     MOVF _PWMf_ENOSC, W, BANKED
A6D8  EC7A     CALL 0xCAF4, 0
A6DA  F065     NOP
517:               DtKNF.aleg = eeprom_read(_ADRTAL); //aktywacja timera AL
A6DC  0100     MOVLB 0x0
A6DE  6BDF     CLRF pco, BANKED
A6E0  0EC6     MOVLW 0xC6
A6E2  6FDE     MOVWF __pcstackBANK0, BANKED
A6E4  EC2E     CALL 0xF05C, 0
A6E6  F078     NOP
A6E8  0100     MOVLB 0x0
A6EA  6FA9     MOVWF _rglf_del1s, BANKED
518:               DtKNF.robg = eeprom_read(_ADROBG); //rodzaj obiegu 0-otwarty,1-zamkniety
A6EC  0100     MOVLB 0x0
A6EE  6BDF     CLRF pco, BANKED
A6F0  0EC8     MOVLW 0xC8
A6F2  6FDE     MOVWF __pcstackBANK0, BANKED
A6F4  EC2E     CALL 0xF05C, 0
A6F6  F078     NOP
A6F8  0100     MOVLB 0x0
A6FA  6FA6     MOVWF _mux, BANKED
519:               PFN.poz = eeprom_read(_ADRPFN); //pozycja PFN
A6FC  0100     MOVLB 0x0
A6FE  6BDF     CLRF pco, BANKED
A700  0ECB     MOVLW 0xCB
A702  6FDE     MOVWF __pcstackBANK0, BANKED
A704  EC2E     CALL 0xF05C, 0
A706  F078     NOP
A708  0101     MOVLB 0x1
A70A  6FF3     MOVWF min, BANKED
520:               SetPFN();
A70C  EC12     CALL 0xE224, 0
A70E  F071     NOP
521:               DtKNF.opdg = eeprom_read(_ADRPDG); //aktywacja trybu ogrzewania podlogowego
A710  0100     MOVLB 0x0
A712  6BDF     CLRF pco, BANKED
A714  0ECC     MOVLW 0xCC
A716  6FDE     MOVWF __pcstackBANK0, BANKED
A718  EC2E     CALL 0xF05C, 0
A71A  F078     NOP
A71C  0100     MOVLB 0x0
A71E  6FA7     MOVWF _rglf_btco, BANKED
522:               DtCO.PCO = eeprom_read(_ADRPCO); //nastawa PCO
A720  0100     MOVLB 0x0
A722  6BDF     CLRF pco, BANKED
A724  0EC9     MOVLW 0xC9
A726  6FDE     MOVWF __pcstackBANK0, BANKED
A728  EC2E     CALL 0xF05C, 0
A72A  F078     NOP
A72C  0100     MOVLB 0x0
A72E  6FD0     MOVWF 0xD0, BANKED
523:               DtCW.PCW = eeprom_read(_ADRPCW); //nastawa PCW
A730  0100     MOVLB 0x0
A732  6BDF     CLRF pco, BANKED
A734  0ECA     MOVLW 0xCA
A736  6FDE     MOVWF __pcstackBANK0, BANKED
A738  EC2E     CALL 0xF05C, 0
A73A  F078     NOP
A73C  0100     MOVLB 0x0
A73E  6FAB     MOVWF _rglf_fast_up, BANKED
524:               SetNST();
A740  EC82     CALL 0xCD04, 0
A742  F066     NOP
525:               PFN.PCO = DtCO.PCO;
A744  C0D0     MOVFF 0xD0, 0x1EF
A746  F1EF     NOP
A748  0101     MOVLB 0x1
A74A  6BF0     CLRF p, BANKED
526:               PFN.PCW = DtCW.PCW;
A74C  C0AB     MOVFF _rglf_fast_up, 0x1F1
A74E  F1F1     NOP
A750  0101     MOVLB 0x1
A752  6BF2     CLRF tid, BANKED
527:               DtKNF.tpcs = eeprom_read(_ADRCS5); //alternatywny czujnik cisnienia 5V
A754  0100     MOVLB 0x0
A756  6BDF     CLRF pco, BANKED
A758  0ECD     MOVLW 0xCD
A75A  6FDE     MOVWF __pcstackBANK0, BANKED
A75C  EC2E     CALL 0xF05C, 0
A75E  F078     NOP
A760  0100     MOVLB 0x0
A762  6FA8     MOVWF _rglf_btcw, BANKED
528:               DtKNFf_wymCO = 0; //wylacz wymuszenie CO
A764  9006     BCF DtKNFf_wymCO, 0, ACCESS
529:               DtKNFf_wymCW = 0; //wylacz wymuszenie CW
A766  9206     BCF DtKNFf_wymCO, 1, ACCESS
530:               M.LICZNIK_ANL = eeprom_read(_ADRRTA); //wartosc timera AL
A768  0100     MOVLB 0x0
A76A  6BDF     CLRF pco, BANKED
A76C  0EC7     MOVLW 0xC7
A76E  6FDE     MOVWF __pcstackBANK0, BANKED
A770  EC2E     CALL 0xF05C, 0
A772  F078     NOP
A774  0100     MOVLB 0x0
A776  6F86     MOVWF _PFNf_opgres, BANKED
531:           
532:               if(M.LICZNIK_ANL)
A778  0100     MOVLB 0x0
A77A  5186     MOVF _PFNf_opgres, W, BANKED
A77C  E010     BZ 0xA79E
533:               {
534:                   if(!DtKNF.aleg || (DtKNF.tpkt != _UNICO)) //nieaktywna funkcja AL?
A77E  51A9     MOVF _rglf_del1s, W, BANKED
A780  E002     BZ 0xA786
A782  519E     MOVF _PWMf_ENPWM2, W, BANKED
A784  E00C     BZ 0xA79E
535:                   {
536:                       eeprom_write(_ADRRTA, 0); //wyzeruj licznik timera aktywacji AL
A786  ECFE     CALL 0xF3FC, 0
A788  F079     NOP
A78A  0100     MOVLB 0x0
A78C  6BDF     CLRF pco, BANKED
A78E  0EC7     MOVLW 0xC7
A790  6FDE     MOVWF __pcstackBANK0, BANKED
A792  6BE0     CLRF bdat, BANKED
A794  EC58     CALL 0xE2B0, 0
A796  F071     NOP
537:                       M.LICZNIK_ANL = 0;
A798  0100     MOVLB 0x0
A79A  6B86     CLRF _PFNf_opgres, BANKED
538:                   }
A79C  D000     BRA 0xA79E
539:               }
540:               //-----
541:               DtKNF.rdpm = eeprom_read(_ADRRDPM); //rodzaj pompy
A79E  0100     MOVLB 0x0
A7A0  6BDF     CLRF pco, BANKED
A7A2  0ED0     MOVLW 0xD0
A7A4  6FDE     MOVWF __pcstackBANK0, BANKED
A7A6  EC2E     CALL 0xF05C, 0
A7A8  F078     NOP
A7AA  0100     MOVLB 0x0
A7AC  6FA0     MOVWF _UADtf_RData, BANKED
542:               DtKNF.dtpm = eeprom_read(_ADRDLPM); //wielkosc delty T dla pompy
A7AE  0100     MOVLB 0x0
A7B0  6BDF     CLRF pco, BANKED
A7B2  0ED1     MOVLW 0xD1
A7B4  6FDE     MOVWF __pcstackBANK0, BANKED
A7B6  EC2E     CALL 0xF05C, 0
A7B8  F078     NOP
A7BA  0100     MOVLB 0x0
A7BC  6FA1     MOVWF _UADtf_REnd, BANKED
543:               DtKNF.mdpm = eeprom_read(_ADRMNPM); //dolny prog predkosci dla pompy
A7BE  0100     MOVLB 0x0
A7C0  6BDF     CLRF pco, BANKED
A7C2  0ED2     MOVLW 0xD2
A7C4  6FDE     MOVWF __pcstackBANK0, BANKED
A7C6  EC2E     CALL 0xF05C, 0
A7C8  F078     NOP
A7CA  0100     MOVLB 0x0
A7CC  6FA2     MOVWF _UADtf_RErrBUF, BANKED
544:           	DtKNF.mgpm = eeprom_read(_ADRMXPM);	//gorny prog predkosci dla pompy    
A7CE  0100     MOVLB 0x0
A7D0  6BDF     CLRF pco, BANKED
A7D2  0ED5     MOVLW 0xD5
A7D4  6FDE     MOVWF __pcstackBANK0, BANKED
A7D6  EC2E     CALL 0xF05C, 0
A7D8  F078     NOP
A7DA  0100     MOVLB 0x0
A7DC  6FA3     MOVWF _UADtf_RErrREC, BANKED
545:               DtKNF.teco = 0;
A7DE  0100     MOVLB 0x0
A7E0  6BA4     CLRF _UADtf_TData, BANKED
546:               DtIN.Eco = 5;
A7E2  0E05     MOVLW 0x5
A7E4  0101     MOVLB 0x1
A7E6  6F22     MOVWF _DtCWf_ad_DZ_CW, BANKED
547:               
548:           }
A7E8  0012     RETURN 0
549:           /*---------------------------------------------------------------------------------*/
550:           //Ustaw parametry ukryte dla wybranego typu kotla
551:           
552:           void SetTpKtParam(void)
553:           {
554:               switch(DtKNF.tpkt)
E072  D019     BRA 0xE0A6
E0A6  0100     MOVLB 0x0
E0A8  519E     MOVF _PWMf_ENPWM2, W, BANKED
E0AA  E0E4     BZ 0xE074
E0AC  0A01     XORLW 0x1
E0AE  E0E7     BZ 0xE07E
E0B0  0A03     XORLW 0x3
E0B2  E0EF     BZ 0xE092
E0B4  0A01     XORLW 0x1
E0B6  E0E8     BZ 0xE088
E0B8  D7F1     BRA 0xE09C
555:               {
556:                   case _UNICO: //zasobnikowy
557:                   {
558:                       DtKNF.czpr = _BRAK;
E074  0E00     MOVLW 0x0
E076  0100     MOVLB 0x0
E078  6F9D     MOVWF _PWMf_ENPWM, BANKED
559:                       //DtKNF.rdpm=_KDWA;
560:                       DtKNF.tpwm = _TERMET;
E07A  6FA5     MOVWF _UADtf_TEnd, BANKED
561:                       break;
E07C  0C00     RETLW 0x0
562:                   }
563:                   case _BITERM: //bitermiczny (miniterm)
564:                   {
565:                       DtKNF.czpr = _BRAK;
E07E  0E00     MOVLW 0x0
E080  0100     MOVLB 0x0
E082  6F9D     MOVWF _PWMf_ENPWM, BANKED
566:                       //DtKNF.rdpm=_KJEDEN;
567:                       DtKNF.tpwm = _TERMET;
E084  6FA5     MOVWF _UADtf_TEnd, BANKED
568:                       break;
E086  0C00     RETLW 0x0
569:                   }
570:                   case _MONOHB: //monotermiczny z hydroblokiem
571:                   {
572:                       DtKNF.czpr = _BRAK;
E088  0E00     MOVLW 0x0
E08A  0100     MOVLB 0x0
E08C  6F9D     MOVWF _PWMf_ENPWM, BANKED
573:                       //DtKNF.rdpm=_KDWA;
574:                       DtKNF.tpwm = _TERMET;
E08E  6FA5     MOVWF _UADtf_TEnd, BANKED
575:                       break;
E090  0C00     RETLW 0x0
576:                   }
577:                   case _BITERM2: //bitermiczny (maxiterm)
578:                   {
579:                       DtKNF.czpr = _BRAK;
E092  0E00     MOVLW 0x0
E094  0100     MOVLB 0x0
E096  6F9D     MOVWF _PWMf_ENPWM, BANKED
580:                       //DtKNF.rdpm=_KJEDEN;
581:                       DtKNF.tpwm = _TERMET;
E098  6FA5     MOVWF _UADtf_TEnd, BANKED
582:                       break;
E09A  0C00     RETLW 0x0
583:                   }
584:                   default: //domyslny monotermiczny
585:                   {
586:                       DtKNF.czpr = _BRAK;
E09C  0E00     MOVLW 0x0
E09E  0100     MOVLB 0x0
E0A0  6F9D     MOVWF _PWMf_ENPWM, BANKED
587:                       //DtKNF.rdpm=_KDWA;
588:                       DtKNF.tpwm = _TERMET;
E0A2  6FA5     MOVWF _UADtf_TEnd, BANKED
589:                       break;
590:                   }
591:               }
E0A4  0012     RETURN 0
592:           }
E0BA  0012     RETURN 0
593:           /*---------------------------------------------------------------------------------*/
594:           //ustaw domyslne wartosci wybranych parametrów po zmianie typu kotla
595:           
596:           void SetDefaultValue(void)
597:           {
598:               switch(DtKNF.tpkt)
E2F6  D01B     BRA 0xE32E
E32E  0100     MOVLB 0x0
E330  519E     MOVF _PWMf_ENPWM2, W, BANKED
E332  0A03     XORLW 0x3
E334  E0E1     BZ 0xE2F8
E336  D7ED     BRA 0xE312
599:               {
600:                   case _MONOHB: //monotermiczny z hydroblokiem
601:                   {
602:                       DtKNF.mstr = 15;
E2F8  0E0F     MOVLW 0xF
E2FA  0100     MOVLB 0x0
E2FC  6F9A     MOVWF _PFNf_trbECO, BANKED
603:                       eeprom_write(_ADRMST, DtKNF.mstr);
E2FE  ECFE     CALL 0xF3FC, 0
E300  F079     NOP
E302  0100     MOVLB 0x0
E304  6BDF     CLRF pco, BANKED
E306  0EC1     MOVLW 0xC1
E308  6FDE     MOVWF __pcstackBANK0, BANKED
E30A  C09A     MOVFF _PFNf_trbECO, bdat
E30C  F0E0     NOP
E30E  EF58     GOTO 0xE2B0
E310  F071     NOP
604:                       break;
605:                   }
606:                   default:
607:                   {
608:                       DtKNF.mstr = 40;
E312  0E28     MOVLW 0x28
E314  0100     MOVLB 0x0
E316  6F9A     MOVWF _PFNf_trbECO, BANKED
609:                       eeprom_write(_ADRMST, DtKNF.mstr);
E318  ECFE     CALL 0xF3FC, 0
E31A  F079     NOP
E31C  0100     MOVLB 0x0
E31E  6BDF     CLRF pco, BANKED
E320  0EC1     MOVLW 0xC1
E322  6FDE     MOVWF __pcstackBANK0, BANKED
E324  C09A     MOVFF _PFNf_trbECO, bdat
E326  F0E0     NOP
E328  EC58     CALL 0xE2B0, 0
E32A  F071     NOP
610:                       break;
611:                   }
612:               }
E32C  0012     RETURN 0
613:           }
E338  0012     RETURN 0
614:           /*---------------------------------------------------------------------------------*/
615:           
616:           /*---------------------------------------------------------------------------------*/
617:           void SetPFN(void)
618:           {
619:               if(PFN.poz == _PFOFF)
E224  0101     MOVLB 0x1
E226  05F3     DECF min, W, BANKED
E228  E105     BNZ 0xE234
620:               {
621:                   PFNf_zima = 0;
E22A  9613     BCF PFNf_zima, 3, ACCESS
622:                   PFNf_lato = 0;
E22C  9E0E     BCF PFNf_lato, 7, ACCESS
623:                   PFNf_off = 1;
E22E  8E0F     BSF PFNf_off, 7, ACCESS
624:                   PFNf_csn = 0;
E230  960D     BCF PFNf_b_str_nco, 3, ACCESS
625:               }
E232  0012     RETURN 0
626:               else
627:                   if(PFN.poz == _PFZMA)
E234  0E03     MOVLW 0x3
E236  0101     MOVLB 0x1
E238  19F3     XORWF min, W, BANKED
E23A  E105     BNZ 0xE246
628:               {
629:                   PFNf_zima = 1;
E23C  8613     BSF PFNf_zima, 3, ACCESS
630:                   PFNf_lato = 0;
E23E  9E0E     BCF PFNf_lato, 7, ACCESS
631:                   PFNf_off = 0;
E240  9E0F     BCF PFNf_off, 7, ACCESS
632:                   PFNf_csn = 0;
E242  960D     BCF PFNf_b_str_nco, 3, ACCESS
633:               }
E244  0012     RETURN 0
634:               else
635:                   if(PFN.poz == _PFLTO)
E246  0E02     MOVLW 0x2
E248  0101     MOVLB 0x1
E24A  19F3     XORWF min, W, BANKED
E24C  E105     BNZ 0xE258
636:               {
637:                   PFNf_zima = 0;
E24E  9613     BCF PFNf_zima, 3, ACCESS
638:                   PFNf_lato = 1;
E250  8E0E     BSF PFNf_lato, 7, ACCESS
639:                   PFNf_off = 0;
E252  9E0F     BCF PFNf_off, 7, ACCESS
640:                   PFNf_csn = 0;
E254  960D     BCF PFNf_b_str_nco, 3, ACCESS
641:               }
E256  0012     RETURN 0
642:               else
643:               {
644:                   PFNf_zima = 1;
E258  8613     BSF PFNf_zima, 3, ACCESS
645:                   PFNf_lato = 0;
E25A  9E0E     BCF PFNf_lato, 7, ACCESS
646:                   PFNf_off = 0;
E25C  9E0F     BCF PFNf_off, 7, ACCESS
647:                   PFNf_csn = 0;
E25E  960D     BCF PFNf_b_str_nco, 3, ACCESS
648:                   PFN.poz = _PFZMA;
E260  0E03     MOVLW 0x3
E262  0101     MOVLB 0x1
E264  6FF3     MOVWF min, BANKED
649:               }
E266  0012     RETURN 0
650:           }
E268  0012     RETURN 0
651:           /*---------------------------------------------------------------------------------*/
652:           
653:           /*---------------------------------------------------------------------------------*/
654:           void WriteEEPCW(void)
655:           {
656:               eeprom_write(_ADRPCW, DtCW.PCW);
F152  ECFE     CALL 0xF3FC, 0
F154  F079     NOP
F156  0100     MOVLB 0x0
F158  6BDF     CLRF pco, BANKED
F15A  0ECA     MOVLW 0xCA
F15C  6FDE     MOVWF __pcstackBANK0, BANKED
F15E  C0AB     MOVFF _rglf_fast_up, bdat
F160  F0E0     NOP
F162  EC58     CALL 0xE2B0, 0
F164  F071     NOP
657:           }
F166  0012     RETURN 0
658:           
659:           unsigned char ReadEEPCW(void)
660:           {
661:               return eeprom_read(_ADRPCW);
662:           }
663:           /*---------------------------------------------------------------------------------*/
664:           
665:           /*---------------------------------------------------------------------------------*/
666:           void WriteEEPCO(void)
667:           {
668:               eeprom_write(_ADRPCO, DtCO.PCO);
F168  ECFE     CALL 0xF3FC, 0
F16A  F079     NOP
F16C  0100     MOVLB 0x0
F16E  6BDF     CLRF pco, BANKED
F170  0EC9     MOVLW 0xC9
F172  6FDE     MOVWF __pcstackBANK0, BANKED
F174  C0D0     MOVFF 0xD0, bdat
F176  F0E0     NOP
F178  EC58     CALL 0xE2B0, 0
F17A  F071     NOP
669:           }
F17C  0012     RETURN 0
670:           
671:           unsigned char ReadEEPCO(void)
672:           {
673:               return eeprom_read(_ADRPCO);
674:           }
675:           /*---------------------------------------------------------------------------------*/
676:           
677:           /*---------------------------------------------------------------------------------*/
678:           void WriteEEPFN(void)
679:           {
680:               eeprom_write(_ADRPFN, PFN.poz);
F13C  ECFE     CALL 0xF3FC, 0
F13E  F079     NOP
F140  0100     MOVLB 0x0
F142  6BDF     CLRF pco, BANKED
F144  0ECB     MOVLW 0xCB
F146  6FDE     MOVWF __pcstackBANK0, BANKED
F148  C1F3     MOVFF 0x1F3, bdat
F14A  F0E0     NOP
F14C  EC58     CALL 0xE2B0, 0
F14E  F071     NOP
681:           }
F150  0012     RETURN 0
682:           
683:           unsigned char ReadEEPFN(void)
684:           {
685:               return eeprom_read(_ADRPFN);
F374  0100     MOVLB 0x0
F376  6BDF     CLRF pco, BANKED
F378  0ECB     MOVLW 0xCB
F37A  6FDE     MOVWF __pcstackBANK0, BANKED
F37C  EF2E     GOTO 0xF05C
F37E  F078     NOP
686:           }
F380  0012     RETURN 0
687:           /*---------------------------------------------------------------------------------*/
688:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/keypad.c  --------------------------------
1:             /*keypad.c*/
2:             //Funkcje obslugi przycisku RESET dla celow konfiguracji
3:             // (!) Bazuje na funkcjach z plikow: rtimer.c
4:             /*---------------------------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"			//parametry globalne
7:             #include "keypad.h"			//parametry lokalne
8:             
9:             /*---------------------------------------------------------------------------------*/
10:            /*---------------------------------------------------------------------------------*/
11:            #if _EN_PK!=0
12:            volatile StPin ky[_EN_PK];
13:            #endif
14:            #if _EN_DPK!=0
15:            volatile StPin dky[_EN_DPK];
16:            #endif
17:            #if _EN_EXPK!=0
18:            volatile StPin xky[_EN_EXPK];
19:            #endif
20:            #if _EN_EXXPK!=0
21:            volatile StPin xxky[_EN_EXXPK];
22:            #endif
23:            
24:            //-------------------------------------------------------------------------------
25:            //-------------------------------------------------------------------------------
26:            //Timer na potrzeby obslugi przyciskow (umiescic w przerwaniu od zegara TMR1)
27:            
28:            void IncKeyTimer(void)
29:            {
30:                unsigned char i;
31:            #if _EN_PK!=0
32:                for(i = 0; i < _EN_PK; i++)
ABD6  0E00     MOVLW 0x0
ABD8  6E17     MOVWF _DtCOf_su_CO, ACCESS
ABDA  0E06     MOVLW 0x6
ABDC  6417     CPFSGT _DtCOf_su_CO, ACCESS
ABDE  D001     BRA 0xABE2
ABE0  D044     BRA 0xAC6A
AC66  2A17     INCF _DtCOf_su_CO, F, ACCESS
AC68  D7B8     BRA 0xABDA
33:                {
34:                    ky[i].cS++;
ABE2  5017     MOVF _DtCOf_su_CO, W, ACCESS
ABE4  0D05     MULLW 0x5
ABE6  2AF3     INCF PROD, F, ACCESS
ABE8  0E00     MOVLW 0x0
ABEA  22F4     ADDWFC PRODH, F, ACCESS
ABEC  0EA6     MOVLW 0xA6
ABEE  24F3     ADDWF PROD, W, ACCESS
ABF0  6ED9     MOVWF FSR2, ACCESS
ABF2  0E01     MOVLW 0x1
ABF4  20F4     ADDWFC PRODH, W, ACCESS
ABF6  6EDA     MOVWF FSR2H, ACCESS
ABF8  2ADF     INCF INDF2, F, ACCESS
35:                    if(ky[i].cS > 9)
ABFA  5017     MOVF _DtCOf_su_CO, W, ACCESS
ABFC  0D05     MULLW 0x5
ABFE  2AF3     INCF PROD, F, ACCESS
AC00  0E00     MOVLW 0x0
AC02  22F4     ADDWFC PRODH, F, ACCESS
AC04  0EA6     MOVLW 0xA6
AC06  24F3     ADDWF PROD, W, ACCESS
AC08  6ED9     MOVWF FSR2, ACCESS
AC0A  0E01     MOVLW 0x1
AC0C  20F4     ADDWFC PRODH, W, ACCESS
AC0E  6EDA     MOVWF FSR2H, ACCESS
AC10  0E09     MOVLW 0x9
AC12  64DF     CPFSGT INDF2, ACCESS
AC14  D028     BRA 0xAC66
36:                    {
37:                        ky[i].cS = 0;
AC16  5017     MOVF _DtCOf_su_CO, W, ACCESS
AC18  0D05     MULLW 0x5
AC1A  2AF3     INCF PROD, F, ACCESS
AC1C  0E00     MOVLW 0x0
AC1E  22F4     ADDWFC PRODH, F, ACCESS
AC20  0EA6     MOVLW 0xA6
AC22  24F3     ADDWF PROD, W, ACCESS
AC24  6ED9     MOVWF FSR2, ACCESS
AC26  0E01     MOVLW 0x1
AC28  20F4     ADDWFC PRODH, W, ACCESS
AC2A  6EDA     MOVWF FSR2H, ACCESS
AC2C  6ADF     CLRF INDF2, ACCESS
38:                        if(ky[i].dS < 255) ky[i].dS++;
AC2E  5017     MOVF _DtCOf_su_CO, W, ACCESS
AC30  0D05     MULLW 0x5
AC32  0E02     MOVLW 0x2
AC34  26F3     ADDWF PROD, F, ACCESS
AC36  0E00     MOVLW 0x0
AC38  22F4     ADDWFC PRODH, F, ACCESS
AC3A  0EA6     MOVLW 0xA6
AC3C  24F3     ADDWF PROD, W, ACCESS
AC3E  6ED9     MOVWF FSR2, ACCESS
AC40  0E01     MOVLW 0x1
AC42  20F4     ADDWFC PRODH, W, ACCESS
AC44  6EDA     MOVWF FSR2H, ACCESS
AC46  28DE     INCF POSTINC2, W, ACCESS
AC48  E00E     BZ 0xAC66
AC4A  5017     MOVF _DtCOf_su_CO, W, ACCESS
AC4C  0D05     MULLW 0x5
AC4E  0E02     MOVLW 0x2
AC50  26F3     ADDWF PROD, F, ACCESS
AC52  0E00     MOVLW 0x0
AC54  22F4     ADDWFC PRODH, F, ACCESS
AC56  0EA6     MOVLW 0xA6
AC58  24F3     ADDWF PROD, W, ACCESS
AC5A  6ED9     MOVWF FSR2, ACCESS
AC5C  0E01     MOVLW 0x1
AC5E  20F4     ADDWFC PRODH, W, ACCESS
AC60  6EDA     MOVWF FSR2H, ACCESS
AC62  2ADF     INCF INDF2, F, ACCESS
AC64  D000     BRA 0xAC66
39:                    }
40:                }
41:            #endif
42:            #if _EN_DPK!=0
43:                for(i = 0; i < _EN_DPK; i++)
44:                {
45:                    dky[i].cS++;
46:                    if(dky[i].cS > 9)
47:                    {
48:                        dky[i].cS = 0;
49:                        if(dky[i].dS < 255) dky[i].dS++;
50:                    }
51:                }
52:            #endif
53:            #if _EN_EXPK!=0
54:                for(i = 0; i < _EN_EXPK; i++)
55:                {
56:                    xky[i].cS++;
57:                    if(xky[i].cS > 9)
58:                    {
59:                        xky[i].cS = 0;
60:                        if(xky[i].dS < 255) xky[i].dS++;
61:                    }
62:                }
63:            #endif
64:            #if _EN_EXXPK!=0
65:                for(i = 0; i < _EN_EXXPK; i++)
AC6A  0E00     MOVLW 0x0
AC6C  6E17     MOVWF _DtCOf_su_CO, ACCESS
AC6E  0E06     MOVLW 0x6
AC70  6417     CPFSGT _DtCOf_su_CO, ACCESS
AC72  D002     BRA 0xAC78
AC74  0C06     RETLW 0x6
AC76  0012     RETURN 0
ACFC  2A17     INCF _DtCOf_su_CO, F, ACCESS
ACFE  0E06     MOVLW 0x6
AD00  6417     CPFSGT _DtCOf_su_CO, ACCESS
AD02  D7BA     BRA 0xAC78
AD04  0C06     RETLW 0x6
66:                {
67:                    xxky[i].cS++;
AC78  5017     MOVF _DtCOf_su_CO, W, ACCESS
AC7A  0D05     MULLW 0x5
AC7C  2AF3     INCF PROD, F, ACCESS
AC7E  0E00     MOVLW 0x0
AC80  22F4     ADDWFC PRODH, F, ACCESS
AC82  0E52     MOVLW 0x52
AC84  24F3     ADDWF PROD, W, ACCESS
AC86  6ED9     MOVWF FSR2, ACCESS
AC88  0E03     MOVLW 0x3
AC8A  20F4     ADDWFC PRODH, W, ACCESS
AC8C  6EDA     MOVWF FSR2H, ACCESS
AC8E  2ADF     INCF INDF2, F, ACCESS
68:                    if(xxky[i].cS > 9)
AC90  5017     MOVF _DtCOf_su_CO, W, ACCESS
AC92  0D05     MULLW 0x5
AC94  2AF3     INCF PROD, F, ACCESS
AC96  0E00     MOVLW 0x0
AC98  22F4     ADDWFC PRODH, F, ACCESS
AC9A  0E52     MOVLW 0x52
AC9C  24F3     ADDWF PROD, W, ACCESS
AC9E  6ED9     MOVWF FSR2, ACCESS
ACA0  0E03     MOVLW 0x3
ACA2  20F4     ADDWFC PRODH, W, ACCESS
ACA4  6EDA     MOVWF FSR2H, ACCESS
ACA6  0E09     MOVLW 0x9
ACA8  64DF     CPFSGT INDF2, ACCESS
ACAA  D028     BRA 0xACFC
69:                    {
70:                        xxky[i].cS = 0;
ACAC  5017     MOVF _DtCOf_su_CO, W, ACCESS
ACAE  0D05     MULLW 0x5
ACB0  2AF3     INCF PROD, F, ACCESS
ACB2  0E00     MOVLW 0x0
ACB4  22F4     ADDWFC PRODH, F, ACCESS
ACB6  0E52     MOVLW 0x52
ACB8  24F3     ADDWF PROD, W, ACCESS
ACBA  6ED9     MOVWF FSR2, ACCESS
ACBC  0E03     MOVLW 0x3
ACBE  20F4     ADDWFC PRODH, W, ACCESS
ACC0  6EDA     MOVWF FSR2H, ACCESS
ACC2  6ADF     CLRF INDF2, ACCESS
71:                        if(xxky[i].dS < 255) xxky[i].dS++;
ACC4  5017     MOVF _DtCOf_su_CO, W, ACCESS
ACC6  0D05     MULLW 0x5
ACC8  0E02     MOVLW 0x2
ACCA  26F3     ADDWF PROD, F, ACCESS
ACCC  0E00     MOVLW 0x0
ACCE  22F4     ADDWFC PRODH, F, ACCESS
ACD0  0E52     MOVLW 0x52
ACD2  24F3     ADDWF PROD, W, ACCESS
ACD4  6ED9     MOVWF FSR2, ACCESS
ACD6  0E03     MOVLW 0x3
ACD8  20F4     ADDWFC PRODH, W, ACCESS
ACDA  6EDA     MOVWF FSR2H, ACCESS
ACDC  28DE     INCF POSTINC2, W, ACCESS
ACDE  E00E     BZ 0xACFC
ACE0  5017     MOVF _DtCOf_su_CO, W, ACCESS
ACE2  0D05     MULLW 0x5
ACE4  0E02     MOVLW 0x2
ACE6  26F3     ADDWF PROD, F, ACCESS
ACE8  0E00     MOVLW 0x0
ACEA  22F4     ADDWFC PRODH, F, ACCESS
ACEC  0E52     MOVLW 0x52
ACEE  24F3     ADDWF PROD, W, ACCESS
ACF0  6ED9     MOVWF FSR2, ACCESS
ACF2  0E03     MOVLW 0x3
ACF4  20F4     ADDWFC PRODH, W, ACCESS
ACF6  6EDA     MOVWF FSR2H, ACCESS
ACF8  2ADF     INCF INDF2, F, ACCESS
ACFA  D000     BRA 0xACFC
72:                    }
73:                }
74:            #endif
75:            }
AD06  0012     RETURN 0
76:            //-------------------------------------------------------------------------------
77:            //Restart zegara przycisku
78:            
79:            void StartKeyTim(volatile StPin *ky)
80:            {
81:                (*ky).cS = 0;
EE68  0100     MOVLB 0x0
EE6A  EE20     LFSR 2, 0x1
EE6C  F001     NOP
EE6E  51DE     MOVF __pcstackBANK0, W, BANKED
EE70  26D9     ADDWF FSR2, F, ACCESS
EE72  51DF     MOVF pco, W, BANKED
EE74  22DA     ADDWFC FSR2H, F, ACCESS
EE76  6ADF     CLRF INDF2, ACCESS
82:                (*ky).dS = 0;
EE78  EE20     LFSR 2, 0x2
EE7A  F002     NOP
EE7C  51DE     MOVF __pcstackBANK0, W, BANKED
EE7E  26D9     ADDWF FSR2, F, ACCESS
EE80  51DF     MOVF pco, W, BANKED
EE82  22DA     ADDWFC FSR2H, F, ACCESS
EE84  0E00     MOVLW 0x0
EE86  6ADF     CLRF INDF2, ACCESS
83:            }
EE88  0012     RETURN 0
84:            //-------------------------------------------------------------------------------
85:            //Odczyt stanu zegara przycisku
86:            
87:            unsigned char KeyTim(volatile StPin *ky)
88:            {
89:                return(*ky).dS;
F1CE  0100     MOVLB 0x0
F1D0  EE20     LFSR 2, 0x2
F1D2  F002     NOP
F1D4  51DE     MOVF __pcstackBANK0, W, BANKED
F1D6  26D9     ADDWF FSR2, F, ACCESS
F1D8  51DF     MOVF pco, W, BANKED
F1DA  22DA     ADDWFC FSR2H, F, ACCESS
F1DC  50DF     MOVF INDF2, W, ACCESS
F1DE  0012     RETURN 0
90:            }
F1E0  0012     RETURN 0
91:            /*---------------------------------------------------------------------------------*/
92:            //-----------------------------------------------------------
93:            //Funkcja detekcji nacisniecia przycisku (wersja podstawowa)
94:            //k-fizyczne wejscie procesora dla przycisku
95:            //ky - pamiec stanu przycisku
96:            //ng - typ reakcji: dla 0 zwraca 1 przy nacisnieciu przycisku, dla 1 przy puszczeniu przycisku 
97:            //np. PresKey(RdPrt(S_SET),&ky[S_SET])
98:            /*
99:            #if _EN_PK!=0
100:           unsigned char PresKey(unsigned char k,StPin *ky,unsigned char ng)
101:           {
102:                   (*ky).bk=(k)?1:0;
103:                   if ((!ng&&(!(*ky).sbk&&(*ky).bk))||(ng&&((*ky).sbk&&!(*ky).bk)))	//nacisnieto przycisk?
104:                   {
105:                           (*ky).sbk=((*ky).bk)?1:0;
106:                           return 1;
107:                   }
108:                   (*ky).sbk=((*ky).bk)?1:0;
109:                   return 0;
110:           }
111:           void SetBufKey(StPin *ky)
112:           {
113:                   (*ky).sbk=1;
114:           }
115:           void ResBufKey(StPin *ky)
116:           {
117:                   (*ky).sbk=0;
118:           }
119:           
120:           #endif
121:            */
122:           //-----------------------------------------------------------
123:           //Funkcja detekcji nacisniecia przycisku (I wersja rozszerzona)
124:           //k-fizyczne wejscie procesora dla przycisku
125:           //ky - pamiec stanu przycisku
126:           //ng - typ reakcji: dla 0 zwraca 1 przy nacisnieciu przycisku, dla 1 przy puszczeniu przycisku 
127:           //np. PresKey(RdPrt(S_SET),&ky[S_SET])
128:           //funkcja zwraca:
129:           //0 - przycisk w stanie spoczynku
130:           //1...99 - przycisk wcisniety lub podtrzymanie stanu przycisku, wartosc rowna czasowi przytrzymania przycisku
131:           //100 - dla szybkiego nacisniecia przycisku
132:           #if _EN_PK!=0
133:           
134:           unsigned char PresKeyEX(unsigned char k, volatile StPin *ky)
8556  0100     MOVLB 0x0
8558  6FE6     MOVWF counter, BANKED
135:           {
136:           
137:               (*ky).bk = (k) ? 1 : 0;
855A  0100     MOVLB 0x0
855C  51E6     MOVF counter, W, BANKED
855E  E003     BZ 0x8566
8560  6BE2     CLRF divisor, BANKED
8562  2BE2     INCF divisor, F, BANKED
8564  D002     BRA 0x856A
8566  0100     MOVLB 0x0
8568  6BE2     CLRF divisor, BANKED
856A  C0E0     MOVFF bdat, FSR2
856C  FFD9     NOP
856E  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8570  FFDA     NOP
8572  50DF     MOVF INDF2, W, ACCESS
8574  0100     MOVLB 0x0
8576  19E2     XORWF divisor, W, BANKED
8578  0BFE     ANDLW 0xFE
857A  19E2     XORWF divisor, W, BANKED
857C  6EDF     MOVWF INDF2, ACCESS
138:               switch((*ky).krk)
857E  D0F8     BRA 0x8770
8770  0100     MOVLB 0x0
8772  EE20     LFSR 2, 0x3
8774  F003     NOP
8776  51E0     MOVF bdat, W, BANKED
8778  26D9     ADDWF FSR2, F, ACCESS
877A  51E1     MOVF GIE_BIT_VAL, W, BANKED
877C  22DA     ADDWFC FSR2H, F, ACCESS
877E  50DF     MOVF INDF2, W, ACCESS
8780  E101     BNZ 0x8784
8782  D6FE     BRA 0x8580
8784  0A01     XORLW 0x1
8786  E101     BNZ 0x878A
8788  D72B     BRA 0x85E0
878A  0A03     XORLW 0x3
878C  E0A1     BZ 0x86D0
878E  0A01     XORLW 0x1
8790  E0D6     BZ 0x873E
8792  0C00     RETLW 0x0
139:               {
140:                       //oczekiwanie na nacisniecie przycisku
141:                   case 0:
142:                   {
143:                       if(!(*ky).sbk && (*ky).bk) //nacisnieto przycisk?
8580  C0E0     MOVFF bdat, FSR2
8582  FFD9     NOP
8584  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8586  FFDA     NOP
8588  B2DF     BTFSC INDF2, 1, ACCESS
858A  D01C     BRA 0x85C4
858C  C0E0     MOVFF bdat, FSR2
858E  FFD9     NOP
8590  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8592  FFDA     NOP
8594  A0DF     BTFSS INDF2, 0, ACCESS
8596  D016     BRA 0x85C4
144:                       {
145:                           (*ky).sbk = 1; //((*ky).bk)?1:0;
8598  C0E0     MOVFF bdat, FSR2
859A  FFD9     NOP
859C  C0E1     MOVFF GIE_BIT_VAL, FSR2H
859E  FFDA     NOP
85A0  0100     MOVLB 0x0
85A2  82DF     BSF INDF2, 1, ACCESS
146:                           StartKeyTim(ky);
85A4  C0E0     MOVFF bdat, __pcstackBANK0
85A6  F0DE     NOP
85A8  C0E1     MOVFF GIE_BIT_VAL, pco
85AA  F0DF     NOP
85AC  EC34     CALL 0xEE68, 0
85AE  F077     NOP
147:                           (*ky).krk = 1;
85B0  0100     MOVLB 0x0
85B2  EE20     LFSR 2, 0x3
85B4  F003     NOP
85B6  51E0     MOVF bdat, W, BANKED
85B8  26D9     ADDWF FSR2, F, ACCESS
85BA  51E1     MOVF GIE_BIT_VAL, W, BANKED
85BC  22DA     ADDWFC FSR2H, F, ACCESS
85BE  0E01     MOVLW 0x1
85C0  6EDF     MOVWF INDF2, ACCESS
148:                       }
85C2  D00C     BRA 0x85DC
149:                       else (*ky).sbk = ((*ky).bk) ? 1 : 0;
85C4  C0E0     MOVFF bdat, FSR2
85C6  FFD9     NOP
85C8  C0E1     MOVFF GIE_BIT_VAL, FSR2H
85CA  FFDA     NOP
85CC  A0DF     BTFSS INDF2, 0, ACCESS
85CE  D003     BRA 0x85D6
85D0  0100     MOVLB 0x0
85D2  82DF     BSF INDF2, 1, ACCESS
85D4  D003     BRA 0x85DC
85D6  0100     MOVLB 0x0
85D8  92DF     BCF INDF2, 1, ACCESS
85DA  D000     BRA 0x85DC
150:                       return 0;
85DC  0E00     MOVLW 0x0
85DE  0012     RETURN 0
151:                   }
152:                       //oczekiwanie na puszczenie przycisku
153:                   case 1:
154:                   {
155:                       (*ky).val = KeyTim(ky) + 1; //kod przytrzymania przycisku
85E0  C0E0     MOVFF bdat, __pcstackBANK0
85E2  F0DE     NOP
85E4  C0E1     MOVFF GIE_BIT_VAL, pco
85E6  F0DF     NOP
85E8  ECE7     CALL 0xF1CE, 0
85EA  F078     NOP
85EC  0100     MOVLB 0x0
85EE  6FE2     MOVWF divisor, BANKED
85F0  2BE2     INCF divisor, F, BANKED
85F2  EE20     LFSR 2, 0x4
85F4  F004     NOP
85F6  51E0     MOVF bdat, W, BANKED
85F8  26D9     ADDWF FSR2, F, ACCESS
85FA  51E1     MOVF GIE_BIT_VAL, W, BANKED
85FC  22DA     ADDWFC FSR2H, F, ACCESS
85FE  C0E2     MOVFF divisor, INDF2
8600  FFDF     NOP
156:                       if((*ky).val > 99) (*ky).val = 99;
8602  0100     MOVLB 0x0
8604  EE20     LFSR 2, 0x4
8606  F004     NOP
8608  51E0     MOVF bdat, W, BANKED
860A  26D9     ADDWF FSR2, F, ACCESS
860C  51E1     MOVF GIE_BIT_VAL, W, BANKED
860E  22DA     ADDWFC FSR2H, F, ACCESS
8610  0E63     MOVLW 0x63
8612  64DF     CPFSGT INDF2, ACCESS
8614  D009     BRA 0x8628
8616  EE20     LFSR 2, 0x4
8618  F004     NOP
861A  51E0     MOVF bdat, W, BANKED
861C  26D9     ADDWF FSR2, F, ACCESS
861E  51E1     MOVF GIE_BIT_VAL, W, BANKED
8620  22DA     ADDWFC FSR2H, F, ACCESS
8622  0E63     MOVLW 0x63
8624  6EDF     MOVWF INDF2, ACCESS
8626  D000     BRA 0x8628
157:                       if((*ky).sbk && !(*ky).bk) //puszczono przycisk?
8628  C0E0     MOVFF bdat, FSR2
862A  FFD9     NOP
862C  C0E1     MOVFF GIE_BIT_VAL, FSR2H
862E  FFDA     NOP
8630  A2DF     BTFSS INDF2, 1, ACCESS
8632  D045     BRA 0x86BE
8634  C0E0     MOVFF bdat, FSR2
8636  FFD9     NOP
8638  C0E1     MOVFF GIE_BIT_VAL, FSR2H
863A  FFDA     NOP
863C  B0DF     BTFSC INDF2, 0, ACCESS
863E  D03F     BRA 0x86BE
158:                       {
159:                           (*ky).sbk = 0; //((*ky).bk)?1:0;
8640  C0E0     MOVFF bdat, FSR2
8642  FFD9     NOP
8644  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8646  FFDA     NOP
8648  92DF     BCF INDF2, 1, ACCESS
160:                           if(((*ky).val - 1) < _TFASTK)
864A  0100     MOVLB 0x0
864C  69E2     SETF divisor, BANKED
864E  69E3     SETF a, BANKED
8650  EE20     LFSR 2, 0x4
8652  F004     NOP
8654  51E0     MOVF bdat, W, BANKED
8656  26D9     ADDWF FSR2, F, ACCESS
8658  51E1     MOVF GIE_BIT_VAL, W, BANKED
865A  22DA     ADDWFC FSR2H, F, ACCESS
865C  50DF     MOVF INDF2, W, ACCESS
865E  6FE4     MOVWF k, BANKED
8660  6BE5     CLRF k, BANKED
8662  51E2     MOVF divisor, W, BANKED
8664  27E4     ADDWF k, F, BANKED
8666  51E3     MOVF a, W, BANKED
8668  23E5     ADDWFC k, F, BANKED
866A  BFE5     BTFSC k, 7, BANKED
866C  D006     BRA 0x867A
866E  51E5     MOVF k, W, BANKED
8670  E10E     BNZ 0x868E
8672  0E08     MOVLW 0x8
8674  5DE4     SUBWF k, W, BANKED
8676  B0D8     BTFSC STATUS, 0, ACCESS
8678  D00A     BRA 0x868E
161:                           {
162:                               (*ky).val = 100; //kod szybkiego klikniecia
867A  0100     MOVLB 0x0
867C  EE20     LFSR 2, 0x4
867E  F004     NOP
8680  51E0     MOVF bdat, W, BANKED
8682  26D9     ADDWF FSR2, F, ACCESS
8684  51E1     MOVF GIE_BIT_VAL, W, BANKED
8686  22DA     ADDWFC FSR2H, F, ACCESS
8688  0E64     MOVLW 0x64
868A  6EDF     MOVWF INDF2, ACCESS
868C  D000     BRA 0x868E
163:                           }
164:                           StartKeyTim(ky);
868E  C0E0     MOVFF bdat, __pcstackBANK0
8690  F0DE     NOP
8692  C0E1     MOVFF GIE_BIT_VAL, pco
8694  F0DF     NOP
8696  EC34     CALL 0xEE68, 0
8698  F077     NOP
165:                           (*ky).krk = 2;
869A  0100     MOVLB 0x0
869C  EE20     LFSR 2, 0x3
869E  F003     NOP
86A0  51E0     MOVF bdat, W, BANKED
86A2  26D9     ADDWF FSR2, F, ACCESS
86A4  51E1     MOVF GIE_BIT_VAL, W, BANKED
86A6  22DA     ADDWFC FSR2H, F, ACCESS
86A8  0E02     MOVLW 0x2
86AA  6EDF     MOVWF INDF2, ACCESS
166:                           return(*ky).val;
86AC  0100     MOVLB 0x0
86AE  EE20     LFSR 2, 0x4
86B0  F004     NOP
86B2  51E0     MOVF bdat, W, BANKED
86B4  26D9     ADDWF FSR2, F, ACCESS
86B6  51E1     MOVF GIE_BIT_VAL, W, BANKED
86B8  22DA     ADDWFC FSR2H, F, ACCESS
86BA  50DF     MOVF INDF2, W, ACCESS
86BC  0012     RETURN 0
167:                       }
168:                       return(*ky).val;
86BE  0100     MOVLB 0x0
86C0  EE20     LFSR 2, 0x4
86C2  F004     NOP
86C4  51E0     MOVF bdat, W, BANKED
86C6  26D9     ADDWF FSR2, F, ACCESS
86C8  51E1     MOVF GIE_BIT_VAL, W, BANKED
86CA  22DA     ADDWFC FSR2H, F, ACCESS
86CC  50DF     MOVF INDF2, W, ACCESS
86CE  0012     RETURN 0
169:                   }
170:                       //podtrzymanie stanu przycisku
171:                   case 2:
172:                   {
173:                       if((KeyTim(ky) > 1 && !(*ky).sbk && (*ky).bk) || KeyTim(ky) >= _TMEMK) //ponownie nacisnieto przycisk lub minal czas podtrzymania?
86D0  C0E0     MOVFF bdat, __pcstackBANK0
86D2  F0DE     NOP
86D4  C0E1     MOVFF GIE_BIT_VAL, pco
86D6  F0DF     NOP
86D8  ECE7     CALL 0xF1CE, 0
86DA  F078     NOP
86DC  0100     MOVLB 0x0
86DE  6FE2     MOVWF divisor, BANKED
86E0  0E01     MOVLW 0x1
86E2  65E2     CPFSGT divisor, BANKED
86E4  D00C     BRA 0x86FE
86E6  C0E0     MOVFF bdat, FSR2
86E8  FFD9     NOP
86EA  C0E1     MOVFF GIE_BIT_VAL, FSR2H
86EC  FFDA     NOP
86EE  B2DF     BTFSC INDF2, 1, ACCESS
86F0  D006     BRA 0x86FE
86F2  C0E0     MOVFF bdat, FSR2
86F4  FFD9     NOP
86F6  C0E1     MOVFF GIE_BIT_VAL, FSR2H
86F8  FFDA     NOP
86FA  B0DF     BTFSC INDF2, 0, ACCESS
86FC  D00C     BRA 0x8716
86FE  C0E0     MOVFF bdat, __pcstackBANK0
8700  F0DE     NOP
8702  C0E1     MOVFF GIE_BIT_VAL, pco
8704  F0DF     NOP
8706  ECE7     CALL 0xF1CE, 0
8708  F078     NOP
870A  0100     MOVLB 0x0
870C  6FE2     MOVWF divisor, BANKED
870E  0E09     MOVLW 0x9
8710  65E2     CPFSGT divisor, BANKED
8712  D00C     BRA 0x872C
8714  D000     BRA 0x8716
174:                       {
175:                           (*ky).krk = 0;
8716  0100     MOVLB 0x0
8718  EE20     LFSR 2, 0x3
871A  F003     NOP
871C  51E0     MOVF bdat, W, BANKED
871E  26D9     ADDWF FSR2, F, ACCESS
8720  51E1     MOVF GIE_BIT_VAL, W, BANKED
8722  22DA     ADDWFC FSR2H, F, ACCESS
8724  0E00     MOVLW 0x0
8726  6EDF     MOVWF INDF2, ACCESS
176:                           return 0;
8728  0E00     MOVLW 0x0
872A  0012     RETURN 0
177:                       }
178:                       return(*ky).val; //przez 1 sek podtrzymaj kod stanu przycisku
872C  0100     MOVLB 0x0
872E  EE20     LFSR 2, 0x4
8730  F004     NOP
8732  51E0     MOVF bdat, W, BANKED
8734  26D9     ADDWF FSR2, F, ACCESS
8736  51E1     MOVF GIE_BIT_VAL, W, BANKED
8738  22DA     ADDWFC FSR2H, F, ACCESS
873A  50DF     MOVF INDF2, W, ACCESS
873C  0012     RETURN 0
179:                   }
180:                   case 3: //oczekiwanie na puszczenie przycisku
181:                   {
182:                       if(!(*ky).bk) //puszczono przycisk?
873E  C0E0     MOVFF bdat, FSR2
8740  FFD9     NOP
8742  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8744  FFDA     NOP
8746  0100     MOVLB 0x0
8748  B0DF     BTFSC INDF2, 0, ACCESS
874A  D00F     BRA 0x876A
183:                       {
184:                           (*ky).sbk = 0;
874C  C0E0     MOVFF bdat, FSR2
874E  FFD9     NOP
8750  C0E1     MOVFF GIE_BIT_VAL, FSR2H
8752  FFDA     NOP
8754  92DF     BCF INDF2, 1, ACCESS
185:                           (*ky).krk = 0;
8756  0100     MOVLB 0x0
8758  EE20     LFSR 2, 0x3
875A  F003     NOP
875C  51E0     MOVF bdat, W, BANKED
875E  26D9     ADDWF FSR2, F, ACCESS
8760  51E1     MOVF GIE_BIT_VAL, W, BANKED
8762  22DA     ADDWFC FSR2H, F, ACCESS
8764  0E00     MOVLW 0x0
8766  6EDF     MOVWF INDF2, ACCESS
8768  D000     BRA 0x876A
186:                       }
187:                       return 0;
876A  0E00     MOVLW 0x0
876C  0012     RETURN 0
188:                   }
189:               }
876E  0C00     RETLW 0x0
190:               return 0;
8794  0C00     RETLW 0x0
191:           }
8796  0012     RETURN 0
192:           //Resetuje czas podtrzymania
193:           
194:           void ResBufKeyEx(volatile StPin *ky) //resetuj podtrzymanie kodu stanu przycisku
195:           {
196:               (*ky).sbk = 0;
EAF6  C0DE     MOVFF __pcstackBANK0, FSR2
EAF8  FFD9     NOP
EAFA  C0DF     MOVFF pco, FSR2H
EAFC  FFDA     NOP
EAFE  92DF     BCF INDF2, 1, ACCESS
197:               (*ky).krk = 0;
EB00  0100     MOVLB 0x0
EB02  EE20     LFSR 2, 0x3
EB04  F003     NOP
EB06  51DE     MOVF __pcstackBANK0, W, BANKED
EB08  26D9     ADDWF FSR2, F, ACCESS
EB0A  51DF     MOVF pco, W, BANKED
EB0C  22DA     ADDWFC FSR2H, F, ACCESS
EB0E  6ADF     CLRF INDF2, ACCESS
198:               (*ky).val = 0;
EB10  0100     MOVLB 0x0
EB12  EE20     LFSR 2, 0x4
EB14  F004     NOP
EB16  51DE     MOVF __pcstackBANK0, W, BANKED
EB18  26D9     ADDWF FSR2, F, ACCESS
EB1A  51DF     MOVF pco, W, BANKED
EB1C  22DA     ADDWFC FSR2H, F, ACCESS
EB1E  0E00     MOVLW 0x0
EB20  6ADF     CLRF INDF2, ACCESS
199:           }
EB22  0012     RETURN 0
200:           //Wymusza oczekiwanie na zwolnienie przyciskow (na czas oczekiwania funkcja zwraca 0)
201:           
202:           void WaitToLowEx(volatile StPin *ky) //wymus oczekiwanie na puszczenie przycisku
203:           {
204:               (*ky).krk = 3;
EE20  0100     MOVLB 0x0
EE22  EE20     LFSR 2, 0x3
EE24  F003     NOP
EE26  51DE     MOVF __pcstackBANK0, W, BANKED
EE28  26D9     ADDWF FSR2, F, ACCESS
EE2A  51DF     MOVF pco, W, BANKED
EE2C  22DA     ADDWFC FSR2H, F, ACCESS
EE2E  0E03     MOVLW 0x3
EE30  6EDF     MOVWF INDF2, ACCESS
205:               (*ky).val = 0;
EE32  EE20     LFSR 2, 0x4
EE34  F004     NOP
EE36  51DE     MOVF __pcstackBANK0, W, BANKED
EE38  26D9     ADDWF FSR2, F, ACCESS
EE3A  51DF     MOVF pco, W, BANKED
EE3C  22DA     ADDWFC FSR2H, F, ACCESS
EE3E  0E00     MOVLW 0x0
EE40  6ADF     CLRF INDF2, ACCESS
206:           }
EE42  0012     RETURN 0
207:           #endif
208:           /*---------------------------------------------------------------------------------*/
209:           #if _EN_DPK!=0
210:           //Funkcja detekcji podwojnego nacisniecia przycisku
211:           //k-fizyczne wejscie procesora dla przycisku
212:           //np. DoublePresKey(RdPrt(S_SET),&ky[S_SET])
213:           
214:           unsigned char DoublePresKey(unsigned char k, StPin *ky)
215:           {
216:               (*ky).c = PresKey(k, ky);
217:               if(!(*ky).dk && (*ky).c) //pierwsze nacisniecie przycisku?
218:               {
219:                   (*ky).dk = 1;
220:                   StartKeyTim(ky);
221:                   return 0;
222:               }
223:               (*ky).t = (KeyTim(ky) <= 5);
224:               if((*ky).dk && (*ky).t)
225:               {
226:                   if((*ky).c) //drugie nacisniecie przycisku?
227:                   {
228:                       (*ky).dk = 0;
229:                       return 1;
230:                   }
231:               }
232:               if(!(*ky).t) (*ky).dk = 0; //czas uplynol?
233:               return 0;
234:           }
235:           #endif
236:           /*---------------------------------------------------------------------------------*/
237:           #if _EN_EXPK!=0
238:           //Funkcja detekcji nacisniecia przycisku (wersja zaawansowana)
239:           //dla danych liczbowych (<2.5 cyfry)
240:           //k-fizyczne wejscie procesora dla przycisku,
241:           //dTim-czas po jakim przy nacisnietym przycisku nastapi wygenerowanie ciagu impulsów [*0.1sek],
242:           //pTim-czas miedzy kolejnymi impulsami przy spelnieniu warunku dTim [*0.1sek]
243:           //zwraca 0 dla przycisku w stanie spoczynku
244:           //zwraca 1 dla pojedynczego nacisniecia przycisku
245:           //zwraca 2 dla impulsu w trakcie podtrzymania pzrycisku
246:           //np. ExPresKey(RdPrt(S_OFF),&xxky[S_OFF],50,1)
247:           
248:           unsigned char ExPresKey(unsigned char k, StPin *ky, unsigned char dTim, unsigned char pTim)
249:           {
250:               (*ky).bk = (k) ? 1 : 0;
251:           
252:               if(!(*ky).sbk && (*ky).bk)
253:               {
254:                   (*ky).sbk = ((*ky).bk) ? 1 : 0;
255:                   StartKeyTim(ky);
256:                   return 1; //nacisnieto przycisk
257:               }
258:               (*ky).sbk = ((*ky).bk) ? 1 : 0;
259:               if((*ky).sbk && (*ky).bk)
260:               {
261:                   if(!(*ky).ap && KeyTim(ky) >= dTim) //przytrzymano przycisk
262:                   {
263:                       (*ky).ap = 1;
264:                       StartKeyTim(ky);
265:                       return 2; //pierwszy impuls
266:                   }
267:                   if((*ky).ap && KeyTim(ky) >= pTim)
268:                   {
269:                       StartKeyTim(ky); //kolejne impulsy co pTim
270:                       return 2;
271:                   }
272:               }
273:               else (*ky).ap = 0;
274:               return 0;
275:           }
276:           
277:           void ExResKey(StPin *ky)
278:           {
279:               (*ky).bk = 0;
280:               (*ky).sbk = 0;
281:               (*ky).ap = 0;
282:               StartKeyTim(ky);
283:           }
284:           #endif
285:           /*---------------------------------------------------------------------------------*/
286:           #if _EN_EXXPK!=0
287:           //Funkcja detekcji nacisniecia przycisku (wersja b.zaawansowana)
288:           //dla duzych danych liczbowych (>2.5 cyfry)
289:           //k-fizyczne wejscie procesora dla przycisku,
290:           //dTim-czas po jakim przy nacisnietym przycisku nastapi wygenerowanie ciagu impulsów [*0.1sek],
291:           //pTim-czas miedzy kolejnymi impulsami przy spelnieniu warunku dTim [*0.1sek]
292:           //zwraca 0 dla przycisku w stanie spoczynku
293:           //zwraca 1 dla pojedynczego nacisniecia przycisku
294:           //zwraca 2 dla impulsu w trakcie podtrzymania pzrycisku
295:           //zwraca 3 miedzy impulsami w trakcie podtrzymania pzrycisku 
296:           //np. ExxPresKey(RdPrt(S_OFF),&xxky[S_OFF],50,1)
297:           
298:           unsigned char ExxPresKey(unsigned char k, volatile StPin *ky, unsigned char dTim, unsigned char pTim)
9E2E  0100     MOVLB 0x0
9E30  6FE5     MOVWF k, BANKED
299:           {
300:               (*ky).bk = (k) ? 1 : 0;
9E32  0100     MOVLB 0x0
9E34  51E5     MOVF k, W, BANKED
9E36  E003     BZ 0x9E3E
9E38  6BE4     CLRF k, BANKED
9E3A  2BE4     INCF k, F, BANKED
9E3C  D002     BRA 0x9E42
9E3E  0100     MOVLB 0x0
9E40  6BE4     CLRF k, BANKED
9E42  C0E0     MOVFF bdat, FSR2
9E44  FFD9     NOP
9E46  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E48  FFDA     NOP
9E4A  50DF     MOVF INDF2, W, ACCESS
9E4C  0100     MOVLB 0x0
9E4E  19E4     XORWF k, W, BANKED
9E50  0BFE     ANDLW 0xFE
9E52  19E4     XORWF k, W, BANKED
9E54  6EDF     MOVWF INDF2, ACCESS
301:           
302:               if((*ky).fl && (*ky).sbk && !(*ky).bk)
9E56  C0E0     MOVFF bdat, FSR2
9E58  FFD9     NOP
9E5A  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E5C  FFDA     NOP
9E5E  A8DF     BTFSS INDF2, 4, ACCESS
9E60  D023     BRA 0x9EA8
9E62  C0E0     MOVFF bdat, FSR2
9E64  FFD9     NOP
9E66  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E68  FFDA     NOP
9E6A  A2DF     BTFSS INDF2, 1, ACCESS
9E6C  D01D     BRA 0x9EA8
9E6E  C0E0     MOVFF bdat, FSR2
9E70  FFD9     NOP
9E72  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E74  FFDA     NOP
9E76  B0DF     BTFSC INDF2, 0, ACCESS
9E78  D017     BRA 0x9EA8
303:               {
304:                   (*ky).fl = 0;
9E7A  C0E0     MOVFF bdat, FSR2
9E7C  FFD9     NOP
9E7E  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E80  FFDA     NOP
9E82  98DF     BCF INDF2, 4, ACCESS
305:                   (*ky).sbk = ((*ky).bk) ? 1 : 0;
9E84  C0E0     MOVFF bdat, FSR2
9E86  FFD9     NOP
9E88  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9E8A  FFDA     NOP
9E8C  A0DF     BTFSS INDF2, 0, ACCESS
9E8E  D003     BRA 0x9E96
9E90  0100     MOVLB 0x0
9E92  82DF     BSF INDF2, 1, ACCESS
9E94  D002     BRA 0x9E9A
9E96  0100     MOVLB 0x0
9E98  92DF     BCF INDF2, 1, ACCESS
306:                   StartKeyTim(ky);
9E9A  C0E0     MOVFF bdat, __pcstackBANK0
9E9C  F0DE     NOP
9E9E  C0E1     MOVFF GIE_BIT_VAL, pco
9EA0  F0DF     NOP
9EA2  EC34     CALL 0xEE68, 0
9EA4  F077     NOP
9EA6  D000     BRA 0x9EA8
307:               }
308:               if(!(*ky).sbk && (*ky).bk)
9EA8  C0E0     MOVFF bdat, FSR2
9EAA  FFD9     NOP
9EAC  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9EAE  FFDA     NOP
9EB0  B2DF     BTFSC INDF2, 1, ACCESS
9EB2  D019     BRA 0x9EE6
9EB4  C0E0     MOVFF bdat, FSR2
9EB6  FFD9     NOP
9EB8  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9EBA  FFDA     NOP
9EBC  A0DF     BTFSS INDF2, 0, ACCESS
9EBE  D013     BRA 0x9EE6
309:               {
310:                   (*ky).sbk = ((*ky).bk) ? 1 : 0;
9EC0  C0E0     MOVFF bdat, FSR2
9EC2  FFD9     NOP
9EC4  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9EC6  FFDA     NOP
9EC8  A0DF     BTFSS INDF2, 0, ACCESS
9ECA  D003     BRA 0x9ED2
9ECC  0100     MOVLB 0x0
9ECE  82DF     BSF INDF2, 1, ACCESS
9ED0  D002     BRA 0x9ED6
9ED2  0100     MOVLB 0x0
9ED4  92DF     BCF INDF2, 1, ACCESS
311:                   StartKeyTim(ky);
9ED6  C0E0     MOVFF bdat, __pcstackBANK0
9ED8  F0DE     NOP
9EDA  C0E1     MOVFF GIE_BIT_VAL, pco
9EDC  F0DF     NOP
9EDE  EC34     CALL 0xEE68, 0
9EE0  F077     NOP
312:                   return 1;
9EE2  0E01     MOVLW 0x1
9EE4  0012     RETURN 0
313:               }
314:               if(!(*ky).fl && (*ky).sbk && !(*ky).bk)
9EE6  C0E0     MOVFF bdat, FSR2
9EE8  FFD9     NOP
9EEA  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9EEC  FFDA     NOP
9EEE  B8DF     BTFSC INDF2, 4, ACCESS
9EF0  D01E     BRA 0x9F2E
9EF2  C0E0     MOVFF bdat, FSR2
9EF4  FFD9     NOP
9EF6  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9EF8  FFDA     NOP
9EFA  A2DF     BTFSS INDF2, 1, ACCESS
9EFC  D018     BRA 0x9F2E
9EFE  C0E0     MOVFF bdat, FSR2
9F00  FFD9     NOP
9F02  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F04  FFDA     NOP
9F06  B0DF     BTFSC INDF2, 0, ACCESS
9F08  D012     BRA 0x9F2E
315:               {
316:                   (*ky).sbk = ((*ky).bk) ? 1 : 0;
9F0A  C0E0     MOVFF bdat, FSR2
9F0C  FFD9     NOP
9F0E  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F10  FFDA     NOP
9F12  A0DF     BTFSS INDF2, 0, ACCESS
9F14  D003     BRA 0x9F1C
9F16  0100     MOVLB 0x0
9F18  82DF     BSF INDF2, 1, ACCESS
9F1A  D002     BRA 0x9F20
9F1C  0100     MOVLB 0x0
9F1E  92DF     BCF INDF2, 1, ACCESS
317:                   StartKeyTim(ky);
9F20  C0E0     MOVFF bdat, __pcstackBANK0
9F22  F0DE     NOP
9F24  C0E1     MOVFF GIE_BIT_VAL, pco
9F26  F0DF     NOP
9F28  EC34     CALL 0xEE68, 0
9F2A  F077     NOP
9F2C  D000     BRA 0x9F2E
318:               }
319:               if((*ky).sbk && (*ky).bk)
9F2E  C0E0     MOVFF bdat, FSR2
9F30  FFD9     NOP
9F32  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F34  FFDA     NOP
9F36  A2DF     BTFSS INDF2, 1, ACCESS
9F38  D03D     BRA 0x9FB4
9F3A  C0E0     MOVFF bdat, FSR2
9F3C  FFD9     NOP
9F3E  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F40  FFDA     NOP
9F42  A0DF     BTFSS INDF2, 0, ACCESS
9F44  D037     BRA 0x9FB4
320:               {
321:           
322:                   if(!(*ky).ap && KeyTim(ky) >= dTim)
9F46  C0E0     MOVFF bdat, FSR2
9F48  FFD9     NOP
9F4A  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F4C  FFDA     NOP
9F4E  0100     MOVLB 0x0
9F50  B4DF     BTFSC INDF2, 2, ACCESS
9F52  D015     BRA 0x9F7E
9F54  C0E0     MOVFF bdat, __pcstackBANK0
9F56  F0DE     NOP
9F58  C0E1     MOVFF GIE_BIT_VAL, pco
9F5A  F0DF     NOP
9F5C  ECE7     CALL 0xF1CE, 0
9F5E  F078     NOP
9F60  0100     MOVLB 0x0
9F62  6FE4     MOVWF k, BANKED
9F64  51E2     MOVF divisor, W, BANKED
9F66  5DE4     SUBWF k, W, BANKED
9F68  E30A     BNC 0x9F7E
323:                   {
324:                       (*ky).fl = 1;
9F6A  C0E0     MOVFF bdat, FSR2
9F6C  FFD9     NOP
9F6E  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F70  FFDA     NOP
9F72  88DF     BSF INDF2, 4, ACCESS
325:                       (*ky).ap = 1;
9F74  C0E0     MOVFF bdat, FSR2
9F76  FFD9     NOP
9F78  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F7A  FFDA     NOP
9F7C  84DF     BSF INDF2, 2, ACCESS
326:                   }
327:                   if((*ky).ap && KeyTim(ky) >= pTim)
9F7E  C0E0     MOVFF bdat, FSR2
9F80  FFD9     NOP
9F82  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9F84  FFDA     NOP
9F86  0100     MOVLB 0x0
9F88  A4DF     BTFSS INDF2, 2, ACCESS
9F8A  D019     BRA 0x9FBE
9F8C  C0E0     MOVFF bdat, __pcstackBANK0
9F8E  F0DE     NOP
9F90  C0E1     MOVFF GIE_BIT_VAL, pco
9F92  F0DF     NOP
9F94  ECE7     CALL 0xF1CE, 0
9F96  F078     NOP
9F98  0100     MOVLB 0x0
9F9A  6FE4     MOVWF k, BANKED
9F9C  51E3     MOVF a, W, BANKED
9F9E  5DE4     SUBWF k, W, BANKED
9FA0  E30E     BNC 0x9FBE
328:                   {
329:                       StartKeyTim(ky);
9FA2  C0E0     MOVFF bdat, __pcstackBANK0
9FA4  F0DE     NOP
9FA6  C0E1     MOVFF GIE_BIT_VAL, pco
9FA8  F0DF     NOP
9FAA  EC34     CALL 0xEE68, 0
9FAC  F077     NOP
330:                       return 2;
9FAE  0E02     MOVLW 0x2
9FB0  0012     RETURN 0
331:                   }
332:               }
9FB2  D005     BRA 0x9FBE
333:               else (*ky).ap = 0;
9FB4  C0E0     MOVFF bdat, FSR2
9FB6  FFD9     NOP
9FB8  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9FBA  FFDA     NOP
9FBC  94DF     BCF INDF2, 2, ACCESS
334:               (*ky).sbk = ((*ky).bk) ? 1 : 0;
9FBE  C0E0     MOVFF bdat, FSR2
9FC0  FFD9     NOP
9FC2  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9FC4  FFDA     NOP
9FC6  A0DF     BTFSS INDF2, 0, ACCESS
9FC8  D002     BRA 0x9FCE
9FCA  82DF     BSF INDF2, 1, ACCESS
9FCC  D001     BRA 0x9FD0
9FCE  92DF     BCF INDF2, 1, ACCESS
335:               if((*ky).ap) return 3;
9FD0  C0E0     MOVFF bdat, FSR2
9FD2  FFD9     NOP
9FD4  C0E1     MOVFF GIE_BIT_VAL, FSR2H
9FD6  FFDA     NOP
9FD8  0100     MOVLB 0x0
9FDA  A4DF     BTFSS INDF2, 2, ACCESS
9FDC  0C00     RETLW 0x0
9FDE  0E03     MOVLW 0x3
9FE0  0012     RETURN 0
336:               return 0;
9FE2  0C00     RETLW 0x0
337:           }
9FE4  0012     RETURN 0
338:           
339:           void ExxResKey(volatile StPin *ky)
340:           {
341:               (*ky).bk = 0;
342:               (*ky).sbk = 0;
343:               (*ky).ap = 0;
344:               StartKeyTim(ky);
345:           }
346:           #endif
347:           /*---------------------------------------------------------------------------------*/
348:           /*---------------------------------------------------------------------------------*/
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/isr.c  -----------------------------------
1:             /*--------------------------------------------------------------*/
2:             /*isr.c*/
3:             /*obsluga przerwan*/
4:             /*--------------------------------------------------------------*/
5:             #include <pic18.h>
6:             #include "global.h"				//parametry globalne
7:             #include "isr.h"				//parametry lokalne
8:             
9:             void interrupt ISR(void)
0008  CFFA     MOVFF PCLATH, _DtCWf_su_CW
000A  F028     NOP
000C  CFFB     MOVFF PCLATU, _DtCWf_su_DZ_CW
000E  F029     NOP
0010  CFE9     MOVFF FSR0, _DtCWf_wpz_CW
0012  F02A     NOP
0014  CFEA     MOVFF FSR0H, _DtCWf_wrtPCW
0016  F02B     NOP
0018  CFE1     MOVFF FSR1, _DtI2Cf_krok
001A  F02C     NOP
001C  CFE2     MOVFF FSR1H, _DtINf_err_IN
001E  F02D     NOP
0020  CFD9     MOVFF FSR2, _DtINf_newECO
0022  F02E     NOP
0024  CFDA     MOVFF FSR2H, _DtKNFf_enknf
0026  F02F     NOP
0028  CFF3     MOVFF PROD, _DtKNFf_wymCO
002A  F030     NOP
002C  CFF4     MOVFF PRODH, _DtKNFf_wymCW
002E  F031     NOP
0030  CFF6     MOVFF TBLPTR, _DtZWf_on_ZW
0032  F032     NOP
0034  CFF7     MOVFF TBLPTRH, 0x33
0036  F033     NOP
0038  CFF8     MOVFF TBLPTRU, 0x34
003A  F034     NOP
003C  CFF5     MOVFF TABLAT, 0x35
003E  F035     NOP
10:            {
11:                if((RCIF) && (RCIE)) //odbior RS232 (RCIF jest zerowane sprzetowo)
0040  BA9E     BTFSC PIR1, 5, ACCESS
0042  AA9D     BTFSS PIE1, 5, ACCESS
0044  D003     BRA 0x4C
12:                {
13:                    IntUSARTRC();
0046  EC5D     CALL 0xC2BA, 0
0048  F061     NOP
004A  D000     BRA 0x4C
14:                }
15:                if((TXIF) && (TXIE)) //transmisja RS232 (TXIF jest zerowane sprzetowo)
004C  B89E     BTFSC PIR1, 4, ACCESS
004E  A89D     BTFSS PIE1, 4, ACCESS
0050  D003     BRA 0x58
16:                {
17:                    IntUSARTTR();
0052  ECDD     CALL 0xDBBA, 0
0054  F06D     NOP
0056  D000     BRA 0x58
18:                }
19:                if((TMR1IF) && (TMR1IE))
0058  B09E     BTFSC PIR1, 0, ACCESS
005A  A09D     BTFSS PIE1, 0, ACCESS
005C  D010     BRA 0x7E
20:                {
21:                    TMR1IF = 0;
005E  909E     BCF PIR1, 0, ACCESS
22:                    ReloadTimer1(); //obsluga zegara Timer1
0060  ECEE     CALL 0xEBDC, 0
0062  F075     NOP
23:                    IncRTimer(); //obsluga zegarow RT
0064  EC08     CALL 0x8C10, 0
0066  F046     NOP
24:                    IncPmrTimer(); //obsluga zegarow proc. filtracji wart temp.
0068  EC85     CALL 0xED0A, 0
006A  F076     NOP
25:                    IncKeyTimer(); //obsluga zegarow klawiszy
006C  ECEB     CALL 0xABD6, 0
006E  F055     NOP
26:                    //IntCzCw();			//obsluga czujnika przeplywu CW
27:                    RefreshWSW();
0070  EC4C     CALL 0xF298, 0
0072  F079     NOP
28:                    //IncRSTimer();		//obsluga timerow modulu MGS_RS
29:                    //IncRSTimer2();		//obsluga timerow modulu SMGS_RS
30:                    StabPort(); //stabilizacja stanu okreslonych sygnalow
0074  EC6B     CALL 0x98D6, 0
0076  F04C     NOP
31:                    FormatDataIMY();
0078  EC28     CALL 0x1A50, 0
007A  F00D     NOP
007C  D000     BRA 0x7E
32:                }
33:                if((TMR0IF) && (TMR0IE))
007E  B4F2     BTFSC INTCON, 2, ACCESS
0080  AAF2     BTFSS INTCON, 5, ACCESS
0082  D001     BRA 0x86
34:                {
35:                    TMR0IF = 0;
0084  94F2     BCF INTCON, 2, ACCESS
36:                }
37:                if((TMR2IF) && (TMR2IE))
0086  B29E     BTFSC PIR1, 1, ACCESS
0088  A29D     BTFSS PIE1, 1, ACCESS
008A  D006     BRA 0x98
38:                {
39:                    TMR2IF = 0;
008C  929E     BCF PIR1, 1, ACCESS
40:                    IntPWM(); //pwm1 - modulator
008E  EC5E     CALL 0xE0BC, 0
0090  F070     NOP
41:                    IntPWM2(); //pwm2 - pompa
0092  EC70     CALL 0xECE0, 0
0094  F076     NOP
0096  D000     BRA 0x98
42:                }
43:                if((SSPIF) && (SSPIE)) //obsluga przerwania od I2C
0098  B69E     BTFSC PIR1, 3, ACCESS
009A  A69D     BTFSS PIE1, 3, ACCESS
009C  D004     BRA 0xA6
44:                {
45:                    SSPIF = 0;
009E  969E     BCF PIR1, 3, ACCESS
46:                    I2CSlaveTR();
00A0  ECF6     CALL 0xCFEC, 0
00A2  F067     NOP
00A4  D000     BRA 0xA6
47:                }
48:            }
00A6  C035     MOVFF 0x35, TABLAT
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/i2c_s.c  ---------------------------------
1:             /*i2c_s.c*/
2:             /*I2C Slave Mode*/
3:             //-------------------------------------------------------------------------------
4:             #include <pic18.h>
5:             #include "global.h"			//parametry globalne
6:             #include "i2c_s.h"			//parametry lokalne
7:             #include "dtimy.h"			
8:             #include "main.tp.h"
9:             #include "pomiar.h"	
10:            #include "pwm.h"
11:            #include "konfig2.h"
12:            #include "rgl.h"
13:            #include "uart9b.h"			//parametry lokalne
14:            #include "pompa.tp.h"
15:            extern UARTData UADt;
16:            volatile static DataI2C DtI2C;
17:            volatile static bfI2C BufI2C;
18:            
19:            extern volatile tpMAIN M;
20:            extern volatile DataCO DtCO;
21:            extern volatile DataCW DtCW;
22:            extern volatile DataZW DtZW;
23:            extern volatile DataCSN DtCS;
24:            extern volatile DtPWM PWM;
25:            extern volatile DtKONF DtKNF;
26:            extern volatile DtRgl rgl;
27:            //extern tpRSDTA1 RSDT1;
28:            extern volatile DataIN DtIN;
29:            extern volatile DtPMP PMP;
30:            extern volatile DataPFN PFN;
31:            
32:            extern volatile unsigned char x,xj;
33:            //extern unsigned char xxy,zzz,vvv,mmm;
34:            //-------------------------------------------------------------------------------
35:            //Inicjalizacja modulu I2C
36:            
37:            void InitI2C(void)
38:            {
39:                //TRISC
40:                TRISC3 = 1; //SDA i SCA konfiguracja jako wejscia
EC8C  8694     BSF TRISC, 3, ACCESS
41:                TRISC4 = 1;
EC8E  8894     BSF TRISC, 4, ACCESS
42:            
43:                //SSPADD
44:                SSPADD = _I2CSPADD;
EC90  0ECC     MOVLW 0xCC
EC92  6EC8     MOVWF SSPADD, ACCESS
45:            
46:                //SSPCON1
47:                SSPM0 = 0;
EC94  90C6     BCF SSPCON1, 0, ACCESS
48:                SSPM1 = 1;
EC96  82C6     BSF SSPCON1, 1, ACCESS
49:                SSPM2 = 1;
EC98  84C6     BSF SSPCON1, 2, ACCESS
50:                SSPM3 = 0; //I2C Slave Mode, 7 bit address
EC9A  96C6     BCF SSPCON1, 3, ACCESS
51:                SSPEN = 1; //enables the serial port
EC9C  8AC6     BSF SSPCON1, 5, ACCESS
52:                CKP = 1; //Release clock
EC9E  88C6     BSF SSPCON1, 4, ACCESS
53:            
54:                //SSPSTAT
55:                SMP = 1; //standart speed mode
ECA0  8EC7     BSF SSPSTAT, 7, ACCESS
56:                CKE = 0; //data transmited on rising edge
ECA2  9CC7     BCF SSPSTAT, 6, ACCESS
57:            
58:                //PIE
59:                SSPIE = 1; //serial interrupt enable bit
ECA4  869D     BSF PIE1, 3, ACCESS
60:                //BCLIE=1;				//bus collision interrupt enable bit
61:            
62:                //IPR
63:                //high prioriy interrupt
64:                SSPIP = 1;
ECA6  869F     BSF IPR1, 3, ACCESS
65:            
66:                BufI2C.indeks = 0;
ECA8  0E00     MOVLW 0x0
ECAA  0102     MOVLB 0x2
ECAC  6B6C     CLRF _PFNf_enKNF, BANKED
67:                DtI2C.error = 0;
ECAE  0101     MOVLB 0x1
ECB0  6BC9     CLRF iu, BANKED
68:                DtI2Cf_krok = 0;
ECB2  9805     BCF DtKNFf_enknf, 4, ACCESS
69:            }
ECB4  0012     RETURN 0
70:            
71:            
72:            //-------------------------------------------------------------------------------
73:            //Procedura transferu/odbioru danych
74:            //UWAGA: umiescic w przerwaniu od SSPIF.
75:            volatile static unsigned char dt;
76:            /*void I2CSlaveTR(void)
77:            {
78:                unsigned char dt;
79:            
80:                if(WCOL) //nadpisanie danej przy zapisie?
81:                {
82:                    WCOL = 0;
83:                    DtI2C.error = _ErWCOL;
84:            
85:                }
86:                else
87:                    if(SSPOV) //nadpisanie danej przy odbiorze?
88:                {
89:                    SSPOV = 0;
90:                    DtI2C.error = _ErSSPOV;
91:                }
92:                else
93:                {
94:                    if(!DA) //adres czy dane?
95:                    {
96:                        //ADRES
97:                        if(RW)
98:                        {
99:                            //Przygotowanie do transmisji danych
100:                           DtI2Cf_krok = 1;
101:                           SetTData();
102:                           BufI2C.Bf[_NBDATA - 1] = LiczCHK(_NBDATA);
103:                           BufI2C.indeks = 0;
104:                           dt = SSPBUF;
105:                       }
106:                       else
107:                       {
108:                           //Przygotowanie do odbioru danych
109:                           DtI2Cf_krok = 0;
110:                           SetRData();
111:                           dt = SSPBUF;
112:                           return;
113:                       }
114:                   }
115:                   //DATA
116:                   //Odbior danych
117:                   if(DtI2Cf_krok == 0)
118:                   {
119:                       ReceptDataI2C();
120:                       return;
121:                   }
122:                   //Transmisja danych
123:                   if(DtI2Cf_krok == 1)
124:                   {
125:                       TransmitDataI2C();
126:                       return;
127:                   }
128:               }
129:               //Koniec transmisji/odbioru
130:               CKP = 1;
131:               DtI2Cf_krok = 0;
132:               BufI2C.indeks = 0;
133:           }*/
134:           void I2CSlaveTR(void)
135:           {
136:               //unsigned char dt;
137:           	if(WCOL)							//nadpisanie danej przy zapisie?
CFEC  AEC6     BTFSS SSPCON1, 7, ACCESS
CFEE  D005     BRA 0xCFFA
138:           	{ 
139:           		WCOL=0;
CFF0  9EC6     BCF SSPCON1, 7, ACCESS
140:           		DtI2C.error=_ErWCOL;
CFF2  0E07     MOVLW 0x7
CFF4  0101     MOVLB 0x1
CFF6  6FC9     MOVWF iu, BANKED
141:           	}
CFF8  D02E     BRA 0xD056
142:           	else
143:           	if(SSPOV) 							//nadpisanie danej przy odbiorze?
CFFA  ACC6     BTFSS SSPCON1, 6, ACCESS
CFFC  D007     BRA 0xD00C
144:           	{
145:           		SSPOV=0;
CFFE  9CC6     BCF SSPCON1, 6, ACCESS
146:           		DtI2C.error=_ErSSPOV;
D000  0E08     MOVLW 0x8
D002  0101     MOVLB 0x1
D004  6FC9     MOVWF iu, BANKED
147:                   dt = SSPBUF;
D006  CFC9     MOVFF SSPBUF, dt
D008  F178     NOP
148:           	}
D00A  D025     BRA 0xD056
149:           	else
150:           	{ 
151:           		if(!DA)							//adres czy dane?
D00C  BAC7     BTFSC SSPSTAT, 5, ACCESS
D00E  D016     BRA 0xD03C
152:           		{	
153:           			//ADRES
154:           			if(RW) 						//transmisja danych
D010  A4C7     BTFSS SSPSTAT, 2, ACCESS
D012  D00D     BRA 0xD02E
155:           			{
156:           				//Przygotowanie do transmisji danych
157:           				DtI2Cf_krok=1;
D014  8805     BSF DtKNFf_enknf, 4, ACCESS
158:           				dt=SSPBUF;
D016  CFC9     MOVFF SSPBUF, dt
D018  F178     NOP
159:           				SetTData();
D01A  EC08     CALL 0xDC10, 0
D01C  F06E     NOP
160:           				BufI2C.Bf[_NBDATA-1]=LiczCHK(_NBDATA);
D01E  0E16     MOVLW 0x16
D020  EC33     CALL 0xDC66, 0
D022  F06E     NOP
D024  0102     MOVLB 0x2
D026  6F82     MOVWF M, BANKED
161:           				BufI2C.indeks=0;
D028  0102     MOVLB 0x2
D02A  6B6C     CLRF _PFNf_enKNF, BANKED
162:           			}
D02C  D007     BRA 0xD03C
163:           			else 
164:           			{
165:           				//Przygotowanie do odbioru danych
166:           				DtI2Cf_krok=0;
D02E  9805     BCF DtKNFf_enknf, 4, ACCESS
167:           				dt=SSPBUF;
D030  CFC9     MOVFF SSPBUF, dt
D032  F178     NOP
168:           				SetRData();
D034  EC02     CALL 0xF404, 0
D036  F07A     NOP
169:                           CKP = 1;    //uwolnij zegar
D038  88C6     BSF SSPCON1, 4, ACCESS
170:           				return;
D03A  0012     RETURN 0
171:           			}
172:           		}
173:           		//DATA
174:           		//Odbior danych
175:           		if(DtI2Cf_krok==0) 
D03C  B805     BTFSC DtKNFf_enknf, 4, ACCESS
D03E  D004     BRA 0xD048
176:           		{
177:           			ReceptDataI2C();
D040  EC9D     CALL 0xE33A, 0
D042  F071     NOP
178:                       CKP = 1;    //uwolnij zegar
D044  88C6     BSF SSPCON1, 4, ACCESS
179:           			return;
D046  0012     RETURN 0
180:           		}
181:           		//Transmisja danych
182:           		if(DtI2Cf_krok==1) 
D048  A805     BTFSS DtKNFf_enknf, 4, ACCESS
D04A  D005     BRA 0xD056
183:           		{
184:           			TransmitDataI2C();
D04C  ECC0     CALL 0xE580, 0
D04E  F072     NOP
185:                       CKP = 1;    //uwolnij zegar
D050  88C6     BSF SSPCON1, 4, ACCESS
186:           			return;
D052  0012     RETURN 0
187:           		}
D054  D000     BRA 0xD056
188:           	}
189:           	//Koniec transmisji/odbioru
190:           	dt=SSPBUF;
D056  CFC9     MOVFF SSPBUF, dt
D058  F178     NOP
191:           	DtI2Cf_krok=0;
D05A  9805     BCF DtKNFf_enknf, 4, ACCESS
192:           	BufI2C.indeks=0;
D05C  0E00     MOVLW 0x0
D05E  0102     MOVLB 0x2
D060  6B6C     CLRF _PFNf_enKNF, BANKED
193:               CKP = 1;    //uwolnij zegar
D062  88C6     BSF SSPCON1, 4, ACCESS
194:           }
D064  0012     RETURN 0
195:           //-------------------------------------------------------------------------------
196:           //Oblicza CHK i umieszcza go w ostatnim bajcie bufora danych
197:           //NBTI2C - liczba danych bez adresu z CHK
198:           
199:           unsigned char LiczCHK(const unsigned char NBTI2C)
DC66  6E1E     MOVWF _DtCSf_no, ACCESS
200:           {
201:               unsigned char i;
202:               unsigned char chk = 0;
DC68  6A1D     CLRF _DtCSf_lo, ACCESS
203:           
204:               for(i = 0; i < NBTI2C - 1; i++) chk += (BufI2C.Bf[i] + i)^0xAA;
DC6A  6A1F     CLRF _DtCSf_no_mont, ACCESS
DC6C  6816     SETF _DtCOf_resPCO, ACCESS
DC6E  6817     SETF _DtCOf_su_CO, ACCESS
DC70  501E     MOVF _DtCSf_no, W, ACCESS
DC72  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
DC74  6A19     CLRF _DtCOf_su_SRW_CO, ACCESS
DC76  5016     MOVF _DtCOf_resPCO, W, ACCESS
DC78  2618     ADDWF _DtCOf_su_DZ_CO, F, ACCESS
DC7A  5017     MOVF _DtCOf_su_CO, W, ACCESS
DC7C  2219     ADDWFC _DtCOf_su_SRW_CO, F, ACCESS
DC7E  501F     MOVF _DtCSf_no_mont, W, ACCESS
DC80  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
DC82  6A1B     CLRF _DtCSf_error, ACCESS
DC84  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
DC86  5C1A     SUBWF _DtCOf_zroPCO, W, ACCESS
DC88  501B     MOVF _DtCSf_error, W, ACCESS
DC8A  0A80     XORLW 0x80
DC8C  6E1C     MOVWF _DtCSf_hi, ACCESS
DC8E  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
DC90  0A80     XORLW 0x80
DC92  581C     SUBWFB _DtCSf_hi, W, ACCESS
DC94  E210     BC 0xDCB6
DC96  D001     BRA 0xDC9A
DC98  D00E     BRA 0xDCB6
DC9A  501F     MOVF _DtCSf_no_mont, W, ACCESS
DC9C  0D01     MULLW 0x1
DC9E  0E6D     MOVLW 0x6D
DCA0  24F3     ADDWF PROD, W, ACCESS
DCA2  6ED9     MOVWF FSR2, ACCESS
DCA4  0E02     MOVLW 0x2
DCA6  20F4     ADDWFC PRODH, W, ACCESS
DCA8  6EDA     MOVWF FSR2H, ACCESS
DCAA  50DF     MOVF INDF2, W, ACCESS
DCAC  241F     ADDWF _DtCSf_no_mont, W, ACCESS
DCAE  0AAA     XORLW 0xAA
DCB0  261D     ADDWF _DtCSf_lo, F, ACCESS
DCB2  2A1F     INCF _DtCSf_no_mont, F, ACCESS
DCB4  D7DB     BRA 0xDC6C
205:               return chk;
DCB6  501D     MOVF _DtCSf_lo, W, ACCESS
DCB8  0012     RETURN 0
206:           }
DCBA  0012     RETURN 0
207:           //-------------------------------------------------------------------------------
208:           //Wysyla dane do odbiornika
209:           /*
210:           void TransmitDataI2C(void)
211:           {
212:               if(RW) //ACK lub bit STOP?
213:               {
214:                   if(BufI2C.indeks < _NBSIZE) SSPBUF = BufI2C.Bf[BufI2C.indeks];
215:                   else SSPBUF = BufI2C.Bf[_NBSIZE - 1];
216:                   CKP = 1;
217:                   if(BufI2C.indeks < _NBDATA - 1) BufI2C.indeks++;
218:               }
219:               else
220:               {
221:                   CKP = 1;
222:                   BufI2C.indeks = 0;
223:               }
224:           }
225:            */
226:           void TransmitDataI2C(void)
227:           {
228:           	if(RW)				//ACK lub bit STOP?
E580  A4C7     BTFSS SSPSTAT, 2, ACCESS
E582  D018     BRA 0xE5B4
229:           	{
230:           		if(BufI2C.indeks<_NBSIZE) SSPBUF=BufI2C.Bf[BufI2C.indeks];
E584  0E18     MOVLW 0x18
E586  0102     MOVLB 0x2
E588  616C     CPFSLT _PFNf_enKNF, BANKED
E58A  D00B     BRA 0xE5A2
E58C  516C     MOVF _PFNf_enKNF, W, BANKED
E58E  0D01     MULLW 0x1
E590  0E6D     MOVLW 0x6D
E592  24F3     ADDWF PROD, W, ACCESS
E594  6ED9     MOVWF FSR2, ACCESS
E596  0E02     MOVLW 0x2
E598  20F4     ADDWFC PRODH, W, ACCESS
E59A  6EDA     MOVWF FSR2H, ACCESS
E59C  50DF     MOVF INDF2, W, ACCESS
E59E  6EC9     MOVWF SSPBUF, ACCESS
E5A0  D003     BRA 0xE5A8
231:           		else SSPBUF=BufI2C.Bf[_NBSIZE-1];
E5A2  C284     MOVFF 0x284, SSPBUF
E5A4  FFC9     NOP
E5A6  D000     BRA 0xE5A8
232:           		if(BufI2C.indeks<_NBDATA-1) BufI2C.indeks++;	
E5A8  0E15     MOVLW 0x15
E5AA  0102     MOVLB 0x2
E5AC  616C     CPFSLT _PFNf_enKNF, BANKED
E5AE  0C15     RETLW 0x15
E5B0  2B6C     INCF _PFNf_enKNF, F, BANKED
233:           	}
E5B2  0012     RETURN 0
234:           	else
235:           	{
236:           		BufI2C.indeks=0;		
E5B4  0E00     MOVLW 0x0
E5B6  0102     MOVLB 0x2
E5B8  6F6C     MOVWF _PFNf_enKNF, BANKED
E5BA  0C00     RETLW 0x0
237:           	}
238:           }
E5BC  0012     RETURN 0
239:           //-------------------------------------------------------------------------------
240:           //Odbiera nadeslane dane
241:           /*
242:           void ReceptDataI2C(void)
243:           {
244:               if(BufI2C.indeks < _NRCDT)
245:               {
246:                   BufI2C.Bf[BufI2C.indeks] = SSPBUF;
247:                   BufI2C.indeks++;
248:                   if(BufI2C.indeks == _NRCDT - 1)
249:                       if(LiczCHK(_NRCDT) == BufI2C.Bf[_NRCDT - 1]) ToWork();
250:               }
251:           }
252:           */
253:           void ReceptDataI2C(void)
254:           {
255:               //unsigned char dt;
256:           	dt = SSPBUF;
E33A  CFC9     MOVFF SSPBUF, dt
E33C  F178     NOP
257:           	if(BufI2C.indeks<_NRCDT)
E33E  0E03     MOVLW 0x3
E340  0102     MOVLB 0x2
E342  616C     CPFSLT _PFNf_enKNF, BANKED
E344  0C03     RETLW 0x3
258:           	{
259:           		BufI2C.Bf[BufI2C.indeks]=dt;
E346  516C     MOVF _PFNf_enKNF, W, BANKED
E348  0D01     MULLW 0x1
E34A  0E6D     MOVLW 0x6D
E34C  24F3     ADDWF PROD, W, ACCESS
E34E  6ED9     MOVWF FSR2, ACCESS
E350  0E02     MOVLW 0x2
E352  20F4     ADDWFC PRODH, W, ACCESS
E354  6EDA     MOVWF FSR2H, ACCESS
E356  C178     MOVFF dt, INDF2
E358  FFDF     NOP
260:           		BufI2C.indeks++;
E35A  0102     MOVLB 0x2
E35C  2B6C     INCF _PFNf_enKNF, F, BANKED
261:           		if(BufI2C.indeks==_NRCDT-1)
E35E  0E02     MOVLW 0x2
E360  0102     MOVLB 0x2
E362  196C     XORWF _PFNf_enKNF, W, BANKED
E364  A4D8     BTFSS STATUS, 2, ACCESS
E366  0012     RETURN 0
262:           		if(LiczCHK(_NRCDT)==BufI2C.Bf[_NRCDT-1]) ToWork();
E368  0E03     MOVLW 0x3
E36A  EC33     CALL 0xDC66, 0
E36C  F06E     NOP
E36E  0102     MOVLB 0x2
E370  196F     XORWF _PFNf_errCW, W, BANKED
E372  A4D8     BTFSS STATUS, 2, ACCESS
E374  0012     RETURN 0
E376  EC14     CALL 0xF428, 0
E378  F07A     NOP
263:           	}
E37A  0012     RETURN 0
264:           }
E37C  0012     RETURN 0
265:           //-------------------------------------------------------------------------------
266:           //Operacje wykonywane po odebraniu danych
267:           
268:           void ToWork(void)
269:           {
270:           
271:           }
F428  0012     RETURN 0
272:           
273:           //-------------------------------------------------------------------------------
274:           //Zapis danych przeznaczonych do wysylki do bufora
275:           
276:           void SetTData(void)
277:           {
278:               //unsigned int p;
279:               //p=(rgl.tmp_pwm-PWM.MDMOD)*100;
280:               //p=p/(PWM.MGMOD-PWM.MDMOD);
281:               BufI2C.Bf[0] = DtI2C.kod;
DC10  C1CA     MOVFF 0x1CA, 0x26D
DC12  F26D     NOP
282:               BufI2C.Bf[1] = M.LICZNIK_PL;//DtI2C.PCO;//mmm%100;
DC14  C082     MOVFF M, 0x26E
DC16  F26E     NOP
283:               BufI2C.Bf[2] = DtI2C.CO;//mmm/100;
DC18  C1CC     MOVFF 0x1CC, 0x26F
DC1A  F26F     NOP
284:               BufI2C.Bf[3] = DtI2C.PCW;
DC1C  C1CD     MOVFF 0x1CD, 0x270
DC1E  F270     NOP
285:               BufI2C.Bf[4] = DtI2C.CW;
DC20  C1CE     MOVFF 0x1CE, 0x271
DC22  F271     NOP
286:               BufI2C.Bf[5] = DtI2C.CS;
DC24  C1CF     MOVFF 0x1CF, 0x272
DC26  F272     NOP
287:               BufI2C.Bf[6] = DtI2C.STR_PWM;
DC28  C1D0     MOVFF 0x1D0, 0x273
DC2A  F273     NOP
288:               BufI2C.Bf[7] = DtI2C.MAX_PWM;
DC2C  C1D1     MOVFF 0x1D1, 0x274
DC2E  F274     NOP
289:               BufI2C.Bf[8] = DtI2C.BUF_PWM;
DC30  C1D2     MOVFF 0x1D2, 0x275
DC32  F275     NOP
290:               BufI2C.Bf[9] = DtI2C.ST_AD1;
DC34  C1D3     MOVFF 0x1D3, 0x276
DC36  F276     NOP
291:               BufI2C.Bf[10] = DtI2C.ST_AD2;
DC38  C1D4     MOVFF 0x1D4, 0x277
DC3A  F277     NOP
292:               BufI2C.Bf[11] = DtI2C.ST_AD3;
DC3C  C1D5     MOVFF 0x1D5, 0x278
DC3E  F278     NOP
293:               BufI2C.Bf[12] = DtI2C.PORTC;
DC40  C1D6     MOVFF 0x1D6, 0x279
DC42  F279     NOP
294:               BufI2C.Bf[13] = DtI2C.PORTD;
DC44  C1D7     MOVFF 0x1D7, 0x27A
DC46  F27A     NOP
295:               BufI2C.Bf[14] = DtI2C.ST_GLOBAL0;
DC48  C1D8     MOVFF 0x1D8, 0x27B
DC4A  F27B     NOP
296:               BufI2C.Bf[15] = DtI2C.ST_GLOBAL2;
DC4C  C1D9     MOVFF 0x1D9, 0x27C
DC4E  F27C     NOP
297:               BufI2C.Bf[16] = DtI2C.ST_GLOBAL3;
DC50  C1DA     MOVFF 0x1DA, 0x27D
DC52  F27D     NOP
298:               BufI2C.Bf[17] = DtI2C.ST_GLOBAL4;
DC54  C1DB     MOVFF 0x1DB, 0x27E
DC56  F27E     NOP
299:               BufI2C.Bf[18] = DtI2C.TPRZ_CW;
DC58  C1DC     MOVFF 0x1DC, 0x27F
DC5A  F27F     NOP
300:               BufI2C.Bf[19] = DtI2C.ST0_WSW;
DC5C  C1DD     MOVFF 0x1DD, 0x280
DC5E  F280     NOP
301:               BufI2C.Bf[20] = DtI2C.ERR_BTY;
DC60  C1DE     MOVFF 0x1DE, 0x281
DC62  F281     NOP
302:           }
DC64  0012     RETURN 0
303:           //-------------------------------------------------------------------------------
304:           //Przygotowanie na odbior danych
305:           
306:           void SetRData(void)
307:           {
308:               BufI2C.indeks = 0;
F404  0E00     MOVLW 0x0
F406  0102     MOVLB 0x2
F408  6B6C     CLRF _PFNf_enKNF, BANKED
309:           }
F40A  0012     RETURN 0
310:           //-------------------------------------------------------------------------------
311:           //Formatowanie danych na potrzeby modulu IMY-02
312:           /*
313:           void FormatDataIMY(void)
314:           {
315:               //Kod sterownika
316:               //DtI2C.kod=RSDT1.outRDZ0;
317:               switch(DtKNF.tpkt) //dla danego rodzaju kotla
318:               {
319:                   case _UNICO: //unico - monotermiczny
320:                       if(!Mf_TURBO) DtI2C.kod = 0xA0;
321:                       else DtI2C.kod = 0xA5;
322:                       break;
323:                   case _BITERM: //bitermiczny (miniterm)
324:                       if(!Mf_TURBO) DtI2C.kod = 0xA2;
325:                       else DtI2C.kod = 0xA7;
326:                       break;
327:                   case _BITERM2: //bitermiczny (maksiterm)
328:                       if(!Mf_TURBO) DtI2C.kod = 0xA4;
329:                       else DtI2C.kod = 0xA9;
330:                       break;
331:                   case _MONOHB: //monotermiczny z hydroblokiem
332:                       if(!Mf_TURBO) DtI2C.kod = 0xAA;
333:                       else DtI2C.kod = 0xAB;
334:                       break;
335:                   default: //domyslny monotermiczny
336:                       if(!Mf_TURBO) DtI2C.kod = 0xAA;
337:                       else DtI2C.kod = 0xAB; //inny domyslny
338:               }
339:               //PCO
340:               if(Mf_AKTYWNE_KNF) DtI2C.PCO = DtCO.PPCO;
341:               else
342:                   if(Mf_AKTYWNE_PGD) DtI2C.PCO = DtCO.PPCO;
343:               else DtI2C.PCO = DtCO.PPCO;
344:               //CO
345:               DtI2C.CO = DtCO.CO;
346:               //PCW
347:               if(Mf_AKTYWNE_KNF) DtI2C.PCW = DtCW.PPCW;
348:               else
349:                   if(Mf_pob_AL) DtI2C.PCW = DtCW.PPCW;
350:               else DtI2C.PCW = DtCW.PPCW;
351:               //CW
352:               DtI2C.CW = DtCW.CW;
353:               //CS
354:               DtI2C.CS = DtCS.CS;
355:               //Moc startowa
356:               DtI2C.STR_PWM = PWM.MSTART;
357:               //Moc maksymalna
358:               DtI2C.MAX_PWM = PWM.MMAXCO;
359:               //Wypelnienia modulatora
360:               DtI2C.BUF_PWM = PWM.BufPWM;
361:               //ST_AD1
362:               BitSet3(&DtI2C.ST_AD1, b_ERR_CO, RdPrt(S_ERR_CO));
363:               BitSet3(&DtI2C.ST_AD1, b_ERR_CW, DtCWf_err_CW);
364:               BitSet3(&DtI2C.ST_AD1, b_NEW_PCO, DtCOf_newPCO);
365:               BitSet3(&DtI2C.ST_AD1, b_NEW_PCW, DtCWf_newPCW);
366:               BitSet3(&DtI2C.ST_AD1, b_TERR_CSN, RdPrt(S_ERR_CSN));
367:               BitSet3(&DtI2C.ST_AD1, b_TLO_CSN, DtCSf_lo);
368:               BitSet3(&DtI2C.ST_AD1, b_THI_CSN, DtCSf_hi);
369:               BitSet3(&DtI2C.ST_AD1, b_TWRK_CSN, RdPrt(S_WRK_CSN));
370:               //ST_AD2
371:               BitSet3(&DtI2C.ST_AD2, b_SU_CO, DtCOf_su_CO);
372:               BitSet3(&DtI2C.ST_AD2, b_AD_CO, RdPrt(S_ADD_CO));
373:               BitSet3(&DtI2C.ST_AD2, b_ON_DZ, DtCOf_on_DZ_CO);
374:               BitSet3(&DtI2C.ST_AD2, b_ON_POMP, DtCOf_cold_CO || DtCOf_hot_CO);
375:               BitSet3(&DtI2C.ST_AD2, b_SU_CW, DtCWf_su_CW);
376:               BitSet3(&DtI2C.ST_AD2, b_AD_CW, DtCWf_ad_CW);
377:               BitSet3(&DtI2C.ST_AD2, b_S_DTF, RdPrt(S_DTF));
378:               BitSet3(&DtI2C.ST_AD2, b_F_DTF, RdPrt(S_DTF));
379:               //ST_AD3
380:               BitSet3(&DtI2C.ST_AD3, b_HOT_CO, DtCOf_hot_CO);
381:               BitSet3(&DtI2C.ST_AD3, b_NO_CSN, DtCSf_no);
382:               BitSet3(&DtI2C.ST_AD3, b_F_LO_CSN, RdPrt(S_LO_CSN));
383:               BitSet3(&DtI2C.ST_AD3, b_S_LO_CSN, RdPrt(S_LO_CSN));
384:               BitSet3(&DtI2C.ST_AD3, b_BLOK_15S, Mf_BLOKUJ_15S);
385:               //PORTC
386:               BitSet3(&DtI2C.PORTC, b_PLOMIEN, _PLOMIEN);
387:               BitSet3(&DtI2C.PORTC, b_ALARM, 1);
388:               BitSet3(&DtI2C.PORTC, b_VNT, _VNT);
389:               BitSet3(&DtI2C.PORTC, b_PRZEPLYW_CO, _PRZ_CO);
390:               if(!Mf_TURBO)
391:                   BitSet3(&DtI2C.PORTC, b_BRAK_CIAGU, _CIG_NC);
392:               else
393:                   BitSet3(&DtI2C.PORTC, b_BRAK_CIAGU, _CIG_NO);
394:               BitSet3(&DtI2C.PORTC, b_MOD_ON, _MOD_ON);
395:               //PORTD
396:               BitSet3(&DtI2C.PORTD, b_DTF, 0);
397:               BitSet3(&DtI2C.PORTD, b_GRZEJ, _GRZEJ);
398:               BitSet3(&DtI2C.PORTD, b_KCO_KCW, _KCO_CW);
399:               BitSet3(&DtI2C.PORTD, b_POMPA, _POMPA);
400:               BitSet3(&DtI2C.PORTD, b_RESET_O, PFNf_res); //0);
401:               BitSet3(&DtI2C.PORTD, b_SW_CONTROL, PFNf_off); //PFNf_lato||PFNf_zima);
402:               BitSet3(&DtI2C.PORTD, b_ZIMA, PFNf_zima);
403:               //ST_GLOBAL0
404:               if(DtKNF.tpkt != _UNICO)
405:               {
406:                   BitSet3(&DtI2C.ST_GLOBAL0, b_S_CW, (!Mf_AKTYWNE_SRW && !Mf_pob_KCO) ? RdPrt(S_WCW) : 0);
407:               }
408:               else
409:               {
410:                   if((Mf_pob_AL || Mf_pob_KCW || Mf_pob_DzCW) && Mf_PRACA) BitSet3(&DtI2C.ST_GLOBAL0, b_S_CW, 1);
411:                   else
412:                   {
413:                       if(!Mf_AKTYWNE_SRW&&!Mf_pob_KCO)
414:                               BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,(RdPrt(S_WCW)&&DtCWf_wpz_CW)?1:0);
415:                       else
416:                               BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,0);
417:                   }
418:               }
419:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_RT, RdPrt(S_RT));
420:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_ALARM, 1);
421:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_PRZ_CO, RdPrt(S_PRZ_CO));
422:               if(!Mf_TURBO)
423:                   BitSet3(&DtI2C.ST_GLOBAL0, b_S_BRAK_CI, !RdPrt(S_CIG_NC));
424:               else
425:                   BitSet3(&DtI2C.ST_GLOBAL0, b_S_BRAK_CI, !RdPrt(S_CIG_NO));
426:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_MOD_ON, !RdPrt(S_MOD_ON));
427:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_RESET, PFNf_res); //RdPrt(S_RESET));
428:               BitSet3(&DtI2C.ST_GLOBAL0, b_S_PLOMIEN, !RdPrt(S_PLM));
429:               //ST_GLOBAL2
430:               BitSet3(&DtI2C.ST_GLOBAL2, b_OPDG, DtKNF.opdg);
431:               BitSet3(&DtI2C.ST_GLOBAL2, b_GP, DtKNF.rdgz);
432:               BitSet3(&DtI2C.ST_GLOBAL2, b_OK_WRT, 0);
433:               BitSet3(&DtI2C.ST_GLOBAL2, b_S_ON_DZ, RdPrt(S_DZ_CO));
434:               BitSet3(&DtI2C.ST_GLOBAL2, b_F_ON_DZ, RdPrt(S_DZ_CO));
435:               BitSet3(&DtI2C.ST_GLOBAL2, b_S_SWC, !PFNf_off);//PFNf_lato || PFNf_zima);
436:               BitSet3(&DtI2C.ST_GLOBAL2, b_F_SWC, !PFNf_off);//PFNf_lato || PFNf_zima);
437:               BitSet3(&DtI2C.ST_GLOBAL2, b_S_STB, !RdPrt(S_STB));
438:               //ST_GLOBAL3
439:               BitSet3(&DtI2C.ST_GLOBAL3, b_ROZRUCH, Mf_ROZRUCH);
440:               BitSet3(&DtI2C.ST_GLOBAL3, b_WYLACZ, Mf_WYLACZ);
441:               BitSet3(&DtI2C.ST_GLOBAL3, b_RUSZ_CIAG, Mf_RUSZ_CIAG);
442:               BitSet3(&DtI2C.ST_GLOBAL3, b_RUSZ_POMPE, Mf_RUSZ_POMPE);
443:               BitSet3(&DtI2C.ST_GLOBAL3, b_CZEKAJ_NTC, Mf_RUSZ_NTC_CO);
444:               BitSet3(&DtI2C.ST_GLOBAL3, b_RUSZ_PLOMIEN, Mf_RUSZ_PLOMIEN);
445:               BitSet3(&DtI2C.ST_GLOBAL3, b_RUSZ_STB, Mf_RUSZ_STB);
446:               BitSet3(&DtI2C.ST_GLOBAL3, b_BLOKUJ_3M, Mf_BLOKUJ_3M);
447:               //ST_GLOBAL4
448:               BitSet3(&DtI2C.ST_GLOBAL4, b_RUSZ_48, Mf_RUSZ_48);
449:               BitSet3(&DtI2C.ST_GLOBAL4, b_ROZRUCH_AWR, 0);
450:               BitSet3(&DtI2C.ST_GLOBAL4, b_MODULUJ, Mf_MODULUJ);
451:               BitSet3(&DtI2C.ST_GLOBAL4, b_OST_STB, 0);
452:               BitSet3(&DtI2C.ST_GLOBAL4, b_OST_PLM, Mf_OST_PL);
453:               BitSet3(&DtI2C.ST_GLOBAL4, b_VWYBIEG, Mf_VWYBIEG);
454:               BitSet3(&DtI2C.ST_GLOBAL4, b_PPOMP, 0);
455:               BitSet3(&DtI2C.ST_GLOBAL4, b_ZMKCOCW, Mf_ZMKCOCW);
456:               //TPRZ_CW
457:               DtI2C.TPRZ_CW = 0;
458:               //ST0_WSW
459:               DtI2C.ST0_WSW = 0;
460:               BitSet3(&DtI2C.ST0_WSW, b_MSG_A1, !M.ERR_BTY && Mf_RUSZ_PLOMIEN);
461:               BitSet3(&DtI2C.ST0_WSW, b_MSG_A2, !M.ERR_BTY && Mf_RUSZ_STB);
462:               BitSet3(&DtI2C.ST0_WSW, b_MSG_A3, !M.ERR_BTY && Mf_RUSZ_CIAG && Mf_prb_CIG);
463:               if(DtKNF.robg == _OTWARTY) BitSet3(&DtI2C.ST0_WSW, b_MSG_A5, !M.ERR_BTY && Mf_RUSZ_POMPE && Mf_prb_PRZ);
464:           
465:               switch(M.ERR_BTY)
466:               {
467:                   case 0x01:
468:                       DtI2C.ERR_BTY = 1;
469:                       break;
470:                   case 0x02:
471:                       DtI2C.ERR_BTY = 2;
472:                       break;
473:                   case 0x03:
474:                       DtI2C.ERR_BTY = 3;
475:                       break;
476:                   case 0x04:
477:                       BitSet3(&DtI2C.ST0_WSW, b_MSG_A4, 1);
478:                       break;
479:                   case 0x05:
480:                       if(DtKNF.robg == _OTWARTY) DtI2C.ERR_BTY = 5;
481:                       else BitSet3(&DtI2C.ST0_WSW, b_MSG_A5, 1);
482:                       break;
483:                   case 0x06:
484:                       DtI2C.ERR_BTY = 6;
485:                       break;
486:                   case 0x07:
487:                       BitSet3(&DtI2C.ST0_WSW, b_MSG_A7, 1);
488:                       break;
489:                   case 0x08:
490:                       BitSet3(&DtI2C.ST0_WSW, b_MSG_A8, 1);
491:                       break;
492:                   case 0x09:
493:                       BitSet3(&DtI2C.ST0_WSW, b_MSG_A9, 1);
494:                       break;
495:               }
496:           }
497:            */
498:           void FormatDataIMY(void)
499:           {
500:           	//Kod sterownika
501:           	//DtI2C.kod=RSDT1.outRDZ0;
502:           	switch(DtKNF.tpkt)		//dla danego rodzaju kotla
1A50  D01F     BRA 0x1A90
1A90  0100     MOVLB 0x0
1A92  519E     MOVF _PWMf_ENPWM2, W, BANKED
1A94  E0DE     BZ 0x1A52
1A96  0A01     XORLW 0x1
1A98  E0E3     BZ 0x1A60
1A9A  0A03     XORLW 0x3
1A9C  E0E8     BZ 0x1A6E
1A9E  0A01     XORLW 0x1
1AA0  D7ED     BRA 0x1A7C
503:           	{
504:           		case _UNICO:		//unico - monotermiczny
505:           			if(!Mf_TURBO) DtI2C.kod=0xA0;
1A52  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1A54  D002     BRA 0x1A5A
1A56  0EA0     MOVLW 0xA0
1A58  D018     BRA 0x1A8A
506:           			else DtI2C.kod=0xA5;
1A5A  0EA5     MOVLW 0xA5
1A5C  D016     BRA 0x1A8A
507:           			break;
1A5E  D021     BRA 0x1AA2
508:           		case _BITERM:		//bitermiczny (miniterm)
509:           			if(!Mf_TURBO) DtI2C.kod=0xA2;
1A60  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1A62  D002     BRA 0x1A68
1A64  0EA2     MOVLW 0xA2
1A66  D011     BRA 0x1A8A
510:           			else DtI2C.kod=0xA7;
1A68  0EA7     MOVLW 0xA7
1A6A  D00F     BRA 0x1A8A
511:           			break;
1A6C  D01A     BRA 0x1AA2
512:           		case _BITERM2:		//bitermiczny (maksiterm)
513:           			if(!Mf_TURBO) DtI2C.kod=0xA4;
1A6E  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1A70  D002     BRA 0x1A76
1A72  0EA4     MOVLW 0xA4
1A74  D00A     BRA 0x1A8A
514:           			else DtI2C.kod=0xA9;
1A76  0EA9     MOVLW 0xA9
1A78  D008     BRA 0x1A8A
515:           			break;
1A7A  D013     BRA 0x1AA2
516:           		case _MONOHB:		//monotermiczny z hydroblokiem
517:           			if(!Mf_TURBO) DtI2C.kod=0xAA;
1A7C  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1A7E  D004     BRA 0x1A88
1A80  0EAA     MOVLW 0xAA
1A82  D003     BRA 0x1A8A
518:           			else DtI2C.kod=0xAB;
1A84  D001     BRA 0x1A88
519:           			break;
1A86  D00D     BRA 0x1AA2
520:           		default:			//domyslny monotermiczny
521:           			if(!Mf_TURBO) DtI2C.kod=0xAA;
522:           			else DtI2C.kod=0xAB;	//inny domyslny
1A88  0EAB     MOVLW 0xAB
1A8A  0101     MOVLB 0x1
1A8C  6FCA     MOVWF pp, BANKED
523:           	}
1A8E  D009     BRA 0x1AA2
524:           	//PCO
525:           	if(Mf_AKTYWNE_KNF) DtI2C.PCO=DtCO.PPCO;
1AA2  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
526:           	else
527:           	if(Mf_AKTYWNE_PGD) DtI2C.PCO=DtCO.PPCO;
1AA4  AA06     BTFSS DtKNFf_wymCO, 5, ACCESS
1AA6  D000     BRA 0x1AA8
528:           	else DtI2C.PCO=DtCO.PPCO;
1AA8  C0D1     MOVFF 0xD1, 0x1CB
1AAA  F1CB     NOP
1AAC  D000     BRA 0x1AAE
529:           	//CO
530:           	DtI2C.CO=DtCO.CO;
1AAE  C0CF     MOVFF DtCO, 0x1CC
1AB0  F1CC     NOP
531:           	//PCW
532:           	if(Mf_AKTYWNE_KNF) DtI2C.PCW=DtCW.PPCW;
1AB2  A806     BTFSS DtKNFf_wymCO, 4, ACCESS
533:           	else
534:           	if(Mf_pob_AL) DtI2C.PCW=DtCW.PPCW;
1AB4  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
1AB6  D000     BRA 0x1AB8
535:           	else DtI2C.PCW=DtCW.PPCW;
1AB8  C0AC     MOVFF _rglf_fz, 0x1CD
1ABA  F1CD     NOP
1ABC  D000     BRA 0x1ABE
536:           	//CW
537:           	DtI2C.CW=DtCW.CW;
1ABE  C0AA     MOVFF DtCW, 0x1CE
1AC0  F1CE     NOP
538:           	//CS
539:           	DtI2C.CS=DtCS.CS;
1AC2  C0CB     MOVFF DtCS, 0x1CF
1AC4  F1CF     NOP
540:           	//Moc startowa
541:           	DtI2C.STR_PWM=PWM.MSTART;
1AC6  C07C     MOVFF _PFNf_oaleg, 0x1D0
1AC8  F1D0     NOP
542:           	//Moc maksymalna
543:           	DtI2C.MAX_PWM=PWM.MMAXCO;
1ACA  C07D     MOVFF _PFNf_obgCO, 0x1D1
1ACC  F1D1     NOP
544:           	//Wypelnienia modulatora
545:           	DtI2C.BUF_PWM=PWM.BufPWM;
1ACE  C060     MOVFF PWM, 0x1D2
1AD0  F1D2     NOP
546:           	//ST_AD1
547:           	BitSet3(&DtI2C.ST_AD1,b_ERR_CO,RdPrt(S_ERR_CO));
1AD2  0ED3     MOVLW 0xD3
1AD4  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1AD6  0E01     MOVLW 0x1
1AD8  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1ADA  6A1A     CLRF _DtCOf_zroPCO, ACCESS
1ADC  0E12     MOVLW 0x12
1ADE  EC63     CALL 0xEAC6, 0
1AE0  F075     NOP
1AE2  0E01     MOVLW 0x1
1AE4  A0D8     BTFSS STATUS, 0, ACCESS
1AE6  0E00     MOVLW 0x0
1AE8  6E1B     MOVWF _DtCSf_error, ACCESS
1AEA  ECA1     CALL 0xDF42, 0
1AEC  F06F     NOP
548:           	BitSet3(&DtI2C.ST_AD1,b_ERR_CW,DtCWf_err_CW);
1AEE  0ED3     MOVLW 0xD3
1AF0  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1AF2  0E01     MOVLW 0x1
1AF4  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1AF6  0E01     MOVLW 0x1
1AF8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1AFA  0E00     MOVLW 0x0
1AFC  B804     BTFSC DtCWf_err_CW, 4, ACCESS
1AFE  0E01     MOVLW 0x1
1B00  6E1B     MOVWF _DtCSf_error, ACCESS
1B02  ECA1     CALL 0xDF42, 0
1B04  F06F     NOP
549:           	BitSet3(&DtI2C.ST_AD1,b_NEW_PCO,DtCOf_newPCO);
1B06  0ED3     MOVLW 0xD3
1B08  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B0A  0E01     MOVLW 0x1
1B0C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B0E  0E02     MOVLW 0x2
1B10  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B12  0E00     MOVLW 0x0
1B14  B402     BTFSC DtCOf_su_CO, 2, ACCESS
1B16  0E01     MOVLW 0x1
1B18  6E1B     MOVWF _DtCSf_error, ACCESS
1B1A  ECA1     CALL 0xDF42, 0
1B1C  F06F     NOP
550:           	BitSet3(&DtI2C.ST_AD1,b_NEW_PCW,DtCWf_newPCW);
1B1E  0ED3     MOVLW 0xD3
1B20  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B22  0E01     MOVLW 0x1
1B24  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B26  0E03     MOVLW 0x3
1B28  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B2A  0E00     MOVLW 0x0
1B2C  BC04     BTFSC DtCWf_err_CW, 6, ACCESS
1B2E  0E01     MOVLW 0x1
1B30  6E1B     MOVWF _DtCSf_error, ACCESS
1B32  ECA1     CALL 0xDF42, 0
1B34  F06F     NOP
551:           	BitSet3(&DtI2C.ST_AD1,b_TERR_CSN,RdPrt(S_ERR_CSN));
1B36  0ED3     MOVLW 0xD3
1B38  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B3A  0E01     MOVLW 0x1
1B3C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B3E  0E04     MOVLW 0x4
1B40  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B42  0E0E     MOVLW 0xE
1B44  EC63     CALL 0xEAC6, 0
1B46  F075     NOP
1B48  0E01     MOVLW 0x1
1B4A  A0D8     BTFSS STATUS, 0, ACCESS
1B4C  0E00     MOVLW 0x0
1B4E  6E1B     MOVWF _DtCSf_error, ACCESS
1B50  ECA1     CALL 0xDF42, 0
1B52  F06F     NOP
552:           	BitSet3(&DtI2C.ST_AD1,b_TLO_CSN,DtCSf_lo);
1B54  0ED3     MOVLW 0xD3
1B56  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B58  0E01     MOVLW 0x1
1B5A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B5C  0E05     MOVLW 0x5
1B5E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B60  0E00     MOVLW 0x0
1B62  BA03     BTFSC DtCOf_su_SRW_CO, 5, ACCESS
1B64  0E01     MOVLW 0x1
1B66  6E1B     MOVWF _DtCSf_error, ACCESS
1B68  ECA1     CALL 0xDF42, 0
1B6A  F06F     NOP
553:           	BitSet3(&DtI2C.ST_AD1,b_THI_CSN,DtCSf_hi);
1B6C  0ED3     MOVLW 0xD3
1B6E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B70  0E01     MOVLW 0x1
1B72  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B74  0E06     MOVLW 0x6
1B76  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B78  0E00     MOVLW 0x0
1B7A  B803     BTFSC DtCOf_su_SRW_CO, 4, ACCESS
1B7C  0E01     MOVLW 0x1
1B7E  6E1B     MOVWF _DtCSf_error, ACCESS
1B80  ECA1     CALL 0xDF42, 0
1B82  F06F     NOP
554:           	BitSet3(&DtI2C.ST_AD1,b_TWRK_CSN,RdPrt(S_WRK_CSN));
1B84  0ED3     MOVLW 0xD3
1B86  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1B88  0E01     MOVLW 0x1
1B8A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1B8C  0E07     MOVLW 0x7
1B8E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1B90  0E0F     MOVLW 0xF
1B92  EC63     CALL 0xEAC6, 0
1B94  F075     NOP
1B96  0E01     MOVLW 0x1
1B98  A0D8     BTFSS STATUS, 0, ACCESS
1B9A  0E00     MOVLW 0x0
1B9C  6E1B     MOVWF _DtCSf_error, ACCESS
1B9E  ECA1     CALL 0xDF42, 0
1BA0  F06F     NOP
555:           	//ST_AD2
556:           	BitSet3(&DtI2C.ST_AD2,b_SU_CO,DtCOf_su_CO);
1BA2  0ED4     MOVLW 0xD4
1BA4  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1BA6  0E01     MOVLW 0x1
1BA8  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1BAA  0E00     MOVLW 0x0
1BAC  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1BAE  BE02     BTFSC DtCOf_su_CO, 7, ACCESS
1BB0  0E01     MOVLW 0x1
1BB2  6E1B     MOVWF _DtCSf_error, ACCESS
1BB4  ECA1     CALL 0xDF42, 0
1BB6  F06F     NOP
557:           	BitSet3(&DtI2C.ST_AD2,b_AD_CO,RdPrt(S_ADD_CO));
1BB8  0ED4     MOVLW 0xD4
1BBA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1BBC  0E01     MOVLW 0x1
1BBE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1BC0  0E01     MOVLW 0x1
1BC2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1BC4  0E13     MOVLW 0x13
1BC6  EC63     CALL 0xEAC6, 0
1BC8  F075     NOP
1BCA  0E01     MOVLW 0x1
1BCC  A0D8     BTFSS STATUS, 0, ACCESS
1BCE  0E00     MOVLW 0x0
1BD0  6E1B     MOVWF _DtCSf_error, ACCESS
1BD2  ECA1     CALL 0xDF42, 0
1BD4  F06F     NOP
558:           	BitSet3(&DtI2C.ST_AD2,b_ON_DZ,DtCOf_on_DZ_CO);
1BD6  0ED4     MOVLW 0xD4
1BD8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1BDA  0E01     MOVLW 0x1
1BDC  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1BDE  0E02     MOVLW 0x2
1BE0  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1BE2  0E00     MOVLW 0x0
1BE4  B602     BTFSC DtCOf_su_CO, 3, ACCESS
1BE6  0E01     MOVLW 0x1
1BE8  6E1B     MOVWF _DtCSf_error, ACCESS
1BEA  ECA1     CALL 0xDF42, 0
1BEC  F06F     NOP
559:           	BitSet3(&DtI2C.ST_AD2,b_ON_POMP,DtCOf_cold_CO||DtCOf_hot_CO);
1BEE  0E01     MOVLW 0x1
1BF0  6E21     MOVWF _DtCWf_ad_CW, ACCESS
1BF2  AC01     BTFSS DtCOf_err_CO, 6, ACCESS
1BF4  B002     BTFSC DtCOf_su_CO, 0, ACCESS
1BF6  D003     BRA 0x1BFE
1BF8  0E00     MOVLW 0x0
1BFA  6E21     MOVWF _DtCWf_ad_CW, ACCESS
1BFC  D000     BRA 0x1BFE
1BFE  0ED4     MOVLW 0xD4
1C00  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C02  0E01     MOVLW 0x1
1C04  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C06  0E03     MOVLW 0x3
1C08  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C0A  C021     MOVFF _DtCWf_ad_CW, _DtCSf_error
1C0C  F01B     NOP
1C0E  ECA1     CALL 0xDF42, 0
1C10  F06F     NOP
560:           	BitSet3(&DtI2C.ST_AD2,b_SU_CW,DtCWf_su_CW);
1C12  0ED4     MOVLW 0xD4
1C14  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C16  0E01     MOVLW 0x1
1C18  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C1A  0E04     MOVLW 0x4
1C1C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C1E  0E00     MOVLW 0x0
1C20  B005     BTFSC DtKNFf_enknf, 0, ACCESS
1C22  0E01     MOVLW 0x1
1C24  6E1B     MOVWF _DtCSf_error, ACCESS
1C26  ECA1     CALL 0xDF42, 0
1C28  F06F     NOP
561:           	BitSet3(&DtI2C.ST_AD2,b_AD_CW,DtCWf_ad_CW);
1C2A  0ED4     MOVLW 0xD4
1C2C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C2E  0E01     MOVLW 0x1
1C30  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C32  0E05     MOVLW 0x5
1C34  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C36  0E00     MOVLW 0x0
1C38  B204     BTFSC DtCWf_err_CW, 1, ACCESS
1C3A  0E01     MOVLW 0x1
1C3C  6E1B     MOVWF _DtCSf_error, ACCESS
1C3E  ECA1     CALL 0xDF42, 0
1C40  F06F     NOP
562:           	BitSet3(&DtI2C.ST_AD2,b_S_DTF,RdPrt(S_DTF));
1C42  0ED4     MOVLW 0xD4
1C44  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C46  0E01     MOVLW 0x1
1C48  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C4A  0E06     MOVLW 0x6
1C4C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C4E  EC63     CALL 0xEAC6, 0
1C50  F075     NOP
1C52  0E01     MOVLW 0x1
1C54  A0D8     BTFSS STATUS, 0, ACCESS
1C56  0E00     MOVLW 0x0
1C58  6E1B     MOVWF _DtCSf_error, ACCESS
1C5A  ECA1     CALL 0xDF42, 0
1C5C  F06F     NOP
563:           	BitSet3(&DtI2C.ST_AD2,b_F_DTF,RdPrt(S_DTF));
1C5E  0ED4     MOVLW 0xD4
1C60  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C62  0E01     MOVLW 0x1
1C64  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C66  0E07     MOVLW 0x7
1C68  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C6A  0E06     MOVLW 0x6
1C6C  EC63     CALL 0xEAC6, 0
1C6E  F075     NOP
1C70  0E01     MOVLW 0x1
1C72  A0D8     BTFSS STATUS, 0, ACCESS
1C74  0E00     MOVLW 0x0
1C76  6E1B     MOVWF _DtCSf_error, ACCESS
1C78  ECA1     CALL 0xDF42, 0
1C7A  F06F     NOP
564:           	//ST_AD3
565:           	BitSet3(&DtI2C.ST_AD3,b_HOT_CO,DtCOf_hot_CO);
1C7C  0ED5     MOVLW 0xD5
1C7E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C80  0E01     MOVLW 0x1
1C82  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C84  0E00     MOVLW 0x0
1C86  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C88  B002     BTFSC DtCOf_su_CO, 0, ACCESS
1C8A  0E01     MOVLW 0x1
1C8C  6E1B     MOVWF _DtCSf_error, ACCESS
1C8E  ECA1     CALL 0xDF42, 0
1C90  F06F     NOP
566:           	BitSet3(&DtI2C.ST_AD3,b_NO_CSN,DtCSf_no);
1C92  0ED5     MOVLW 0xD5
1C94  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1C96  0E01     MOVLW 0x1
1C98  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1C9A  0E01     MOVLW 0x1
1C9C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1C9E  0E00     MOVLW 0x0
1CA0  BC03     BTFSC DtCOf_su_SRW_CO, 6, ACCESS
1CA2  0E01     MOVLW 0x1
1CA4  6E1B     MOVWF _DtCSf_error, ACCESS
1CA6  ECA1     CALL 0xDF42, 0
1CA8  F06F     NOP
567:           	BitSet3(&DtI2C.ST_AD3,b_F_LO_CSN,RdPrt(S_LO_CSN));
1CAA  0ED5     MOVLW 0xD5
1CAC  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1CAE  0E01     MOVLW 0x1
1CB0  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1CB2  0E02     MOVLW 0x2
1CB4  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1CB6  0E10     MOVLW 0x10
1CB8  EC63     CALL 0xEAC6, 0
1CBA  F075     NOP
1CBC  0E01     MOVLW 0x1
1CBE  A0D8     BTFSS STATUS, 0, ACCESS
1CC0  0E00     MOVLW 0x0
1CC2  6E1B     MOVWF _DtCSf_error, ACCESS
1CC4  ECA1     CALL 0xDF42, 0
1CC6  F06F     NOP
568:           	BitSet3(&DtI2C.ST_AD3,b_S_LO_CSN,RdPrt(S_LO_CSN));
1CC8  0ED5     MOVLW 0xD5
1CCA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1CCC  0E01     MOVLW 0x1
1CCE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1CD0  0E03     MOVLW 0x3
1CD2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1CD4  0E10     MOVLW 0x10
1CD6  EC63     CALL 0xEAC6, 0
1CD8  F075     NOP
1CDA  0E01     MOVLW 0x1
1CDC  A0D8     BTFSS STATUS, 0, ACCESS
1CDE  0E00     MOVLW 0x0
1CE0  6E1B     MOVWF _DtCSf_error, ACCESS
1CE2  ECA1     CALL 0xDF42, 0
1CE4  F06F     NOP
569:           	BitSet3(&DtI2C.ST_AD3,b_BLOK_15S,Mf_BLOKUJ_15S);
1CE6  0ED5     MOVLW 0xD5
1CE8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1CEA  0E01     MOVLW 0x1
1CEC  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1CEE  0E05     MOVLW 0x5
1CF0  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1CF2  0E00     MOVLW 0x0
1CF4  BE06     BTFSC DtKNFf_wymCO, 7, ACCESS
1CF6  0E01     MOVLW 0x1
1CF8  6E1B     MOVWF _DtCSf_error, ACCESS
1CFA  ECA1     CALL 0xDF42, 0
1CFC  F06F     NOP
570:           	//PORTC
571:           	BitSet3(&DtI2C.PORTC,b_PLOMIEN,_PLOMIEN);
1CFE  0ED6     MOVLW 0xD6
1D00  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D02  0E01     MOVLW 0x1
1D04  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D06  0E00     MOVLW 0x0
1D08  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D0A  B883     BTFSC PORTD, 4, ACCESS
1D0C  0E01     MOVLW 0x1
1D0E  6E1B     MOVWF _DtCSf_error, ACCESS
1D10  ECA1     CALL 0xDF42, 0
1D12  F06F     NOP
572:           	BitSet3(&DtI2C.PORTC,b_ALARM,1);
1D14  0ED6     MOVLW 0xD6
1D16  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D18  0E01     MOVLW 0x1
1D1A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D1C  0E01     MOVLW 0x1
1D1E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D20  6E1B     MOVWF _DtCSf_error, ACCESS
1D22  ECA1     CALL 0xDF42, 0
1D24  F06F     NOP
573:           	BitSet3(&DtI2C.PORTC,b_VNT,_VNT);
1D26  0ED6     MOVLW 0xD6
1D28  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D2A  0E01     MOVLW 0x1
1D2C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D2E  0E03     MOVLW 0x3
1D30  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D32  0E00     MOVLW 0x0
1D34  B683     BTFSC PORTD, 3, ACCESS
1D36  0E01     MOVLW 0x1
1D38  6E1B     MOVWF _DtCSf_error, ACCESS
1D3A  ECA1     CALL 0xDF42, 0
1D3C  F06F     NOP
574:           	BitSet3(&DtI2C.PORTC,b_PRZEPLYW_CO,_PRZ_CO);
1D3E  0ED6     MOVLW 0xD6
1D40  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D42  0E01     MOVLW 0x1
1D44  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D46  0E05     MOVLW 0x5
1D48  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D4A  0E00     MOVLW 0x0
1D4C  BA81     BTFSC PORTB, 5, ACCESS
1D4E  0E01     MOVLW 0x1
1D50  6E1B     MOVWF _DtCSf_error, ACCESS
1D52  ECA1     CALL 0xDF42, 0
1D54  F06F     NOP
575:           	if(!Mf_TURBO)
1D56  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1D58  D00D     BRA 0x1D74
576:           		BitSet3(&DtI2C.PORTC,b_BRAK_CIAGU,_CIG_NC);
1D5A  0ED6     MOVLW 0xD6
1D5C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D5E  0E01     MOVLW 0x1
1D60  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D62  0E06     MOVLW 0x6
1D64  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D66  0E00     MOVLW 0x0
1D68  B082     BTFSC PORTC, 0, ACCESS
1D6A  0E01     MOVLW 0x1
1D6C  6E1B     MOVWF _DtCSf_error, ACCESS
1D6E  ECA1     CALL 0xDF42, 0
1D70  F06F     NOP
1D72  D00C     BRA 0x1D8C
577:           	else
578:           		BitSet3(&DtI2C.PORTC,b_BRAK_CIAGU,_CIG_NO);
1D74  0ED6     MOVLW 0xD6
1D76  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D78  0E01     MOVLW 0x1
1D7A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D7C  0E06     MOVLW 0x6
1D7E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D80  0E00     MOVLW 0x0
1D82  BC80     BTFSC PORTA, 6, ACCESS
1D84  0E01     MOVLW 0x1
1D86  6E1B     MOVWF _DtCSf_error, ACCESS
1D88  ECA1     CALL 0xDF42, 0
1D8A  F06F     NOP
579:           	BitSet3(&DtI2C.PORTC,b_MOD_ON,_MOD_ON);
1D8C  0ED6     MOVLW 0xD6
1D8E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1D90  0E01     MOVLW 0x1
1D92  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1D94  0E07     MOVLW 0x7
1D96  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1D98  0E00     MOVLW 0x0
1D9A  BA82     BTFSC PORTC, 5, ACCESS
1D9C  0E01     MOVLW 0x1
1D9E  6E1B     MOVWF _DtCSf_error, ACCESS
1DA0  ECA1     CALL 0xDF42, 0
1DA2  F06F     NOP
580:           	//PORTD
581:           	BitSet3(&DtI2C.PORTD,b_DTF,0);
1DA4  0ED7     MOVLW 0xD7
1DA6  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1DA8  0E01     MOVLW 0x1
1DAA  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1DAC  0E00     MOVLW 0x0
1DAE  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1DB0  6E1B     MOVWF _DtCSf_error, ACCESS
1DB2  ECA1     CALL 0xDF42, 0
1DB4  F06F     NOP
582:           	BitSet3(&DtI2C.PORTD,b_GRZEJ,_GRZEJ);
1DB6  0ED7     MOVLW 0xD7
1DB8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1DBA  0E01     MOVLW 0x1
1DBC  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1DBE  0E01     MOVLW 0x1
1DC0  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1DC2  0E00     MOVLW 0x0
1DC4  B083     BTFSC PORTD, 0, ACCESS
1DC6  0E01     MOVLW 0x1
1DC8  6E1B     MOVWF _DtCSf_error, ACCESS
1DCA  ECA1     CALL 0xDF42, 0
1DCC  F06F     NOP
583:           	BitSet3(&DtI2C.PORTD,b_KCO_KCW,_KCO_CW);
1DCE  0ED7     MOVLW 0xD7
1DD0  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1DD2  0E01     MOVLW 0x1
1DD4  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1DD6  0E02     MOVLW 0x2
1DD8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1DDA  0E00     MOVLW 0x0
1DDC  B283     BTFSC PORTD, 1, ACCESS
1DDE  0E01     MOVLW 0x1
1DE0  6E1B     MOVWF _DtCSf_error, ACCESS
1DE2  ECA1     CALL 0xDF42, 0
1DE4  F06F     NOP
584:           	BitSet3(&DtI2C.PORTD,b_POMPA,_POMPA);
1DE6  0ED7     MOVLW 0xD7
1DE8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1DEA  0E01     MOVLW 0x1
1DEC  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1DEE  0E03     MOVLW 0x3
1DF0  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1DF2  0E00     MOVLW 0x0
1DF4  B483     BTFSC PORTD, 2, ACCESS
1DF6  0E01     MOVLW 0x1
1DF8  6E1B     MOVWF _DtCSf_error, ACCESS
1DFA  ECA1     CALL 0xDF42, 0
1DFC  F06F     NOP
585:           	BitSet3(&DtI2C.PORTD,b_RESET_O,PFNf_res);//0);
1DFE  0ED7     MOVLW 0xD7
1E00  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1E02  0E01     MOVLW 0x1
1E04  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1E06  0E04     MOVLW 0x4
1E08  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1E0A  0E00     MOVLW 0x0
1E0C  B012     BTFSC PFNf_str_nco, 0, ACCESS
1E0E  0E01     MOVLW 0x1
1E10  6E1B     MOVWF _DtCSf_error, ACCESS
1E12  ECA1     CALL 0xDF42, 0
1E14  F06F     NOP
586:           	BitSet3(&DtI2C.PORTD,b_SW_CONTROL,!PFNf_off);//PFNf_lato||PFNf_zima);
1E16  0ED7     MOVLW 0xD7
1E18  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1E1A  0E01     MOVLW 0x1
1E1C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1E1E  0E05     MOVLW 0x5
1E20  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1E22  0E01     MOVLW 0x1
1E24  BE0F     BTFSC PFNf_off, 7, ACCESS
1E26  0E00     MOVLW 0x0
1E28  6E1B     MOVWF _DtCSf_error, ACCESS
1E2A  ECA1     CALL 0xDF42, 0
1E2C  F06F     NOP
587:           	BitSet3(&DtI2C.PORTD,b_ZIMA,(!PFNf_off&&PFNf_zima));
1E2E  0E00     MOVLW 0x0
1E30  6E22     MOVWF _DtCWf_ad_DZ_CW, ACCESS
1E32  AE0F     BTFSS PFNf_off, 7, ACCESS
1E34  A613     BTFSS PFNf_zima, 3, ACCESS
1E36  D003     BRA 0x1E3E
1E38  0E01     MOVLW 0x1
1E3A  6E22     MOVWF _DtCWf_ad_DZ_CW, ACCESS
1E3C  D000     BRA 0x1E3E
1E3E  0ED7     MOVLW 0xD7
1E40  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1E42  0E01     MOVLW 0x1
1E44  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1E46  0E06     MOVLW 0x6
1E48  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1E4A  C022     MOVFF _DtCWf_ad_DZ_CW, _DtCSf_error
1E4C  F01B     NOP
1E4E  ECA1     CALL 0xDF42, 0
1E50  F06F     NOP
588:           	//ST_GLOBAL0
589:           	if(DtKNF.tpkt!=_UNICO)
1E52  0100     MOVLB 0x0
1E54  519E     MOVF _PWMf_ENPWM2, W, BANKED
1E56  E01C     BZ 0x1E90
590:           	{
591:           		BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,(!Mf_AKTYWNE_SRW&&!Mf_pob_KCO)?RdPrt(S_WCW):0);
1E58  BC06     BTFSC DtKNFf_wymCO, 6, ACCESS
1E5A  D002     BRA 0x1E60
1E5C  A60B     BTFSS Mf_pob_KCO, 3, ACCESS
1E5E  D004     BRA 0x1E68
1E60  0E00     MOVLW 0x0
1E62  6E20     MOVWF _DtCSf_work, ACCESS
1E64  6E1F     MOVWF _DtCSf_no_mont, ACCESS
1E66  D009     BRA 0x1E7A
1E68  0E0B     MOVLW 0xB
1E6A  EC63     CALL 0xEAC6, 0
1E6C  F075     NOP
1E6E  0E01     MOVLW 0x1
1E70  A0D8     BTFSS STATUS, 0, ACCESS
1E72  0E00     MOVLW 0x0
1E74  6E1F     MOVWF _DtCSf_no_mont, ACCESS
1E76  6A20     CLRF _DtCSf_work, ACCESS
1E78  D000     BRA 0x1E7A
1E7A  0ED8     MOVLW 0xD8
1E7C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1E7E  0E01     MOVLW 0x1
1E80  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1E82  0E00     MOVLW 0x0
1E84  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1E86  C01F     MOVFF _DtCSf_no_mont, _DtCSf_error
1E88  F01B     NOP
1E8A  ECA1     CALL 0xDF42, 0
1E8C  F06F     NOP
592:           	}
1E8E  D034     BRA 0x1EF8
593:           	else
594:           	{
595:           		if((Mf_pob_AL||Mf_pob_KCW||Mf_pob_DzCW)&&Mf_PRACA) BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,1);
1E90  AC0A     BTFSS Mf_pob_AL, 6, ACCESS
1E92  B80B     BTFSC Mf_pob_KCO, 4, ACCESS
1E94  D002     BRA 0x1E9A
1E96  A40B     BTFSS Mf_pob_KCO, 2, ACCESS
1E98  D00D     BRA 0x1EB4
1E9A  AC07     BTFSS Mf_BLOKUJ_3M, 6, ACCESS
1E9C  D00B     BRA 0x1EB4
1E9E  0ED8     MOVLW 0xD8
1EA0  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1EA2  0E01     MOVLW 0x1
1EA4  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1EA6  0E00     MOVLW 0x0
1EA8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1EAA  0E01     MOVLW 0x1
1EAC  6E1B     MOVWF _DtCSf_error, ACCESS
1EAE  ECA1     CALL 0xDF42, 0
1EB0  F06F     NOP
1EB2  D022     BRA 0x1EF8
596:           		else
597:           		{
598:           			if(!Mf_AKTYWNE_SRW&&!Mf_pob_KCO)
1EB4  AC06     BTFSS DtKNFf_wymCO, 6, ACCESS
1EB6  B60B     BTFSC Mf_pob_KCO, 3, ACCESS
1EB8  D015     BRA 0x1EE4
599:           				BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,(RdPrt(S_WCW)&&DtCWf_wpz_CW)?1:0);
1EBA  6A23     CLRF _DtCWf_cold_CW, ACCESS
1EBC  0E0B     MOVLW 0xB
1EBE  EC63     CALL 0xEAC6, 0
1EC0  F075     NOP
1EC2  B0D8     BTFSC STATUS, 0, ACCESS
1EC4  A405     BTFSS DtKNFf_enknf, 2, ACCESS
1EC6  D003     BRA 0x1ECE
1EC8  0E01     MOVLW 0x1
1ECA  6E23     MOVWF _DtCWf_cold_CW, ACCESS
1ECC  D000     BRA 0x1ECE
1ECE  0ED8     MOVLW 0xD8
1ED0  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1ED2  0E01     MOVLW 0x1
1ED4  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1ED6  0E00     MOVLW 0x0
1ED8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1EDA  C023     MOVFF _DtCWf_cold_CW, _DtCSf_error
1EDC  F01B     NOP
1EDE  ECA1     CALL 0xDF42, 0
1EE0  F06F     NOP
1EE2  D00A     BRA 0x1EF8
600:           			else
601:           				BitSet3(&DtI2C.ST_GLOBAL0,b_S_CW,0);
1EE4  0ED8     MOVLW 0xD8
1EE6  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1EE8  0E01     MOVLW 0x1
1EEA  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1EEC  0E00     MOVLW 0x0
1EEE  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1EF0  6E1B     MOVWF _DtCSf_error, ACCESS
1EF2  ECA1     CALL 0xDF42, 0
1EF4  F06F     NOP
602:           		}
1EF6  D000     BRA 0x1EF8
603:           	}
604:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_RT,RdPrt(S_RT));
1EF8  0ED8     MOVLW 0xD8
1EFA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1EFC  0E01     MOVLW 0x1
1EFE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F00  0E01     MOVLW 0x1
1F02  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F04  0E0C     MOVLW 0xC
1F06  EC63     CALL 0xEAC6, 0
1F08  F075     NOP
1F0A  0E01     MOVLW 0x1
1F0C  A0D8     BTFSS STATUS, 0, ACCESS
1F0E  0E00     MOVLW 0x0
1F10  6E1B     MOVWF _DtCSf_error, ACCESS
1F12  ECA1     CALL 0xDF42, 0
1F14  F06F     NOP
605:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_ALARM,1);
1F16  0ED8     MOVLW 0xD8
1F18  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1F1A  0E01     MOVLW 0x1
1F1C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F1E  0E02     MOVLW 0x2
1F20  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F22  0E01     MOVLW 0x1
1F24  6E1B     MOVWF _DtCSf_error, ACCESS
1F26  ECA1     CALL 0xDF42, 0
1F28  F06F     NOP
606:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_PRZ_CO,RdPrt(S_PRZ_CO));
1F2A  0ED8     MOVLW 0xD8
1F2C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1F2E  0E01     MOVLW 0x1
1F30  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F32  0E03     MOVLW 0x3
1F34  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F36  0E01     MOVLW 0x1
1F38  EC63     CALL 0xEAC6, 0
1F3A  F075     NOP
1F3C  0E01     MOVLW 0x1
1F3E  A0D8     BTFSS STATUS, 0, ACCESS
1F40  0E00     MOVLW 0x0
1F42  6E1B     MOVWF _DtCSf_error, ACCESS
1F44  ECA1     CALL 0xDF42, 0
1F46  F06F     NOP
607:           	if(!Mf_TURBO)
1F48  B40A     BTFSC Mf_pob_AL, 2, ACCESS
1F4A  D010     BRA 0x1F6C
608:           		BitSet3(&DtI2C.ST_GLOBAL0,b_S_BRAK_CI,!RdPrt(S_CIG_NC));
1F4C  0ED8     MOVLW 0xD8
1F4E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1F50  0E01     MOVLW 0x1
1F52  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F54  0E04     MOVLW 0x4
1F56  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F58  0E02     MOVLW 0x2
1F5A  EC63     CALL 0xEAC6, 0
1F5C  F075     NOP
1F5E  0E01     MOVLW 0x1
1F60  B0D8     BTFSC STATUS, 0, ACCESS
1F62  0E00     MOVLW 0x0
1F64  6E1B     MOVWF _DtCSf_error, ACCESS
1F66  ECA1     CALL 0xDF42, 0
1F68  F06F     NOP
1F6A  D00F     BRA 0x1F8A
609:           	else
610:           		BitSet3(&DtI2C.ST_GLOBAL0,b_S_BRAK_CI,!RdPrt(S_CIG_NO));
1F6C  0ED8     MOVLW 0xD8
1F6E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1F70  0E01     MOVLW 0x1
1F72  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F74  0E04     MOVLW 0x4
1F76  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F78  0E03     MOVLW 0x3
1F7A  EC63     CALL 0xEAC6, 0
1F7C  F075     NOP
1F7E  0E01     MOVLW 0x1
1F80  B0D8     BTFSC STATUS, 0, ACCESS
1F82  0E00     MOVLW 0x0
1F84  6E1B     MOVWF _DtCSf_error, ACCESS
1F86  ECA1     CALL 0xDF42, 0
1F88  F06F     NOP
611:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_MOD_ON,!RdPrt(S_MOD_ON));
1F8A  0ED8     MOVLW 0xD8
1F8C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1F8E  0E01     MOVLW 0x1
1F90  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1F92  0E05     MOVLW 0x5
1F94  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1F96  0E08     MOVLW 0x8
1F98  EC63     CALL 0xEAC6, 0
1F9A  F075     NOP
1F9C  0E01     MOVLW 0x1
1F9E  B0D8     BTFSC STATUS, 0, ACCESS
1FA0  0E00     MOVLW 0x0
1FA2  6E1B     MOVWF _DtCSf_error, ACCESS
1FA4  ECA1     CALL 0xDF42, 0
1FA6  F06F     NOP
612:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_RESET,PFNf_res);//RdPrt(S_RESET));
1FA8  0ED8     MOVLW 0xD8
1FAA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1FAC  0E01     MOVLW 0x1
1FAE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1FB0  0E06     MOVLW 0x6
1FB2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1FB4  0E00     MOVLW 0x0
1FB6  B012     BTFSC PFNf_str_nco, 0, ACCESS
1FB8  0E01     MOVLW 0x1
1FBA  6E1B     MOVWF _DtCSf_error, ACCESS
1FBC  ECA1     CALL 0xDF42, 0
1FBE  F06F     NOP
613:           	BitSet3(&DtI2C.ST_GLOBAL0,b_S_PLOMIEN,!RdPrt(S_PLM));
1FC0  0ED8     MOVLW 0xD8
1FC2  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1FC4  0E01     MOVLW 0x1
1FC6  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1FC8  0E07     MOVLW 0x7
1FCA  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1FCC  0E05     MOVLW 0x5
1FCE  EC63     CALL 0xEAC6, 0
1FD0  F075     NOP
1FD2  0E01     MOVLW 0x1
1FD4  B0D8     BTFSC STATUS, 0, ACCESS
1FD6  0E00     MOVLW 0x0
1FD8  6E1B     MOVWF _DtCSf_error, ACCESS
1FDA  ECA1     CALL 0xDF42, 0
1FDC  F06F     NOP
614:           	//ST_GLOBAL2
615:           	BitSet3(&DtI2C.ST_GLOBAL2,b_OPDG,DtKNF.opdg);
1FDE  0ED9     MOVLW 0xD9
1FE0  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1FE2  0E01     MOVLW 0x1
1FE4  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1FE6  0E00     MOVLW 0x0
1FE8  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1FEA  C0A7     MOVFF _rglf_btco, _DtCSf_error
1FEC  F01B     NOP
1FEE  ECA1     CALL 0xDF42, 0
1FF0  F06F     NOP
616:           	BitSet3(&DtI2C.ST_GLOBAL2,b_GP,DtKNF.rdgz);
1FF2  0ED9     MOVLW 0xD9
1FF4  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
1FF6  0E01     MOVLW 0x1
1FF8  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
1FFA  0E01     MOVLW 0x1
1FFC  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
1FFE  C09F     MOVFF _PWMf_tpGZ, _DtCSf_error
2000  F01B     NOP
2002  ECA1     CALL 0xDF42, 0
2004  F06F     NOP
617:           	BitSet3(&DtI2C.ST_GLOBAL2,b_OK_WRT,0);
2006  0ED9     MOVLW 0xD9
2008  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
200A  0E01     MOVLW 0x1
200C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
200E  0E02     MOVLW 0x2
2010  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2012  0E00     MOVLW 0x0
2014  6E1B     MOVWF _DtCSf_error, ACCESS
2016  ECA1     CALL 0xDF42, 0
2018  F06F     NOP
618:           	BitSet3(&DtI2C.ST_GLOBAL2,b_S_ON_DZ,RdPrt(S_DZ_CO));
201A  0ED9     MOVLW 0xD9
201C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
201E  0E01     MOVLW 0x1
2020  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2022  0E03     MOVLW 0x3
2024  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2026  0E09     MOVLW 0x9
2028  EC63     CALL 0xEAC6, 0
202A  F075     NOP
202C  0E01     MOVLW 0x1
202E  A0D8     BTFSS STATUS, 0, ACCESS
2030  0E00     MOVLW 0x0
2032  6E1B     MOVWF _DtCSf_error, ACCESS
2034  ECA1     CALL 0xDF42, 0
2036  F06F     NOP
619:           	BitSet3(&DtI2C.ST_GLOBAL2,b_F_ON_DZ,RdPrt(S_DZ_CO));
2038  0ED9     MOVLW 0xD9
203A  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
203C  0E01     MOVLW 0x1
203E  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2040  0E04     MOVLW 0x4
2042  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2044  0E09     MOVLW 0x9
2046  EC63     CALL 0xEAC6, 0
2048  F075     NOP
204A  0E01     MOVLW 0x1
204C  A0D8     BTFSS STATUS, 0, ACCESS
204E  0E00     MOVLW 0x0
2050  6E1B     MOVWF _DtCSf_error, ACCESS
2052  ECA1     CALL 0xDF42, 0
2054  F06F     NOP
620:           	BitSet3(&DtI2C.ST_GLOBAL2,b_S_SWC,!PFNf_off);//PFNf_lato||PFNf_zima);
2056  0ED9     MOVLW 0xD9
2058  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
205A  0E01     MOVLW 0x1
205C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
205E  0E05     MOVLW 0x5
2060  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2062  0E01     MOVLW 0x1
2064  BE0F     BTFSC PFNf_off, 7, ACCESS
2066  0E00     MOVLW 0x0
2068  6E1B     MOVWF _DtCSf_error, ACCESS
206A  ECA1     CALL 0xDF42, 0
206C  F06F     NOP
621:           	BitSet3(&DtI2C.ST_GLOBAL2,b_F_SWC,!PFNf_off);//PFNf_lato||PFNf_zima);
206E  0ED9     MOVLW 0xD9
2070  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2072  0E01     MOVLW 0x1
2074  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2076  0E06     MOVLW 0x6
2078  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
207A  0E01     MOVLW 0x1
207C  BE0F     BTFSC PFNf_off, 7, ACCESS
207E  0E00     MOVLW 0x0
2080  6E1B     MOVWF _DtCSf_error, ACCESS
2082  ECA1     CALL 0xDF42, 0
2084  F06F     NOP
622:           	BitSet3(&DtI2C.ST_GLOBAL2,b_S_STB,!RdPrt(S_STB));
2086  0ED9     MOVLW 0xD9
2088  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
208A  0E01     MOVLW 0x1
208C  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
208E  0E07     MOVLW 0x7
2090  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2092  0E04     MOVLW 0x4
2094  EC63     CALL 0xEAC6, 0
2096  F075     NOP
2098  0E01     MOVLW 0x1
209A  B0D8     BTFSC STATUS, 0, ACCESS
209C  0E00     MOVLW 0x0
209E  6E1B     MOVWF _DtCSf_error, ACCESS
20A0  ECA1     CALL 0xDF42, 0
20A2  F06F     NOP
623:           	//ST_GLOBAL3
624:           	BitSet3(&DtI2C.ST_GLOBAL3,b_ROZRUCH,Mf_ROZRUCH);
20A4  0EDA     MOVLW 0xDA
20A6  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
20A8  0E01     MOVLW 0x1
20AA  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
20AC  0E00     MOVLW 0x0
20AE  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
20B0  B008     BTFSC Mf_ROZRUCH, 0, ACCESS
20B2  0E01     MOVLW 0x1
20B4  6E1B     MOVWF _DtCSf_error, ACCESS
20B6  ECA1     CALL 0xDF42, 0
20B8  F06F     NOP
625:           	BitSet3(&DtI2C.ST_GLOBAL3,b_WYLACZ,Mf_WYLACZ);
20BA  0EDA     MOVLW 0xDA
20BC  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
20BE  0E01     MOVLW 0x1
20C0  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
20C2  0E01     MOVLW 0x1
20C4  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
20C6  0E00     MOVLW 0x0
20C8  B80A     BTFSC Mf_pob_AL, 4, ACCESS
20CA  0E01     MOVLW 0x1
20CC  6E1B     MOVWF _DtCSf_error, ACCESS
20CE  ECA1     CALL 0xDF42, 0
20D0  F06F     NOP
626:           	BitSet3(&DtI2C.ST_GLOBAL3,b_RUSZ_CIAG,Mf_RUSZ_CIAG);
20D2  0EDA     MOVLW 0xDA
20D4  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
20D6  0E01     MOVLW 0x1
20D8  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
20DA  0E02     MOVLW 0x2
20DC  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
20DE  0E00     MOVLW 0x0
20E0  BC08     BTFSC Mf_ROZRUCH, 6, ACCESS
20E2  0E01     MOVLW 0x1
20E4  6E1B     MOVWF _DtCSf_error, ACCESS
20E6  ECA1     CALL 0xDF42, 0
20E8  F06F     NOP
627:           	BitSet3(&DtI2C.ST_GLOBAL3,b_RUSZ_POMPE,Mf_RUSZ_POMPE);
20EA  0EDA     MOVLW 0xDA
20EC  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
20EE  0E01     MOVLW 0x1
20F0  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
20F2  0E03     MOVLW 0x3
20F4  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
20F6  0E00     MOVLW 0x0
20F8  BC09     BTFSC Mf_RUSZ_PWR, 6, ACCESS
20FA  0E01     MOVLW 0x1
20FC  6E1B     MOVWF _DtCSf_error, ACCESS
20FE  ECA1     CALL 0xDF42, 0
2100  F06F     NOP
628:           	BitSet3(&DtI2C.ST_GLOBAL3,b_CZEKAJ_NTC,Mf_RUSZ_NTC_CO);
2102  0EDA     MOVLW 0xDA
2104  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2106  0E01     MOVLW 0x1
2108  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
210A  0E04     MOVLW 0x4
210C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
210E  0E00     MOVLW 0x0
2110  B409     BTFSC Mf_RUSZ_PWR, 2, ACCESS
2112  0E01     MOVLW 0x1
2114  6E1B     MOVWF _DtCSf_error, ACCESS
2116  ECA1     CALL 0xDF42, 0
2118  F06F     NOP
629:           	BitSet3(&DtI2C.ST_GLOBAL3,b_RUSZ_PLOMIEN,Mf_RUSZ_PLOMIEN);
211A  0EDA     MOVLW 0xDA
211C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
211E  0E01     MOVLW 0x1
2120  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2122  0E05     MOVLW 0x5
2124  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2126  0E00     MOVLW 0x0
2128  BA09     BTFSC Mf_RUSZ_PWR, 5, ACCESS
212A  0E01     MOVLW 0x1
212C  6E1B     MOVWF _DtCSf_error, ACCESS
212E  ECA1     CALL 0xDF42, 0
2130  F06F     NOP
630:           	BitSet3(&DtI2C.ST_GLOBAL3,b_RUSZ_STB,Mf_RUSZ_STB);
2132  0EDA     MOVLW 0xDA
2134  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2136  0E01     MOVLW 0x1
2138  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
213A  0E06     MOVLW 0x6
213C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
213E  0E00     MOVLW 0x0
2140  B20A     BTFSC Mf_pob_AL, 1, ACCESS
2142  0E01     MOVLW 0x1
2144  6E1B     MOVWF _DtCSf_error, ACCESS
2146  ECA1     CALL 0xDF42, 0
2148  F06F     NOP
631:           	BitSet3(&DtI2C.ST_GLOBAL3,b_BLOKUJ_3M,Mf_BLOKUJ_3M);
214A  0EDA     MOVLW 0xDA
214C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
214E  0E01     MOVLW 0x1
2150  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2152  0E07     MOVLW 0x7
2154  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2156  0E00     MOVLW 0x0
2158  B007     BTFSC Mf_BLOKUJ_3M, 0, ACCESS
215A  0E01     MOVLW 0x1
215C  6E1B     MOVWF _DtCSf_error, ACCESS
215E  ECA1     CALL 0xDF42, 0
2160  F06F     NOP
632:           	//ST_GLOBAL4
633:           	BitSet3(&DtI2C.ST_GLOBAL4,b_RUSZ_48,Mf_RUSZ_48);
2162  0EDB     MOVLW 0xDB
2164  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2166  0E01     MOVLW 0x1
2168  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
216A  0E00     MOVLW 0x0
216C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
216E  B808     BTFSC Mf_ROZRUCH, 4, ACCESS
2170  0E01     MOVLW 0x1
2172  6E1B     MOVWF _DtCSf_error, ACCESS
2174  ECA1     CALL 0xDF42, 0
2176  F06F     NOP
634:           	BitSet3(&DtI2C.ST_GLOBAL4,b_ROZRUCH_AWR,0);
2178  0EDB     MOVLW 0xDB
217A  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
217C  0E01     MOVLW 0x1
217E  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2180  0E01     MOVLW 0x1
2182  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2184  0E00     MOVLW 0x0
2186  6E1B     MOVWF _DtCSf_error, ACCESS
2188  ECA1     CALL 0xDF42, 0
218A  F06F     NOP
635:           	BitSet3(&DtI2C.ST_GLOBAL4,b_MODULUJ,Mf_MODULUJ);
218C  0EDB     MOVLW 0xDB
218E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2190  0E01     MOVLW 0x1
2192  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2194  0E02     MOVLW 0x2
2196  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2198  0E00     MOVLW 0x0
219A  B807     BTFSC Mf_BLOKUJ_3M, 4, ACCESS
219C  0E01     MOVLW 0x1
219E  6E1B     MOVWF _DtCSf_error, ACCESS
21A0  ECA1     CALL 0xDF42, 0
21A2  F06F     NOP
636:           	BitSet3(&DtI2C.ST_GLOBAL4,b_OST_STB,0);
21A4  0EDB     MOVLW 0xDB
21A6  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
21A8  0E01     MOVLW 0x1
21AA  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
21AC  0E03     MOVLW 0x3
21AE  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
21B0  0E00     MOVLW 0x0
21B2  6E1B     MOVWF _DtCSf_error, ACCESS
21B4  ECA1     CALL 0xDF42, 0
21B6  F06F     NOP
637:           	BitSet3(&DtI2C.ST_GLOBAL4,b_OST_PLM,Mf_OST_PL);
21B8  0EDB     MOVLW 0xDB
21BA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
21BC  0E01     MOVLW 0x1
21BE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
21C0  0E04     MOVLW 0x4
21C2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
21C4  0E00     MOVLW 0x0
21C6  BA07     BTFSC Mf_BLOKUJ_3M, 5, ACCESS
21C8  0E01     MOVLW 0x1
21CA  6E1B     MOVWF _DtCSf_error, ACCESS
21CC  ECA1     CALL 0xDF42, 0
21CE  F06F     NOP
638:           	BitSet3(&DtI2C.ST_GLOBAL4,b_VWYBIEG,Mf_VWYBIEG);
21D0  0EDB     MOVLW 0xDB
21D2  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
21D4  0E01     MOVLW 0x1
21D6  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
21D8  0E05     MOVLW 0x5
21DA  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
21DC  0E00     MOVLW 0x0
21DE  B60A     BTFSC Mf_pob_AL, 3, ACCESS
21E0  0E01     MOVLW 0x1
21E2  6E1B     MOVWF _DtCSf_error, ACCESS
21E4  ECA1     CALL 0xDF42, 0
21E6  F06F     NOP
639:           	BitSet3(&DtI2C.ST_GLOBAL4,b_PPOMP,0);
21E8  0EDB     MOVLW 0xDB
21EA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
21EC  0E01     MOVLW 0x1
21EE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
21F0  0E06     MOVLW 0x6
21F2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
21F4  0E00     MOVLW 0x0
21F6  6E1B     MOVWF _DtCSf_error, ACCESS
21F8  ECA1     CALL 0xDF42, 0
21FA  F06F     NOP
640:           	BitSet3(&DtI2C.ST_GLOBAL4,b_ZMKCOCW,Mf_ZMKCOCW);
21FC  0EDB     MOVLW 0xDB
21FE  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2200  0E01     MOVLW 0x1
2202  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2204  0E07     MOVLW 0x7
2206  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2208  0E00     MOVLW 0x0
220A  BA0A     BTFSC Mf_pob_AL, 5, ACCESS
220C  0E01     MOVLW 0x1
220E  6E1B     MOVWF _DtCSf_error, ACCESS
2210  ECA1     CALL 0xDF42, 0
2212  F06F     NOP
641:           	//TPRZ_CW
642:           	DtI2C.TPRZ_CW=0;
2214  0E00     MOVLW 0x0
2216  0101     MOVLB 0x1
2218  6FDC     MOVWF zm, BANKED
643:           	//ST0_WSW
644:           	DtI2C.ST0_WSW=0;
221A  0E00     MOVLW 0x0
221C  0101     MOVLB 0x1
221E  6FDD     MOVWF zmn, BANKED
645:           	BitSet3(&DtI2C.ST0_WSW,b_MSG_A1,!M.ERR_BTY&&Mf_RUSZ_PLOMIEN);
2220  0E00     MOVLW 0x0
2222  6E24     MOVWF _DtCWf_err_CW, ACCESS
2224  0100     MOVLB 0x0
2226  5187     MOVF _PFNf_pgd, W, BANKED
2228  B4D8     BTFSC STATUS, 2, ACCESS
222A  AA09     BTFSS Mf_RUSZ_PWR, 5, ACCESS
222C  D003     BRA 0x2234
222E  0E01     MOVLW 0x1
2230  6E24     MOVWF _DtCWf_err_CW, ACCESS
2232  D000     BRA 0x2234
2234  0EDD     MOVLW 0xDD
2236  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2238  0E01     MOVLW 0x1
223A  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
223C  0E00     MOVLW 0x0
223E  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2240  C024     MOVFF _DtCWf_err_CW, _DtCSf_error
2242  F01B     NOP
2244  ECA1     CALL 0xDF42, 0
2246  F06F     NOP
646:           	BitSet3(&DtI2C.ST0_WSW,b_MSG_A2,!M.ERR_BTY&&Mf_RUSZ_STB);
2248  0E00     MOVLW 0x0
224A  6E25     MOVWF _DtCWf_fpCW, ACCESS
224C  0100     MOVLB 0x0
224E  5187     MOVF _PFNf_pgd, W, BANKED
2250  B4D8     BTFSC STATUS, 2, ACCESS
2252  A20A     BTFSS Mf_pob_AL, 1, ACCESS
2254  D003     BRA 0x225C
2256  0E01     MOVLW 0x1
2258  6E25     MOVWF _DtCWf_fpCW, ACCESS
225A  D000     BRA 0x225C
225C  0EDD     MOVLW 0xDD
225E  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2260  0E01     MOVLW 0x1
2262  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2264  0E01     MOVLW 0x1
2266  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2268  C025     MOVFF _DtCWf_fpCW, _DtCSf_error
226A  F01B     NOP
226C  ECA1     CALL 0xDF42, 0
226E  F06F     NOP
647:           	BitSet3(&DtI2C.ST0_WSW,b_MSG_A3,!M.ERR_BTY&&Mf_RUSZ_CIAG&&Mf_prb_CIG);
2270  0E00     MOVLW 0x0
2272  6E26     MOVWF _DtCWf_newPCW, ACCESS
2274  0100     MOVLB 0x0
2276  5187     MOVF _PFNf_pgd, W, BANKED
2278  B4D8     BTFSC STATUS, 2, ACCESS
227A  AC08     BTFSS Mf_ROZRUCH, 6, ACCESS
227C  D005     BRA 0x2288
227E  AC0B     BTFSS Mf_pob_KCO, 6, ACCESS
2280  D003     BRA 0x2288
2282  0E01     MOVLW 0x1
2284  6E26     MOVWF _DtCWf_newPCW, ACCESS
2286  D000     BRA 0x2288
2288  0EDD     MOVLW 0xDD
228A  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
228C  0E01     MOVLW 0x1
228E  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2290  0E02     MOVLW 0x2
2292  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2294  C026     MOVFF _DtCWf_newPCW, _DtCSf_error
2296  F01B     NOP
2298  ECA1     CALL 0xDF42, 0
229A  F06F     NOP
648:           	if(DtKNF.robg==_OTWARTY) BitSet3(&DtI2C.ST0_WSW,b_MSG_A5,!M.ERR_BTY&&Mf_RUSZ_POMPE&&Mf_prb_PRZ);
229C  0100     MOVLB 0x0
229E  51A6     MOVF _mux, W, BANKED
22A0  E159     BNZ 0x2354
22A2  0E00     MOVLW 0x0
22A4  6E27     MOVWF _DtCWf_on_DZ_CW, ACCESS
22A6  5187     MOVF _PFNf_pgd, W, BANKED
22A8  B4D8     BTFSC STATUS, 2, ACCESS
22AA  AC09     BTFSS Mf_RUSZ_PWR, 6, ACCESS
22AC  D005     BRA 0x22B8
22AE  AE0B     BTFSS Mf_pob_KCO, 7, ACCESS
22B0  D003     BRA 0x22B8
22B2  0E01     MOVLW 0x1
22B4  6E27     MOVWF _DtCWf_on_DZ_CW, ACCESS
22B6  D000     BRA 0x22B8
22B8  0EDD     MOVLW 0xDD
22BA  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
22BC  0E01     MOVLW 0x1
22BE  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
22C0  0E04     MOVLW 0x4
22C2  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
22C4  C027     MOVFF _DtCWf_on_DZ_CW, _DtCSf_error
22C6  F01B     NOP
22C8  ECA1     CALL 0xDF42, 0
22CA  F06F     NOP
649:           
650:           	switch(M.ERR_BTY)
22CC  D043     BRA 0x2354
2354  0100     MOVLB 0x0
2356  5187     MOVF _PFNf_pgd, W, BANKED
2358  0A01     XORLW 0x1
235A  E0B9     BZ 0x22CE
235C  0A03     XORLW 0x3
235E  E0BB     BZ 0x22D6
2360  0A01     XORLW 0x1
2362  E0BD     BZ 0x22DE
2364  0A07     XORLW 0x7
2366  E0BF     BZ 0x22E6
2368  0A01     XORLW 0x1
236A  E0C3     BZ 0x22F2
236C  0A03     XORLW 0x3
236E  E0D3     BZ 0x2316
2370  0A01     XORLW 0x1
2372  E0D5     BZ 0x231E
2374  0A0F     XORLW 0xF
2376  E0D9     BZ 0x232A
2378  0A01     XORLW 0x1
237A  A4D8     BTFSS STATUS, 2, ACCESS
237C  0012     RETURN 0
237E  D7DF     BRA 0x233E
651:           	{
652:           		case 0x01:
653:           			DtI2C.ERR_BTY=1;
22CE  0E01     MOVLW 0x1
22D0  0101     MOVLB 0x1
22D2  6FDE     MOVWF __pcstackBANK0, BANKED
654:           		break;
22D4  0C01     RETLW 0x1
655:           		case 0x02:
656:           			DtI2C.ERR_BTY=2;
22D6  0E02     MOVLW 0x2
22D8  0101     MOVLB 0x1
22DA  6FDE     MOVWF __pcstackBANK0, BANKED
657:           		break;
22DC  0C02     RETLW 0x2
658:           		case 0x03:
659:           			DtI2C.ERR_BTY=3;
22DE  0E03     MOVLW 0x3
22E0  0101     MOVLB 0x1
22E2  6FDE     MOVWF __pcstackBANK0, BANKED
660:           		break;
22E4  0C03     RETLW 0x3
661:           		case 0x04:
662:           			BitSet3(&DtI2C.ST0_WSW,b_MSG_A4,1);
22E6  0EDD     MOVLW 0xDD
22E8  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
22EA  0E01     MOVLW 0x1
22EC  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
22EE  0E03     MOVLW 0x3
22F0  D021     BRA 0x2334
663:           		break;
664:           		case 0x05:
665:           			if(DtKNF.robg==_OTWARTY) DtI2C.ERR_BTY=5;
22F2  0100     MOVLB 0x0
22F4  51A6     MOVF _mux, W, BANKED
22F6  E104     BNZ 0x2300
22F8  0E05     MOVLW 0x5
22FA  0101     MOVLB 0x1
22FC  6FDE     MOVWF __pcstackBANK0, BANKED
22FE  0C05     RETLW 0x5
666:           			else BitSet3(&DtI2C.ST0_WSW,b_MSG_A5,1);
2300  0EDD     MOVLW 0xDD
2302  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2304  0E01     MOVLW 0x1
2306  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2308  0E04     MOVLW 0x4
230A  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
230C  0E01     MOVLW 0x1
230E  6E1B     MOVWF _DtCSf_error, ACCESS
2310  ECA1     CALL 0xDF42, 0
2312  F06F     NOP
667:           		break;
2314  0012     RETURN 0
668:           		case 0x06:
669:           			DtI2C.ERR_BTY=6;
2316  0E06     MOVLW 0x6
2318  0101     MOVLB 0x1
231A  6FDE     MOVWF __pcstackBANK0, BANKED
670:           		break;
231C  0C06     RETLW 0x6
671:           		case 0x07:
672:           			BitSet3(&DtI2C.ST0_WSW,b_MSG_A7,1);
231E  0EDD     MOVLW 0xDD
2320  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2322  0E01     MOVLW 0x1
2324  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2326  0E05     MOVLW 0x5
2328  D005     BRA 0x2334
673:           		break;
674:           		case 0x08:
675:           			BitSet3(&DtI2C.ST0_WSW,b_MSG_A8,1);
232A  0EDD     MOVLW 0xDD
232C  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
232E  0E01     MOVLW 0x1
2330  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2332  0E06     MOVLW 0x6
2334  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
2336  0E01     MOVLW 0x1
2338  6E1B     MOVWF _DtCSf_error, ACCESS
233A  EFA1     GOTO 0xDF42
233C  F06F     NOP
676:           		break;
677:           		case 0x09:
678:           			BitSet3(&DtI2C.ST0_WSW,b_MSG_A9,1);
233E  0EDD     MOVLW 0xDD
2340  6E18     MOVWF _DtCOf_su_DZ_CO, ACCESS
2342  0E01     MOVLW 0x1
2344  6E19     MOVWF _DtCOf_su_SRW_CO, ACCESS
2346  0E07     MOVLW 0x7
2348  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
234A  0E01     MOVLW 0x1
234C  6E1B     MOVWF _DtCSf_error, ACCESS
234E  ECA1     CALL 0xDF42, 0
2350  F06F     NOP
679:           		break;
680:           	}
2352  0012     RETURN 0
681:           }
2380  0012     RETURN 0
682:           //-------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/bit.c  -----------------------------------
1:             /*bit.c*/
2:             /*Procedury zwiazane operacjami na bitach*/
3:             
4:             #include <pic18.h>
5:             #include "global.h"			//parametry globalne
6:             //-------------------------------------------------------------------------------
7:             //-------------------------------------------------------------------------------
8:             //odczyt stanu wybranego bitu dowolnej danej typu char
9:             
10:            bit GetBit(const unsigned char data, const unsigned char nbit)
11:            {
12:                if(data & (1 << nbit)) return 1;
13:                return 0;
14:            }
15:            //do wywolania w petli glownej
16:            
17:            bit GetBit2(const unsigned char data, const unsigned char nbit)
18:            {
19:                if(data & (1 << nbit)) return 1;
20:                return 0;
21:            }
22:            //ustawia/kasuje wybrany bit dowolnej danej typu char (zapalenie/wygaszenie diody)
23:            
24:            void BitSet(unsigned char *data, const unsigned char nbit, const unsigned char bt)
25:            {
26:                if(bt) *data |= 1 << nbit;
27:                else *data &= ~(1 << nbit);
28:            }
29:            void BitSet3(volatile unsigned char *data, const unsigned char nbit, const unsigned char bt)
30:            {
31:                if(bt) *data |= 1 << nbit;
DF42  501B     MOVF _DtCSf_error, W, ACCESS
DF44  E011     BZ 0xDF68
DF46  C01A     MOVFF _DtCOf_zroPCO, _DtCSf_hi
DF48  F01C     NOP
DF4A  0E01     MOVLW 0x1
DF4C  6E1D     MOVWF _DtCSf_lo, ACCESS
DF4E  2A1C     INCF _DtCSf_hi, F, ACCESS
DF50  D002     BRA 0xDF56
DF52  90D8     BCF STATUS, 0, ACCESS
DF54  361D     RLCF _DtCSf_lo, F, ACCESS
DF56  2E1C     DECFSZ _DtCSf_hi, F, ACCESS
DF58  D7FC     BRA 0xDF52
DF5A  C018     MOVFF _DtCOf_su_DZ_CO, FSR2
DF5C  FFD9     NOP
DF5E  C019     MOVFF _DtCOf_su_SRW_CO, FSR2H
DF60  FFDA     NOP
DF62  501D     MOVF _DtCSf_lo, W, ACCESS
DF64  12DF     IORWF INDF2, F, ACCESS
DF66  0012     RETURN 0
32:                else *data &= ~(1 << nbit);
DF68  C01A     MOVFF _DtCOf_zroPCO, _DtCSf_hi
DF6A  F01C     NOP
DF6C  0E01     MOVLW 0x1
DF6E  6E1D     MOVWF _DtCSf_lo, ACCESS
DF70  2A1C     INCF _DtCSf_hi, F, ACCESS
DF72  D002     BRA 0xDF78
DF74  90D8     BCF STATUS, 0, ACCESS
DF76  361D     RLCF _DtCSf_lo, F, ACCESS
DF78  2E1C     DECFSZ _DtCSf_hi, F, ACCESS
DF7A  D7FC     BRA 0xDF74
DF7C  1C1D     COMF _DtCSf_lo, W, ACCESS
DF7E  6E1E     MOVWF _DtCSf_no, ACCESS
DF80  C018     MOVFF _DtCOf_su_DZ_CO, FSR2
DF82  FFD9     NOP
DF84  C019     MOVFF _DtCOf_su_SRW_CO, FSR2H
DF86  FFDA     NOP
DF88  501E     MOVF _DtCSf_no, W, ACCESS
DF8A  16DF     ANDWF INDF2, F, ACCESS
DF8C  0012     RETURN 0
33:            }
DF8E  0012     RETURN 0
34:            //do wywolania w petli glownej
35:            
36:            void BitSet2(unsigned char *data, const unsigned char nbit, const unsigned char bt)
37:            {
38:                if(bt) *data |= 1 << nbit;
39:                else *data &= ~(1 << nbit);
40:            }
41:            //-------------------------------------------------------------------------------
42:            //-------------------------------------------------------------------------------
---  C:/praca/PICC/T02_T03/UNI-02/PLED_T02/T02_v6ppwmLEDv03pro/ac.c  ------------------------------------
1:             /*ac.c*/
2:             //Funkcje obslugi przetwornika AC
3:             // (!) Bazuje na funkcjach z pliku: eeprom.c
4:             //wersja takze dla procesorow serii K
5:             /*---------------------------------------------------------------------------------*/
6:             #include <pic18.h>
7:             #include <htc.h>
8:             #include "global.h"			//parametry globalne
9:             #include "ac.h"				//parametry lokalne
10:            /*---------------------------------------------------------------------------------*/
11:            #if defined(_18F46K20)
12:            
13:            void InitAC(void)
14:            {
15:                ADIE = 0; //disable AC interrupt
ED5C  9C9D     BCF PIE1, 6, ACCESS
16:                //-----------
17:            #if _ENACO!=0	
18:                ACQT0 = 1; //Acquisition time
19:                ACQT1 = 1; //20TAD
20:                ACQT2 = 1;
21:            #else
22:                ACQT0 = 0; //Manual acquisition time
ED5E  96C0     BCF ADCON2, 3, ACCESS
23:                ACQT1 = 0;
ED60  98C0     BCF ADCON2, 4, ACCESS
24:                ACQT2 = 0;
ED62  9AC0     BCF ADCON2, 5, ACCESS
25:            #endif
26:                //-----------
27:                ADCS0 = 0; //fAD = FOSC/32
ED64  90C0     BCF ADCON2, 0, ACCESS
28:                ADCS1 = 1;
ED66  82C0     BSF ADCON2, 1, ACCESS
29:                ADCS2 = 0;
ED68  94C0     BCF ADCON2, 2, ACCESS
30:                //-----------
31:                VCFG0 = 0; //Vref+=VDD
ED6A  98C1     BCF ADCON1, 4, ACCESS
32:                VCFG1 = 0; //Vref-=VSS
ED6C  9AC1     BCF ADCON1, 5, ACCESS
33:                //-----------
34:                //PCFG0=1;	//AN0 do AN4 jako wyjscie analogowe
35:                //PCFG1=1;
36:                //PCFG2=0;
37:                //PCFG3=1;
38:                ANSEL = 0b00001111;
ED6E  0E0F     MOVLW 0xF
ED70  6E7E     MOVWF ANSEL, ACCESS
39:                ANSELH = 0b00000000;
ED72  0E00     MOVLW 0x0
ED74  6A7F     CLRF ANSELH, ACCESS
40:                //-----------
41:                ADFM = 0; //bardziej znaczaca czesc wyniku w ADRESH
ED76  9EC0     BCF ADCON2, 7, ACCESS
42:                ADON = 1; //przylacz modul AC
ED78  80C2     BSF ADCON0, 0, ACCESS
43:                CHS0 = 0; //CHANEL=0
ED7A  94C2     BCF ADCON0, 2, ACCESS
44:                CHS1 = 0;
ED7C  96C2     BCF ADCON0, 3, ACCESS
45:                CHS2 = 0;
ED7E  98C2     BCF ADCON0, 4, ACCESS
46:                CHS3 = 0;
ED80  9AC2     BCF ADCON0, 5, ACCESS
47:            }
ED82  0012     RETURN 0
48:            #else
49:            
50:            void InitAC(void)
51:            {
52:                ADIE = 0; //disable AC interrupt
53:                //-----------
54:            #if _ENACO!=0	
55:                ACQT0 = 1; //Acquisition time
56:                ACQT1 = 1; //20TAD
57:                ACQT2 = 1;
58:            #else
59:                ACQT0 = 0; //Manual acquisition time
60:                ACQT1 = 0;
61:                ACQT2 = 0;
62:            #endif
63:                //-----------
64:                ADCS0 = 0; //fAD = FOSC/32
65:                ADCS1 = 1;
66:                ADCS2 = 0;
67:                //-----------
68:                VCFG0 = 0; //Vref+=VDD
69:                VCFG1 = 0; //Vref-=VSS
70:                //-----------
71:                PCFG0 = 1; //AN0 do AN4 jako wyjscie analogowe
72:                PCFG1 = 1;
73:                PCFG2 = 0;
74:                PCFG3 = 1;
75:                //-----------
76:                ADFM = 0; //bardziej znaczaca czesc wyniku w ADRESH
77:                ADON = 1; //przylacz modul AC
78:                CHS0 = 0; //CHANEL=0
79:                CHS1 = 0;
80:                CHS2 = 0;
81:                CHS3 = 0;
82:            }
83:            #endif
84:            /*---------------------------------------------------------------------------------*/
85:            #if _ENACQ==0
86:            //Opoznienie 50u sek.
87:            
88:            void DelayAD(void) //54u sek.
89:            {
90:                unsigned char i;
91:                for(i = 0; i < _DLAC; i++)
92:                {
93:                    asm("nop");
94:                }
95:            }
96:            #endif
97:            /*---------------------------------------------------------------------------------*/
98:            //Pomiar na wybranym wyjsciu
99:            
100:           unsigned char ReadAC(unsigned char chanel)
D466  0100     MOVLB 0x0
D468  6FDF     MOVWF pco, BANKED
101:           {
102:           #if _ENACQ==0
103:               DelayAD(); //opoznienie 50 u sek.
104:           #endif
105:               CHS0 = (chanel & 0b00000001); //wybor kanalu pomiarowego
D46A  0100     MOVLB 0x0
D46C  B1DF     BTFSC pco, 0, BANKED
D46E  D002     BRA 0xD474
D470  94C2     BCF ADCON0, 2, ACCESS
D472  D001     BRA 0xD476
D474  84C2     BSF ADCON0, 2, ACCESS
106:               CHS1 = ((chanel & 0b00000010) >> 1);
D476  C0DF     MOVFF pco, __pcstackBANK0
D478  F0DE     NOP
D47A  0100     MOVLB 0x0
D47C  90D8     BCF STATUS, 0, ACCESS
D47E  33DE     RRCF __pcstackBANK0, F, BANKED
D480  31DE     RRCF __pcstackBANK0, W, BANKED
D482  B0D8     BTFSC STATUS, 0, ACCESS
D484  D002     BRA 0xD48A
D486  96C2     BCF ADCON0, 3, ACCESS
D488  D001     BRA 0xD48C
D48A  86C2     BSF ADCON0, 3, ACCESS
107:               CHS2 = ((chanel & 0b00000100) >> 2);
D48C  C0DF     MOVFF pco, __pcstackBANK0
D48E  F0DE     NOP
D490  0100     MOVLB 0x0
D492  90D8     BCF STATUS, 0, ACCESS
D494  33DE     RRCF __pcstackBANK0, F, BANKED
D496  90D8     BCF STATUS, 0, ACCESS
D498  33DE     RRCF __pcstackBANK0, F, BANKED
D49A  31DE     RRCF __pcstackBANK0, W, BANKED
D49C  B0D8     BTFSC STATUS, 0, ACCESS
D49E  D002     BRA 0xD4A4
D4A0  98C2     BCF ADCON0, 4, ACCESS
D4A2  D001     BRA 0xD4A6
D4A4  88C2     BSF ADCON0, 4, ACCESS
108:               CHS3 = ((chanel & 0b00001000) >> 3);
D4A6  C0DF     MOVFF pco, __pcstackBANK0
D4A8  F0DE     NOP
D4AA  0100     MOVLB 0x0
D4AC  90D8     BCF STATUS, 0, ACCESS
D4AE  33DE     RRCF __pcstackBANK0, F, BANKED
D4B0  90D8     BCF STATUS, 0, ACCESS
D4B2  33DE     RRCF __pcstackBANK0, F, BANKED
D4B4  90D8     BCF STATUS, 0, ACCESS
D4B6  33DE     RRCF __pcstackBANK0, F, BANKED
D4B8  31DE     RRCF __pcstackBANK0, W, BANKED
D4BA  B0D8     BTFSC STATUS, 0, ACCESS
D4BC  D002     BRA 0xD4C2
D4BE  9AC2     BCF ADCON0, 5, ACCESS
D4C0  D001     BRA 0xD4C4
D4C2  8AC2     BSF ADCON0, 5, ACCESS
109:               GODONE = 1; //start dla pomiaru
D4C4  82C2     BSF ADCON0, 1, ACCESS
110:               while(GODONE)continue;
D4C6  D000     BRA 0xD4C8
D4C8  B2C2     BTFSC ADCON0, 1, ACCESS
D4CA  D7FE     BRA 0xD4C8
111:               return ADRESH; //zwrot wartosci AC
D4CC  50C4     MOVF ADRESH, W, ACCESS
D4CE  0012     RETURN 0
112:           }
D4D0  0012     RETURN 0
113:           /*---------------------------------------------------------------------------------*/
114:           //Przetworzenie wyniku pomiaru na wartosc z tab. NTC czujnika typu termet.
115:           
116:           unsigned char ReadTabNTC(unsigned char zrAC)
D242  0100     MOVLB 0x0
D244  6FE0     MOVWF bdat, BANKED
117:           {
118:               unsigned int i;
119:               unsigned char data;
120:               i = zrAC;
D246  C0E0     MOVFF bdat, divisor
D248  F0E2     NOP
D24A  0100     MOVLB 0x0
D24C  6BE3     CLRF a, BANKED
121:               //obliczenie indeksu tablicy
122:               if(i < _NTC_0) i = _NTC_0;
D24E  0100     MOVLB 0x0
D250  51E3     MOVF a, W, BANKED
D252  E10A     BNZ 0xD268
D254  0E34     MOVLW 0x34
D256  5DE2     SUBWF divisor, W, BANKED
D258  B0D8     BTFSC STATUS, 0, ACCESS
D25A  D006     BRA 0xD268
D25C  0E00     MOVLW 0x0
D25E  0100     MOVLB 0x0
D260  6FE3     MOVWF a, BANKED
D262  0E34     MOVLW 0x34
D264  6FE2     MOVWF divisor, BANKED
D266  D000     BRA 0xD268
123:               if(i > _NTC_99) i = _NTC_99;
D268  0100     MOVLB 0x0
D26A  51E3     MOVF a, W, BANKED
D26C  E103     BNZ 0xD274
D26E  0EEE     MOVLW 0xEE
D270  5DE2     SUBWF divisor, W, BANKED
D272  E305     BNC 0xD27E
D274  0100     MOVLB 0x0
D276  6BE3     CLRF a, BANKED
D278  0EED     MOVLW 0xED
D27A  6FE2     MOVWF divisor, BANKED
D27C  D000     BRA 0xD27E
124:               i -= _NTC_0;
D27E  0E34     MOVLW 0x34
D280  0100     MOVLB 0x0
D282  5FE2     SUBWF divisor, F, BANKED
D284  0E00     MOVLW 0x0
D286  5BE3     SUBWFB a, F, BANKED
125:               if(i > _NDTTCO) i = _NDTTCO;
D288  0100     MOVLB 0x0
D28A  51E3     MOVF a, W, BANKED
D28C  E103     BNZ 0xD294
D28E  0EC1     MOVLW 0xC1
D290  5DE2     SUBWF divisor, W, BANKED
D292  E305     BNC 0xD29E
D294  0100     MOVLB 0x0
D296  6BE3     CLRF a, BANKED
D298  0EC0     MOVLW 0xC0
D29A  6FE2     MOVWF divisor, BANKED
D29C  D000     BRA 0xD29E
126:               i += _AEETCO;
127:               //odczyt danej z tablicy
128:               data = eeprom_read(i);
D29E  C0E2     MOVFF divisor, __pcstackBANK0
D2A0  F0DE     NOP
D2A2  C0E3     MOVFF a, pco
D2A4  F0DF     NOP
D2A6  EC2E     CALL 0xF05C, 0
D2A8  F078     NOP
D2AA  0100     MOVLB 0x0
D2AC  6FE1     MOVWF GIE_BIT_VAL, BANKED
129:               return data;
D2AE  0100     MOVLB 0x0
D2B0  51E1     MOVF GIE_BIT_VAL, W, BANKED
D2B2  0012     RETURN 0
130:           }
D2B4  0012     RETURN 0
131:           /*---------------------------------------------------------------------------------*/
132:           //Zwrot wartosci AC adresujacej podana wartosc z tabeli NTC czujnika typu termet.
133:           
134:           unsigned char ReturnACfromNTC(unsigned char data)
DEF4  0100     MOVLB 0x0
DEF6  6FE0     MOVWF bdat, BANKED
135:           {
136:               unsigned int i;
137:               unsigned char bdta;
138:               for(i = _AEETCO; i < _AEETCO + _NDTTCO; i++)
DEF8  0E00     MOVLW 0x0
DEFA  0100     MOVLB 0x0
DEFC  6FE3     MOVWF a, BANKED
DEFE  6FE2     MOVWF divisor, BANKED
DF00  0100     MOVLB 0x0
DF02  51E3     MOVF a, W, BANKED
DF04  E119     BNZ 0xDF38
DF06  0EC0     MOVLW 0xC0
DF08  5DE2     SUBWF divisor, W, BANKED
DF0A  E216     BC 0xDF38
DF0C  D001     BRA 0xDF10
DF0E  D014     BRA 0xDF38
DF2E  0100     MOVLB 0x0
DF30  4BE2     INFSNZ divisor, F, BANKED
DF32  2BE3     INCF a, F, BANKED
DF34  D7E5     BRA 0xDF00
DF36  D000     BRA 0xDF38
139:               {
140:                   bdta = eeprom_read(i);
DF10  C0E2     MOVFF divisor, __pcstackBANK0
DF12  F0DE     NOP
DF14  C0E3     MOVFF a, pco
DF16  F0DF     NOP
DF18  EC2E     CALL 0xF05C, 0
DF1A  F078     NOP
DF1C  0100     MOVLB 0x0
DF1E  6FE1     MOVWF GIE_BIT_VAL, BANKED
141:                   if(bdta < data) return((i - _AEETCO) + _NTC_0) - 1;
DF20  0100     MOVLB 0x0
DF22  51E0     MOVF bdat, W, BANKED
DF24  5DE1     SUBWF GIE_BIT_VAL, W, BANKED
DF26  E203     BC 0xDF2E
DF28  51E2     MOVF divisor, W, BANKED
DF2A  0F33     ADDLW 0x33
DF2C  0012     RETURN 0
142:               }
143:               return(i - _AEETCO)+_NTC_0;
DF38  0100     MOVLB 0x0
DF3A  51E2     MOVF divisor, W, BANKED
DF3C  0F34     ADDLW 0x34
DF3E  0012     RETURN 0
144:           }
DF40  0012     RETURN 0
145:           /*---------------------------------------------------------------------------------*/
146:           //Przetworzenie wyniku pomiaru na wartosc z tab. NTC czujnika zewnetrznego.
147:           
148:           signed char ReadTabZNTC(unsigned char zrAC)
CD86  0100     MOVLB 0x0
CD88  6FE0     MOVWF bdat, BANKED
149:           {
150:               unsigned int i;
151:               signed char data;
152:               i = zrAC;
CD8A  C0E0     MOVFF bdat, divisor
CD8C  F0E2     NOP
CD8E  0100     MOVLB 0x0
CD90  6BE3     CLRF a, BANKED
153:               //obliczenie indeksu tablicy
154:               if(i < _ZNTC_0) i = _ZNTC_0;
CD92  0100     MOVLB 0x0
CD94  51E3     MOVF a, W, BANKED
CD96  E10A     BNZ 0xCDAC
CD98  0E29     MOVLW 0x29
CD9A  5DE2     SUBWF divisor, W, BANKED
CD9C  B0D8     BTFSC STATUS, 0, ACCESS
CD9E  D006     BRA 0xCDAC
CDA0  0E00     MOVLW 0x0
CDA2  0100     MOVLB 0x0
CDA4  6FE3     MOVWF a, BANKED
CDA6  0E29     MOVLW 0x29
CDA8  6FE2     MOVWF divisor, BANKED
CDAA  D000     BRA 0xCDAC
155:               if(i > _ZNTC_99) i = _ZNTC_99;
CDAC  0100     MOVLB 0x0
CDAE  51E3     MOVF a, W, BANKED
CDB0  E103     BNZ 0xCDB8
CDB2  0EED     MOVLW 0xED
CDB4  5DE2     SUBWF divisor, W, BANKED
CDB6  E305     BNC 0xCDC2
CDB8  0100     MOVLB 0x0
CDBA  6BE3     CLRF a, BANKED
CDBC  0EEC     MOVLW 0xEC
CDBE  6FE2     MOVWF divisor, BANKED
CDC0  D000     BRA 0xCDC2
156:               i -= _ZNTC_0;
CDC2  0E29     MOVLW 0x29
CDC4  0100     MOVLB 0x0
CDC6  5FE2     SUBWF divisor, F, BANKED
CDC8  0E00     MOVLW 0x0
CDCA  5BE3     SUBWFB a, F, BANKED
157:               if(i > _NDTTZW) i = _NDTTZW;
CDCC  0100     MOVLB 0x0
CDCE  51E3     MOVF a, W, BANKED
CDD0  E103     BNZ 0xCDD8
CDD2  0EC9     MOVLW 0xC9
CDD4  5DE2     SUBWF divisor, W, BANKED
CDD6  E305     BNC 0xCDE2
CDD8  0100     MOVLB 0x0
CDDA  6BE3     CLRF a, BANKED
CDDC  0EC8     MOVLW 0xC8
CDDE  6FE2     MOVWF divisor, BANKED
CDE0  D000     BRA 0xCDE2
158:               i += _AEETZW;
CDE2  0EE0     MOVLW 0xE0
CDE4  0100     MOVLB 0x0
CDE6  27E2     ADDWF divisor, F, BANKED
CDE8  0E00     MOVLW 0x0
CDEA  23E3     ADDWFC a, F, BANKED
159:               //odczyt danej z tablicy
160:               data = eeprom_read(i);
CDEC  C0E2     MOVFF divisor, __pcstackBANK0
CDEE  F0DE     NOP
CDF0  C0E3     MOVFF a, pco
CDF2  F0DF     NOP
CDF4  EC2E     CALL 0xF05C, 0
CDF6  F078     NOP
CDF8  0100     MOVLB 0x0
CDFA  6FE1     MOVWF GIE_BIT_VAL, BANKED
161:               return data;
CDFC  0100     MOVLB 0x0
CDFE  51E1     MOVF GIE_BIT_VAL, W, BANKED
CE00  0012     RETURN 0
162:           }
CE02  0012     RETURN 0
163:           /*---------------------------------------------------------------------------------*/
---  C:/Program Files/Microchip/xc8/v1.34/sources/pic18/plib/EEP/write_B.c  -----------------------------
1:             #include <p18cxxx.h>
2:             #include <EEP.h>
3:             
4:             /********************************************************************
5:             *     Function Name:    Write_b_eep                                 *
6:             *     Return Value:     None										*
7:             *     Parameters:       unsigned int add, unsigned char data        *
8:             *     Description:      Write single byte to Internal EEP           *
9:             ********************************************************************/
10:            #if defined (EEP_V1)		//	128 byte EEP
11:            void Write_b_eep( unsigned int badd,unsigned char bdat )
12:            {
13:            	char GIE_BIT_VAL = 0;
14:            	EEADR = (badd & 0x07f);
15:            	EEDATA = bdat;
16:              	EECON1bits.EEPGD = 0;
17:            	EECON1bits.CFGS = 0;
18:            	EECON1bits.WREN = 1;
19:            	GIE_BIT_VAL = INTCONbits.GIE;
20:            	INTCONbits.GIE = 0;
21:            	EECON2 = 0x55;
22:            	EECON2 = 0xAA;
23:            	EECON1bits.WR = 1;
24:            	while(EECON1bits.WR);				//Wait till the write completion
25:            	INTCONbits.GIE = GIE_BIT_VAL;
26:            	EECON1bits.WREN = 0;
27:            }
28:            
29:            #elif defined (EEP_V2)	//	256 byte EEP
30:            void Write_b_eep( unsigned int badd,unsigned char bdat )
31:            {
32:            	char GIE_BIT_VAL = 0;
33:            	EEADR = (badd & 0x0ff);
34:              	EEDATA = bdat;
35:              	EECON1bits.EEPGD = 0;
36:            	EECON1bits.CFGS = 0;
37:            	EECON1bits.WREN = 1;
38:            	GIE_BIT_VAL = INTCONbits.GIE;
39:            	INTCONbits.GIE = 0;
40:            	EECON2 = 0x55;
41:            	EECON2 = 0xAA;
42:            	EECON1bits.WR = 1;
43:            	while(EECON1bits.WR);				//Wait till the write completion
44:            	INTCONbits.GIE = GIE_BIT_VAL;
45:            	EECON1bits.WREN = 0;
46:            }
47:            
48:            #elif defined (EEP_V3)				// 1024 byte EEP	
49:            void Write_b_eep( unsigned int badd,unsigned char bdat )
50:            {
51:            	char GIE_BIT_VAL = 0;
E2B0  0100     MOVLB 0x0
E2B2  6BE1     CLRF GIE_BIT_VAL, BANKED
52:            	EEADRH = (badd >> 8) & 0x03;
E2B4  0100     MOVLB 0x0
E2B6  51DF     MOVF pco, W, BANKED
E2B8  0B03     ANDLW 0x3
E2BA  6EAA     MOVWF EEADRH, ACCESS
53:            	EEADR = (badd & 0x0ff);
E2BC  C0DE     MOVFF __pcstackBANK0, EEADR
E2BE  FFA9     NOP
54:            	EEDATA = bdat;
E2C0  C0E0     MOVFF bdat, EEDATA
E2C2  FFA8     NOP
55:              	EECON1bits.EEPGD = 0;
E2C4  9EA6     BCF EECON1, 7, ACCESS
56:            	EECON1bits.CFGS = 0;
E2C6  9CA6     BCF EECON1, 6, ACCESS
57:            	EECON1bits.WREN = 1;
E2C8  84A6     BSF EECON1, 2, ACCESS
58:            	GIE_BIT_VAL = INTCONbits.GIE;
E2CA  0E00     MOVLW 0x0
E2CC  BEF2     BTFSC INTCON, 7, ACCESS
E2CE  0E01     MOVLW 0x1
E2D0  0100     MOVLB 0x0
E2D2  6FE1     MOVWF GIE_BIT_VAL, BANKED
59:            	INTCONbits.GIE = 0;
E2D4  9EF2     BCF INTCON, 7, ACCESS
60:            	EECON2 = 0x55;
E2D6  0E55     MOVLW 0x55
E2D8  6EA7     MOVWF EECON2, ACCESS
61:            	EECON2 = 0xAA;
E2DA  0EAA     MOVLW 0xAA
E2DC  6EA7     MOVWF EECON2, ACCESS
62:            	EECON1bits.WR = 1;
E2DE  82A6     BSF EECON1, 1, ACCESS
63:            	while(EECON1bits.WR);				//Wait till the write completion
E2E0  D000     BRA 0xE2E2
E2E2  B2A6     BTFSC EECON1, 1, ACCESS
E2E4  D7FE     BRA 0xE2E2
64:            	INTCONbits.GIE = GIE_BIT_VAL;
E2E6  0100     MOVLB 0x0
E2E8  B1E1     BTFSC GIE_BIT_VAL, 0, BANKED
E2EA  D002     BRA 0xE2F0
E2EC  9EF2     BCF INTCON, 7, ACCESS
E2EE  D001     BRA 0xE2F2
E2F0  8EF2     BSF INTCON, 7, ACCESS
65:            	EECON1bits.WREN = 0;
E2F2  94A6     BCF EECON1, 2, ACCESS
66:            }
E2F4  0012     RETURN 0
67:            #endif
---  C:/Program Files/Microchip/xc8/v1.34/sources/pic18/plib/EEP/read_B.c  ------------------------------
1:             #include <p18cxxx.h>
2:             #include <EEP.h>
3:             
4:             /********************************************************************
5:             *     Function Name:    Read_b_eep                                 *
6:             *     Return Value:     contents of EEDATA register                *
7:             *     Parameters:       unsigned int add                           *
8:             *     Description:      Read single byte from Internal EEP         *
9:             ********************************************************************/
10:            #if defined (EEP_V1)		//	128 byte EEP
11:            unsigned char Read_b_eep( unsigned int badd )
12:            {
13:            	EEADR = (badd & 0x07f);
14:            	EECON1bits.CFGS = 0;
15:            	EECON1bits.EEPGD = 0;
16:            	EECON1bits.RD = 1;
17:            	Nop();							//Nop may be required for latency at high frequencies
18:            	Nop();							//Nop may be required for latency at high frequencies
19:            	return ( EEDATA );              // return with read byte 
20:            }
21:            
22:            #elif defined (EEP_V2)	//	256 byte EEP
23:            unsigned char Read_b_eep( unsigned int badd )
24:            {
25:            	EEADR = (badd & 0x0ff);
26:              	EECON1bits.CFGS = 0;
27:            	EECON1bits.EEPGD = 0;
28:            	EECON1bits.RD = 1;
29:            	Nop();							//Nop may be required for latency at high frequencies
30:            	Nop();							//Nop may be required for latency at high frequencies
31:            	return ( EEDATA );              // return with read byte
32:            }
33:            
34:            #elif defined (EEP_V3)				// 1024 byte EEP	
35:            unsigned char Read_b_eep( unsigned int badd )
36:            {
37:            	EEADRH = (badd >> 8) & 0x03;
F05C  0100     MOVLB 0x0
F05E  51DF     MOVF pco, W, BANKED
F060  0B03     ANDLW 0x3
F062  6EAA     MOVWF EEADRH, ACCESS
38:            	EEADR = (badd & 0x0ff);
F064  C0DE     MOVFF __pcstackBANK0, EEADR
F066  FFA9     NOP
39:              	EECON1bits.CFGS = 0;
F068  9CA6     BCF EECON1, 6, ACCESS
40:            	EECON1bits.EEPGD = 0;
F06A  9EA6     BCF EECON1, 7, ACCESS
41:            	EECON1bits.RD = 1;
F06C  80A6     BSF EECON1, 0, ACCESS
42:            	Nop();							//Nop may be required for latency at high frequencies
F06E  F000     NOP
43:            	Nop();							//Nop may be required for latency at high frequencies
F070  F000     NOP
44:            	return ( EEDATA );              // return with read byte 
F072  50A8     MOVF EEDATA, W, ACCESS
F074  0012     RETURN 0
45:            }
F076  0012     RETURN 0
46:            #endif
---  C:/Program Files/Microchip/xc8/v1.34/sources/pic18/plib/EEP/busy_eep.c  ----------------------------
1:             #include <p18cxxx.h>
2:             #include <EEP.h>
3:             
4:             /********************************************************************
5:             *     Function Name:    Busy_eep                                    *
6:             *     Return Value:     None										*
7:             *     Parameters:       None										*
8:             *     Description:      Checks & waits the status of ER bit in 		*
9:             						EECON1 register     						*
10:            ********************************************************************/
11:            #if defined (EEP_V1) || defined (EEP_V2) || defined (EEP_V3)				
12:            void Busy_eep ( void )
13:            {
14:            	while(EECON1bits.WR);
F3FC  D000     BRA 0xF3FE
F3FE  B2A6     BTFSC EECON1, 1, ACCESS
F400  D7FE     BRA 0xF3FE
15:            }
F402  0012     RETURN 0
16:            #endif
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/lwmod.c  ---------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
DD10  0100     MOVLB 0x0
DD12  51E0     MOVF bdat, W, BANKED
DD14  11E1     IORWF GIE_BIT_VAL, W, BANKED
DD16  E021     BZ 0xDD5A
14:            		counter = 1;
DD18  0E01     MOVLW 0x1
DD1A  6FE2     MOVWF divisor, BANKED
15:            		while((divisor & 0x8000) == 0) {
DD1C  D006     BRA 0xDD2A
DD2A  0100     MOVLB 0x0
DD2C  BFE1     BTFSC GIE_BIT_VAL, 7, BANKED
DD2E  D002     BRA 0xDD34
DD30  D7F6     BRA 0xDD1E
DD32  D000     BRA 0xDD34
16:            			divisor <<= 1;
DD1E  0100     MOVLB 0x0
DD20  90D8     BCF STATUS, 0, ACCESS
DD22  37E0     RLCF bdat, F, BANKED
DD24  37E1     RLCF GIE_BIT_VAL, F, BANKED
17:            			counter++;
DD26  2BE2     INCF divisor, F, BANKED
DD28  D000     BRA 0xDD2A
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
DD34  0100     MOVLB 0x0
DD36  51E0     MOVF bdat, W, BANKED
DD38  5DDE     SUBWF __pcstackBANK0, W, BANKED
DD3A  51E1     MOVF GIE_BIT_VAL, W, BANKED
DD3C  59DF     SUBWFB pco, W, BANKED
DD3E  E305     BNC 0xDD4A
21:            				dividend -= divisor;
DD40  51E0     MOVF bdat, W, BANKED
DD42  5FDE     SUBWF __pcstackBANK0, F, BANKED
DD44  51E1     MOVF GIE_BIT_VAL, W, BANKED
DD46  5BDF     SUBWFB pco, F, BANKED
DD48  D000     BRA 0xDD4A
22:            			divisor >>= 1;
DD4A  0100     MOVLB 0x0
DD4C  90D8     BCF STATUS, 0, ACCESS
DD4E  33E1     RRCF GIE_BIT_VAL, F, BANKED
DD50  33E0     RRCF bdat, F, BANKED
23:            		} while(--counter != 0);
DD52  0100     MOVLB 0x0
DD54  2FE2     DECFSZ divisor, F, BANKED
DD56  D7EE     BRA 0xDD34
DD58  D000     BRA 0xDD5A
24:            	}
25:            	return dividend;
DD5A  C0DE     MOVFF __pcstackBANK0, __pcstackBANK0
DD5C  F0DE     NOP
DD5E  C0DF     MOVFF pco, pco
DD60  F0DF     NOP
26:            }
DD62  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/lwdiv.c  ---------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
D816  0100     MOVLB 0x0
D818  6BEA     CLRF tim, BANKED
D81A  6BE9     CLRF p, BANKED
15:            	if(divisor != 0) {
D81C  0100     MOVLB 0x0
D81E  51E6     MOVF counter, W, BANKED
D820  11E7     IORWF sign, W, BANKED
D822  E027     BZ 0xD872
16:            		counter = 1;
D824  0E01     MOVLW 0x1
D826  6FE8     MOVWF quotient, BANKED
17:            		while((divisor & 0x8000) == 0) {
D828  D006     BRA 0xD836
D836  0100     MOVLB 0x0
D838  BFE7     BTFSC sign, 7, BANKED
D83A  D002     BRA 0xD840
D83C  D7F6     BRA 0xD82A
D83E  D000     BRA 0xD840
18:            			divisor <<= 1;
D82A  0100     MOVLB 0x0
D82C  90D8     BCF STATUS, 0, ACCESS
D82E  37E6     RLCF counter, F, BANKED
D830  37E7     RLCF sign, F, BANKED
19:            			counter++;
D832  2BE8     INCF quotient, F, BANKED
D834  D000     BRA 0xD836
20:            		}
21:            		do {
22:            			quotient <<= 1;
D840  0100     MOVLB 0x0
D842  90D8     BCF STATUS, 0, ACCESS
D844  37E9     RLCF p, F, BANKED
D846  37EA     RLCF tim, F, BANKED
23:            			if(divisor <= dividend) {
D848  0100     MOVLB 0x0
D84A  51E6     MOVF counter, W, BANKED
D84C  5DE4     SUBWF k, W, BANKED
D84E  51E7     MOVF sign, W, BANKED
D850  59E5     SUBWFB k, W, BANKED
D852  E307     BNC 0xD862
24:            				dividend -= divisor;
D854  51E6     MOVF counter, W, BANKED
D856  5FE4     SUBWF k, F, BANKED
D858  51E7     MOVF sign, W, BANKED
D85A  5BE5     SUBWFB k, F, BANKED
25:            				quotient |= 1;
D85C  0100     MOVLB 0x0
D85E  81E9     BSF p, 0, BANKED
D860  D000     BRA 0xD862
26:            			}
27:            			divisor >>= 1;
D862  0100     MOVLB 0x0
D864  90D8     BCF STATUS, 0, ACCESS
D866  33E7     RRCF sign, F, BANKED
D868  33E6     RRCF counter, F, BANKED
28:            		} while(--counter != 0);
D86A  0100     MOVLB 0x0
D86C  2FE8     DECFSZ quotient, F, BANKED
D86E  D7E8     BRA 0xD840
D870  D000     BRA 0xD872
29:            	}
30:            	return quotient;
D872  C0E9     MOVFF p, k
D874  F0E4     NOP
D876  C0EA     MOVFF tim, k
D878  F0E5     NOP
31:            }
D87A  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/awmod.c  ---------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
CF72  6A1B     CLRF _DtCSf_error, ACCESS
14:            	if(dividend < 0) {
CF74  AE17     BTFSS _DtCOf_su_CO, 7, ACCESS
CF76  D007     BRA 0xCF86
15:            		dividend = -dividend;
CF78  6C16     NEGF _DtCOf_resPCO, ACCESS
CF7A  1E17     COMF _DtCOf_su_CO, F, ACCESS
CF7C  B0D8     BTFSC STATUS, 0, ACCESS
CF7E  2A17     INCF _DtCOf_su_CO, F, ACCESS
16:            		sign = 1;
CF80  0E01     MOVLW 0x1
CF82  6E1B     MOVWF _DtCSf_error, ACCESS
CF84  D000     BRA 0xCF86
17:            	}
18:            	if(divisor < 0)
CF86  AE19     BTFSS _DtCOf_su_SRW_CO, 7, ACCESS
CF88  D005     BRA 0xCF94
19:            		divisor = -divisor;
CF8A  6C18     NEGF _DtCOf_su_DZ_CO, ACCESS
CF8C  1E19     COMF _DtCOf_su_SRW_CO, F, ACCESS
CF8E  B0D8     BTFSC STATUS, 0, ACCESS
CF90  2A19     INCF _DtCOf_su_SRW_CO, F, ACCESS
CF92  D000     BRA 0xCF94
20:            	if(divisor != 0) {
CF94  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CF96  1019     IORWF _DtCOf_su_SRW_CO, W, ACCESS
CF98  E01C     BZ 0xCFD2
21:            		counter = 1;
CF9A  0E01     MOVLW 0x1
CF9C  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
CF9E  D005     BRA 0xCFAA
CFAA  BE19     BTFSC _DtCOf_su_SRW_CO, 7, ACCESS
CFAC  D002     BRA 0xCFB2
CFAE  D7F8     BRA 0xCFA0
CFB0  D000     BRA 0xCFB2
23:            			divisor <<= 1;
CFA0  90D8     BCF STATUS, 0, ACCESS
CFA2  3618     RLCF _DtCOf_su_DZ_CO, F, ACCESS
CFA4  3619     RLCF _DtCOf_su_SRW_CO, F, ACCESS
24:            			counter++;
CFA6  2A1A     INCF _DtCOf_zroPCO, F, ACCESS
CFA8  D000     BRA 0xCFAA
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
CFB2  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CFB4  5C16     SUBWF _DtCOf_resPCO, W, ACCESS
CFB6  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
CFB8  5817     SUBWFB _DtCOf_su_CO, W, ACCESS
CFBA  E305     BNC 0xCFC6
28:            				dividend -= divisor;
CFBC  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CFBE  5E16     SUBWF _DtCOf_resPCO, F, ACCESS
CFC0  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
CFC2  5A17     SUBWFB _DtCOf_su_CO, F, ACCESS
CFC4  D000     BRA 0xCFC6
29:            			*(unsigned int *)&divisor >>= 1;
CFC6  90D8     BCF STATUS, 0, ACCESS
CFC8  3219     RRCF _DtCOf_su_SRW_CO, F, ACCESS
CFCA  3218     RRCF _DtCOf_su_DZ_CO, F, ACCESS
30:            		} while(--counter != 0);
CFCC  2E1A     DECFSZ _DtCOf_zroPCO, F, ACCESS
CFCE  D7F1     BRA 0xCFB2
CFD0  D000     BRA 0xCFD2
31:            	}
32:            	if(sign)
CFD2  501B     MOVF _DtCSf_error, W, ACCESS
CFD4  E005     BZ 0xCFE0
33:            		dividend = -dividend;
CFD6  6C16     NEGF _DtCOf_resPCO, ACCESS
CFD8  1E17     COMF _DtCOf_su_CO, F, ACCESS
CFDA  B0D8     BTFSC STATUS, 0, ACCESS
CFDC  2A17     INCF _DtCOf_su_CO, F, ACCESS
CFDE  D000     BRA 0xCFE0
34:            	return dividend;
CFE0  C016     MOVFF _DtCOf_resPCO, _DtCOf_resPCO
CFE2  F016     NOP
CFE4  C017     MOVFF _DtCOf_su_CO, _DtCOf_su_CO
CFE6  F017     NOP
CFE8  0012     RETURN 0
35:            }
CFEA  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/awdiv.c  ---------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
C212  0100     MOVLB 0x0
C214  6BE9     CLRF p, BANKED
C9E4  6A1B     CLRF _DtCSf_error, ACCESS
15:            	if(divisor < 0) {
C216  0100     MOVLB 0x0
C218  AFE7     BTFSS sign, 7, BANKED
C21A  D008     BRA 0xC22C
C9E6  AE19     BTFSS _DtCOf_su_SRW_CO, 7, ACCESS
C9E8  D007     BRA 0xC9F8
16:            		divisor = -divisor;
C21C  6DE6     NEGF counter, BANKED
C21E  1FE7     COMF sign, F, BANKED
C220  B0D8     BTFSC STATUS, 0, ACCESS
C222  2BE7     INCF sign, F, BANKED
C9EA  6C18     NEGF _DtCOf_su_DZ_CO, ACCESS
C9EC  1E19     COMF _DtCOf_su_SRW_CO, F, ACCESS
C9EE  B0D8     BTFSC STATUS, 0, ACCESS
C9F0  2A19     INCF _DtCOf_su_SRW_CO, F, ACCESS
17:            		sign = 1;
C224  0E01     MOVLW 0x1
C226  0100     MOVLB 0x0
C228  6FE9     MOVWF p, BANKED
C22A  D000     BRA 0xC22C
C9F2  0E01     MOVLW 0x1
C9F4  6E1B     MOVWF _DtCSf_error, ACCESS
C9F6  D000     BRA 0xC9F8
18:            	}
19:            	if(dividend < 0) {
C22C  0100     MOVLB 0x0
C22E  AFE5     BTFSS k, 7, BANKED
C230  D008     BRA 0xC242
C9F8  AE17     BTFSS _DtCOf_su_CO, 7, ACCESS
C9FA  D007     BRA 0xCA0A
20:            		dividend = -dividend;
C232  6DE4     NEGF k, BANKED
C234  1FE5     COMF k, F, BANKED
C236  B0D8     BTFSC STATUS, 0, ACCESS
C238  2BE5     INCF k, F, BANKED
C9FC  6C16     NEGF _DtCOf_resPCO, ACCESS
C9FE  1E17     COMF _DtCOf_su_CO, F, ACCESS
CA00  B0D8     BTFSC STATUS, 0, ACCESS
CA02  2A17     INCF _DtCOf_su_CO, F, ACCESS
21:            		sign ^= 1;
C23A  0E01     MOVLW 0x1
C23C  0100     MOVLB 0x0
C23E  1BE9     XORWF p, F, BANKED
C240  D000     BRA 0xC242
CA04  0E01     MOVLW 0x1
CA06  1A1B     XORWF _DtCSf_error, F, ACCESS
CA08  D000     BRA 0xCA0A
22:            	}
23:            	quotient = 0;
C242  0100     MOVLB 0x0
C244  6BEB     CLRF pop, BANKED
C246  6BEA     CLRF tim, BANKED
CA0A  6A1D     CLRF _DtCSf_lo, ACCESS
CA0C  6A1C     CLRF _DtCSf_hi, ACCESS
24:            	if(divisor != 0) {
C248  0100     MOVLB 0x0
C24A  51E6     MOVF counter, W, BANKED
C24C  11E7     IORWF sign, W, BANKED
C24E  E027     BZ 0xC29E
CA0E  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CA10  1019     IORWF _DtCOf_su_SRW_CO, W, ACCESS
CA12  E020     BZ 0xCA54
25:            		counter = 1;
C250  0E01     MOVLW 0x1
C252  6FE8     MOVWF quotient, BANKED
CA14  0E01     MOVLW 0x1
CA16  6E1A     MOVWF _DtCOf_zroPCO, ACCESS
26:            		while((divisor & 0x8000U) == 0) {
C254  D006     BRA 0xC262
C262  0100     MOVLB 0x0
C264  BFE7     BTFSC sign, 7, BANKED
C266  D002     BRA 0xC26C
C268  D7F6     BRA 0xC256
C26A  D000     BRA 0xC26C
CA18  D005     BRA 0xCA24
CA24  BE19     BTFSC _DtCOf_su_SRW_CO, 7, ACCESS
CA26  D002     BRA 0xCA2C
CA28  D7F8     BRA 0xCA1A
CA2A  D000     BRA 0xCA2C
27:            			divisor <<= 1;
C256  0100     MOVLB 0x0
C258  90D8     BCF STATUS, 0, ACCESS
C25A  37E6     RLCF counter, F, BANKED
C25C  37E7     RLCF sign, F, BANKED
CA1A  90D8     BCF STATUS, 0, ACCESS
CA1C  3618     RLCF _DtCOf_su_DZ_CO, F, ACCESS
CA1E  3619     RLCF _DtCOf_su_SRW_CO, F, ACCESS
28:            			counter++;
C25E  2BE8     INCF quotient, F, BANKED
C260  D000     BRA 0xC262
CA20  2A1A     INCF _DtCOf_zroPCO, F, ACCESS
CA22  D000     BRA 0xCA24
29:            		}
30:            		do {
31:            			quotient <<= 1;
C26C  0100     MOVLB 0x0
C26E  90D8     BCF STATUS, 0, ACCESS
C270  37EA     RLCF tim, F, BANKED
C272  37EB     RLCF pop, F, BANKED
CA2C  90D8     BCF STATUS, 0, ACCESS
CA2E  361C     RLCF _DtCSf_hi, F, ACCESS
CA30  361D     RLCF _DtCSf_lo, F, ACCESS
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
C274  0100     MOVLB 0x0
C276  51E6     MOVF counter, W, BANKED
C278  5DE4     SUBWF k, W, BANKED
C27A  51E7     MOVF sign, W, BANKED
C27C  59E5     SUBWFB k, W, BANKED
C27E  E307     BNC 0xC28E
CA32  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CA34  5C16     SUBWF _DtCOf_resPCO, W, ACCESS
CA36  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
CA38  5817     SUBWFB _DtCOf_su_CO, W, ACCESS
CA3A  E306     BNC 0xCA48
33:            				dividend -= divisor;
C280  51E6     MOVF counter, W, BANKED
C282  5FE4     SUBWF k, F, BANKED
C284  51E7     MOVF sign, W, BANKED
C286  5BE5     SUBWFB k, F, BANKED
CA3C  5018     MOVF _DtCOf_su_DZ_CO, W, ACCESS
CA3E  5E16     SUBWF _DtCOf_resPCO, F, ACCESS
CA40  5019     MOVF _DtCOf_su_SRW_CO, W, ACCESS
CA42  5A17     SUBWFB _DtCOf_su_CO, F, ACCESS
34:            				quotient |= 1;
C288  0100     MOVLB 0x0
C28A  81EA     BSF tim, 0, BANKED
C28C  D000     BRA 0xC28E
CA44  801C     BSF _DtCSf_hi, 0, ACCESS
CA46  D000     BRA 0xCA48
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
C28E  0100     MOVLB 0x0
C290  90D8     BCF STATUS, 0, ACCESS
C292  33E7     RRCF sign, F, BANKED
C294  33E6     RRCF counter, F, BANKED
CA48  90D8     BCF STATUS, 0, ACCESS
CA4A  3219     RRCF _DtCOf_su_SRW_CO, F, ACCESS
CA4C  3218     RRCF _DtCOf_su_DZ_CO, F, ACCESS
37:            		} while(--counter != 0);
C296  0100     MOVLB 0x0
C298  2FE8     DECFSZ quotient, F, BANKED
C29A  D7E8     BRA 0xC26C
C29C  D000     BRA 0xC29E
CA4E  2E1A     DECFSZ _DtCOf_zroPCO, F, ACCESS
CA50  D7ED     BRA 0xCA2C
CA52  D000     BRA 0xCA54
38:            	}
39:            	if(sign)
C29E  0100     MOVLB 0x0
C2A0  51E9     MOVF p, W, BANKED
C2A2  E005     BZ 0xC2AE
CA54  501B     MOVF _DtCSf_error, W, ACCESS
CA56  E005     BZ 0xCA62
40:            		quotient = -quotient;
C2A4  6DEA     NEGF tim, BANKED
C2A6  1FEB     COMF pop, F, BANKED
C2A8  B0D8     BTFSC STATUS, 0, ACCESS
C2AA  2BEB     INCF pop, F, BANKED
C2AC  D000     BRA 0xC2AE
CA58  6C1C     NEGF _DtCSf_hi, ACCESS
CA5A  1E1D     COMF _DtCSf_lo, F, ACCESS
CA5C  B0D8     BTFSC STATUS, 0, ACCESS
CA5E  2A1D     INCF _DtCSf_lo, F, ACCESS
CA60  D000     BRA 0xCA62
41:            	return quotient;
C2AE  C0EA     MOVFF tim, k
C2B0  F0E4     NOP
C2B2  C0EB     MOVFF pop, k
C2B4  F0E5     NOP
C2B6  0012     RETURN 0
CA62  C01C     MOVFF _DtCSf_hi, _DtCOf_resPCO
CA64  F016     NOP
CA66  C01D     MOVFF _DtCSf_lo, _DtCOf_su_CO
CA68  F017     NOP
CA6A  0012     RETURN 0
42:            }
C2B8  0012     RETURN 0
CA6C  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/aldiv.c  ---------------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __aldiv(signed long int divisor, signed long int dividend)
7:             #else
8:             __aldiv(signed long int dividend, signed long int divisor)
9:             #endif
10:            {
11:            	signed long int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
B3E6  0100     MOVLB 0x0
B3E8  6BE7     CLRF sign, BANKED
15:            	if(divisor < 0) {
B3EA  0100     MOVLB 0x0
B3EC  AFE5     BTFSS k, 7, BANKED
B3EE  D00C     BRA 0xB408
16:            		divisor = -divisor;
B3F0  1FE5     COMF k, F, BANKED
B3F2  1FE4     COMF k, F, BANKED
B3F4  1FE3     COMF a, F, BANKED
B3F6  6DE2     NEGF divisor, BANKED
B3F8  0E00     MOVLW 0x0
B3FA  23E3     ADDWFC a, F, BANKED
B3FC  23E4     ADDWFC k, F, BANKED
B3FE  23E5     ADDWFC k, F, BANKED
17:            		sign = 1;
B400  0E01     MOVLW 0x1
B402  0100     MOVLB 0x0
B404  6FE7     MOVWF sign, BANKED
B406  D000     BRA 0xB408
18:            	}
19:            	if(dividend < 0) {
B408  0100     MOVLB 0x0
B40A  AFE1     BTFSS GIE_BIT_VAL, 7, BANKED
B40C  D00C     BRA 0xB426
20:            		dividend = -dividend;
B40E  1FE1     COMF GIE_BIT_VAL, F, BANKED
B410  1FE0     COMF bdat, F, BANKED
B412  1FDF     COMF pco, F, BANKED
B414  6DDE     NEGF __pcstackBANK0, BANKED
B416  0E00     MOVLW 0x0
B418  23DF     ADDWFC pco, F, BANKED
B41A  23E0     ADDWFC bdat, F, BANKED
B41C  23E1     ADDWFC GIE_BIT_VAL, F, BANKED
21:            		sign ^= 1;
B41E  0E01     MOVLW 0x1
B420  0100     MOVLB 0x0
B422  1BE7     XORWF sign, F, BANKED
B424  D000     BRA 0xB426
22:            	}
23:            	quotient = 0;
B426  0100     MOVLB 0x0
B428  6BE8     CLRF quotient, BANKED
B42A  6BE9     CLRF p, BANKED
B42C  6BEA     CLRF tim, BANKED
B42E  6BEB     CLRF pop, BANKED
24:            	if(divisor != 0) {
B430  0100     MOVLB 0x0
B432  51E2     MOVF divisor, W, BANKED
B434  11E3     IORWF a, W, BANKED
B436  11E4     IORWF k, W, BANKED
B438  11E5     IORWF k, W, BANKED
B43A  E035     BZ 0xB4A6
25:            		counter = 1;
B43C  0E01     MOVLW 0x1
B43E  6FE6     MOVWF counter, BANKED
26:            		while((divisor & 0x80000000UL) == 0) {
B440  D008     BRA 0xB452
B452  0100     MOVLB 0x0
B454  BFE5     BTFSC k, 7, BANKED
B456  D002     BRA 0xB45C
B458  D7F4     BRA 0xB442
B45A  D000     BRA 0xB45C
27:            			divisor <<= 1;
B442  0100     MOVLB 0x0
B444  90D8     BCF STATUS, 0, ACCESS
B446  37E2     RLCF divisor, F, BANKED
B448  37E3     RLCF a, F, BANKED
B44A  37E4     RLCF k, F, BANKED
B44C  37E5     RLCF k, F, BANKED
28:            			counter++;
B44E  2BE6     INCF counter, F, BANKED
B450  D000     BRA 0xB452
29:            		}
30:            		do {
31:            			quotient <<= 1;
B45C  0100     MOVLB 0x0
B45E  90D8     BCF STATUS, 0, ACCESS
B460  37E8     RLCF quotient, F, BANKED
B462  37E9     RLCF p, F, BANKED
B464  37EA     RLCF tim, F, BANKED
B466  37EB     RLCF pop, F, BANKED
32:            			if((unsigned long)divisor <= (unsigned long)dividend) {
B468  0100     MOVLB 0x0
B46A  51E2     MOVF divisor, W, BANKED
B46C  5DDE     SUBWF __pcstackBANK0, W, BANKED
B46E  51E3     MOVF a, W, BANKED
B470  59DF     SUBWFB pco, W, BANKED
B472  51E4     MOVF k, W, BANKED
B474  59E0     SUBWFB bdat, W, BANKED
B476  51E5     MOVF k, W, BANKED
B478  59E1     SUBWFB GIE_BIT_VAL, W, BANKED
B47A  E30B     BNC 0xB492
33:            				dividend -= divisor;
B47C  51E2     MOVF divisor, W, BANKED
B47E  5FDE     SUBWF __pcstackBANK0, F, BANKED
B480  51E3     MOVF a, W, BANKED
B482  5BDF     SUBWFB pco, F, BANKED
B484  51E4     MOVF k, W, BANKED
B486  5BE0     SUBWFB bdat, F, BANKED
B488  51E5     MOVF k, W, BANKED
B48A  5BE1     SUBWFB GIE_BIT_VAL, F, BANKED
34:            				quotient |= 1;
B48C  0100     MOVLB 0x0
B48E  81E8     BSF quotient, 0, BANKED
B490  D000     BRA 0xB492
35:            			}
36:            			*(unsigned long int *)&divisor >>= 1;
B492  0100     MOVLB 0x0
B494  90D8     BCF STATUS, 0, ACCESS
B496  33E5     RRCF k, F, BANKED
B498  33E4     RRCF k, F, BANKED
B49A  33E3     RRCF a, F, BANKED
B49C  33E2     RRCF divisor, F, BANKED
37:            		} while(--counter != 0);
B49E  0100     MOVLB 0x0
B4A0  2FE6     DECFSZ counter, F, BANKED
B4A2  D7DC     BRA 0xB45C
B4A4  D000     BRA 0xB4A6
38:            	}
39:            	if(sign)
B4A6  0100     MOVLB 0x0
B4A8  51E7     MOVF sign, W, BANKED
B4AA  E009     BZ 0xB4BE
40:            		quotient = -quotient;
B4AC  1FEB     COMF pop, F, BANKED
B4AE  1FEA     COMF tim, F, BANKED
B4B0  1FE9     COMF p, F, BANKED
B4B2  6DE8     NEGF quotient, BANKED
B4B4  0E00     MOVLW 0x0
B4B6  23E9     ADDWFC p, F, BANKED
B4B8  23EA     ADDWFC tim, F, BANKED
B4BA  23EB     ADDWFC pop, F, BANKED
B4BC  D000     BRA 0xB4BE
41:            	return quotient;
B4BE  C0E8     MOVFF quotient, __pcstackBANK0
B4C0  F0DE     NOP
B4C2  C0E9     MOVFF p, pco
B4C4  F0DF     NOP
B4C6  C0EA     MOVFF tim, bdat
B4C8  F0E0     NOP
B4CA  C0EB     MOVFF pop, GIE_BIT_VAL
B4CC  F0E1     NOP
B4CE  0012     RETURN 0
42:            }
B4D0  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/Umul32.c  --------------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
DA5E  0100     MOVLB 0x0
DA60  6BE6     CLRF counter, BANKED
DA62  6BE7     CLRF sign, BANKED
DA64  6BE8     CLRF quotient, BANKED
DA66  6BE9     CLRF p, BANKED
DA68  D000     BRA 0xDA6A
120:           	do {
121:           		if(multiplier & 1)
DA6A  0100     MOVLB 0x0
DA6C  A1DE     BTFSS __pcstackBANK0, 0, BANKED
DA6E  D009     BRA 0xDA82
122:           			product += multiplicand;
DA70  51E2     MOVF divisor, W, BANKED
DA72  27E6     ADDWF counter, F, BANKED
DA74  51E3     MOVF a, W, BANKED
DA76  23E7     ADDWFC sign, F, BANKED
DA78  51E4     MOVF k, W, BANKED
DA7A  23E8     ADDWFC quotient, F, BANKED
DA7C  51E5     MOVF k, W, BANKED
DA7E  23E9     ADDWFC p, F, BANKED
DA80  D000     BRA 0xDA82
123:           		multiplicand <<= 1;
DA82  0100     MOVLB 0x0
DA84  90D8     BCF STATUS, 0, ACCESS
DA86  37E2     RLCF divisor, F, BANKED
DA88  37E3     RLCF a, F, BANKED
DA8A  37E4     RLCF k, F, BANKED
DA8C  37E5     RLCF k, F, BANKED
124:           		multiplier >>= 1;
DA8E  0100     MOVLB 0x0
DA90  90D8     BCF STATUS, 0, ACCESS
DA92  33E1     RRCF GIE_BIT_VAL, F, BANKED
DA94  33E0     RRCF bdat, F, BANKED
DA96  33DF     RRCF pco, F, BANKED
DA98  33DE     RRCF __pcstackBANK0, F, BANKED
125:           	} while(multiplier != 0);
DA9A  51DE     MOVF __pcstackBANK0, W, BANKED
DA9C  11DF     IORWF pco, W, BANKED
DA9E  11E0     IORWF bdat, W, BANKED
DAA0  11E1     IORWF GIE_BIT_VAL, W, BANKED
DAA2  E1E3     BNZ 0xDA6A
126:           
127:           #endif
128:           	return product;
DAA4  C0E6     MOVFF counter, __pcstackBANK0
DAA6  F0DE     NOP
DAA8  C0E7     MOVFF sign, pco
DAAA  F0DF     NOP
DAAC  C0E8     MOVFF quotient, bdat
DAAE  F0E0     NOP
DAB0  C0E9     MOVFF p, GIE_BIT_VAL
DAB2  F0E1     NOP
129:           }
DAB4  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v1.34/sources/common/Umul16.c  --------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
ECB6  0100     MOVLB 0x0
ECB8  51DE     MOVF __pcstackBANK0, W, BANKED
ECBA  03E0     MULWF bdat, BANKED
ECBC  CFF3     MOVFF PROD, divisor
ECBE  F0E2     NOP
ECC0  CFF4     MOVFF PRODH, a
ECC2  F0E3     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
ECC4  51DE     MOVF __pcstackBANK0, W, BANKED
ECC6  03E1     MULWF GIE_BIT_VAL, BANKED
ECC8  50F3     MOVF PROD, W, ACCESS
ECCA  27E3     ADDWF a, F, BANKED
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
ECCC  51DF     MOVF pco, W, BANKED
ECCE  03E0     MULWF bdat, BANKED
ECD0  50F3     MOVF PROD, W, ACCESS
ECD2  27E3     ADDWF a, F, BANKED
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
ECD4  C0E2     MOVFF divisor, __pcstackBANK0
ECD6  F0DE     NOP
ECD8  C0E3     MOVFF a, pco
ECDA  F0DF     NOP
ECDC  0012     RETURN 0
53:            }
ECDE  0012     RETURN 0
